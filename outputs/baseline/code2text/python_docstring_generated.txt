Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, service_sid, channel_sid, ):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      @property     def page_size(self):         """         :returns: How many resources to return in each list page. The default is 50, and the maximum is 1000.         :rtype: unicode         """         return self._properties['page_size']      @property     def next_page_url(self):         """         :returns: The URL of the next page in the list         :rtype: unicode         """         return self._properties['next_page_url']      @property     def key(self
Get the channel sid from the channel
Code: def sina_z
Get
Get an item from the list of resources          :param unicode key: The index of the resource to fetch          :returns
Code: def __init__(self, version, response, solution):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to          :returns: twilio.rest.chat.v
Initialize the InvitePage          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :
Build an instance of InviteInstance          :param dict payload:
Download videos from a Vimeo channel          :param str channel_id: Vimeo channel id     :param str output_dir: Output directory     :param bool merge: Merge all videos into one file     :param bool info_only: Only print information of videos     :param dict kwargs: Other parameters Code: def vimeo_download_by_video_id(video_id, output_dir='.', merge=False, info_only=False, **kwargs
Makes the requests to the Twilio Video API to get the next page of         results.          :param str target_url:
Code: def get_video_url_from_video_id(video_id):          # from js     data = [""] * 256     for index, _ in enumerate(data):         t = index         for i in range(8):             t = -306674912 ^ unsigned_right_shitf(t, 1) if 1 & t else unsigned_right_shitf(t, 1)         data[index] = t      def tmp():         rand_num = random.random()         path = "/video/urls/v/1/toutiao/mp4/{video_id}?r={random_num}".format(video_id=video_id,                                                                               random_num=str(rand_num)[2:])         e = o = r = -1         i, a = 0, len(path)         while i < a:             e = ord(path[i])             i += 1             if e < 128:                 r = unsigned_right_shitf(r, 8) ^ data[255 & (r ^ e)]             else:                 if e < 2048:                     r = unsigned_right_shitf(r, 8) ^ data[255 & (r ^ (192 | e >> 6 & 31))]                     r = unsigned_right_shitf(r, 8) ^ data[255 & (r ^ (128 | 63 & e))]                 else:                     if 55296 <= e < 57344:                         e = (1023 & e) + 64                         i += 1                         o = 1023 & t.url(i)                         r = unsigned_right_shitf(r, 8) ^ data[255 & (r ^ (240 | e >> 8 & 7))]                         r = unsigned_right_shitf(r, 8) ^ data[255 & (r ^ (128 | e >> 2 & 63))]                         r = unsigned_right_shitf(r, 8) ^ data[255 & (r ^ (128 | o >> 6 & 15 | (3
Code: def get_mgtv_real_url(url):                  content = loads(get_content(url))         m3u_
Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'created_by': payload.get('created_by'),             'created_by_identity': payload.get('created_by_identity'),             'role_sid': payload.get('role_sid'),             'date_created': deserialize.iso8601_datetime(payload.get('date_created')),             'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')),             'url': payload.get('url'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': payload.get('sid'),         }      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property     def service_sid(self):         """         :returns: The SID of the Service that the resource is associated with         :rtype: unicode         """         return self._properties['service_sid']      @property     def channel_sid(self):         """         :returns: The SID of the Channel the resource belongs to         :rtype: unicode         """         return self._properties['channel_sid']      @property     def created_by(self):         """         :returns: The identity of the User that created the resource         :rtype: unicode         """         return
Code: def cbs_download(url, output_dir='.', merge=True, info_only=False, **kwargs):           html = get_content(url)     pid = match1(html, r'video\.settings\.pid\s*=\s*\'([^\']+)\'')     title = match1(html, r'video\.settings\.title\s*=\s*\"([^\"]+)\"')      theplatform_download_by_pid(pid, title, output_dir=output_dir, merge
Get the available streams          :param dict kwargs: Optional arguments          :returns: dict         :rtype: dict Code: def get_stream_url(self, stream_id, **kwargs):         """         Get the stream URL          :param
Get the srt json from the acfun api          :param str vid: Acfun video id          :returns: srt json         :rtype: str Code: def get_content(url, headers=None, cookies=None, timeout=10, verify=True):     """     Get the content of a url      :param str url: The url to get the content      :param dict headers: The headers to use when requesting the url      :param dict cookies: The cookies to use when requesting the url      :param int timeout: The timeout to use when requesting the url      :param bool verify: Whether to verify the ssl certificate      :returns: The content of the url     :rtype: str     """     if headers is None:         headers = {}     if cookies is None:         cookies = {}     if 'User-Agent' not in headers:         headers['User-Agent'] = 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.118 Safari/537.36'     if 'Referer' not in headers:         headers['Referer'] = url     if 'Accept-Encoding' not in headers:         headers['Accept-Encoding'] = 'gzip, deflate'     if 'Accept-Language' not in headers:         headers['Accept-Language'] = 'zh-CN,zh;q=0.8,en-US;q=0.6,en;q=0.4'     if 'Connection' not in headers:         headers['Connection'] = 'keep-alive'     if 'Cache-Control' not in headers:         headers['Cache-Control'] ='max-age=0'
Code: def matchoneornoneorallornoneorallornoneorall(text, patterns):           ret = []     for pattern in patterns:         match = re.findall(
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, service_sid, channel_sid):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def stream(self, limit=None, page_size=None):         """         Streams InviteInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until the limit         is reached.         The results are returned as a generator, so this operation is memory efficient.          :param int limit: Upper limit for the number of records to return. stream()                           guarantees to never return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, stream() will attempt to read the                               limit with the most efficient page size, i.e. min(limit, 1
Retrieve a specific page of InviteInstance records from the API.         Request is executed immediately          :param str target_url: API-generated URL for the requested results page          :returns: Page of InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def get_page(self, target_url):         """         Retrieve a specific page of InviteInstance records from the API.         Request is executed immediately          :param str target_url: API-generated URL for the requested results page          :returns: Page of InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         response = self._version.domain.twilio.request(             'GET',             target_url,         )          return InvitePage(self._version,
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, role_sid=values.unset,                  identity=values.unset, url=values.unset, links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._version.account_sid,            'service_sid': service_sid,             'channel_sid': channel_sid,             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'role_sid': role_sid,             'identity': identity,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self
Build an instance of InviteInstance          :param dict payload:
Code: def _wanmen_get_title_by_json_topic_part_part_part_part(json_content, tIndex, pIndex, pIndex2, pIndex3, pIndex4
下载课程 Code: def wanmen_download_by_course_topic_part(json_api_content, tIndex, pIndex, output_dir='.', merge=True, info_only=False, **kwargs):     """     下载课程     :param json_api_content:     :param tIndex:     :param pIndex:     :param output_dir:     :param merge:     :param info_only:     :param kwargs:     :return:     """     if not os.path.exists(output_dir):         os.makedirs(output_dir)     course_name = json_api_content[0]['Topics'][tIndex]['Name']     course_id = json_api_content[0]['Topics'][tIndex]['Id']     part_name = json_api_content[0]['Topics'][tIndex]['Parts'][pIndex]['Name']     part_id = json_api_content[0]['Topics'][tIndex]['Parts'][pIndex]['Id']     part_url = json_api_content[0]['Topics'][tIndex]['Parts'][pIndex]['Url']     part_url = part_url.replace('http://', 'https://')     part_url = part_url.replace('www.', '')     part_url = part_url.replace('www.', '')     part_url = part_url.replace('www.', '')     part_url = part_url.replace('www.', '')     part_url = part_url.replace('www.', '')     part_url = part_url.replace('www.', '')     part_url = part_url.replace('www.', '')     part_url = part_url.replace('www.', '')     part_url = part_url.replace('www.', '')     part_url = part_url.replace('www.', '')     part_url = part_url.replace('www.', '')     part_url = part_url.replace('www.', '')     part_url = part_url.replace('www.', '')     part_url = part_url.replace('www.', '')     part_url = part_url.replace('www.', '')     part_url = part_url.replace('www.', '')     part_url = part_url.replace('www.', '')     part_url = part_url.replace('www
Code: def wanmen_download_by_id(vid, title, output_dir='.', merge=True, info_only=False, **kwargs):           if not os.path.exists(output_dir):         os.makedirs(output_dir)      if info_only:         print(title)         return      url = 'http://www.wanmen.tv/bokecc/player/player.php?vid={}&type=1'.format(vid)      html = get_content(url)      if not html:         print('Failed to get html')         return      if '播放失败' in html:         print('Failed to play')         return      if '播放中' in html:         print('Playing')         return      if '播放器初始化失败' in html:         print('Failed to init player')         return      if '播放器初始化中' in html:         print('Init player')         return      if '播放器初始化成功' in html:         print('Init player success')
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset, links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': None,            'service_sid': service_sid,             'channel_sid': channel_sid,             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property
Generate an absolute URL for this Invite          :returns: Absolute URL for this Invite         :rtype: unicode Code
Get connection parameters from the configuration file          :
Code: def _get_aws_credentials(self):                  if self.snowflake_conn_id:             connection_object = self.get_connection(self.snowflake_conn_id)             if 'aws_secret_access_key' in connection_object.extra_dejson:                 aws_access_key

Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset, links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['account_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource
Fetch the next row of a query result set, returning a single sequence,         or None when no more data is available.          :returns: The next row of a query result set, or None         :rtype: tuple Code: def fetchmany(self, size=None):         """         Fetch the next set of rows of a query result, returning a sequence of         sequences (e.g. a list of tuples).  If size is specified, at most size         rows will be fetched.          :param int size: The maximum
Code: def __init__(self,                  service_sid,                  channel_sid,                  identity,                  role_sid=values.unset,                  ttl=values.unset,                  x_twilio_webhook_enabled=values.unset,                  ):         """         Initialize the CreateInviteInstance          :param unicode service_sid: The SID of the Service to create the resource         :param unicode channel_sid: The SID of the Channel the new resource belongs to         :param unicode identity: The `identity` value that identifies the new resource's User         :param unicode role_sid: The SID of the Role to assign to the new resource         :param unicode ttl: An application-defined integer value that indicates how long, in seconds, the invite is valid. Can be an integer between 86400 and 2592000 (1 day and 30 days, respectively). By default, the invite is valid for 24 hours.         :param unicode x_twilio_webhook_enabled: The X-Twilio-Webhook-Enabled HTTP request header          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(CreateInviteInstance, self).__init__()          self._version = version         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,             'identity': identity,         }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)          # Values of the request         self._values = {             'role_sid': role_sid,             'ttl': ttl,             'x_twilio_webhook_enabled': x_twilio_webhook_enabled,         }      @property     def service_sid(self):         """         :returns: The SID of the Service to create the resource         :rtype: unicode         """         return self._properties['service_sid']      @property     def channel_sid(self):         """         :returns: The SID of the Channel the new resource belongs to         :rtype: unicode         """         return self._properties['channel_sid']      @property     def sid(self):         """         :returns: The unique string that identifies the resource
Code: def max_partition(
Get the connection schema          :returns: str         :rtype: str Code: def get_conn_login(self):         """         Get the connection login          :returns: str         :rtype: str
Code: def task_state(args):          dag = get_dag(args)     task = dag.get_task(task_id=args.task_id)     ti = TaskInstance(task, args.execution_
Get the number of workers expected in gunicorn master process          :param num_workers: number of workers in gunicorn master process         :param num_workers_max: maximum number of workers in gunicorn master process          :returns: number of workers expected         :rtype: int Code: def get_num_workers_max(num_workers, num_workers_max):     """     Get the number of workers expected in gunicorn master process      :param num_workers: number of workers in gunicorn master process     :param num_workers_
Generate an API-ready query string for the request.          :returns: Twilio Request
Initialize the InviteContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel
Code: def get_instance(self, instance, project_id=None):                  return self.get_conn().instances().get(             project
Update an instance of InviteInstance          :param dict body: A JSON string that represents an InviteInstance resource's state          :param project_id: The SID of the Project that the resource is associated with          :returns: True if update succeeds, False otherwise         :rtype: bool Code: def list_instances(self, limit=None, page_size=None):         """         Lists InviteInstance records from the API as a list.         Unlike stream(), this operation is eager and will load `limit` records into         memory before returning.          :param int limit: Upper limit for the number of records to return. list() guarantees                           never to return more than limit.  Default is no limit         :param
Get an instance.          :param str project_id: Project ID         :param str instance_id: Instance ID          :returns: Instance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def _delete_instance(self, project_id, instance_id):         """         Delete an instance.          :param str project_id: Project ID         :param str instance_id: Instance ID          :returns: True if delete succeeded, False otherwise         :rtype: bool         """         response = self.get_conn().instances().delete(             project=project_id,             instance
Code: def delete_instance
Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def get_instance(self, payload):         """         Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance
Code: def delete_database_user(self, instance, project_id=None):         response = self.get_conn().databaseUsers().delete(             project=project_id,             instance=instance         ).execute(num_retries=self.num_retries)         operation_name = response["name"]         self._wait_for
Returns a database instance.          :param str instance: Instance name         :param str project_id: Project ID          :rtype: google.cloud.sql.db_instance.DatabaseInstance Code: def get_database(self, instance, database, project_id=None):         """         Returns a database.          :param str instance: Instance name         :param str database: Database name         :param str project
Code: def delete_database(self, instance, database, project_id=None):                  response = self.get_conn().databases().delete(             project=project_id,             instance=instance,             database=database         ).execute(num_retries=self.num_retries)         operation_name = response["name"]         self._wait_for_operation_to_complete
Export an instance of a Service          :param str instance: The SID of the Service Instance to export         :param str body: The JSON string that specifies the export configuration         :param str project_id: The SID of the Sync Project with the Service to export         :rtype: dict         :return: The response from the API         """         try:             response = self.get_conn().instances().export(                 project=project_id,                 instance=instance,                 body=body             ).execute(num_retries=self.num_retries)             operation_name = response["name"]             self._wait_for_operation_to_complete(project_id=project_id,                                                  operation_name=operation_name)         except HttpError as ex:             raise AirflowException(                 'Exporting instance {} failed: {}'.format(instance, ex.content)             ) Code: def _wait_for_operation_to_complete(self, project_id, operation_name):         """         Wait for an operation to complete          :param str project_id: The SID of the Sync Project with the Service to export         :param str operation_name: The name of the operation to wait for         :rtype: dict         :return: The response from the API         """         while True:             response = self.get_conn().instances().operations(                 project=project_id,                 operation=operation_name             ).get().execute(num_retries=self.num_retries)             if response['
Download the cloud_sql_proxy if it is not already present. Code: def get_temp_path(self):
Get the credentials from the file.          :returns: dict         :rtype: dict Code: def _get_credentials_from_env(self):         """         Get the credentials from the environment variables.          :returns: dict         :rtype: dict         """         return {             'username': os.environ.get('CLOUD_SQL_USERNAME'),             'password': os
Get the version of the SQL proxy binary from the file.          :returns: The version of the SQL proxy binary from the file.         :rtype: str Code: def get_sql_proxy_version_from_url(self):         """         Get the version of the SQL proxy binary from the URL.          :returns: The version of the SQL proxy binary from the URL.         :rtype: str         """         try:             response = requests.get(self._sql_proxy_version_url)             if response.status_code == 200:                 return response.
Get the connection parameters for the connection URI.          :returns: The connection parameters         :rtype: dict Code: def _get_connection_params_for_id(self):         """         Get the connection parameters for the connection ID.          :returns: The connection parameters         :rtype: dict         """         return {             'uri_prefix': self.uri_prefix
Code: def __init__(self, version, service_sid, channel_sid):         """         Initialize the InviteList
Code: def delete_connection(self, session=None):                  self.log.info("Deleting connection %s", self.db_conn_id)         connections = session.query(Connection).filter(             Connection.conn_id == self.db_conn_id)         if connections.count():             connection = connections[0]             session.delete(connection)             session.commit()         else:             self.log
Code: def get_sqlproxy_instance_specification(self):         """         Returns the instance specification for the Cloud SQL Proxy.          :rtype: dict         """         return {            'region': self.region,             'instance_name': self.instance_name,             'database_name': self.database_name,             'database_username': self.database_username,             'database_password': self.database_password,             'database_port': self.database_port,             'database_type': self.database_type,             'database_flags': self.database_flags,             'database_charset': self.database_charset,             'database_collation': self.database_collation,             'database_uri': self.database_uri,             'database_uri_override': self.database_uri_override,             'database_proxy_uri': self.database_proxy_uri,             'database_proxy_uri_override': self.database_proxy_uri_override,             'database_proxy_port': self.database_proxy_port,             'database_proxy_port_override': self.database_proxy_port_override,             'database_proxy_username': self.database_proxy_username,             'database_proxy_username_override': self.database_proxy_username_override,             'database_proxy_password': self.database_proxy_password,             'database_proxy_password_override': self.database_proxy_password_override,             'database_proxy_database_name': self.database_proxy_database_name,             'database_proxy_database_name_override': self.database_proxy_database_name_override,             'database_proxy_database_type': self.database_proxy_database_type,             'database_proxy_database_type_override': self.database_proxy_database_type_override,             'database_proxy_database_flags': self.database_proxy_database_flags,             'database_proxy_database_flags_override': self.database_proxy_database_flags_override,             'database_proxy_database_charset': self.database_proxy_database_charset,             'database_proxy_database_charset_override': self.database_proxy_database_charset_override,             'database_proxy_database_
Code: def get_database_hook(self):
Get the service name from the service sid          :returns: The service name         :rtype: unicode Code: def _get_identity(self):         """         Get the identity from the identity_field          :returns: The identity         :rtype: unicode         """         if self.identity_field
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset, links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['account_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource
Code: def _normalize_mlengine_job_
Code: def _get_error_code(self, e):                  try:             matches = self.error
Get the channel members from the channel sid          :param str channel_sid: The channel sid          :returns: The channel members         :rtype: list Code: def _get_channel_invites(self, channel_sid):         """         Get the channel invites from the channel sid          :param str channel_sid: The channel sid          :returns: The channel invites         :rtype: list         """         channel_invites = []         if channel_sid:             channel_invites = self.client.invites.list(
Get the channel sid from the channel name          :param str channel_name: The channel name          :returns: The channel sid         :rtype: str Code: def _get_channel_sid(self, channel_name):         """         Get the channel sid from the channel name          :param str channel_name: The channel name          :returns: The channel sid         :rtype: str         """         channel_sid = None         if channel_name:             channel_sid = self._client.channels.list(                 service
Code: def set_d
Code: def __init__(self, version, sid, **kwargs):         """         Initialize the ChatServiceInstance          :returns: twilio.rest.chat.v2.service.ChatServiceInstance         :rtype: twilio.rest.chat.v2.service.ChatServiceInstance         """         super(ChatServiceInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': kwargs.get('account_sid'),             'friendly_name': kwargs.get('friendly_name'),             'attributes': kwargs.get('attributes'),            'reachability_enabled': deserialize.bool(kwargs.get('reachability_enabled')),             'typing_indicator_timeout': deserialize.integer(kwargs.get('typing_indicator_timeout')),             'consumption_report_interval': deserialize.integer(kwargs.get('consumption_report_interval')),             'notifications': NotificationList(                 self._version,                 service_sid=sid,             ),             'users': UserList(                 self._version,                 service_sid=sid,             ),             'channels': ChannelList(                 self._version,                 service_sid=sid,             ),             'roles': RoleList(                 self._version,                 service_sid=sid,             ),             'bindings': BindingList(                 self._version,                 service_sid=sid,             ),             'webhooks': WebhookList(                 self._version,                 service_sid=sid,             ),             'url': kwargs.get('
Code: def heartbeat(self):                  super(SchedulerMetricsJob, self).heartbeat()         session = settings.Session()         # Get all the relevant task instances         TI = TaskInstance         successful_tis = (             session            .query(TI)            .filter(TI.dag_id.in_(DAG_IDS))            .filter(TI.state.in_([State.SUCCESS]))            .all()         )         session.commit()          dagbag = DagBag(SUBDIR)         dags = [dagbag.dags[dag_id] for dag_id in DAG_IDS]         # the tasks in perf_dag_1 and per_dag_2 have a daily schedule interval.         num_task_instances = sum([(timezone.utcnow() - task.start_date).days                                  for dag in dags for task in dag.tasks])          if (len(successful_tis) == num_task_instances or                 (timezone.
Return a boto3 connection.          :rtype: boto3.client Code: def _get_aws_conn(self):         """         Return a boto3 connection.          :
Code: def create_evaluate_ops(task_prefix,                         data_format,                         input_paths,                         prediction_path,                         metric_fn_and_keys,                         validate_fn,                         batch_prediction_job_id=None,                         project_id=None,                         region=None,                         dataflow_options=None,                         model_uri=None,                         model_name=None,                         version_name=None,                         dag=None):           # Verify that task_prefix doesn't have any special characters except hyphen     # '-', which is the only allowed non-alphanumeric character by Dataflow.     if not re.match(r"^[a-zA-Z][-A-Za-z0-9]*$", task_prefix):         raise AirflowException(             "Malformed task_id for DataFlowPythonOperator (only alphanumeric "             "and hyphens are allowed but got: " + task_prefix)      metric_fn, metric_keys = metric_fn_and_keys     if not callable(metric_fn):         raise AirflowException("`metric_fn` param must be callable.")     if not callable(validate_fn):         raise AirflowException("`validate_fn` param must be callable.")      if dag is not None and dag.default_args is not None:         default_args = dag.default_args         project_id = project_id or default_args.get('project_id')         region = region or default_args.get('region')         model_name = model_name or default_args.get('model_name')         version_name = version_name or default_args.get('version_name')         dataflow_options = dataflow_options or \             default_args.get('dataflow_default_options')      evaluate_prediction = MLEngineBatchPredictionOperator(         task_id=(task_prefix + "-prediction"),         project_id=project_id,         job_id=batch_prediction_job_id,         region=region,         data_format=data_format,         input_paths=input_paths,         output_path=prediction_path,         uri=model_uri,         model_name=model_name,         version_name=version_name,         dag=dag)      metric_fn_encoded = base64.b64
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset, links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': None,            'service_sid': service_sid,             'channel_sid': channel_sid,             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __repr__(self):
Iterate over pages of results          :returns: Page of InviteInstance         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance] Code: def __getitem__(self, key):         """         Get an
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __iter__(self):         """         Iterate over list of invites          :returns
Code: def get_druid_broker_conn_id(self):         """         Get the druid broker connection id          :returns: str         :rtype: str         """         return self.druid_broker_conn_id Docstring
Makes a request and returns a Page object instance.          :param str target_url: API-generated URL for the requested results page         :param dict params: Parameters to pass to the API         :param str method: HTTP method to use         :param bool stream: Whether to stream the response to the client. Not supported for GET requests         :param int timeout: HTTP request timeout         :param int connect_timeout: Connection timeout         :param str idempotency_key: Optional HTTP header to pass to the API          :returns: Page         :rtype: twilio.rest.base.page.Page Code: def get_page_of_items(self, target_url, params=None, method='GET', stream=
Code: def run_and_check(self, session, prepped_request, extra_options):         try:             response = session.send(prepped_request, **extra_options)         except requests.exceptions.SSLError as e:             raise AirflowException(                 "SSL Error: %s" % e,                 error_code=503,                 error_message=str(e),                 method=self.method,                 url=prepped_request.url,                 headers=prepped_request.headers,                 data=prepped_request.body,             )         except requests.exceptions.ConnectionError as e:             raise AirflowException(                 "Connection Error: %s" % e,                 error_code=503,                 error_message=str(e),                 method=self.method,                 url=prepped_request.url,                 headers=prepped_request.headers,                 data=prepped_request.body,             )         except requests.exceptions.Timeout as e:             raise AirflowException(                 "Timeout Error: %s" % e,                 error_code=503,                 error_message=str(e),                 method=self.method,                 url=prepped_request.url,                 headers=prepped_request.headers,                 data=prepped_request.body,             )         except requests.exceptions.RequestException as e:             raise AirflowException(                 "RequestException: %s" % e,                 error_code=503,                 error_message=str(e),                 method=self.method,                 url=prepped_request.url,                 headers=prepped_request.headers,                 data=prepped_request.body,             )          if response.status_code == 401:             raise AirflowException(                 "Unauthorized Error: %s" % response.text,                 error_code=401,                 error_message=response.text,                 method=self.method,                 url=prepped_request.url,                 headers=prepped_request.headers,                 data=prepped_request.body,             )         elif response.status_code == 404:             raise AirflowException(                 "Not Found Error: %s" % response.text,                 error_code=404,
Code: def __iter__(self):         """         Iterate over pages of results          :returns: Page of InviteInstance         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]         """         return self._version.page(             method='GET',             uri=self._uri,
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset,                  links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': None,            'service_sid': service_sid,             'channel_sid': channel_sid,             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  identity=values.unset, role_sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  url=values.unset, links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._version.account_sid,            'service_sid': service_sid,             'channel_sid': channel_sid,             'identity': identity,             'role_sid': role_sid,             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  identity=values.unset, role_sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  url=values.unset, links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': None,            'service_sid': service_sid,             'channel_sid': channel_sid,             'identity': identity,             'role_sid': role_sid,             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """
Get the channel type from the channel_type parameter or the channel_name         parameter.          :returns: The channel type         :rtype: str Code: def _get_channel_attributes(self):         """         Get the channel attributes from the channel_attributes parameter or the         channel_name parameter.          :returns: The
Code: def __iter__(self):         """         Iterate over pages of InviteInstance          :returns: Page of InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.Invite
Strip the SQL from the exception message          :param str sql: The SQL to strip          :returns: The stripped SQL         :rtype: str Code: def _get_pretty_exception_message(self, e):         """         Get a pretty exception message          :param Exception e: The exception to get the message for          :returns: The pretty exception message         :rtype: str         """         return ''.join(traceback.format_exception(             type(e), e, e.__traceback
Generate a WSGI request for the InviteInstance          :param unicode method: The HTTP method to use to fetch the InviteInstance         :param unicode url: The absolute URL for the InviteInstance         :param dict data: The data to include in the request's body         :param dict headers: The HTTP request headers          :returns: WSGI request object
Get the result set from the HQL string.          :param str hql: The HQL string to get the result set from.          :returns: The result set from the HQL string.
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, response, solution):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The service_sid          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__
Constructs a ChannelContext          :param unique_name: The unique_name          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext Code: def get_invite(self, sid):         """         Constructs a InviteContext          :param sid: The
Code: def get_conn(self):         if self.conn is None:             self.conn = DocumentClient(                 host=self.host,                 port=self.port,                 auth=self.auth,                 ssl=self.ssl,                 database=self.database_name,                 connection_mode=ConnectionMode.Gateway,                 gateway_mode=GatewayMode.Direct,                 gateway_connection_string=self.gateway_connection_string,                 gateway_host=self.gateway_host,                 gateway_port=self.gateway_port,                 gateway_auth=self.gateway_auth,                 gateway_ssl=self.gateway_ssl,                 gateway_database=self.gateway_database,                 gateway_consistency_level=self.gateway_consistency_level,                 gateway_max_retry_attempts=self.gateway_max_retry_attempts,                 gateway_max_retry_wait_time=self.gateway_max_retry_wait_time,                 gateway_min_retry_wait_time=self.gateway_min_retry_wait_time,                 gateway_max_retry_wait_time_scale=self.gateway_max_retry_wait_time_scale,                 gateway_min_retry_wait_time_scale=self.gateway_min_retry_wait_time_scale,                 gateway_max_retry_wait_time_jitter=self.gateway_max_retry_wait_time_jitter,                 gateway_min_retry_wait_time_jitter=self.gateway_min_retry_wait_time_jitter,                 gateway_max_retry_wait_time_jitter_scale=self.gateway_max_retry_wait_time_jitter_scale,                 gateway_min_retry_wait_time_jitter_scale=self.gateway_min_retry_wait_time_jitter_scale,                 gateway_max_retry_wait_time_jitter_scale_jitter=self.gateway_max_retry_wait_time_jitter_scale_jitter,                 gateway_min_retry_wait_time_jitter_scale_jitter=self
Create a new collection in the database.          :param str collection_name: The name of the collection to create.
Returns the database table partition expiration days.          :rtype: int Code: def get_database_table_partition_expiration_hours(self):         """         Returns the database table partition expiration hours.          :rtype:
Create a table in the database          :param str database_name: The name of the database         :param str table_name: The name of the table         :param dict table_schema: The schema of the table          :returns: True if the table was created, False otherwise         :rtype: bool Code: def delete_database(self, database_name):         """         Delete a database          :param str database_name: The name of the database          :returns: True if the database was deleted, False otherwise         :rtype: bool         """         if database_name is None:             raise AirflowBadRequest("Database name cannot be None.")          # We need to check to see if this database already exists so we don't try         # to delete it twice         existing_database = list(self.get_conn().QueryDatabases({             "query": "SELECT * FROM r WHERE r.id=@id",             "parameters": [                 {"name": "@id", "value": database_name}
Code: def delete_database(self, database_name):                  if database_name is None:             raise AirflowBadRequest("Database name cannot be None.")          self.get_conn
Get a document from a collection          :param str collection_name: The name of the collection         :param str document_id: The id of the document to get         :param str database_name: The name of the database          :returns: The document         :rtype: dict Code: def get_collection(self, collection_name, database_name=None):         """         Get a collection          :param str collection_name: The name of the collection         :param str database
Insert a single document into the collection          :param dict document: The document to insert         :param str database_name: The name of the database         :param str collection_name: The name of the collection         :return: The created document         :rtype: dict Code: def list_documents(self, database_name=None, collection_name=None, query=None, top=None, skip=None, orderby=None, orderby_type=None, select=None, expand=None, max_item_count=None, max_item_count_per_partition=None, partition_key_start_from=None, partition_key_end_with=None, partition_key_range_id=None, enable_cross_partition_query=None, consistency_level=None):         """         List documents in the collection          :param str database_name: The name of the database         :param str collection_name: The name of the collection         :param dict query: The query to execute         :param int top: The maximum number of items to return         :param int skip: The number of items to skip         :param str orderby: The orderby clause         :param str orderby_type: The orderby type         :param str select: The select clause
Get the link to a document          :param str database_name: The name of the database to get the document from         :param str collection_name: The name of the collection to get the document from         :param str document_id: The id of the document to get          :returns: str         :rtype: str Code
Get a document by query          :param dict query: The query to use         :param str database_name: The name of the database         :param str collection_name: The name of the collection          :returns: The document         :rtype: dict Code: def get_document_by
Get a database from the account          :param str database_name: The name of the database to get         :rtype: dict Code: def get_collection
Generate an API-ready query string for the request.          :returns: Twilio-specific query string for this Request         :rtype: unicode Code: def get_payload(self):         """         Generate the Twilio-provided JSON request body for this request.          :returns: Body twilio.rest.chat.v2.service.channel.invite instance         :rtype: unicode         """         data = values.of({             'RoleSid': serialize.map(self.role_sid, lambda e: e),         })          payload = self.version.serialize(data)         headers = {'Content-Type': 'application/x-www-form
Returns the function source archive url.
Returns a function with the given name from the specified project and         location.          :param str name: The name of the function which should be returned.          :returns: The result of the operation.         :rtype: dict Code: def list_functions(self, parent):         """Lists information about the
Return the function trigger http.          :param bool function_trigger_http: Function trigger http          :returns: Function trigger http         :rtype: bool Code: def _get_function_trigger_pubsub(self, function_trigger_pubsub):         """         Return the function trigger pubsub.          :param bool function_trigger_pubsub: Function trigger pubsub          :returns: Function trigger pubsub         :rtype: bool         """         if function_trigger_pubsub is not None:             return function_trigger_pubsub
Code: def delete_function(self, name):                  response = self.get_conn().projects().locations().functions
Code: def get_dep_statuses(self, ti, session, dep_context=None):                  # this avoids a circular dependency         from airflow.ti_deps.dep_context import DepContext          if dep_context is None:             dep_context = DepContext()          if self.IGNOREABLE and dep_context.ignore_all_deps:             yield self._passing_status(                 reason="Context specified all dependencies should be ignored.")             return          if self.IS_TASK_DEP and dep_context.ignore_task_deps:             yield self._passing_status(                 reason="Context specified all task dependencies should be ignored.")             return          for dep_status in self._get_dep_statuses(ti, session, dep_context):
Retrieve a single page of InviteInstance records from the API.         Request is executed immediately          :param str page_token: PageToken provided by the API         :param int page_number: Page Number, this value is simply for client state         :param int page_size: Number of records to return, defaults to 50
Returns a list of DepStatus objects for the task instance.          :param TaskInstance ti: TaskInstance to get dependencies for         :param Session session: Session to use for dependencies         :param DepContext dep_context: DepContext to use for dependencies         :rtype: list[DepStatus] Code: def get_dep_statuses(self, ti, session, dep_context=None):         """         Returns a list of DepStatus objects for the task instance.          :param TaskInstance ti: TaskInstance to get dependencies for         :param Session session: Session to use for dependencies         :param DepContext dep_context: DepContext to use for dependencies         :rtype: list[DepStatus]         """         dep_statuses = []         for dep in self.dependencies:             dep_statuses.append(dep.get_dep_status(ti, session, dep_context))         return
Setting option names depending on file format          :param str config_file_name: Path to the config
session, _ = self._get_credentials(region_name)         # Credentials are refreshable, so accessing your access key and         # secret key separately can lead to a race condition.         # See https://stackoverflow.com/a/36291428/8283373         return session.get_credentials().get_frozen_credentials() Code: def get_credentials(self, region_name=None):                  session, _ = self._get_credentials(region_name)         # Credentials are refreshable, so accessing your access key and         # secret key separately can lead to a race condition.         # See https://stackoverflow.com/
Get cursor from connection string          :param str conn_string: Connection string          :returns: Cursor         :rtype: Cursor Code: def get_cursor_from_conn_string_id(self, conn_string_id):         """         Get cursor from connection string id          :param str conn_string_id: Connection string id          :returns: Cursor         :rtype: Cursor         """         return self.get_cursor_from_conn(self.get_connection_from_conn_string_id(conn_string_id)) Docstring
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset,                  links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': sid,             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def date_created(self):         """         :returns: The ISO 8601 date and time in GMT when the resource was created         :rtype: datetime         """         return self._properties['date_created']      @property     def date_updated(self):         """         :returns: The ISO 860
Code: def correct_maybe_zipped(fileloc):           _, archive, filename = re.search(         r
Code: def list_py_file_paths(directory, safe_mode=True,                        include_examples=None):          if include_examples is None:         include_examples = conf.getboolean('core', 'LOAD_EXAMPLES')     file_paths = []     if directory is None:         return []     elif os.path.isfile(directory):         return [directory]     elif os.path.isdir(directory):         patterns_by_dir = {}         for root, dirs, files in os.walk(directory, followlinks=True):             patterns = patterns_by_dir.get(root, [])             ignore_file = os.path.join(root, '.airflowignore')             if os.path.isfile(ignore_file):                 with open(ignore_file, 'r') as f:                     # If we have new patterns create a copy so we don't change                     # the previous list (which would affect other subdirs)                     patterns += [re.compile(p) for p in f.read().split('\n') if p]              # If we can ignore any subdirs entirely we should - fewer paths             # to walk is better. We have to modify the ``dirs`` array in             # place for this to affect os.walk             dirs[:] = [                 d                 for d in dirs                 if not any(p.search(os.path.join(root, d)) for p in patterns)             ]              # We want patterns defined in a parent folder's.airflowignore to             # apply to subdirs too             for d in dirs:                 patterns_by_dir[os.path.join(root, d)] = patterns              for f in files:                 try:                     file_path = os.path.join(root, f)                     if not os.path.isfile(file_path):                         continue                     mod_name, file_ext = os.path.splitext(                         os.path.split(file_path)[-1])                     if file_ext!= '.py' and not zipfile.is_zipfile(file_path):                         continue                     if any([re.findall(p, file_path) for p in patterns]):                         continue                      # Heuristic that guesses whether a Python file contains an                     # Airflow DAG definition.                     might_contain_dag = True                     if safe_mode and not zipfile.is_zipfile
Constructs a InviteContext
Launches a DagFileProcessorManager process.          :param str dag_directory: The directory containing the DAGs         :param list[str] file_paths: The file paths to the DAGs         :param int max_runs: The maximum number of times to run the DAGs         :param DagFileProcessorFactory processor_factory: The factory to use             to create DagFileProcessor instances         :param multiprocessing.connection.Connection child_signal_conn: The             connection to the child process signal handler         :param multiprocessing.Queue stat_queue: The queue to put stats into         :param multiprocessing.Queue result_queue: The queue to put results             into         :param bool async_mode: Whether to run the DagFileProcessorManager in             async mode or not          :return: The DagFileProcessorManager process         :rtype: multiprocessing.Process
Code: def _on_message(self, message):         """         Handle a message from the manager.          :param str message: The message received from the manager.         """         if message == DagParsingSignal.TERMINATE_MANAGER:             self.log.info("Manager has terminated.")             self._child_signal_conn.close()             self._child_signal_conn = None             self._child_process.terminate()             self._child_process = None             self._child_process_lock.release()             self._child_process_lock = None             self._child_process_event.set()             self._child_process_event = None             self._child_process_event_lock.release()             self._child_process_event_lock = None             self._child_process_event_lock.acquire()             self._child_process_event.wait()             self._child_process_event = None             self._child_process_event_lock = None             self._child_process_event_lock.acquire()             self._child_process_event.set()             self._child_process_event = None             self._child_process_event_lock = None             self._child_process_event_lock.acquire()             self._child_process_event.wait()             self._child_process_event = None             self._child_process_event_lock = None             self._child_process_event_lock.acquire()             self._child_process_event.set()             self._child_process_event = None             self._child_process_event_lock = None             self._child_process_event_lock.acquire()             self._child_process_event.wait()             self._child_process_event = None             self._child_process_event_lock = None             self._child_process_event_lock.acquire()             self._child_process_event.set()             self._child_process_event = None             self._child_process_event_lock = None             self._child_process_event_lock.acquire()             self._child_process_event.wait()             self._child_process_event = None             self._child_process_event_lock = None             self._child_process_event_lock.acquire()             self._child_process_event.
Process a task from the queue.          :param task_id: Task to process         :type task_id: str Code: def _process_event(self, event_id):         """         Process an event from the queue.          :param event_id: Event to process         :type event_id: str         """         self.
Code: def wait_for_tasks_to_finish(self):         """         Wait for all tasks to finish.          :return: None         """         self.log.info("Waiting for all tasks to finish")         self.log.info("Waiting for all tasks to finish")         self.log.info("Waiting for all tasks to finish")         self.log.info("Waiting for all tasks to finish")         self.log.info("Waiting for all tasks to finish")         self.log.info("Waiting for all tasks to finish")         self.log.info("Waiting for all tasks to finish")         self.log.info("Waiting for all tasks to finish")         self.log.info("Waiting for all tasks to finish")         self.log.info("Waiting for all tasks to finish")         self.log.info("Waiting for all tasks to finish")         self.log.info("Waiting for all tasks to finish")         self.log.info("Waiting for all tasks to finish")         self.log.info("Waiting for all tasks to finish")         self.log.info("Waiting for all tasks to finish")         self.log.info("Waiting for all tasks to finish")         self.log.info("Waiting for all tasks to finish")         self.log.info("Waiting for all tasks to finish")         self.log.info("Waiting for all tasks to finish")         self.log.info("Waiting for all tasks to finish")         self.log.info("Waiting for all tasks to finish
Check if any of the files in the DAG directory have been modified         since the last time we checked.          :returns: A list of SimpleDag objects         :rtype: list[SimpleDag] Code: def terminate(self):         """         Terminate the manager.          :returns: None         :rtype: None         """         self.log.info("Terminating manager")         self._signal_conn.send(DagParsingSignal.TERMINATE_MANAGER) Docstring
Mark a file as processed.          :param str file_path: Path to the file to mark as processed          :return: None Code
Stop the thread that refreshes the list
Code: def _log_file_processing_stats(self, file_paths):         """         Log the stats for the files that were processed          :param list[str] file_paths: List of file paths that were processed         """         self.logger.info('Processing stats for files: %s', file_paths)         for file_path in file_paths:             self.logger.info('File: %s', file_path)             self.logger.info('Total lines: %s', self._file_stats[file_path]['total_lines'])             self.logger.info('Total errors: %s', self._file_stats[file_path]['total_errors'])             self.logger.info('Total warnings: %s', self._file_stats[file_path]['total_warnings'])             self.logger.info('Total info: %s', self._file_stats[file_path]['total_info'])             self.logger.info('Total debug: %s', self._file_stats[file_path]['total_debug'])             self.logger.info('Total critical: %s', self._file_stats[file_path]['total_critical'])             self.logger.info('Total fatal: %s', self._file_stats[file_path]['total_fatal'])             self.logger.info('Total unknown: %s', self._file_stats[file_path]['total_unknown'])             self.logger.info('Total ignored: %s', self._file_stats[file_path]['total_ignored'])             self.logger.info('Total skipped: %s', self._file_stats[file_path]['total_skipped'])             self.logger.info('Total ignored: %s', self._file_stats[file_path]['total_ignored'])             self.logger.info('Total skipped: %s', self._file_stats[file_path]['total_skipped'])             self.logger.info('Total ignored: %s', self._file_stats[file_path]['total_ignored'])             self.logger.info('Total skipped: %s', self._file_stats[file_path]['total_skipped'])             self.logger.info('Total ignored: %s', self._file_stats[file_path]['total_ignored'])             self.logger.info('Total skipped: %
Code: def __iter__(self):         """         Iterate over pages of InviteInstance          :returns: Page of InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage
Code: def _log_file_processing_stats(self, known_file_paths):                   # File Path: Path to the file containing the DAG definition         # PID: PID associated with the process that's processing the file. May         # be empty.         # Runtime: If the process is currently running, how long it's been         # running for in seconds.         # Last Runtime: If the process ran before, how long did it take to         # finish in seconds         # Last Run: When the file finished processing in the previous run.         headers = ["File Path",                    "PID",                    "Runtime",                    "Last Runtime",                    "Last Run"]          rows = []         for file_path in known_file_paths:             last_runtime = self.get_last_runtime(file_path)             file_name = os.path.basename(file_path)             file_name = os.path.splitext(file_name)[0].replace(os.sep, '.')             if last_runtime:                 Stats.gauge(                     'dag_processing.last_runtime.{}'.format(file_name),                     last_runtime                 )              processor_pid = self.get_pid(file_path)             processor_start_time = self.get_start_time(file_path)             runtime = ((timezone.utcnow() - processor_start_time).total_seconds()                        if processor_start_time else None)             last_run = self.get_last_finish_time(file_path)             if last_run:                 seconds_ago = (timezone.utcnow() - last_run).total_seconds()                 Stats.gauge(                     'dag_processing.last_run.seconds_ago.{}'.format(file_name),                     seconds_ago                 )              rows.append((file_path,                          processor_pid,                          runtime,                          last_runtime,                          last_run))          # Sort by longest last runtime. (Can't sort None values in python3)         rows = sorted(rows, key=lambda x: x[3] or 0.0)          formatted_rows = []         for file_path, pid, runtime, last_runtime, last_run in rows:             formatted_rows.append((file_path,                                    pid,                                    "{:.2f}s".format(runtime)                                    if runtime else None,
Process files in the queue in a background thread          :returns: True if files were processed, False otherwise         :rtype: bool Code: def _send_packet(self, packet):         """         Send a packet to the server          :param packet: Packet to send         :type packet: twilio.rest.chat.v2.service.channel.invite.packet.Packet          :returns: True if packet was sent, False otherwise         :rtype: bool         """         if self.ws:             self.ws.send(packet.to
Iterate over list of Invites and return a generator yielding one Invite instance each          :returns: Generator that will yield up to limit results         :rtype: list[twilio.rest.chat.v2.service.channel
Get the zombies          :returns: list[airflow.models.dag.DAG]         :rtype: list[airflow.models.dag.DAG] Code: def heartbeat(self):                  finished_processors = {}                  running_
Build an instance of MessageInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.message.MessageInstance         :rtype: twilio.rest.chat.v2.service.channel.message.MessageInstance Code: def get_instance(self, payload):         """         Build an instance of RoleInstance
Code: def get_conn(self):                   self.log.debug('Creating SSH client for conn_id: %s', self.ssh_conn_id)         client = paramiko.SSHClient()         if not self.allow_host_key_change:             self.log.warning('Remote Identification Change is not verified. '                              'This wont protect against Man-In-The-Middle attacks')             client.load_system_host_keys()         if self.no_host_key_check:             self.log.warning('No Host Key Verification. This wont protect '                              'against Man-In-The-Middle attacks')             # Default is RejectPolicy             client.set_missing
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __eq__(self, other):         """         Returns true if both instances are equal, false otherwise          :returns: True if both instances are equal,
Retrieve a single page of TransferJobInstance records from the API.         Request is executed immediately          :param str target_url: API-generated URL for the requested results page          :param unicode project_id: The SID of the Project to fetch the TransferJobs from          :returns: Page of TransferJobInstance         :rtype: twilio.rest.chat.v2.service.channel.transfer_job.TransferJobPage Code: def get_transfer_jobs_stream(self, project_id=None, limit=None, page_size=None):         """         Streams TransferJobInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until
Code: def list_user_channel_invitation(self, filter):                  conn = self.get_conn()         filter = self._inject_project_id(filter, FILTER, FILTER_PROJECT_ID)         request = conn.userChannelInvitations().list(filter=json.dumps(filter))         invitations = []          while request is not None:             response = request.execute(num_retries=self.num_retries)             invitations.extend(response[USER_CHANNEL_INVITATIONS])              request = conn.
Get the channel sid from the channel unique name.          :param str channel_unique_name
Code: def delete_transfer_job(self, job_name, project_id):                   return (             self.get_conn()            .transferJobs()            .patch(                 jobName=job_name,
Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def get_instance(self, payload):         """         Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.
Remove a user from the channel          :param unicode identity: The identity of the User to remove from the Channel          :returns: True if delete succeeds, False otherwise         :rtype: bool Code: def remove_user_role(self, sid):         """         Remove a user role from the
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, service_sid, channel_sid, ):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def stream(self, limit=None, page_size=None):         """         Streams InviteInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until the limit         is reached.         The results are returned as a generator, so this operation is memory efficient.          :param int limit: Upper limit for the number of records to return. stream()                           guarantees to never return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page
Code: def wait_for_transfer_job(self, job, expected_statuses=(GcpTransferOperationStatus.SUCCESS,), timeout=60):                  while timeout > 0:             operations = self
Build an instance of InviteInstance          :param dict payload:
Code: def __init__(self, version, payload, service_sid, channel_sid, ):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'identity': payload.get('identity'),             'role_sid': payload.get('role_sid'),             'date_created': deserialize.iso8601_datetime(payload.get('date_created')),             'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')),             'url': payload.get('url'),         }          # Context         self._context = None
Code: def run_command(command):          process = subprocess.Popen(         shlex.split(command),         stdout=subprocess.PIPE,         stderr=subprocess.PIPE,         close_fds=True)     output, stderr = [stream.decode(sys.getdefaultencoding(), 'ignore')                       for stream in process.communicate()]      if process.returncode!= 0:         raise AirflowConfigException(             "Cannot execute {}. Error code is: {}. Output
Remove a section from the config file if it is empty.
Code: def get_instance(self, payload):         """         Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel
Get a connection to the Google Cloud Pub/Sub API.          :returns: Google Cloud Pub/Sub API connection         :rtype: googleapiclient.discovery.Resource Code: def get_conn(self):         """         Get a connection to the Google Cloud Pub/Sub API.          :returns: Google Cloud Pub/Sub API connection         :rtype: googleapic
Get the credentials from the Google Cloud Platform API.          :returns: Credentials         :rtype:
Get a resource from the Google Cloud Platform API.          :param str name: Name of the resource          :returns: Google Cloud Platform resource         :rtype: googleapiclient.discovery.Resource Code: def get_service(self, name):         """         Get a service from the Google Cloud Platform API.          :param str name: Name of the service          :returns: Google Cloud Platform
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset, links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['account_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {             'account_sid': account_sid,            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns:
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset,                  links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['account_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {             'account_sid': account_sid,            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns
Retrieve a single page of InviteInstance records from the API.         Request is executed immediately          :param twilio.rest.chat.v2.service.channel.invite.InvitePage response: page             from which to start retrieving the next page          :returns: Page of InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def _get_next_page(self, response):         """Retrieve the next page of records          :param twilio.rest.chat.v2.service.channel.invite.InvitePage response: page             from which to start retrieving the next page          :returns: Page of InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         response = self._version.page(             'GET',             self._uri,
Generate a payload for a

Code: def __init__(self, version, service_sid, channel_sid, ):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      @property     def has_previous_page(self):         """         :returns: True if there is a previous page of results, False otherwise         :rtype: bool         """         return self._version.has_previous_page(self._uri)      @property     def previous_page_url(self):         """         :returns: The URL of the previous page of results         :rtype: unicode         """         return self._version.previous_page_url(self._uri)      @property     def next_page_url(self):         """         :returns: The URL of the next page of results         :rtype: unicode         """         return self._version.next_page_url(self._uri)      @property     def invites(self):         """         :returns: A list of instances of Inv
Code
Code: def list_members(self, limit=None, page_size=None):         """         Lists MemberInstance records from the API as a list.         Unlike stream(), this operation is eager and will load `limit` records
Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'identity': payload.get('identity'),             'role_sid': payload.get('role_sid'),             'date_created': deserialize.iso8601_datetime(payload.get('date_created')),             'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')),             'url': payload.get('url'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': payload.get('sid'),         }      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property     def service_sid(self):         """         :returns: The SID of the Service that the resource is associated
Code: def get_hostname():          # First we attempt to fetch the callable path from the config.     try:         callable_path = conf.get('core
Code
Code: def classify_document(self, document, encoding_type=None, retry=None, timeout=None, metadata=None):                  client = self.get_conn()          return client.classify
Return a connection to the service.          :rtype: :class:`ibm_watson.natural_language_understanding_v1.NaturalLanguageUnderstandingV1` Code: def get_conn(self):         """         Return a connection to the service.          :rtype: :class:`ibm_watson.natural_language_understanding_v1.NaturalLanguageUnderstandingV1`         """         if self._conn is None:             self._conn = NaturalLanguageUnderstandingV1(                 version=self
Return a connection to the service.          :rtype: :class:`ibm_watson.natural_language_understanding_v1.NaturalLanguageUnderstandingV1` Code: def get_conn(self):         """         Return a connection to the service.          :rtype: :class:`ibm_watson.natural_language_understanding_v1.NaturalLanguageUnderstandingV1`         """         if self._conn is None:             self._conn = NaturalLanguageUnderstandingV1(                 version=self
Get the template fields for a given object.          :param env: Sphinx environment         :type env: Sphinx environment         :param fullname: Full name of the object         :type fullname: str         :returns: List of template fields         :rtype: list Code: def get_template_fields_for_package(env, fullname):     """     Get the template fields for a given package.      :param env: Sphinx environment     :type env: Sphinx environment     :param fullname: Full name of the package     :type fullname: str     :returns: List of template fields     :rtype: list
Code: def template_field_role(app, typ, rawtext, text, lineno, inliner, options={}, content=[]):          text = utils.unescape(text)      try:         template_fields = get_template_field(app.env, text)     except RoleException as e:         msg = inliner.reporter.error("invalid class name %s \n%s" % (text, e, ), line=lineno)         prb = inliner.problematic(rawtext, rawtext, msg)         return [prb], [msg]      node = nodes.inline
Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'role_sid': payload.get('role_sid'),             'identity': payload.get('identity'),             'date_created': deserialize.rfc2822_datetime(payload.get('date_created')),             'date_updated': deserialize.rfc2822_datetime(payload.get('date_updated')),             'url': payload.get('url'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': payload.get('sid'),         }      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property     def service_sid(self):         """         :returns: The SID of the Service that the resource is associated with         :rtype: unicode         """         return self._properties['service_sid']      @property     def channel_sid(self):         """         :returns: The SID of the Channel the resource belongs to         :rtype: unicode         """         return self._properties['channel_sid']      @property     def role_sid(self):         """         :returns: The SID of the Role assigned to the user when they join the Channel         :rtype: unicode         """         return self._properties['role_sid']      @property     def identity(self):

Code: def _check_task_id(self, context):                  ti = context['ti']         cel
Code: def detect_conf_var():          ticket_cache = configuration.conf.get('kerberos', 'ccache')      with open(ticket_cache, 'rb') as f:         #
Converts a Twilio.IpMessaging.V2.InvitePage instance into a JSON         object that can be turned into valid JSON in a Twilio request.          :returns: JSON object representing this InvitePage         :rtype: dict Code: def __init__(self, version, response, solution):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init__(version)          # Path
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, service_sid, channel_sid):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The service_sid          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def stream(self, limit=None,
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  by=values.unset, role_sid=values.unset, identity=values.unset,                  url=values.unset):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to         :param sid: The unique string that identifies the resource         :param date_created: The ISO 8601 date and time in GMT when the resource was created         :param date_updated: The ISO 8601 date and time in GMT when the resource was last updated         :param by: The identity of the User who created the resource         :param role_sid: The SID of the Role assigned to the User         :param identity: The unique string that identifies the resource's User         :param url: The absolute URL of the Page          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)          # Page Parameters         self._page_size = kwargs.get('page_size', limits.DEFAULT_PAGE_SIZE)         self._limit = kwargs.get('limit')         self._page_token = kwargs.get('page_token')          #has a limit and a next_page_url         self._has_next_page = True if self._limit is not None else False         self._next_page_url = None if self._limit is not None else url          # Filter results from the server         self.path_account_sid = kwargs.get('path_account_sid', self._solution['service_sid'])         self.by = by         self.role_sid = role_sid         self.identity = identity
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset, links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': sid,             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def date_created(self):         """         :returns: The ISO 8601 date and time in GMT when the resource was created         :rtype: datetime         """         return self._properties['date_created']      @property     def date_updated(self):         """         :returns: The ISO 8601
Provide a friendly representation          :returns: Machine friendly representation         :rtype
Code: def render_log_filename(ti, try_number, filename_template):          filename_template, filename_jinja_template = parse_template_string(filename_template)     if filename_jinja_template:         jinja_context = ti.get_template_context()         jinja_context
Retrieve a specific page of InviteInstance records from the API.         Request is executed immediately          :param str target_url: API-generated URL for the requested results page          :returns: Page of InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def get_page(self, target_url):         """         Retrieve a specific page of InviteInstance records from the API.         Request is executed immediately          :param str target_url: API-generated URL for the requested results page          :returns: Page of InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         response = self._version.domain.twilio.request(             'GET',             target_url,         )          return InvitePage(self._version,
Code
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __getitem__(self, key):         """         Get an item from the list of resources          :param unicode key: The index of the resource to fetch          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         return self._version.get(             'GET',             self._uri,             params={                 'PageToken': self._solution['page_token'],                 'Page': self._solution['page'],                 'PageSize':
Code: def _handle_databricks_operator_execution(operator, hook, log, context):          if operator.do_xcom_push:         context['ti'].xcom_push(key=XCOM_RUN_ID_KEY, value=operator.run_id)     log.info('Run submitted with run_id: %s', operator.run_id)     run_page_url = hook.get_run_page_url(operator.run_id)     if operator.do_xcom_push:         context['ti
Code: def run_cli(self, pig, verbose=True):                   with TemporaryDirectory(prefix='airflow_pigop_') as tmp_dir:             with NamedTemporaryFile(dir=tmp_dir) as f:                 f.write(pig.encode('utf-8'))                 f.flush()                 fname = f.name                 pig_bin = 'pig'                 cmd_extra = []                  pig_cmd = [pig_bin, '-f', fname] + cmd_extra                  if self.pig_properties:                     pig_properties_list = self.pig_properties.split()                     pig_cmd.extend(pig_properties_list)                 if verbose:                     self.log.info("%s", " ".join(pig_cmd))                 sp = subprocess.Popen(                     pig_cmd,                     stdout=subprocess.PIPE,                     stderr=subprocess.STDOUT,                     cwd=tmp_dir,                     close_fds=True)                 self.sp = sp                 stdout = ''                 for line
Fetch a InviteInstance          :param identity: The identity          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def fetch_invite_by_role_sid(self, role_sid):         """         Fetch a InviteInstance          :param role_sid: The role_sid          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.
This background task sends packets to the server. Code: def _send_packet_loop_task(self):         """         This background task sends packets to the server.         """         self.logger.info('Starting packet loop')         while self.state == 'connected':             try:                 packets = self.queue.get(block=True, timeout=self.send_timeout)                 if packets:                     self._send_packets(packets)             except queue.Empty:                 pass             except Exception as e:                 self.logger.error('Error in packet loop: %s', e)                 if self.ws:                     self.ws.close()                 self.queue.put(None)                 break         self.logger.info('Exiting packet loop') Docstring
Initialize the SyncListResource          :param unicode service_sid: The SID of the Service to fetch the resource from         :param unicode channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList Code: def _sync_list_item_resource(self, service_sid, channel_sid, sid):         """         Initialize the SyncListItemResource          :param
Get an item from the list of resources          :param unicode key: The index of the resource to
Code: def get_page(self, target_url):         response = self._version.domain.twilio.request(             'GET',
Wait for job to finish          :param str project_id: Project ID         :param str job_id: Job ID          :returns: Job         :rtype: Job Code: def _get_job_output(self, project_id, job_id):         request = self._mlengine.projects().jobs().get(             name='projects/{}/jobs/{}'.format(project_id, job_id))         job = request.execute()         if job['state']!= 'SUCCEEDED':             raise Exception('Job failed: {}'.format(job))         request = self._mlengine.projects().jobs().getIamPolicy(             resource='projects/{}/jobs/{}'.format(project_id, job_id))         policy = request.execute()         if 'bindings' not in policy:             raise Exception('Job output not found: {}'.format(job))         for binding in policy['bindings']:             if 'role' in binding
Code: def _get_job(self, project_id, job_id):                  job_name = 'projects/{}/jobs/{}'.format(project_id, job_id)         request = self._mlengine.projects().jobs().get(name=job_name)         while True:             try:                 return request.execute()             except HttpError as e:                 if e.resp.
Convenience method to access a single instance of InviteInstance          :param str key: The index of the resource to fetch          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.
Code: def get_model(self, project
Set the default version for the model.          :param str project_id: The project ID.         :param str model_name: The name of the model.         :param str version_name: The name of the version.          :returns: The response from the API.         :rtype: dict         """         full_version_name = 'projects/{}/models/{}/versions/{}'.format(             project_id, model_name, version_name)         request = self._mlengine.projects().models().versions().setDefault(             name=full_version_name, body={})          try:             response = request.execute()             self.log.info('Successfully set version:
Code: def list_versions(self, project_id, model_name):                  result = []         full_parent_name = 'projects/{}/models/{}'.format(             project_id, model_name)         request = self._mlengine.projects().models().versions().list(             parent=full_parent_name
Code: def delete_version(self, project_id, model_name, version_name):                  full_name = 'projects/{}/models/{}/versions/{}'.format(             project_id, model_name, version_name)         delete_request = self._mlengine.projects().models().versions().delete(             name=full_name)         response = delete_request.execute()         get_request = self._mlengine.projects().operations().get(             name=response['name'])          return _poll_with_exponential_delay(             request=get_request,             max_n=9,             is_done_func=lambda resp: resp.get('done', False),             is_error_
Get a model.          :param str project_id: The project that owns the model to get.         :param str model_id: The ID of the model to get.         :returns: The model.         :rtype: dict Code: def list_models(self, project_id):         """         List models.          :param str project_id:
Get a model from the project.          :param str project_id: The project ID.         :param str model_name: The model name.          :returns: A model.         :rtype: dict         """         if not model_name:             raise ValueError("Model name must be provided and "                              "it could not be an empty string")         full_model_name = 'projects/{}/models/{}'.format(             project_id, model_name)         request = self._mlengine.projects().models().get(name=full_model_name)         try:             return request.execute()         except HttpError as e:             if e.resp.status == 404:                 self.log.error('Model was not found: %s
Returns the table fields map reverse.          :rtype: dict Code: def get_table_fields_map_reverse_keys(self):         """         Returns the table fields map reverse keys.          :rtype: list         """         return self.
Makes a request to the Twilio API          :param str method: The HTTP method to use         :param str url: The URL to request         :param dict data: The data to send         :param dict headers:
Build an instance of InviteInstance          :param dict payload:
Get a list of all hook objects          :return: The list of hook objects         :rtype: list Code: def
Code: def on_success(self, response):         """         :param response:         :return:         """         self.log.info('Received response: {}'.format(response))         self.log.info('Received response: {}'.format(response))         self.log.info('Received response: {}'.format(response))         self.log.info('Received response: {}'.format(response))         self.log.info('Received response: {}'.format(response))         self.log.info('Received response: {}'.format(response))         self.log.info('Received response: {}'.format(response))         self.log.info('Received response: {}'.format(response))         self.log.info('Received response: {}'.format(response))         self.log.info('Received response: {}'.format(response))         self.log.info('Received response: {}'.format(response))         self.log.info('Received response: {}'.format(response))         self.log.info('Received response: {}'.format(response))         self.log.info('Received response: {}'.format(response))         self.log.info('Received response: {}'.format(response))         self.log.info('Received response: {}'.format(response))         self.log.info('Received response: {}'.format(response))         self.log.info('Received response: {}'.format(response))         self.log.info('Received response: {}'.format(response))         self.log.info('Received response: {}'.format(response))         self.log.info('Received response: {}'.format(response))         self.log.info('Received response: {}'.format(response))         self.log.info('Received response: {}'.format(response))         self.log.info('Received response: {}'.format(response))         self.log.info('Received response: {}'.format(response))         self.log.info('Received response: {}'.format(response))         self.log.info('Received response: {}'.format(response))         self.log.info('Received response: {}'.format(response))         self.log.info('Received response: {}'.format(response))         self.log.info('Received response: {}'.format(response))         self.log.info('Received response: {}'.format(response))         self.log.info('Received response: {}'.format(response))         self.log.info('
Get cursor from connection id          :param str schema: Schema         :param str conn_id: Connection id          :returns: Cursor         :rtype: Cursor Code: def get_cursor_schema_conn_mssql(self, schema, conn_id):         """         Get cursor from connection id          :param str schema: Schema
Code: def trigger_dag(dag_id):          data = request.get_json(force=True)      run_id = None     if 'run_id' in data:         run_id = data['run_id']      conf = None     if 'conf' in data:         conf = data['conf']      execution_date = None     if 'execution_date' in data and data['execution_date'] is not None:         execution_date = data['execution_date']          # Convert string datetime into actual datetime         try:             execution_date = timezone.parse(execution_date)         except ValueError:             error_message = (                 'Given execution date, {}, could not be identified '                 'as a
Code: def delete_dag(dag_id):          try:         count = delete.delete_dag(dag_id
Code: def task_instances(dag_id, state=None, execution_date=None,                        execution_date_gte=None, execution_date_lte=None,                        external_trigger=None,                        map_index=None,                        include_adhoc=None,                        include_subdags=None,                        include_parentdag=None,                        include_filename=None,                        include_log_url=None,                        only_failed=None,                        only_running=None,                        limit=None,                        order_by=None,                        desc=None,                        include_ext_xcom_data=None,                        include_parent_dag_data=None,                        include_children_data=None,                        include_task_ids=None,                        include_dag_ids=None,                        include_task_ids_regex=None,                        include_dag_ids_regex=None,                        include_task_states=None,                        include_task_states_regex=None,                        include_task_type=None,                        include_task_type_regex=None,                        include_task_handler=None,                        include_task_handler_regex=None,                        include_task_handler_class=None,                        include_task_handler_class_regex=None,                        include_task_group_id=None,                        include_task_group_id_regex=None,                        include_task_group_name=None,                        include_task_group_name_regex=None,                        include_task_group_type=None,                        include_task_group_type_regex=None,                        include_task_group_state=None,                        include_task_group_state_regex=None,                        include_task_group_external_trigger=None,                        include_task_group_external_trigger_regex=None,                        include_task_group_external_trigger_id=None,                        include_task_group_external_trigger_id_regex=None,                        include_task_group_external_trigger_type=None,                        include_task_group_external_trigger_type_regex=None,                        include_task_group_external_trigger_data=None,                        include_task_group_external_trigger_data_regex=None,                        include_task_group_external_trigger_
Code: def get_pool_member_stats_history(pool_id, member_id):     try:         stats = pool_api.get_pool_member_stats_history(pool_id, member_id)     except AirflowException as err:         _log.error(err)         response = jsonify(error="{}".format(err))         response.status_code = err.status_code         return response     else:         return jsonify([s.to_json() for s in stats])
Code: def create_pool():          params = request.get_json(force=True)
Code: def delete_pool(name):          try:         pool = pool_api.delete_pool(name=name)     except AirflowException as err:         _log.error(err)         response = jsonify(error="{}".format(err))         response.status_code = err.status_
Returns true if both instances are not equal, false otherwise          :returns: True if both instances are not equal, false otherwise         :rtype: bool Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'identity': payload.get('identity'),
Code: def get_state_exitcode_details(self, resource_group, name):                  current_state = self._get_instance_view(resource_group, name).current_state         return (current_state.state,                 current_state.exit_code,
Code: def get_messages(self, resource_group, name):
Retrieve a specific page of InviteInstance records from the API.         Request is executed immediately          :param str target_url: API-generated URL for the requested results page          :returns: Page of InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def get_page(self, target_url):         """         Retrieve a specific page of InviteInstance records from the API.         Request is executed immediately          :param str target_url: API-generated URL for the requested results page          :returns: Page of InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         response = self._version.domain.twilio.request(             'GET',             target_url,         )          return InvitePage(self._version,
Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'identity': payload.get('identity'),             'role_sid': payload.get('role_sid'),             'date_created': deserialize.iso8601_datetime(payload.get('date_created')),             'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')),             'url': payload.get('url'),         }          # Context         self._context = None         self
Build an instance of InviteInstance          :param dict payload:
Code: def __init__(self, *args, **kwargs):         """         Initialize the TaskInstance          :param airflow.models.BaseOperator base_operator: The base operator         :param airflow.utils.state state: The state of the task instance         :param str run_id: The run_id of the task instance         :param str task_id: The task_id of the task instance         :param str dag_id: The dag_id of the task instance         :param datetime start_date: The start_date of the task instance         :param datetime end_date: The end_date of the task instance         :param datetime execution_date: The execution_date of the task instance         :param datetime try_number: The try_number of the task instance         :param str hostname: The hostname of the task instance         :param str unixname: The unixname of the task instance         :param str pid: The pid of the task instance         :param str pool: The pool of the task instance         :param str queue: The queue of the task instance         :param str operator: The operator of the task instance         :param str queued_dttm: The queued_dttm of the task instance         :param str start_date: The start_date of the task instance         :param str end_date: The end_date of the task instance         :param str try_number: The try_number of the task instance         :param str hostname: The hostname of the task instance         :param str unixname: The unixname of the task instance         :param str pid: The pid of the task instance         :param str pool: The pool of the task instance         :param str queue: The queue of the task instance         :param str operator: The operator of the task instance         :param str queued_dttm: The queued_dttm of the task instance         :param str start_date: The start_date of the task instance         :param str end_date: The end_date of the task instance         :param str try_number: The try_number of the task instance         :param str hostname: The hostname of the task instance         :param str unixname: The unixname of the task instance         :param str pid: The pid of the task instance         :param str pool: The pool of the task instance         :param str queue: The queue of the
Get the result of the ingestion query          :param str ingest_query_id: Ingestion query ID          :returns: dict         :rtype: dict Code: def _get_ingest_query_error(self, ingest_query_id):         """         Get the error of the ingestion query          :param str ingest_query_id: Ingestion query ID          :returns: dict         :rtype: dict         """         response = self.client.get(             '
Code: def __init__(self, service_sid, channel_sid, version, client=None):         """         Initialize the InviteList          :param unicode service_sid: The SID of the Service to fetch the resource from         :param unicode channel_sid: The SID of the Channel the resource to fetch belongs to         :param Version version: Version that contains the resource          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)          # Components         self._invites = None      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = InviteList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._invites      def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         return '<Twilio.IpMessaging.V2.InviteList>'   class InvitePage(Page):     """ PLEASE NOTE that this class contains preview products that are subject     to change. Use them with caution. If you currently do not have developer     preview access, please contact <EMAIL>. """      def __init__(self, version, response, solution):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite
Build an instance of InviteInstance          :param dict payload:
Code: def get_task_instances(self, state=None, session=None):                  from airflow.models.taskinstance import TaskInstance  # Avoid circular import         tis = session
Get a list of task instances associated with this task.          :param session: The database session to use.         :type session: Session          :rtype: list[airflow.models.taskinstance.TaskInstance] Code: def get_task_instances_state_count(self, session=None):         """         Get a list of task instances associated with this task.          :param session: The database session to use.         :type session: Session          :rtype: list[airflow.models.taskinstance.TaskInstance]         """         from airflow.models.taskinstance import TaskInstance  # Avoid circular import         TI = TaskInstance         return session.query(TI.state, func.count(TI.state)).filter(             TI.dag_id == self.dag_id,             TI.execution_date == self.execution
Code: def get_previous_
Code: def get_previous_
Get a task instance associated with this dag run          :param str task_id: Task ID         :return: Task instance         :rtype: airflow.models.TaskInstance Code: def get_task_instances(self, state=None, session=None):         """         Get a list of task instances associated with this dag run          :param State state: State of the task instance         :param Session session: Session object         :return: List of task instances         :rtype: list[airflow.models.TaskInstance]         """         TI = TaskInstance         if not session:             session
Get the next dagrun for this task instance.          :param session: the database session         :type session: Session         :return: the next dagrun for this task instance         :rtype: models.DagRun Code: def _get_next_dagrun_create_after_success(self, session):         """         Get the next dagrun for this task instance.          :param session: the database session         :type session: Session         :return: the next dagrun for this task instance
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code:
Code: def _get_response(self, method, url, params=None, data=None, headers=None,                       stream=False, timeout=None, auth=None,                       allow_redirects=True, proxies=None, hooks=None,                       stream_decode_responses=True, verify=None, cert=None):         """         Perform a request and return a Response object.          :param str method: The HTTP method to use.         :param str url: The URL to send the request to.         :param dict params: The parameters to send with the request.         :param dict data: The data to send with the request.         :param dict headers: The headers to send with the request.         :param bool stream: Whether to stream the response.         :param int timeout: The timeout to use for the request.         :param tuple auth: The HTTP Basic Auth credentials to use.         :param bool allow_redirects: Whether to allow redirects.         :param dict proxies: The proxies to use for the request.         :param dict hooks: The hooks to use for the request.         :param bool stream_decode_responses: Whether to stream the response             content.         :param bool verify: Whether to verify the server's SSL certificate.         :param str cert: The path to the SSL client certificate file.         :rtype: requests.Response         """         if not isinstance(url, six.string_types):             raise TypeError('url must be a string, not {}'.format(                 type(url).__name__))         if not isinstance(params, dict):             raise TypeError('params must be a dict, not {}'.format(                 type(params).__name__))         if not isinstance(data, dict):             raise TypeError('data must be a dict, not {}'.format(                 type(data).__name__))         if not isinstance(headers, dict):             raise TypeError('headers must be a dict, not {}'.format(                 type(headers).__name__))         if not isinstance(stream, bool):             raise TypeError('stream must be a bool, not {}'.format(                 type(stream).__name__))         if not isinstance(timeout, int):             raise TypeError('timeout must be an int, not {}'.format(                 type(timeout).__name__))         if not isinstance(auth, tuple):             raise TypeError('auth must be a tuple, not {}'.format(                 type(auth).__name__))         if not isinstance(allow_redirects
Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'role_sid': payload.get('role_sid'),             'identity': payload.get('identity'),             'date_created': deserialize.iso8601_datetime(payload.get('date_created')),             'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')),             'url': payload.get('url'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': payload.get('sid'),         }      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property     def service_sid(self):         """         :returns: The SID of the Service that the resource is associated with         :rtype: unicode         """         return self._properties['service_sid']      @property     def channel_sid(self):         """         :returns: The SID of the Channel the resource belongs to         :rtype: unicode         """         return self._properties['channel_sid']      @property     def role_sid(self):         """         :returns: The SID of the Role assigned to the member         :rtype: unicode         """         return self._properties['role_sid']      @property     def identity(self):         """         :returns
Code: def __init__(self, version, service_sid, channel_sid):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def stream(self, limit=None, page_size=None):         """         Streams InviteInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until the limit         is reached.         The results are returned as a generator, so this operation is memory efficient.          :param int limit: Upper limit for the number of records to return. stream()                           guarantees to never return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, stream() will attempt to read the                               limit with the most efficient page size,
Code: def query_metric(self,                      query,                      from_seconds_ago,                      to_seconds_ago):                  now = int(time.time())          response = api.Metric.query(             start=now - from_seconds_ago,             end=now - to_seconds_ago,
Returns the DagBag singleton          :rtype: airflow.models.dagbag.DagBag Code: def get_dag_by_fileloc(self, filepath):         """         Returns the DagBag singleton          :rtype: air
Lists InviteInstance records from the API as a list.         Unlike stream(), this operation is eager and will load `limit` records into
Code: def _get_next_dag_run(self, dag, execution_date):         """         Returns the next dag run for a given dag and execution date.          :param dag: DAG         :type dag: DAG         :param execution_date: execution date         :type execution_date: datetime         :return: next dag run         :rtype: DagRun         """         # TODO: This is a bit of a hack. We should be able to get the next         #  execution date from the scheduler, but that's not exposed.         #  We should also be able to get the next execution date from the         #  database, but that's not exposed.         #  We should be able to get the next execution date from the         #  scheduler, but that's not exposed.         #  We should be able to get the next execution date from the         #  database, but that's not exposed.         #  We should be able to get the next execution date from the         #  scheduler, but that's not exposed.         #  We should be able to get the next execution date from the         #  database, but that's not exposed.         #  We should be able to get the next execution date from the         #  scheduler, but that's not exposed.         #  We should be able to get the next execution date from the         #  database, but that's not exposed.         #  We should be able to get the next execution date from the         #  scheduler, but that's not exposed.         #  We should be able to get the next execution date from the         #  database, but that's not exposed.         #  We should be able to get the next execution date from the         #  scheduler, but that's not exposed.         #  We should be able to get the next execution date from the         #  database, but that's not exposed.         #  We should be able to get the next execution date from the         #  scheduler, but that's not exposed.         #  We should be able to get the next execution date from the         #  database, but that's not exposed.         #  We should be able to get the next execution date from the         #  scheduler, but that's not exposed.         #  We should be able to get the next execution date from the         #  database, but that's not exposed.         #  We
Build an instance of InviteInstance          :param dict payload:
Code: def __init__(self, dag_id, root_dag, execution_date,                  ignore_dependencies=False,                  ignore_first_depends_on_past=False,                  ignore_task_deps=False,                  ignore_ti_state=False,                  pool=None,                  delay_on_limit_secs=3600,                  pickle_id=None,                  raw=False,                  **kwargs):         """         Constructor          :param str dag_id: DAG ID         :param dag: DAG object         :type dag: DAG         :param datetime execution_date: Execution date         :param bool ignore_dependencies: Ignore task dependencies         :param bool ignore_first_depends_on_past: Ignore depends_on_past             dependencies for the first task         :param bool ignore_task_deps: Ignore task-specific dependencies         :param bool ignore_ti_state: Ignore the previous TaskInstance state         :param str pool: Specify a pool to use. This overrides the default             pool         :param int delay_on_limit_secs: Number of seconds to wait before             considering the limit hit         :param str pickle_id: Specify an ID for the pickled DAG object. This             allows multiple DAG objects to be pickled and unpickled in the             course of a single run         :param bool raw: If True, don't execute the DAG but instead execute             each task and their dependencies as though they were in sequence         """         self.dag_id = dag_id         self.root_dag = root_dag         self.execution_date = execution_date         self.ignore_dependencies = ignore_dependencies         self.ignore_first_depends_on_past = ignore_first_depends_on_past         self.ignore_task_deps = ignore_task_deps         self.ignore_ti_state = ignore_ti_state         self.pool = pool         self.delay_on_limit_secs = delay_on_limit_secs         self.pickle_id = pickle_id         self.raw = raw         self.kwargs = kwargs         self.task_ids = []         self.task_group = None         self.task_instances = {}         self.downstream_task_ids = set()         self.upstream_task_ids = set()         self.queued_task_instances = []         self.queued_task_instances
Code: def ds_
Provide a friendly representation
Code: def poke(self, context):                  sb = self.hook(self.hdfs_conn_id).get_conn()         self.log.info(             'Poking for %s to be a directory with files matching %s', self.filepath, self.regex.pattern         )         result = [f for f in sb.ls([self.filepath], include_toplevel=False) if                   f['file_type'] == 'f' and                   self.regex.match(f['path'].replace('%s/' % self.filepath, ''))]         result = self.filter_for_ignored_ext(result, self.ignored_ext,                                              self.ignore_copying)         result
Code: def poke(self, context):                  sb = self.hook(self.hdfs_conn_id).get_conn()         result = [f for f in sb.ls([self.filepath], include_toplevel=True)]         result = self.filter_for_ignored_ext(result, self.ignored_ext,                                              self.ignore_copying)         result = self.filter_for_filesize(result, self.file_size)         if self.
Get the next page of results          :param Response response: Response from the API          :returns: Response from the API         :rtype: Response Code: def _get_previous_page(self, response):         """         Get the previous page of results          :param Response response: Response from the API          :returns: Response from the API         :rtype: Response         """         if response.headers.get('x-page-count') >
Code: def _set_properties(self, properties):         """         :param dict properties: A mapping of property names to values         """         self._properties = properties         if'sid' in properties:             self._solution['sid'] = properties['sid']         if 'account_sid' in properties:             self._solution['account_sid'] = properties['account_sid']         if'service_sid' in properties:             self._solution['service_sid'] = properties['service_sid']         if 'channel_sid' in properties:             self._solution['channel_sid'] = properties['channel_sid']         if 'identity' in properties:             self._solution['identity'] = properties['identity']         if 'role_sid' in properties:             self._solution['role_sid'] = properties['role_sid']         if 'date_created' in properties:             self._solution['date_created'] = properties['date_created']         if 'date_updated' in properties:             self._solution['date_updated'] = properties['date_updated']         if 'url' in properties:             self._solution['url'] = properties['url']         if 'links' in properties:             self._solution['links'] = properties['links']         if 'channel_sid' in properties:             self._properties['channel_sid'] = properties['channel_sid']         if 'date_created' in properties:             self._properties['date_created'] = deserialize.iso8601_datetime(properties['date_created'])         if 'date_updated' in properties:             self._properties['date_updated'] = deserialize.iso8601_datetime(properties['date_updated'])         if 'url' in properties:             self._properties['url'] = properties['url']         if 'links' in properties:             self._properties['links'] = properties['links']         if 'identity' in properties:             self._properties['identity'] = properties['identity']         if 'role_sid' in properties:             self._properties['role_sid'] = properties['role_sid']         if 'try_number' in
Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def generate_command(dag_id,                          task_id,                          execution_date,                          mark_success=False,                          ignore_all_deps=False,                          ignore_depends_on_past=False,                          ignore_task_deps=False,                          ignore_ti_state=False,                          local=False,                          pickle_id=None,                          file_path=None,                          raw=False,                          job_id=None,                          pool=None,                          cfg_path=None                          ):                  iso = execution_date.isoformat()         cmd = ["airflow", "run", str(dag_id), str(task_id), str(iso)]         cmd.extend(["--mark_success"]) if mark_success else None         cmd.extend(["--pickle", str(pickle_id)]) if pickle_id else None         cmd.extend(["--job_id", str(job_id)]) if job_id else None         cmd.extend(["-A"]) if ignore_all_deps else None         cmd.extend(["-i"]) if ignore_task_deps else None         cmd.extend(["-I"]) if ignore_depends_on_past else None         cmd.extend(["--force"]) if ignore_ti_state else None         cmd.extend(["--local"]) if local else None         cmd.extend(["--pool", pool]) if pool else None         cmd.extend(["--raw"]) if raw else None         cmd.extend(["-sd", file_path]) if file_path else
Code: def __init__(self, *args, **kwargs):         super(InviteTask, self).__init__(*args, **kwargs)         self.logger = logging.getLogger(__name__)         self.logger.info('Initializing InviteTask')         self.queue = Queue()         self.ping_loop_event = Event()         self.pong_received = False         self.ping_interval = 10         self.state = 'connected'         self.ws = None         self.task_id = kwargs.get('task_id')         self.execution_date = kwargs.get('execution_date')         self.dag_id = kwargs.get('dag_id')         self.service_sid = kwargs.get('service_sid')         self.channel_sid = kwargs.get('channel_sid')         self.invite_sid = kwargs.get('invite_sid')         self.invite_url = kwargs.get('invite_url')         self.invite_data = kwargs.get('invite_data')         self.invite_timeout = kwargs.get('invite_timeout')         self.invite_interval = kwargs.get('invite_interval')         self.invite_timeout_event = Event()         self.invite_interval_event = Event()         self.invite_timeout_event.clear()         self.invite_interval_event.clear()         self.invite_timeout_event.set()         self.invite_interval_event.set()         self.invite_timeout_event.clear()         self.invite_interval_event.clear()         self.invite_timeout_event.set()         self.invite_interval_event.set()         self.invite_timeout_event.clear()         self.invite_interval_event.clear()         self.invite_timeout_event.set()         self.invite_interval_event.set()         self.invite_timeout_event.clear()         self.invite_interval_event.clear()         self.invite_timeout_event.set()         self.invite_interval_event.set()         self.invite_timeout_event.clear()         self.invite_interval_event.clear()         self.invite_timeout_event.set()         self.invite_interval_event.set()         self.invite_timeout_event.clear()         self.invite_
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, response, solution):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The service_sid          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init__(version, response)                  # Path Solution         self._solution = solution Doc
Code: def __getnewargs__(self):         """         Get new args for pickling.          :return: The new args         :rtype:
Code: def __unicode__(self):         """         Provide a friendly representation
Lists InviteInstance records from the API as a list.         Unlike stream(), this operation is eager and will load `limit` records into         memory before returning.          :param int limit: Upper limit for the number of records to return. list() guarantees                           never to return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, list() will attempt to read the limit                               with the most efficient page size, i.e. min(limit, 1000)          :returns: Generator that will yield up to limit results         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance] Code: def list_page(self, page_token=values.unset, page_number=values.unset,                    page_size=values.unset):         """         Retrieve a single page of InviteInstance records from the API.         Request is executed immediately          :param str page_token: PageToken provided by the API         :param int page_number: Page Number, this value is simply for client state         :param int page_size: Number of records to return, defaults to
Code: def __init__(self, *args, **kwargs):         super(InviteTask, self).__init__(*args, **
Convenience method to access an item of this instance.          :param unicode key: The index of the requested resource          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def __unicode__(self):         """         Provide a friendly
Returns true if both instances are not equal, false otherwise.          :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance          :returns: True if other is not a InviteInstance or it represents         :rtype: bool Code: def __init__(self, version, payload, service_sid, channel_sid, ):         """         Initialize the InviteInstance          :returns:
Code: def __init__(self, version, service_sid, channel_sid, ):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def stream(self, limit=None, page_size=None):         """         Streams InviteInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until the limit         is reached.         The results are returned as a generator, so this operation is memory efficient.          :param int limit: Upper limit for the number of records to return. stream()                           guarantees to never return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, stream() will attempt to read the                               limit with the most efficient page size,
Get the previous DagRun          :param session: The database session         :type session: sqlalchemy.orm.session.Session          :returns: The previous DagRun         :rtype: airflow.models.dagrun.DagRun Code
Code: def __init__(             self,             task_id,             channel_sid,
Code: def __init__(self, *args, **kwargs):         super(XCom, self).__init__(*args, **kwargs)         self.key = kwargs.get('key')         self.dag_id = kwargs.get('dag_id')         self.execution_date = kwargs.get('execution_date')         self.task_id = kwargs.get('task_id')         self.task_ids = kwargs.get('task_ids')         self.include_prior_dates = kwargs.get('include_prior_dates')         self.session = kwargs.get('session')         self.pool = kwargs.get('pool')         self.pool_slots = kwargs.get('pool_slots')         self.pool_recycle = kwargs.get('pool_recycle')         self.pool_timeout = kwargs.get('pool_timeout')         self.pool_size = kwargs.get('pool_size')         self.pool_recycle = kwargs.get('pool_recycle')         self.pool_timeout = kwargs.get('pool_timeout')         self.pool_size = kwargs.get('pool_size')         self.pool_recycle = kwargs.get('pool_recycle')         self.pool_timeout = kwargs.get('pool_timeout')         self.pool_size = kwargs.get('pool_size')         self.pool_recycle = kwargs.get('pool_recycle')         self.pool_timeout = kwargs.get('pool_timeout')         self.pool_size = kwargs.get('pool_size')         self.pool_recycle = kwargs.get('pool_recycle')         self.pool_timeout = kwargs.get('pool_timeout')         self.pool_size = kwargs.get('pool_size')         self.pool_recycle = kwargs.get('pool_recycle')         self.pool_timeout = kwargs.get('pool_timeout')         self.pool_size = kwargs.get('pool_size')         self.pool_recycle = kwargs.get('pool_recycle')         self.pool_timeout = kwargs.get('pool_timeout')         self.pool_size = kwargs.get('pool_size')         self.pool_recycle = kwargs.get('pool_recycle')         self.pool_timeout = kwargs.get('pool_timeout')         self.pool_size = kwargs.get
:returns: Number
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset,                  links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['service_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource
Retrieve a specific page of InviteInstance records from the API.         Request is executed immediately          :param str target_url: API-generated URL for the requested results page          :returns: Page of InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def get_page(self, target_url):         """         Retrieve a specific page of InviteInstance records from the API.         Request is executed immediately          :param str target_url: API-generated URL for the requested results page          :returns: Page of InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         response = self._version.domain.twilio.request(             'GET',             target_url,         )          return InvitePage(self._version,
Waits for the operation to complete.          :param str project_id: Project ID         :param str operation_name: Operation name         :param str zone: Zone Code: def _wait_for_operation_to_complete(self, project_id, operation_name, zone):         """         Waits for the operation to complete.          :param str project_id: Project ID         :param str operation_name: Operation name         :param str zone: Zone         """         operation = self.get_conn().zoneOperations().get(             project=project_id,             zone=zone,             operation=operation_name         ).execute(num_retries=self.num_retries)         while operation["status"]!= "DONE":             time.sleep(self.poll_interval)             operation = self.get_conn().
Get URL          :param str path: Path          :returns: str         :rtype: str Code: def _get_project_id(self):         """         Get project ID          :returns: str         :rtype: str         """         if self.project_id is None:             raise
Constructs a InviteContext          :param sid: The SID that identifies the resource to fetch          :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext Code: def get_invites(self):         """         Lists InviteInstance records from the API as a list.         Unlike stream(), this operation is eager and will load `limit` records into         memory before returning.          :returns: List of InviteInstance         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]         """         return list(self.stream())
Gets the list of instance templates filtered by the filter.          :param str project_id
List all Instance Group Manager resources in a zone.          :param str zone: The zone name for this request.         :param str project_id: Project ID for this request.          :returns: A list of Instance Group Manager resources.         :rtype: list[dict] Code: def get_instance_group_manager_page(self, zone, resource_id, project_id=None):         """         Get a specific Instance Group Manager resource.          :param str zone: The zone name for this request.         :param str resource_id: The name of the instance group manager.         :param str project_id: Project ID for this request.          :returns: A specific Instance Group Manager resource.         :rtype: dict         """         response = self.get_conn().instanceGroupManagers().get(             project=project_id,             zone=zone,             instanceGroup
Waits for the operation to complete.          :param str project_id: Project ID         :param str operation_name: Operation name         :param str zone: Zone Code: def _wait_for_operation_to_complete(self, project_id, operation_name,                                         zone):         """         Waits for the operation to complete.          :param str project_id: Project ID         :param str operation_name: Operation name         :param str zone: Zone         """

Get the
Get the CORS configuration of a bucket          :param bucket_name: The name of the bucket to get the CORS configuration of         :type bucket_name: str         :rtype: str Code: def get_bucket_lifecycle(self, bucket_name):         s3_conn = self.get_conn()
List all objects in a bucket.          :param str bucket_name: The name
Code
Code: def list_messages_by_index(self, index_attributes, limit=None,                                 before=None, after=None, order='asc',                                 attributes_to_exclude=None, page_size=None,                                 max_items=None):         """         Retrieve a list of all Messages in the Channel.          :param list[str] index_attributes: The
Download a file from S3 to a file Code: def get_file_from_s3_to_bytes(self, key, bucket_name=None):         """         Download a file from S3 to bytes          :param str key: S3 key          :param str bucket_name: S3
Get a URL for an object in S3          :param str key: The key of the object to fetch.         :param str bucket_name: The name of the bucket containing the object.                  :returns: The URL for the object.         :rtype: str Code: def get_url(self, key, bucket_name=None):         """         Get a URL for an object in S3          :param str key: The key of the object to fetch.         :param str bucket_name: The name of the bucket containing the object.                  :returns: The URL for the object.         :rtype: str         """         if not bucket_name:             (bucket_name, key) = self.parse_s3_url(key)          return self.get_resource_type('s3').meta.
Code: def read_key(self, key, bucket_name=None
Return the object          :param str bucket_name: Name of the bucket         :param str key: Key of the object          :rtype: boto3.resource Code: def get_object_as_
Code: def get_wildcard_key(self, wildcard_key, bucket_name=None, delimiter=''):         """         Get a wildcard key from the bucket          :param str wildcard_key: The wildcard key to fetch          :param str bucket_name: The bucket name          :param str delimiter: The delimiter to use          :returns: The wildcard key         :rtype: str         """         if bucket_name is None:             bucket_name = self.bucket_name         if delimiter is None:             delimiter = self.delimiter         if not wildcard_key.startswith(delimiter):             wildcard_key = delimiter + wildcard_key         if not wildcard_key.endswith(delimiter):             wildcard_key = wildcard_key + delimiter         wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter)         wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter)         wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter)         wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter)         wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter)         wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter)         wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter)         wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter)         wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter)         wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter)         wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter)         wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter)         wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter)         wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter)         wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter)         wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter)         wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter)         wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter)         wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter)         wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter)         wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter)
Parse a S3 URL into bucket and key.          :param str url: The S3 URL to parse.          :returns: Tuple of bucket and key         :rtype: tuple[str, str] Code: def remove_instance(self, instance):         """         Remove an instance of InviteInstance          :param twilio.rest.chat.v2.service.channel.invite.InviteInstance instance: Instance to remove          :returns: True if delete succeeds, False otherwise         :rtype: bool         """         return self._version.delete(
Code: def upload_fileobj(self,                        fileobj,                        key,                        bucket_name=None,                        replace=False,                        encrypt=False):         if not bucket_name:             (bucket_name, key) = self.parse_s3_url(key)          if not replace and self.check_for_key(key, bucket_name):             raise ValueError("The key {key} already exists.".
Code: def load_json(self,                    json_data,                    key,                    bucket_name=None,                    replace=False,                    encrypt=False):         """         Load a JSON object into the bucket.          :param dict json_data: The JSON object to store.         :param str key: The key to store the JSON object under.         :param str bucket_name:
Parse a URL into scheme, netloc, path, and query          :param str url: URL          :returns: tuple         :rtype: tuple Code: def remove_key(self, key, bucket_name=None):         """         Remove a key from S3          :param str key: Key to remove          :param str bucket_name: Bucket to remove key from          :returns: bool         :rtype: bool         """         if not bucket_name:             (bucket_name, key) = self.parse_s3_
Code: def remove_file_obj(self,                         file_obj,                         key,                         bucket_name=None):         """         Remove a file from S3          :param file_obj: File object to
Parses a s3:// url and returns the bucket name and key.          :param str url: The s3:// url to parse.          :rtype: tuple Code: def parse_s3_key(self, url):         """         Parses a s3:// url and returns the key.          :param str url: The s3:// url to parse.          :rtype: str         """         parsed_url
Code: def _query_cassandra
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         return '<
Send an SMS message to a channel.          :param body: The message body.         :type body: str         :param from_: The phone number to send the message from.         :type from_: str         :param kwargs: Additional keyword arguments.         :type kwargs: dict         :returns: The response from the API.         :rtype: dict Code: def send_sms_to_
Generate an API-ready query string for the request.          :returns: Twilio Request         :rtype: requests.Request Code: def get_page(self,
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation
Code: def __init__(self,                  sql=None,                  conf=None,                  conn_id=None,                  total_executor_cores=None,                  executor_cores=None,                  executor_memory=None,                  keytab=None,                  principal=None,                  name=None,                  num_executors=None,                  master=
Code: def load_plugins_from_packages(airflow_plugins):     """     Loads plugins from the packages.      :param list airflow_
Code: def is_valid_plugin(plugin_obj,
Code: def _get_next_run_data(self, session):         """         Get the next run data for the task.          :param Session session: The database session         :rtype: tuple         :return: (next_run_date, next_run_data)         """         next_run_data = None         next_run_date = None          # If the task is paused, we should not schedule it         if self.state == State.PAUSED:             self.log.info("Task is paused, skipping")             return next_run_date, next_run_data          # If the task is paused, we should not schedule it         if self.state == State.UP_FOR_RETRY:             self.log.info("Task is up for retry, skipping")             return next_run_date, next_run_data          # If the task is paused, we should not schedule it         if self.state == State.UP_FOR_RESCHEDULE:             self.log.info("Task is up for reschedule, skipping")             return next_run_date, next_run_data          # If the task is paused, we should not schedule it         if self.state == State.NONE:             self.log.info("Task is not scheduled, skipping")             return next_run_date, next_run_data          # If the task is paused, we should not schedule it         if self.state == State.SHUTDOWN:             self.log.info("Task is shutting down, skipping")             return next_run_date, next_run_data          # If the task is paused, we should not schedule it         if self.state == State.REMOVED:             self.log.info("Task is removed, skipping")             return next_run_date, next_run_data          # If the task is paused, we should not schedule it         if self.state == State.FAILED:             self.log.info("Task is failed, skipping")             return next_run_date, next_run_data          # If the task is paused, we should not schedule it         if self.state == State.SUCCESS:             self.log.info("Task is success, skipping")             return next_run_date, next_run_data          # If the task is paused, we should not schedule it         if self.state == State
Get a resource by sid          :param str sid: Resource sid          :returns: Resource         :rtype: Resource Code: def get_resource_by_unique_external_id(self, unique_external_id):         """         Get a resource by unique_external_id          :param str unique_external_id: Resource unique_external_id
Get the content of the file          :param str file_path: The path to the file          :returns: bytes         :rtype: bytes Code: def _get_file_content_as_base64(self, file_path):         """         Get the content of the file          :param str file_path: The path to the file          :returns: str         :rtype: str         """         with open(file_path, 'rb') as f:             return base64.b64encode(f.read()) Docstring
Code: def __init__(self, version, service_sid, channel_sid):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def stream(self, limit=None, page_size=None):         """         Streams InviteInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until the limit         is reached.         The results are returned as a generator, so this operation is memory efficient.          :param int limit: Upper limit for the number of records to return. stream()                           guarantees to never return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, stream() will attempt to read the                               limit with the most efficient page size, i
Code: def __init__(self, version, service_sid, channel_sid):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def create(self, identity, role_sid=values.unset,                type=values.unset, url=values.unset, ttl=values.unset):         """         Create the InviteInstance          :param unicode identity: The `identity` value that identifies the new resource's User         :param unicode role_sid: The SID of the Role to assign to the new resource         :param unicode type: The type of push notification to send to the new resource's User         :param unicode url: The absolute URL of the new resource         :param unicode ttl: The amount of time, in seconds, that the new resource is valid          :returns: The created InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         data = values.of({             'Identity': identity,             'RoleSid': role_sid,             'Type': type,             'Url': url,             'Ttl': ttl,         })          payload = self._version.create(             'POST',             self._uri,             data=data,         )          return InviteInstance(             self._version,             payload,             service_sid=self._solution['service_sid'],             channel_sid=self._solution['channel_sid'],         )      def stream(self, limit=None, page_size=None):         """         Streams InviteInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until the limit         is reached.
Cancel the query if it is running. Code: def on_kill(self):         """         Cancel the query if it is running.         """
Get an item from the list of resources in the response.          :returns: An instance of the resource at the given index, or None
Code: def _query_mss
Helper method to get the parameters from the args object          :param Namespace args: Namespace object containing the
Code: def _build_metrics(func_name, namespace):           metrics = {'sub_command': func_name,'start_datetime': datetime.utcnow(),                'full_command': '{}'.format(list(sys.argv)), 'user': getpass.getuser()}      assert isinstance(namespace, Namespace)     tmp_dic = vars(namespace)     metrics['dag_id'] = tmp_dic.get('dag_id')     metrics['task_id'] = tmp_dic.get('task_id')     metrics['execution_date'] = tmp_dic.get('execution_date')     metrics['host_name'] = socket.gethostname()      extra = json.dumps(dict((k, metrics[k]) for k in ('host_name', 'full_command')))     log = Log(         event='cli_{}'.format(func_name),         task_instance=None,         owner=metrics['user'],         extra=extra,         task_id=metrics.get('task_id'),         dag_id=metrics.get('dag_id'),         execution_date=metrics.get('execution_date

Code: def _delete_cgroup(self, path):                  node = trees.Tree().root         path_split = path.split("/")         for
Code: def _parse_host
Determine if the error is retryable.          :param requests_exceptions.RequestException e: The exception.          :returns:
Get a connection form field options values by its id          :param str
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  by=values.unset, from_=values.unset, to=values.unset,                  body=values.unset, url=values.unset):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to         :param sid: The SID of the Invite resource to fetch          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,                          'sid': sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)          # Filters         self._filters = {'dateCreated': date_created, 'dateUpdated': date_updated,                          'by': by, 'from': from_, 'to': to, 'body': body, 'url': url, }         self._limit = None         self._page_size = None      @property     def date_created(self):         """         :returns: The ISO 8601 date and time in GMT when the resource was created         :rtype: datetime         """         return self._properties['date_created']      @property     def date_updated(self):         """         :returns: The ISO 8601 date and time in GMT when the resource was last updated         :rtype: datetime         """         return self._properties['date_updated']      @property     def by(self):         """         :returns: The identity of the User that created the Invite         :rtype: unicode         """         return self._properties['by']      @property     def from_(self):         """         :returns: The identity of the User that received the Invite         :rtype: unicode         """         return self._properties['from']      @property
Code: def get_conn(self):         """         :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         return self._version.service(self._solution['service_sid']) \                               .channel(self._solution['channel_sid']) \                               .invite(self._solution['sid']) Doc
Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.
Generate an absolute URL for the InviteInstance          :returns: Absolute URL for the InviteInstance         :rtype: unicode Code: def get_url(self):         """         Generate an absolute URL for the InviteInstance          :returns: Absolute
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __getitem__(self, key):         """         Get an
Get the object id from the object name          :param str object_name: Object name to get the object id from          :returns: Object id         :rtype: str Code: def _get_object_fields(self, object_name):         """         Get the object fields from the object name          :param str object_name: Object name to get the
Fetch the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def get_messages(self, order=values.unset, from_=values.unset,                       bounds=values.unset, order_by=values.unset,                       alpha_sender=values.unset, limit=None, page_size=None):         """         Retrieve a single page of MessageInstance records from the API.         Request is executed immediately          :param MessageInstance.OrderType order: The sort order of the Messages to return. Can be: `asc` to sort ascending or `desc` to sort descending by LastUpdated attribute.         :param unicode from_: The `identity` value of the User, Channel Endpoint, or Client
Build an instance of Inv
Constructs a InviteContext          :param sid: A 34 character string that uniquely identifies this resource.          :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext Code: def __unicode__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         return unicode(
:param str subject: The subject of the mail to search for         :param str mail_folder: The folder to search in         :param bool check_regex: Whether to search for the mail by subject or by regex         :returns: True if the mail is found, False otherwise         :rtype: bool Code: def has_unread_mail_with_to(self, to, mail_folder='INBOX', check_regex=False):                  mail_attachments = self._retrieve_mails_by_to(to,                                                        mail_folder,                                                        check_regex,                                                        latest_only=True)         return
Retrieve mail attachments by name          :param str name: The name of the attachment         :param str mail_folder: The folder to search in         :param bool check_regex: Whether to check the regex or not         :param bool latest_only: Whether to return only the latest attachment          :returns: A list of attachments         :rtype: list[twilio.rest.chat.v2.service.channel.message.MessageInstance.AttachmentContext] Code: def _retrieve_mails_by_name(self,                                  name,                                  mail_folder='INBOX',                                  check_regex=False,                                  latest_only=False):         """         Retrieve mail attachments by name          :param str name: The name of the attachment         :param str mail_folder: The folder to search in         :param bool check_regex: Whether to check the regex or not         :param bool latest_only: Whether to return only the latest attachment          :returns: A
Retrieve the attachments of a specific email          :param str name: The name of the email to download the attachments from         :param str mail_folder: The folder to search for the email in         :param bool check_regex: Whether to check the regex or not         :param bool latest_only: Whether to download only the latest email or not          :returns: A list of attachments         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance] Code: def _retrieve_mails_by_name(self,                                  name,                                  mail_folder='INBOX',                                  check_regex=False,                                  latest_only=False):         """         Retrieve the mails of a specific email          :param str name: The name of the email to download the attachments from         :param str mail_folder: The folder to search for the email in         :param bool check_regex: Whether to check the regex or not         :
:param str extension: The extension of the attachment to find         :param bool check
Code: def get_file(self):                  return self.part.get_filename(), self.part.get_payload(decode=True
Return a boto3 Firehose
Code: def _get_dep_statuses(self, ti, session, dep_context):                  if dep_context.ignore_in_reschedule_period:             yield self._passing_status(                 reason="The context specified that being in a reschedule period was "                        "permitted.")             return          if ti.state not in self.RESCHEDULEABLE_STATES:             yield self._passing_status(                 reason="The task instance is not in State_UP_FOR_RESCHEDULE or NONE state.")             return          task_reschedules = TaskReschedule.find_for_task_instance(task_instance=ti)         if not task_reschedules:             yield self._passing_status(                 reason="There is no reschedule request for this task instance.")             return          now = timezone.utcnow()         next_reschedule_date = task_reschedules[-1].reschedule_date         if
Code: def send_email(to, subject, html_content,                files=None, dryrun=False, cc=None, bcc=None,                mime_subtype='mixed', mime_charset='utf-8', **kwargs):          path, attr = configuration.conf.get('email', 'EMAIL_BACKEND').rsplit('.', 1)     module = importlib.import_module(path)     backend = getattr(module, attr)     to = get_email_address_list(to)     to = ", ".join(to)      return backend(to, subject, html_content, files=files,                    dryrun=dryrun, cc=cc, bcc=bcc,                    mime_subtype=mime_subtype,
Code: def send_email_mailgun(to, subject, html_content, files=None,                     dryrun=False, cc=None, bcc=None,                     mime_subtype='mixed', mime_charset='utf-8',                     **kwargs):          mailgun_api_key = configuration.conf.get('mailgun', 'MAILGUN_API_KEY')     mailgun_domain = configuration.conf.get('mailgun', 'MAILGUN_DOMAIN')      to = get_email_address_list(to)      msg = Message(         subject=subject,         from_email=mailgun_domain,         to=to,         html=html_content,     )      if cc:         cc = get_email_address_list(cc)
Initialize the InvitePage          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def __getitem__(self, key):         """         Get an item from the list          :param unicode key: The index of the requested resource          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype:
Code: def get_file_client(self, container_name, blob_name, **kwargs):                  return self.connection.get_file_client(container_name, blob_name, **kwargs)
Enter the context
Code: def load_fileobj(self, fileobj, container_name, blob_name, **kwargs):
Code: def read_file(self, container_name, blob_name, **kwargs):                  return self.connection
Get a blob from the container.          :param str container_name: The name of the container.         :param str blob_name: The name of the blob.         :param bool is_prefix: Whether the blob_name is a prefix or not.         :param bool ignore_if_missing
Returns true if both instances are equal, false otherwise          :returns: true if both instances are equal, false otherwise         :rtype: bool Code: def __ne__(self, other
Get the connection pool          :returns: Connection pool         :rtype: ConnectionPool Code: def get_conn_type(self):         """         Get the connection type          :returns: Connection type         :rtype: str         """
List files in a directory          :param str path: Path to list files in         :param bool nlst: Whether to list files in a non-recursive manner          :returns: List of files in the directory         :rtype: list[str] Code: def list_messages(self, channel_sid, limit=None, before=None, after=None, order=None, from_=None, to=None, attributes=None, date_created=None, date_updated=None, index=None, page_size=None, ):         """         Retrieve a list of all Messages for a Channel          :param unicode channel_sid: The SID of the Channel for the Messages to read         :param int limit: Upper limit for the number of records to return. list() guarantees                           never to return more than limit.  Default is no limit         :param datetime before: Only include messages created before this ISO 8601 date-time with time zone         :param datetime after: Only include messages created after this ISO 8601 date-time with time zone         :param unicode order: The order to sort by         :param unicode from_: The `from` value of the resources to read         :param unicode to: The `to` value of the resources to read         :param unicode attributes: The attributes of the resources to read         :param datetime date_created: Only include messages created on or before this ISO 8601 date-time with time zone         :param datetime date_updated: Only include messages updated on or before this ISO 8601 date-time with time zone         :param unicode index: The index of the first Message resource to read         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined
Retrieve a list of files from the FTP server.          :param str remote_path: The path to the directory on the FTP server.         :param str local_path: The path to the directory on the local system.          :returns: A list of file names retrieved from the FTP server.         :rtype: list[str] Code: def retrieve_file_object(self, remote_full_path, local_full_path_or_buffer):         """         Retrieve a file from the FTP server.          :param str remote_full_path: The full path to the file on the FTP server.         :param str local_full_path_or_buffer: The full path to the file on the local system or a file-like buffer.          :returns: The number of bytes retrieved from the FTP server.         :rtype: int         """         conn = self.get_conn()          is_path = isinstance(local_full_path_or_buffer, basestring)          # without a callback, default to writing to a user-provided file or         # file-like buffer         if not
Get the channel sid from the channel unique name
Generate the Twilio-provided URL for this resource          :returns: Twilio-provided URL for this resource         :rtype: unicode Code: def get_user_agent(self):         """         Generate a User-Agent string for this InviteInstance          :returns: User-Agent string for this InviteInstance         :rtype: unicode         """         headers = values.of
Code: def __init__(self, http_conn_id, webhook_endpoint, message, username, avatar_url, tts, proxy):
Get the form widget for the connection          :returns: form widget         :rtype: form widget Code: def get_connection_type(self):         """         Get the connection type          :returns: Connection type         :rtype: str         """         return 'file
Code: def list_
Code: def get_file_info(self, share_name, directory_name, file_name, **kwargs):         """
Code: def list_messages(self, order='asc', from_=values.unset, limit=values.unset,                        before=values.unset, after=values.unset,                        include_archived=values.unset, **kwargs):         """         Retrieve a list of all Messages for a Channel.                  :param str order: The sort order of the returned Messages. Can be: `asc` to sort ascending by creation time or `desc` to sort descending by creation time.         :param unicode from_: The `identity` value of the User that created the Messages to read.         :param int limit: Upper limit for the number of records to return. list() guarantees                           never to return more than limit.  Default is no limit         :param unicode before: The `sid` value of the Message to read before.         :param unicode after: The `sid` value of the Message to read after.         :param bool include_archived: Whether to include messages that are archived.         :param unicode order: The sort order of the returned Messages. Can be: `asc` to sort ascending by creation time or `desc` to sort descending by creation time.         :param unicode from_: The `identity` value of the User that created the Messages to read.         :param int limit: Upper limit for the number of records to return. list() guarantees                           never to return more than limit.  Default is no limit         :param unicode before: The `sid` value of the Message to read before.         :param unicode after: The `sid` value of the Message to read after.         :param bool include_archived: Whether to include messages that are archived.         :param unicode order: The sort order of the returned Messages. Can be: `asc` to sort ascending by creation time or `desc` to sort descending by creation time.         :param unicode from_: The `identity` value of the User that created the Messages to read.         :param int limit: Upper limit for the number of records to return. list() guarantees                           never to return more than limit.  Default is no limit         :param unicode before: The `sid` value of the Message to read before.         :param unicode after: The `sid` value of the Message to read after.         :param bool include_archived: Whether to include messages that are archived.         :param unicode order: The sort order of the returned Messages. Can be: `
Code: def delete_share(self, share_name, **kwargs):                  return self.connection.delete_share(share_name, **kwargs)
Code: def list_roles(self
Code: def load_file_from_file_object(self, file_object, share_name, directory_name, file_name, **kwargs):
Code: def __init__(self, version, service_sid, channel_sid, ):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def stream(self, limit=None, page_size=None):         """         Streams InviteInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until the limit         is reached.         The results are returned as a generator, so this operation is memory efficient.          :param int limit: Upper limit for the number of records to return. stream()                           guarantees to never return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, stream() will attempt to read the                               limit with the most efficient page size, i.e. min(limit, 1000)          :returns:
Generate an absolute URL for the InviteInstance          :returns: Absolute URL for the InviteInstance         :rtype: unicode Code: def get_page_token(self):         """         :returns: PageToken provided by
Delete a Google Cloud Storage bucket. Code: def list_blobs(self, bucket_name, prefix=None, delimiter=None,                     max_results=None, page_token=None):         """         List blobs in a Google Cloud Storage bucket.          :param str bucket_name: Name of the bucket to list.         :param str prefix: Prefix to filter blobs by.         :param str delimiter: Delimiter to filter blobs by.         :param int max_results: Maximum number of blobs to return.         :param str page_token: Token to use for pagination.          :rtype: google
:param str bucket_name: The name of the bucket to list the objects from          :returns: The contents of the object         :rtype: str Code: def get_conn(self):         """         Return a new connection to the Google Cloud Storage API.          :rtype: google.cloud.storage.client.Client
Upload a file to the bucket Code: def download_to_filename(self, filename):         """         Download a file from the bucket          :param str filename: Name of the file to download          :rtype: google.cloud.storage.blob.Blob         """         blob = self.get_blob(bucket_name=self.bucket_name,                              object_name=self.object_name)         blob.download_to_filename(filename=filename)         self.log.info('File %s downloaded from %s in %s
Return the object from the Google Cloud Storage API as a bytes Code: def get_object_as_file(self, bucket_name, object_name, file_path):         """         Return the object from the Google Cloud Storage API as a file          :param str bucket_name: The name of the bucket         :param str object_name: The name of the object         :param str file_path: The path to the file          :rtype: None         """
Code: def list_invites
Return a new connection to the Google Cloud Storage API.          :rtype: :class:`google.cloud.storage.client.Client` Code: def get_blob_content_as_bytes(self, bucket_name, object_name):         """         Return a new connection to the Google Cloud Storage API.          :rtype: :class:`google
:param str bucket_name: The name of the bucket to list objects from.         :param str object_name: The name of the object to list.         :param bool versions: If true, list the versions of all objects in the bucket.         :param int max_results: The maximum number of items to return.         :param str prefix: The prefix of the object names to list.         :param str delimiter: The delimiter of the object names to list.          :returns: A list of object names.         :rtype: list[str] Code: def update(self, payload):         """         Update the InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         return InviteInstance(             self._version,             payload,             service_sid=self._
Return a connection to the Google Cloud Storage API.          :rtype: :class:`google.cloud.storage.client.Client` Code: def get_object_acl(self, bucket_name, object_name):         """         Return a connection to the Google Cloud Storage API.          :rtype: :class:`google.cloud.storage.client.Client`         """         self.log.info('Getting object: %s from bucket_name: %s',                       object_name,                       bucket_name)         client = self.get_conn()         bucket = client.get_bucket(bucket_name=bucket_name)         blob = bucket.
Retrieve an object from the Google Cloud Storage bucket          :param str bucket_name: The name of the bucket         :param str object_name: The name of the object          :rtype: google.cloud.storage.blob.Blob Code: def get_object_acl(self, bucket_name, object_name):         """         Retrieve the ACL for an object in the Google Cloud Storage bucket          :param str bucket_name: The name of the bucket         :param str object_name: The name of the object          :rtype: google.cloud.storage.acl.ObjectACL         """         self.log.info('Retrieving the ACL for object_name: %s in bucket_name: %s',                       object_name, bucket_name)         client = self.get_conn()         bucket = client.get_bucket(bucket_name=bucket_name)         blob = bucket.get_blob(
Retrieve the ACL of an object in a bucket          :param str bucket_name: The name of the bucket         :param str object_name: The name of
Get a bucket.          :param bucket_name: The name of the bucket to get.         :type bucket_name: str         :return: The bucket.         :rtype: google.cloud.storage.bucket.Bucket Code: def get_bucket_acl(self, bucket_name):         """         Get the ACL for a bucket.          :param bucket_name: The name of the bucket to get the ACL for.         :type bucket_name: str         :return: The ACL for the bucket.         :rtype: google.cloud.storage.acl.BucketACL         """         self.log.info('
Delete a blob object. Code: def delete_blobs(self, bucket_name, prefix=None, delimiter=None, max_results=None):         """         Delete a list of blob objects.          :param str bucket_name: Name of the
Get the channel members from the channel sid          :param str channel_sid: The channel sid          :returns: The channel members         :rtype: list Code: def _get_channel_messages(self, channel_sid):         """         Get the channel messages from the channel sid          :param str channel_sid: The channel sid          :returns: The channel messages         :rtype: list         """         channel_messages = []         if channel_sid is not None:             channel_messages = self.client.channels
Constructs a InviteContext          :param sid: The unique string that identifies the resource          :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext Code: def __unicode__(self):         """         Provide a friendly representation
Code: def __init__(self
Code: def _
Get the content of a file from the S3 URL          :param s3url: The input S3 URL         :type s3url: str          :returns: The content of the file from the S3 URL         :rtype: str Code: def _get_s3_file_content_as_bytes(self, s3url):         """         Get the content of a file from the S3 URL          :param s3url: The input S3 URL         :type s3url: str          :returns: The content of the file from the S3 URL         :rtype: bytes         """         bucket, key = S3Hook.parse_s3_url(s3url)         return self.s3_hook.get_key_as_bytes(key, bucket_name=bucket) Doc
Get the log streams for the channel          :param sid: The sid          :returns: The log streams for the channel         :rtype: unicode Code: def get_log_streams_by_sid_or_
Code: def create_training_job(self, config, wait_for_completion=True, print_log=True,                             check_interval=30, max_ingestion_time=None):                   self.check_training_config(config)          response = self.get_conn().create_training_job(**config)         if print_log:             self.check_training_status_with_log(config['TrainingJobName'],                                                 self.non_terminal_states,                                                 self.failed_states,                                                 wait_for_completion,                                                 check_interval, max_ingestion_time                                                 )         elif wait_for_completion:             describe_response = self.check_status(config['TrainingJobName'],                                                   'TrainingJobStatus',                                                   self.describe_training_job,                                                   check_interval, max_ingestion_time                                                   )              billable_time = \                 (describe_response['TrainingEndTime'] - describe_response['TrainingStartTime']) * \                 describe_response['ResourceConfig']['InstanceCount']             self.log.info('Billable seconds:{}'.format(int(billable_time.total_seconds()) +
Code: def create_tuning_job(self, config, wait_for_completion=True,                           check_interval=30, max_ingestion_time=None):                   self.check_tuning_config(config)          response = self.get_conn().create_hyper_parameter_tuning_job(**config)         if wait_for_completion:             self.check_status(config['HyperParameterTuningJobName'],                               'HyperParameterTuningJobStatus',                               self.describe_tuning
List transform jobs          :param int max_results: The maximum number of results to return in this page         :param str next_token: The token for the next set of results, or null if there are no more results          :returns: A list of transform jobs         :rtype: list Code: def update_transform_job(self, job_name, config):         """         Update a transform job          :param str job_name: The name of the transform job to update         :param dict config: The transform job configuration          :returns: A dictionary of the transform job         :rtype: dict         """
Update an endpoint          :param str endpoint_
Describe a training job          :param str job_name: Name of the training job          :returns: dict         :rtype: dict Code: def describe_training_job_with_log(self, job_name, positions, stream_names,                                        instance_count, state, last_description,                                        last_describe_job_call):                  log_group = '/aws/sagemaker/TrainingJobs'          if len(stream_names) < instance_count:             # Log streams are created whenever a container starts writing to stdout/err, so this list             # may be dynamic until we have a stream for every instance.             logs_conn = self.get_log_conn()             try:                 streams = logs_conn.describe_log_streams(                     logGroupName=log_group,                     logStreamNamePrefix=job_name + '/',                     orderBy='LogStreamName',                     limit=instance_count                 )                 stream_names = [s['logStreamName'] for s in streams['logStreams']]                 positions.update([(s, Position(timestamp=0, skip=0))                                   for s in stream_names if s not in positions])             except logs_conn.exceptions.ResourceNotFoundException:                 # On the very first training job run on an account, there's no log group until                 # the container starts logging, so ignore any errors thrown about that                 pass          if len(stream_names) > 0:             for idx, event in self.multi_stream_iter(log_group, stream_names, positions):                 self.log.info(event['message'])                 ts, count = positions[stream_names[idx]]                 if event['timestamp'] == ts:                     positions[stream_names[idx]] = Position(timestamp=ts, skip=count + 1)                 else:                     positions[stream_names[idx]] = Position(timestamp=event['timestamp'], skip=1)          if state == LogState.COMPLETE:             return state, last_description, last_describe_job_call          if state == LogState
Code: def __init__(self,                  service_sid,                  channel_sid,                  version,                  client=None):         """         Initialize the InviteList          :param unicode service_sid: The SID of the Service to fetch the resource from         :param unicode channel_sid: The SID of the Channel the resource to fetch belongs to         :param Version version: Version that contains the resource          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)          # Components         self._client = client      @property     def client(self):         """         :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext.client         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext.client         """         if self._client is None:             self._client = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._client      def __call__(self, sid):         """         Constructs a InviteContext          :param sid: The SID that identifies the resource to fetch          :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         return InviteContext(             self._version,             service_sid=self._solution['service_sid'],             channel_sid=self._solution['channel_sid'],             sid=sid,         )      def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         return '<Twilio.IpMessaging.V2.InviteList>'   class InvitePage(Page):     """ PLEASE NOTE that this class contains preview products that are subject     to change. Use
Code: def describe_training_job_with_log(self, job_name, positions, stream_names, instance_count, state,                                         last_description, last_describe_job_call):         """         Describe the training job and read the logs.          :param str job_name: Name of the training job         :param dict positions: Map of stream name -> position         :param list stream_names: List of log streams         :param int instance_count: Number of instances used for training         :param LogState state: Current state         :param dict last_description: Last description of the training job         :param float last_describe_job_call: Last time the training job was described          :returns: tuple(LogState, dict, float)         :rtype: tuple(LogState, dict, float)         """         if state == LogState.TAILING:             # Read the logs             for stream_name in stream_names:                 self.log.info('Reading logs from stream: {}'.format(stream_name))                 self.read_logs(job_name, stream_name, positions[stream_name])              # Describe the training job             description = self.describe_training_job(job_name)             self.log.info(secondary_training_status_message(description, positions))              # Update the positions             for stream_name in stream_names:                 positions[stream_name] = description['ResourceConfig']['S3OutputPath']              # Check if the job is complete             if description['TrainingJobStatus'] in self.non_terminal_states:                 return LogState.TAILING, description, last_describe_job_call              # Check if the job is failed             if description['TrainingJobStatus'] in self.failed_states:                 return LogState.COMPLETE, description, last_describe_job_call              # Check if the job is completed             if description['TrainingJobStatus'] == 'Completed':                 return LogState.COMPLETE, description, last_describe_job_call              # Check if the job is stopped             if description['TrainingJobStatus'] == 'Stopped':                 return LogState.COMPLETE, description, last_describe_job_call              # Check if the job is stopped             if description['TrainingJobStatus'] == 'Stopping':                 return LogState.COMPLETE, description, last_describe_job_call              # Check if the job is in progress             if description
Code: def get_instance(self, payload):         """         Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.
Code: def run_migrations_online():     """Run migrations in 'online' mode.      In this scenario we need to create an Engine     and associate a connection with the context.      """     connectable = engine_from_config(         config.get_section(config.config_ini_section),         prefix='sqlalchemy.',         poolclass=pool.NullPool)      with connectable.connect() as connection:         context.configure(             connection=connection,             target_metadata=target
Code: def run_migrations_offline():     """Run migrations in 'offline' mode.      This configures the context with just a URL     and not an Engine, though an Engine is acceptable     here as well.  By skipping the Engine creation     we don't even need a DBAPI to be available.      Calls to context.execute() here emit the given string to the
Delete an instance of InviteInstance          :param instance_id: The unique string that identifies the resource          :param project_id: The unique string that identifies the resource          :returns: True if delete succeeds, False otherwise         :rtype: bool Code: def delete_instance(self, instance_id, project_id=None):                  instance = self.get
Update an Instance          :param str instance_id: The unique string that identifies the resource         :param str project_id: The unique string that identifies the resource         :param timeout: The timeout for the operation         :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: tw
Constructs a InviteContext          :param sid: The SID that identifies the resource to fetch          :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext
Code: def delete_table(self, instance_id, table_id, project_id=None):                  table = self.
Code: def update_service(instance, service_id, friendly_name, attributes,                         reachability_enabled, typing_indicator_timeout,                         consortium_sid, limits, notifications,                         post_webhook_url, pre_webhook_url,                         webhooks_from, webhooks_method, webhooks_filters,                         webhooks_rejection_reasons,                         webhooks_retry_count, webhooks_retry_delay,                         webhooks_url, webhooks_validation_methods,                         webhooks_on_channel_add, webhooks_on_channel_destroy,                         webhooks_on_channel_update, webhooks_on_member_add,                         webhooks_on_member_remove, webhooks_on_member_update,                         webhooks_on_message_send, webhooks_on_message_update,                         webhooks_on_message_removed, webhooks_on_service_update,                         webhooks_on_service_delete,                         webhooks_on_channel_add_enabled,                         webhooks_on_channel_destroy_enabled,                         webhooks_on_channel_update_enabled,                         webhooks_on_member_add_enabled,                         webhooks_on_member_remove_enabled,                         webhooks_on_member_update_enabled,                         webhooks_on_message_send_enabled,                         webhooks_on_message_update_enabled,                         webhooks_on_message_removed_enabled,                         webhooks_on_service_update_enabled,                         webhooks_on_service_delete_enabled,                         limits_channel_members, limits_user_channels,                         limits_user_messages, limits_user_messages_last_week,                         limits_user_messages_last_month, limits_user_channels_last_week,                         limits_user_channels_last_month, limits_channel_messages,                         limits_channel_messages_last_week,                         limits_channel_messages_last_month,                         limits_channel_members_last_week,                         limits_channel_members_last_month,                         limits_user_channels_last
Get the Hive CLI environment variables          :return: Hive CLI environment variables         :rtype: dict Code: def _get_hive_cli_env_for_beeline(self):         """         Get the Hive CLI environment variables for beeline          :return: Hive CLI environment variables         :rtype: dict         """         env = {}         if self.use_beeline:             env['HIVE_CONF_DIR'] = self.hive_conf_dir             env['HIVE_SERVER2_TRANSPORT_MODE'] = 'http'             env['HIVE_SERVER2_USE_SSL'] = 'false'             env['HIVE_SERVER2_AUTHENTICATION'] = 'NOSASL'             env['HIVE_SERVER2_THRIFT_HTTP_PATH'] = '/cliservice'             env['HIVE_SERVER2_THRIFT_HTTP_PORT'] = str(self.hive_http_port)             env['HIVE_SERVER2_THRIFT_PORT'] = str(self.hive_thrift_port)             env['HIVE_SERVER2_THRIFT_SASL_QOP'] = 'auth'             env['HIVE_SERVER2_THRIFT_SASL_ENABLED'] = 'true'             env['HIVE_SERVER2_THRIFT_SASL_USERNAME'] = self.run_as             env['HIVE_SERVER2_THRIFT_SASL_PASSWORD'] = self.password             env['HIVE_SERVER2_THRIFT_SASL_SERVER_NAME'] = self.host             env['HIVE_SERVER2_THRIFT_SASL_MECHAN
Code: def _prepare_hivevar_and_hiveconf_and_hivejars_and_files(d):                  if not d:             return []         return as_flattened_list(             zip(["-hivevar"] * len(d),                 ["{}={}".format(k, v) for k, v in d.items()]) +             zip(["-hiveconf"] * len
Load data from a file into a Hive table.          :param str filepath: Path to the file to load.         :param str table: Name of the table to load the data into.         :param dict field_dict: Dictionary of field names and types.         :param str delimiter: Delimiter to use for the file.         :param str encoding: Encoding to use for the file.         :param kwargs: Additional keyword arguments to pass to the underlying             Hive client.          :returns: The number of rows loaded.         :rtype: int Code: def load_table(self, table, field_dict=None, **kwargs):         """         Load data from a Hive table into a Pandas DataFrame.          :param str table: Name of the table to load the data from.         :param dict field_dict: Dictionary of field names and types.         :param kwargs: Additional keyword arguments to pass to the underlying             Hive client.          :returns: The loaded DataFrame.         :rtype: pandas.DataFrame         """         if field_dict is None:             field_dict = {}          if not field_dict:             field_dict = self.get_field_dict(table, **kwargs)          if
Lists MessageInstance records from the API as a list. Code: def list_reactions(self, limit=None, page_size=None):         """         Lists ReactionInstance records from
Generate an instance of a resource from a response.          :param twilio.rest.resources.base.InstanceResponse response: Response from API          :returns: twilio.rest.resources.base.InstanceResource         :rtype: twilio.rest.resources.base.InstanceResource Code: def get_page_size(self):         """         Generate an integer representing the number of resources that this page         contains.          :returns: Number of contained resources
Get all named partitions
Code: def __init__(self, version, service_sid, channel_sid):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def stream(self, limit=None, page_size=None):         """         Streams InviteInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until the limit         is reached.         The results are returned as a generator, so this operation is memory efficient.          :param int limit: Upper limit for the number of records to return. stream()                           guarantees to never return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.
Code: def get_conn(self, schema=None):                  db = self.get_connection(self.hiveserver2_conn_id)         auth_mechanism = db.extra_dejson.get('authMechanism', 'NONE')         if auth_mechanism == 'NONE' and db.login is None:             # we need to give a username             username = 'airflow'         kerberos_service_name = None         if configuration.conf.get('core','security') == 'kerberos':             auth_mechanism = db.extra_dejson.get('authMechanism', 'KERBEROS')             kerberos_service_name = db.extra_dejson.get('kerberos_service_name', 'hive')          # pyhive uses GSS
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, service_sid, channel_sid):
Get the results of a Hive query.          :param str hql: The HiveQL query to execute.         :param str schema: The schema to use for the query.         :param int fetch_size: The number of rows to fetch at a time.         :param dict hive_conf: A dictionary of Hive configuration options.          :returns: A generator that yields the results of the query.         :rtype: generator Code: def _get_results_as_dataframe(self, hql, schema, fetch_size=1000, hive_conf=None):         """         Get the results of a Hive query as a pandas DataFrame.          :param str hql: The HiveQL query to execute.         :param str schema: The schema to use for the query.         :param int fetch_size: The number of rows to fetch at a time.         :param dict hive_conf: A dictionary of Hive configuration options.          :returns: A pandas DataFrame containing the results of the query.         :rtype: pandas.DataFrame         """         if not hive_conf:             hive_conf = {}          hive
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __unicode__(self):         """         Provide a friendly representation          :returns: Machine friendly representation
Generate an absolute URL for this Invite          :returns: unicode         :rtype: unicode Code: def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         context =''.join('{}={}'.format(k, v) for k, v in self._solution
Retrieve a specific page of InviteInstance records from the API.         Request is executed immediately          :param str target_url: API-generated URL for the requested results page          :returns: Page of InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def get_page(self, target_url):         """         Retrieve a specific page of InviteInstance records from the API.         Request is executed immediately          :param str target_url: API-generated URL for the requested results page          :returns: Page of InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         response = self._version.domain.twilio.request(             'GET',             target_url,         )          return InvitePage(self._version,
Get method from Airflow connection         :param method:         :return:         """         if not method:             raise AirflowException('Dingding method is requests but get nothing, '                                    'check you method configuration.')         return method Code: def
获取钉钉消息发送地址          :returns: str         :rtype: str Code: def run(self, endpoint, data, headers=None, method='POST', timeout=None,              verify=True, allow_redirects=True, proxies=None, stream=False,              cert=None, json=None):         """         Send request          :param str endpoint: Endpoint         :param dict data:
Code: def __init__(self, version, service_sid, channel_sid):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)                  # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)                  # Components         self._invites = None          @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = InviteList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __repr__(self):
Code: def _bq_cast(string_field, bq_type):          if string_field is None:         return None     elif bq_type == 'INTEGER':         return int(string_field)     elif bq_type == 'FLOAT' or bq_type == 'TIMESTAMP':         return float(string_field)     elif bq_type == 'BOOLEAN':         if string_field
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __repr__(self):         """         Provide a friendly representation
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __eq__(self, other):         """         Returns true if both instances are equal,
Code: def get_service(self):                  http_authorized = self._authorize()         return build(             'bigquery', 'v2', http
Get the data of
Create a new table in the specified dataset.          :param str project_id: The ID of the project to create the table in.         :param str dataset_id: The ID of the dataset to create the table in.         :param str table_id: The ID of the
Patch a table          :param str dataset_id: The ID of the dataset containing this table         :param str table_id: The ID of the table to update         :param str project_id: The ID of the project containing this table         :param str description: A user-friendly description of this table         :param str expiration_time: The time when this table expires, in             milliseconds since the epoch         :param dict external_data_configuration: Additional properties to set             for the external data source configuration of the table         :param str friendly_name: A descriptive name for this table         :param list labels: User-provided labels for this table         :param list schema: Describes the schema of this table         :param dict time_partitioning: Additional properties to set for the             time-based partitioning of the table         :param dict view: Additional properties to set for the view of the             table         :param bool require_partition_filter: If set to True, queries over             this table require a partition filter
Code: def _get_next
Insert data into a table.          :param str insertion_dataset_table: The fully-qualified table name.         :param dict insertion_dataset_table_schema: The schema of the table.         :param list insertion_dataset_table_data: The data to insert.         :param bool ignore_if_missing: If True, do not raise an exception if the             table does not exist.         :raises: Exception if the table does not exist and ignore_if_missing             is False. Code: def run_table_update(self, update_dataset_table,                           update_dataset_table_schema,                           update_dataset_table_data,                           ignore_if_missing=False):                  update_project, update_dataset, update_table = \             _split_tablename(table_input=update_dataset_table,                              default_project_id=self.project_id)          try:             self.service.tables() \                .update(projectId=update
Code: def run_table_upsert(self, dataset_id, table_resource, project_id=None):                  # check to see if the table exists         table_id = table_resource['tableReference']['tableId']         project_id = project_id if project_id is not None else self.project_id         tables_list_resp = self.
Grant dataset write access to the current project.          :param str source_dataset: Source dataset to grant access to.         :param str source_project: Source project to grant access to.          :returns: Dataset resource         :rtype: dict Code: def run_grant_dataset_read_access(self,                                        source_dataset,                                        source_project=None):         """         Grant dataset read access to the current project.          :param str source_dataset: Source dataset to grant access to.         :param str source_project: Source project to grant access to.          :returns: Dataset resource         :rtype: dict         """         # Apply default values to projects         source_project = source_project if source_project else self.project_id         self.log.info(             'Granting %s:%s dataset read access to current project.',             source_project, source_dataset)         return self.service.datasets().patch(             projectId=source_project,             datasetId=source_dataset,             body={                 '
Get a list of BigQuery tables          :param str dataset_id: The dataset ID         :param str project_id: The project ID          :returns: list         :rtype: list Code: def get_dataset_table_schema(self, dataset_id, table_id, project_id=None):         """         Get the schema of a BigQuery
Get the table id from the dataset name and table name          :param str dataset_name: The dataset name         :param str table_name: The table name          :returns: The table id         :rtype: str Code: def get_table_schema(self, dataset_name, table_name):         """         Get the table schema from the dataset name and table name          :param str dataset_name: The dataset name         :param str table_name: The table name          :returns: The table schema         :rtype: dict         """         table_id = self.get_table_id(dataset_name, table_name)         table = self.service.tables().get(             projectId=self.project_id,
Retrieve a list of all Invites belonging to the Channel          :param int limit: Upper limit for the number of records to return. list() guarantees
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset, links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['account_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {             'account_sid': account_sid,            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns:
Deletes the InviteInstance          :param dict payload: A JSON payload for this Invite          :returns: True if delete succeeds, False otherwise         :rtype: bool Code: def update(self, payload):         """         Update the InviteInstance          :param dict
Code: def __init__(self, version, service_sid, channel_sid, **kwargs):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def stream(self, limit=None, page_size=None):         """         Streams InviteInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until the limit         is reached.         The results are returned as a generator, so this operation is memory efficient.          :param int limit: Upper limit for the number of records to return. stream()                           guarantees to never return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, stream() will attempt to read the                               limit with the most efficient page size, i.e. min(limit, 1000)          :returns: Generator that will yield up to limit results         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]         """         limits = self._version.read_limits(limit, page_size)          page = self.page(page_size=limits['page_size'], )          return self._version.stream(page, limits['limit'], limits['page_limit'])      def list(self, limit=None, page_size=None):         """         Lists InviteInstance records from the API as a list.         Unlike stream(), this operation is eager and will load `limit` records into         memory before returning.
Code: def _query_postgres(self):                  postgres = PostgresHook(postgres_conn_id=self.postgres_conn_id)         conn = postgres.
Code: def _make_intermediate
Retrieve a list of queues          :param int limit: Upper limit for the number of records to return. list() guarantees                           never to return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If
Code: def send_message(self, queue_url, message_body, delay_seconds=0, message_attributes=None):                  return self.get_conn().
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, payload, service_sid, channel_
Provide a friendly representation Code: def __init__(self, version, service_sid, channel_sid, ):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def stream(self, limit=None, page_size=None):         """         Streams InviteInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until the limit         is reached.         The results are returned as a generator, so this operation is memory efficient.          :param int limit: Upper limit for the number of records to return. stream()                           guarantees to never
Parse arguments Code: def _make_request(self, method, url, data=None, headers=None,                       stream=False, timeout=None, auth=None,                       allow_redirects=True, proxies=None,                       hooks=None, stream_chunks=None):         """         Perform a request.          :param str method: HTTP method to use         :param str url: URL to request         :param dict data: Data to send         :param dict headers: Headers to send         :param bool stream: Whether to stream the response         :param int timeout: Timeout to use         :param tuple auth: Auth tuple to use         :param bool allow_redirects: Whether to allow redirects         :param dict proxies: Proxies to use         :param dict hooks: Hooks to use         :param int stream_chunks: Size of chunks to stream         :returns: Response object         :rtype: requests.Response         """         if not self.session:             self.session = requests.Session()         if not self.session.headers.get('User-Agent'):             self.session.headers['User-Agent'] = self.user_agent         if not self.session.headers.get('Accept'):             self.session.headers['Accept'] = 'application/json'         if not self.session.headers.get('Accept-Encoding'):             self.session.headers['Accept-Encoding'] = 'gzip'         if not self.session.headers.get('Content-Type'):             self.session.headers['Content-Type'] = 'application/json'         if not self.session.headers.get('X-Twilio-Webhook-Enabled'):             self.session.headers['X-Twilio-Webhook-Enabled'] = 'true'         if not self.session.headers.get('X-Twilio-Client'):             self.session.headers['X-Twilio-Client'] = 'python'         if not self.session.headers.get('X-Twilio-Client-Version'):             self.session.headers['X-Twilio-Client-Version'] = __version__         if not self.session.headers.get('X-Twilio-Client-Build'):             self.session.headers['X-Twilio-Client-Build'] = __build__         if not self.session.headers.get('X-Twilio-Client-OS'):             self.session
Code: def build
Create path element          :param str width: Width of the SVG container in pixels or percent         :param str height: Height of the SVG container in pixels
Provide a friendly representation          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def __init__(self, version, payload, service_sid, channel_sid, ):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'created_by': payload.get('created_by'),             'created_by_identity': payload.get('created_by_identity'),             'role_sid': payload.get('role_sid'),             'date_created': deserialize.iso8601_datetime(payload.get('date_created')),             'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')),             'url': payload.get('url'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def sid(self):         """         :returns:
Code: def create_x_axis_date(self, name, label=None, format=None, date=False, custom_format=False):                  axis = {}         if custom_format and format:             axis['tickFormat'] = format         elif format:             if format == 'AM_PM':                 axis['tickFormat'] = "function(d) { return get_am_pm(parseInt(d)); }"             else:                 axis['tickFormat'] = "d3.format(',%s')" % format          if label:             axis['axisLabel'] = "'" + label + "'"          # date format : see https://github.com/mbostock/d3/wiki/Time-Formatting         if date:             self.dateformat = format             axis['tickFormat'] = ("function(d) { return d3.time.format('%s')"                                   "(new Date(parseInt(d))) }\n"                                   "" % self.dateformat)             # flag is the x Axis is a date
axis = {}          if custom_format and format:             axis['tickFormat'] = format         elif format:             axis['tickFormat'] = "d3.format(',%s')" % format          if label:             axis['axisLabel'] = "'" + label + "'"          # Add new axis to list of axis         self.axislist[name] = axis Code: def create_axis(self, name, label=None, format=None, custom_format=False):                  axis = {}          if custom_format and format:             axis['tickFormat'] = format         elif format:             axis['tickFormat'] = "d3.format(',
Get database hook          :returns: DatabaseHook         :rtype: DatabaseHook Code: def get_db_hook_pool
Code: def __init__(self, version, service_sid, channel_sid):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def create(self, identity, role_sid=values.unset,                type=values.unset, url=values.unset, ttl=values.unset):         """         Create a new InviteInstance          :param unicode identity: The `identity` value that identifies the new resource's User         :param unicode role_sid: The SID of the Role to assign to the new resource         :param unicode type: The type of push notification to use. Can be: `gcm` or `apn`.         :param unicode url: The URL we should call using the `notification_protocol` to send a notification when the Invite expires.         :param unicode ttl: The amount of time, in seconds, that the invite is valid. Can be an integer between 86400 and 2592000 (1 day and 30 days, respectively).          :returns: Newly created InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         data = values.of({             'Identity': identity,             'RoleSid': role_sid,             'Type': type,             'Url': url,             'Ttl': ttl,         })          payload = self._version.create(             'POST',             self._uri,             data=data,         )          return InviteInstance(             self._version,             payload,             service_sid=self._solution['service_sid'],             channel_sid=self._solution['channel_sid
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code:
Code: def get_last_dagrun(dag_id, session, include_externally_triggered=False):          DR = DagRun     query = session.query(DR).filter(DR.dag_id == dag_id)     if not include_externally_triggered:         query = query.filter(DR.external_trigger ==
Code: def create_dagrun(self,                       run_id,                       state,                       execution_date,                       start_date=None,                       external_trigger=False,                       conf=None,
Code: def __init__(self, message_content, aws_conn_id='aws_default', sqs_queue=None, delay_seconds=0, message_attributes=None):         super(SQSMessageOperator, self).__init__()         self
Code: def __repr
Get an item from the list of resources          :param unicode key: The index of the resource to fetch
Code: def __init__(self, *args, **kwargs):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def create(self, identity, role_sid=values.unset,                channel_sid=values.unset, **kwargs):         """         Create the InviteInstance          :param unicode identity: The `identity` value that identifies the new resource's User         :param unicode role_sid: The SID of the Role to assign to the new resource         :param unicode channel_sid: The SID of the Channel the new resource belongs to          :returns: The created InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         data = values.of({             'Identity': identity,             'RoleSid': role_sid,             'ChannelSid': channel_sid,         })          payload = self._version.create(             'POST',             self._uri,             data=data,         )          return InviteInstance(             self._version,             payload,             service_sid=self._solution['service_sid'],             channel_sid=self._solution['channel_sid'],         )      def stream(self, limit=None, page_size=None):         """         Streams InviteInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until the limit         is reached.         The results are returned as a generator, so this operation is memory efficient.          :param int limit: Upper limit for the number of records to return. stream()                           guarantees to never return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no
Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def get_instance(self, payload):         """         Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.invite.Invite
Retrieve a member          :param str sid: The SID of the Member resource to fetch          :returns: twilio.rest.chat.v2.service.channel.member.MemberInstance         :rtype: tw
Code: def _get_response(self, method, url, params=None, data=None, headers=None):         http_client = self._get_http_client()         http_client.headers.update(self._get_http_headers())         http_client.params.update(self._get_http_params())         http_client.headers.update(headers)         http_client.params.update(params)         http_client.headers.update({'Content-Type': 'application/json'})         http_client.headers.update({'Authorization': 'GenieKey'+ self._get_api_key()})         http_client.headers.update({'Accept': 'application/json'})         http_client.headers.update({'User-Agent': 'Airflow/1.0'})         http_client.headers.update({'Connection': 'keep-alive'})         http_client.headers.update({'Cache-Control':'max-age=0'})         http_client.headers.update({'Upgrade-Insecure-Requests': '1'})         http_client.headers.update({'Accept-Encoding': 'gzip, deflate, br'})         http_client.headers.update({'Accept-Language': 'en-US,en
Get the connection pool max_overflow          :returns
Build an instance of InviteInstance          :param dict payload:
Code: def _build_opsgenie_payload(self):                  payload
Code: def _build_opsgenie_payload(self):         """         Build the OpsGenie payload          :returns: dict         :rtype: dict         """         payload = {             'alias': self.alias,             'description': self.description,            'source': self.source,             'teams': self.teams,             'entity_selector': self.entity_selector,             'user_selector': self.user_selector,             'priority': self.priority,            'responders': self.responders,             'note': self.note,             'details': self.details,             'tags': self.tags,             'note_type': self.note_type,            'message_type': self.message_type,            'message_data': self.message_data,            'message_data_type': self.message_data_type,            'message_data_encoding': self.message_data_encoding,            'message_subject': self.message_subject,            'message_body': self.message_body,            'message_from': self.message_from,            'message_cc': self.message_cc,            'message_bcc': self.message_bcc,            'message_to': self.message_to,            'message_attachments': self.message_attachments,            'message_priority': self.message_priority,            'message_timeout': self.message_timeout,            'message_scheduled': self.message_scheduled,            'message_client_msg_id': self.message_client_msg_id,            'message_client_msg_ts': self.message_client_msg_ts,            'message_client_msg_seq': self.message_client_msg_seq,            'message_client_msg_channel': self.message_client_msg_channel,            'message_client_msg_tags': self.message_client_msg_tags,            'message_client_msg_alias': self.message_client_msg_alias,            'message_client_msg_description': self.message_client_msg_description,            'message_client_msg_source': self.message_client_msg_source,            'message_client_msg_teams': self.message_client_msg_teams,            'message_client_
Get the client type          :param str client_type: The client type          :returns: The client type         :rtype: str Code: def get_client(self, client_type):         """         Get the client          :param str client_type: The client type          :returns: The client         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         if not self.client:             self.client = self.get_client_type(client_type)()         return self
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset,                  links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['account_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {             'account_sid': account_sid,            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns
Constructs a InviteContext          :param unicode identity: The unique string that identifies the resource's User          :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext Code: def __unicode__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         return unicode(self.__repr__
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  by=values.unset, from_=values.unset, to=values.unset,                  body=values.unset, url=values.unset, media=values.unset,                  index=values.unset, attributes=values.unset,                  last_updated_by=values.unset, last_updated_attributes=values.unset,                  last_updated_reason=values.unset, last_updated_date_created=values.unset,                  last_updated_date_updated=values.unset,                  last_updated_from=values.unset, last_updated_to=values.unset,                  last_updated_body=values.unset, last_updated_url=values.unset,                  last_updated_media=values.unset, last_updated_index=values.unset,                  last_updated_attributes=values.unset,                  last_updated_last_updated_by=values.unset,                  last_updated_last_updated_attributes=values.unset,                  last_updated_last_updated_reason=values.unset,                  last_updated_last_updated_date_created=values.unset,                  last_updated_last_updated_date_updated=values.unset,                  last_updated_last_updated_from=values.unset,                  last_updated_last_updated_to=values.unset,                  last_updated_last_updated_body=values.unset,                  last_updated_last_updated_url=values.unset,                  last_updated_last_updated_media=values.unset,                  last_updated_last_updated_index=values.unset,                  last_updated_last_updated_attributes=values.unset,                  last_updated_last_updated_last_updated_by=values.unset,                  last_updated_last_updated_last_updated_attributes=values.unset,                  last_updated_last_updated_last_updated_reason=values.unset,                  last_updated_last_updated_last_updated_date_created=values.unset,                  last_updated_last_updated_last_updated_date_updated=values.unset,                  last_updated_
Fetch the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def get_message(self, sid):         """         Fetch the MessageInstance          :param unicode sid: The sid          :returns: twilio.rest.chat.v2.service.channel.message.MessageInstance         :rtype: twilio.rest.chat.v2.service.channel.message.MessageInstance         """         params = values.of({})          payload = self._version.fetch(             'GET',             self._uri,             params=params,         )          return MessageInstance(             self._version,             payload,             service_sid=self._solution['service_sid'],             channel_sid=
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __getitem__(self, key):         """         Get an element from the list by index or key (string)          :returns: An instance of the requested resource         :rtype: twilio.rest.chat.v2.service.
Code: def get_conn(self):         """         Return a new connection to the Zendesk API          :rtype: zendesk.client.Client         """         return Client(             self.username,             self.password,             subdomain=self.subdomain,             api_url=self.api_url,             headers=self.headers,             timeout=self.timeout,             verify=self.verify,             proxies=self.proxies,             user_agent=self.user_agent,             user_agent_append=self.user_agent_append,             user_agent_append_version=self.user_agent_append_version,             user_agent_append_version_prefix=self.user_agent_append_version_prefix,             user_agent_append_version_suffix=self.user_agent_append_version_suffix,             user_agent_append_version_separator=self.user_agent_append_version_separator,             user_agent_append_version_separator_prefix=self.user_agent_append_version_separator_prefix,             user_agent_append_version_separator_suffix=self.user_agent_append_version_separator_suffix,             user_agent_append_version_separator_suffix_separator=self.user_agent_append_version_separator_suffix_separator,             user_agent_append_version_separator_suffix_separator_prefix=self.user_agent_append_version_separator_suffix_separator_prefix,             user_agent_append_version_separator_suffix_separator_suffix=self.user_agent_append_version_separator_suffix_separator_suffix,             user_agent_append_version_separator_suffix_separator_suffix_separator=self.user_agent_append_version_separator_suffix_separator_suffix_separator,             user_agent_append_version_separator_suffix_separator_suffix_separator_prefix=self.user_agent_append_version_separator_suffix_separator_suffix_separator_prefix,             user_agent_append_version_separator_suffix_separator_suffix_separator_suffix=self.user_agent_append_version_separator_suffix_separator_suffix_separator_suffix,             user_agent_append_version_separator_suffix_separator_suffix_separator_suffix_separator
Code: def get_partitions(self,                        database_name,                        table_name,                        expression='',                        page_size=None,                        max_items=None):                  config = {             'PageSize': page_size,             'MaxItems': max_
Get the schemas of all tables in a
Get the storage descriptor of a table          :param str database_name: The database name         :param str table_name: The table name          :returns: A dict containing the storage descriptor of the table         :rtype: dict Code: def get_table_table_type(self, database_name, table_name):         """         Get the table type of a table          :param str database_name: The database name         :param str table_name: The
Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.
Code: def get_cluster_parameter_groups(self, cluster_identifier=None
Code: def describe_cluster_snapshots(self,
Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def __repr__(self):         """         Provide a friendly representation
Code: def create_cluster_snapshot(self, snapshot_identifier
Code: def __init__(self, service_sid, channel_sid, identity, role_sid=values.unset,                  ttl=values.unset, x_twilio_webhook_enabled=values.unset,                  **kwargs):         """         Initialize the InviteContext          :param service_sid: The SID of the Service to create the resource under         :param channel_sid: The SID of the Channel the new resource belongs to         :param identity: The unique string that identifies the resource's User         :param role_sid: The SID of the Role assigned to the new resource         :param ttl: An integer representing how long, in seconds, the new resource                    should be retained in the Channel before being automatically                    deleted         :param x_twilio_webhook_enabled: The X-Twilio-Webhook-Enabled HTTP request header          :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         super(InviteContext, self).__init__(version)          # Path Solution         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,             'identity': identity,         }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)          # Headers         self._headers = {'X-Twilio-Webhook-Enabled': x_twilio_webhook_enabled, }         self._payload = {             'RoleSid': role_sid,             'Ttl': ttl,         }      def fetch(self, **kwargs):         """         Fetch a InviteInstance          :returns: Fetched InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         params = values.of({})          payload = self._version.fetch(             'GET',             self._uri,             params=params,             headers=self._headers,         )          return InviteInstance(             self._version,             payload,             service_sid=self._solution['service_sid'],             channel_sid=self._solution['channel_sid'],             identity=self._solution['identity'],         )      def delete(self, **kwargs):         """         Deletes the InviteInstance          :returns
Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.
Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def filter_for_filesize(result, size=None):                  if size:
Get the list of files in the given path.          :param str path: The path to the directory to list.         :param bool ignore_copying: Whether to ignore copying files.          :returns: A list of files in the given path.         :
Get the Mongo conn id          :returns: str         :rtype: str Code: def _get_s3_conn_id(self):
Code: def get_pool_stats(self, session=None):         """         Get pool stats          :param Session session: SQLAlchemy session          :returns: dict         :rtype: dict         """         query = session.query(             func.count(Channel.sid),             func.count(Invite.sid),             func.count(Message.sid),             func.count(UserMessage.sid),             func.count(Reaction.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func.count(File.sid),             func
Code: def create_pool(name, slots, description, session=None):          if not (name and name.strip()):         raise Airflow
Code: def delete_pool(name, session=None):          if not (name and name.
Initialize the InvitePage          :param Version version: Version that contains the resource         :param dict payload: A JSON response from the Twilio API          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def _from_json(self, version, payload):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param dict payload: A JSON response from the Twilio API          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.
Get an operation by id          :param str operation_id: Id of the operation to get         :param str project_id: Project ID to get operation from          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def get_operation_by_name(self, operation_name, project_id=None):         """         Get an operation by name          :param str operation_name: Name of the operation to get         :param str project_id: Project ID to get operation from          :returns: twilio.rest.chat.v2.service.channel.
Generate an absolute URL for this Invite          :returns: Absolute
Get the cluster master version from the cluster proto.          :param google.cloud.container_v1.types.Cluster cluster_proto
Create a cluster.          :param cluster: The cluster to create.         :type cluster: dict or Cluster         :param project_id: The Google Cloud Platform project ID to use.         :type project_id: str         :param retry: A retry object used to retry requests. If ``None`` is             specified, requests will not be retried.         :type retry: google.api_core.retry.Retry         :param timeout: The amount of time, in seconds, to wait for the request             to complete. Note that if ``retry`` is specified, the timeout             applies to each individual attempt.         :type timeout: float         :rtype: str         :raises: :class:`google.api_core.exceptions.GoogleAPICallError` if the             request failed for any reason.         :raises: :class:`airflow.exceptions.AirflowException` if the             request failed for any reason. Code: def create_instance(self, payload):         """         Build an instance of Instance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.instance.InstanceInstance         :rtype: twilio.rest.chat.v2.service.channel.instance.InstanceInstance         """         return InstanceInstance(             self._version,             payload,             service_sid=self._
Fetch a cluster by name.          :param str name: The name of the cluster to fetch.         :param str project_id: The ID of the project that owns the cluster.         :param google.api_core.retry.Retry retry: Designation of what errors, if any,                 should be retried.         :param float timeout: The timeout for
:param str http_conn_
:returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service
Code: def _build_discord_payload(self):         """         Build the payload for Discord          :returns: dict         :rtype: dict         """         payload = {             'username': self.username,             'avatar_url': self.avatar_url,             'embeds': [                 {                     'title': self.title,                     'description': self.description,                     'url': self.url,                     'color': self.color,                     'fields': self.fields,                     'footer': self.footer,                     'image': self.image,                     'thumbnail': self.thumbnail,                     'video': self.video,                     'provider': self.provider,                     'author': self.author,                     'fields': self.fields,                     'timestamp': self.timestamp,                     'footer': self.footer,                     'image': self.image,                     'thumbnail': self.thumbnail,                     'video': self.video,                     'provider': self.provider,                     'author': self.author,                     'fields': self.fields,                     'timestamp': self.timestamp,                     'footer': self.footer,                     'image': self.image,                     'thumbnail': self.thumbnail,                     'video': self.video,                     'provider': self.provider,                     'author': self.author,                     'fields': self.fields,                     'timestamp': self.timestamp,                     'footer': self.footer,                     'image': self.image,                     'thumbnail': self.thumbnail,                     'video': self.video,                     'provider': self.provider,                     'author': self.author,                     'fields': self.fields,                     'timestamp': self.timestamp,                     'footer': self.footer,                     'image': self.image,                     'thumbnail': self.thumbnail,                     'video': self.video,                     'provider': self.provider,                     'author': self.author,                     'fields': self.fields,                     'timestamp': self.timestamp,                     'footer': self.footer,                     'image': self.image,                     'thumbnail': self.thumbnail,                     'video': self.video,                     'provider': self.provider,                     'author': self.author,                     'fields': self.fields,                     'timestamp': self.timestamp,                     'footer': self.footer,                     'image': self.image,                     'thumbnail': self.thumbnail
Decrypts data that was encrypted with a given key.          :param str key_name: The resource name of the CryptoKey to use for             decryption. Must be in the format             ``projects/*/locations/*/keyRings/*/cryptoKeys/*``.         :param bytes ciphertext: The data encrypted with the named CryptoKey.         :param bytes authenticated_data: Optional data that must also be
Code: def list_records(self, limit=None, page_size=None):         """         Lists InviteInstance records from the API as
Code: def list_by_role_sid(self, role_sid, limit=None, page_size=
Code: def export_table(self, table, export_dir, input_null_string,                      input_null_non_string, staging_table,                      clear_staging_table, enclosed_by,                      escaped_by, input_fields_terminated_by,                      input_lines_terminated_by,                      input_optionally_enclosed_by, batch,                      relaxed_isolation, extra_export_options=None):                  cmd = self._export_cmd(
Generate an API-ready query string for the request.          :returns: Twilio-specific query string for this request         :rtype: unicode Code: def get_url(self):         """         Generate the absolute URL for the InviteInstance          :returns: Absolute URL for the InviteInstance         :rtype: unicode         """         return
Synthesize speech from input data          :param str input_data: The input data to synthesize.         :param str voice: The voice to use for synthesis.         :param dict audio_config: The audio configuration to use for synthesis.         :param int retry: The number of times to retry the synthesis request.         :param int timeout: The number of seconds to wait for the synthesis request to complete.          :returns: The synthesized audio data.         :rtype: bytes Code: def update(self, role_sid=values.unset, last_consumed_message_index=values.unset, last_consumption_timestamp=values.unset, attributes=values.unset, date_created=values.unset, date_updated=values.unset, friendly_name=values.unset, identity=values.unset, x_twilio_webhook_enabled=values.unset):         """         Update the InviteInstance          :param unicode role_sid: The SID of the Role assigned to the member.         :param unicode last_consumed_message_index: The index of the last Message that the Member has read within the Channel.         :param unicode last_consumption_timestamp: The RFC 2822 date and time in GMT when the Member last read a Message within the Channel.         :param unicode attributes: The JSON string that stores application-specific data for the Invite.         :param datetime date_created: The RFC 2822 date and time in GMT when the resource was created.         :param datetime date_updated: The RFC 2822 date and time in GMT when the resource was last updated.         :param unicode friendly_name: A string to describe the resource.         :param unicode identity: The unique string that identifies the resource's User.         :param InviteInstance.WebhookEnabledType x_twilio_webhook_enabled: The X-Twilio-Webhook-Enabled HTTP request header          :returns: The updated InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         data = values.of({             'RoleSid': role_sid,             'LastConsumedMessageIndex': last_consumed_message_index,             'LastConsumptionTimestamp': serialize.iso8601_datetime(last_consumption_timestamp),             'Attributes': attributes,             'DateCreated
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset,                  links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['account_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {             'account_sid': account_sid,            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns
Get the volume claims for the dags          :returns: list[dict]         :rtype: list[dict] Code: def _get_volume_mounts(self):         """         Get the volume mounts for the dags          :returns: list[dict]         :rtype: list[dict]         """         volume_mounts = []         if self.kube_config.dags_volume_claim:             volume_mounts.append({                 'name': self.dags_volume_name,                'mountPath': self.kube_config.
Code: def _get_pod_spec(self):         """         Get the pod spec for the worker pod          :return: pod spec         :rtype: dict         """         pod_spec = {             'containers': [                 {                     'name': 'airflow-worker',                     'image': self.kube_config.airflow_image,                     'imagePullPolicy': 'IfNotPresent',                     'env': self._get_environment(),                     'command': [                         'airflow',                         'worker',                         '--pid',                         '/tmp/airflow-worker.pid',                         '--log-file',                         '/tmp/airflow-worker.log',                         '--log-format',                         'airflow.cfg',                         '--log-level',                         'INFO',                         '--pool',                         self.kube_config.airflow_pool,                         '--hostname',                         self.kube_config.airflow_hostname,                         '--executor',                         'LocalExecutor',                         '--max-workers',                         '1',                         '--max-failures',                         '1',                         '--queued-task-ttl',                         '300',                         '--queued-task-retry-delay',                         '300',                         '--queued-task-retry-limit',                         '3',                         '--queued-task-retry-exponential-multiplier',                         '2',                         '--queued-task-retry-exponential-max',                         '300',                         '--queued-task-retry-jitter',                         '0.1',                         '--queued-task-retry-limit-strategy',                         'fixed',                         '--queued-task-retry-limit-strategy-fixed-limit',                         '10',                         '--queued-task-retry-limit-strategy-fixed-interval',                         '300',                         '--queued-task-retry-limit-strategy-fixed-jitter',                         '0.1',                         '--queued-task-retry-limit-strategy-fixed-exponential-multiplier',                         '2',                         '--queued-task-retry-limit-strategy-fixed-exponential-max',                         '300',                         '--queued-task-retry-limit-strategy-fixed-exponential-jitter',                         '0.1',                         '--queued-task-retry-limit-strategy-fixed-exponential-max-interval',                         '300',                         '--queued-task-retry-limit-strategy-fixed-exponent
Code: def
Code: def _get_container_port(self):         return V1ContainerPort(             container
Code: def get_extra_links(self, operator, dttm):                  conn = BaseHook.get_connection(operator.kwargs['qubole_conn_id'])         if conn and conn.host:             host = re.sub(r'api$', 'v2/analyze?command_id=', conn.host)         else:             host = 'https://api.qubole.com/v2/analyze?command_id='          ti = TaskInstance(task=operator, execution_date=dttm)         qds_command_id = ti.xcom_pull(task_ids=operator.task_id, key='qbol_cmd
Log a message. Code
Code: def _launch_process(result_queue,                         file_path,                         pickle_dags,                         dag_id_white_list,                         thread_name,                         zombies):                  def helper():             # This helper runs in the newly
Code: def _process_message(self, message):         """         Process a message from the queue          :param Message message: Message to process         """         if message.type == 'task_failure':             self._process_task_failure(message)         elif message.type == 'task_success':             self._process_task_success(message)         elif message.type == 'task_heartbeat':             self._process_task_heartbeat(message)         elif message.type == 'task_reschedule':             self._process_task_reschedule(message)         elif message.type == 'task_cancel':             self._process_task_cancel(message)         elif message.type == 'task_state_change':             self._process_task_state_change(message)         elif message.type == 'task_failure_reschedule':             self._process_task_failure_reschedule(message)         elif message.type == 'task_failure_cancel':             self._process_task_failure_cancel(message)         elif message.type == 'task_failure_reschedule_cancel':             self._process_task_failure_reschedule_cancel(message)         elif message.type == 'task_failure_reschedule_cancel_reschedule':             self._process_task_failure_reschedule_cancel_reschedule(message)         elif message.type == 'task_failure_reschedule_cancel_reschedule_cancel':             self._process_task_failure_reschedule_cancel_reschedule_cancel(message)         elif message.type == 'task_failure_reschedule_cancel_reschedule_cancel_reschedule':             self._process_task_failure_reschedule_cancel_reschedule_cancel_reschedule(message)         elif message.type == 'task_failure_reschedule_cancel_reschedule_cancel_reschedule_cancel':             self._process_task_failure_reschedule_cancel_reschedule_cancel_reschedule_cancel(message)         elif message.type == 'task_failure_reschedule_cancel_reschedule_cancel_reschedule_cancel_reschedule':             self._process_task_failure_reschedule_cancel_reschedule_cancel_reschedule_cancel_reschedule(message)         elif message.type == 'task_failure_reschedule_cancel_re
Code: def __init__(self, *args, **kwargs):         super(XCom, self).__init__(*args, **kwargs)         self.xcom_key = kwargs.get('xcom_key')         self.task_id = kwargs.get('task_id')         self.dag_id = kwargs.get('dag_id')         self.execution_date = kwargs.get('execution_date')         self.task_instance = kwargs.get('task_instance')         self.context = kwargs.get('context')         self.xcom_push = kwargs.get('xcom_push')         self.xcom_all = kwargs.get('xcom_all')         self.xcom_task_id = kwargs.get('xcom_task_id')         self.xcom_key_task_id = kwargs.get('xcom_key_task_id')         self.xcom_value = kwargs.get('xcom_value')         self.xcom_value_task_id = kwargs.get('xcom_value_task_id')         self.xcom_value_template = kwargs.get('xcom_value_template')         self.xcom_value_template_task_id = kwargs.get('xcom_value_template_task_id')         self.xcom_value_template_context = kwargs.get('xcom_value_template_context')         self.xcom_value_template_context_task_id = kwargs.get('xcom_value_template_context_task_id')         self.xcom_value_template_fields = kwargs.get('xcom_value_template_fields')         self.xcom_value_template_fields_task_id = kwargs.get('xcom_value_template_fields_task_id')         self.xcom_value_template_fields_context = kwargs.get('xcom_value_template_fields_context')         self.xcom_value_template_fields_context_task_id = kwargs.get('xcom_value_template_fields_context_task_id')         self.xcom_value_template_fields_json = kwargs.get('xcom_value_template_fields_json')         self.xcom_value_template_fields
Code: def _process_message(self, message):         """         Process a message from the queue          :param message: Message to process         :type message: Message         """         if message.type == 'invite':             self.get_instance(message.payload).save()         elif message.type == 'invite_accepted':             self.get_instance(message.payload).accept()         elif message.type == 'invite_rejected':             self.get_instance(message.payload).reject()         elif message.type == 'invite_canceled':             self.get_instance(message.payload).cancel()         elif message.type == 'invite_timeout':             self.get_instance(message.payload).timeout()         elif message.type == 'invite_removed':             self.get_instance(message.payload).remove()         elif message.type == 'invite_updated':             self.get_instance(message.payload).update()         elif message.type == 'invite_error':             self.get_instance(message.payload).error()         elif message.type == 'invite_deleted':             self.get_instance(message.payload).delete()         elif message.type == 'invite_replaced':             self.get_instance(message.payload).replace()         elif message.type == 'invite_invited':             self.get_instance(message.payload).invite()         elif message.type == 'invite_accepted_by_remote':             self.get_instance(message.payload).accept_by_remote()         elif message.type == 'invite_rejected_by_remote':             self.get_instance(message.payload).reject_by_remote()         elif message.type == 'invite_canceled_by_remote':             self.get_instance(message.payload).cancel_by_remote()         elif message.type == 'invite_timeout_by_remote':             self.get_instance(message.payload).timeout_by_remote()         elif message.type == 'invite_removed_by_remote':             self.get_instance(message.payload).remove_by_remote()         elif message.type == 'invite_updated_by_remote':             self.get_instance(message.payload).update_by_remote()         elif message.type == 'invite_error_by_remote':
Code: def __init__(self, version, service_sid, channel_sid):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def stream(self, limit=None, page_size=None):         """         Streams InviteInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until the limit         is reached.         The results are returned as a generator, so this operation is memory efficient.          :param int limit: Upper limit for the number of records to return. stream()                           guarantees to never return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.
Code: def _process_task_instances(self, dag, queue, session=None):         """         Process the task instances for a given dag.          :param dag: the dag to process         :type dag: airflow.models.dag.DAG         :param queue: the queue to put task instances into         :type queue: list         :param session: the database session         :type session: sqlalchemy.orm.session.Session         """         # update the state of the previously active dag runs         dag_runs = DagRun.find(dag_id=dag.dag_id, state=State.RUNNING, session=session)         active_dag_runs = []         for run in dag_runs:             self.log.info("Examining DAG run %s", run)             # don't consider runs that are executed in the future             if run.execution_date > timezone.utcnow():                 self.log.error(                     "Execution date is in future: %s",                     run.execution_date                 )                 continue              if len(active_dag_runs) >= dag.max_active_runs:                 self.log.info("Number of active dag runs reached max_active_run.")                 break              # skip backfill dagruns for now as long as they are not really scheduled             if run.is_backfill:                 continue              # todo: run.dag is transient but needs to be set             run.dag = dag             # todo: preferably the integrity check happens at dag collection time             run.verify_integrity(session=session)             run.update_state(session=session)             if run.state == State.RUNNING:                 make_transient(run)                 active_dag_runs.append(run)          for run in active_dag_runs:             self.log.debug("Examining active DAG run: %s", run)             # this needs a fresh session sometimes tis get detached             tis = run.get_task_instances(state=(State.NONE,                                                 State.UP_FOR_RETRY,                                                 State.UP_FOR_RESCHEDULE))              # this loop is quite slow as it uses are_dependencies_met for             # every task (in ti.is_runnable). This is also called in             # update_state above which has already checked these tasks             for ti in tis:                 task = dag
Set

Set the state of the given task instances to queued.          :param list[airflow.models.TaskInstance] task_instances:             The task instances to set to queued.         :param list[airflow.utils.state.State] acceptable_states:             The acceptable states to set the task instances to.         :param Session session: The session to use.         :return: A list of SimpleTaskInstance for the use of queuing             them in the executor.         :rtype: list[airflow.models.SimpleTaskInstance] Code: def _change_state_for_executable_task_instances(self, task_instances,                                                     acceptable_states, session=None):                  if len(task_instances) == 0:             session.commit()             return []          TI = models.TaskInstance         filter_for_ti_state_change = (             [and_(                 TI.dag_id == ti.dag_id,                 TI.task_id == ti.task_id,                 TI.execution_date == ti.execution_date)                 for ti in task_instances])         ti_query = (             session            .query(TI)            .filter(or_(*filter_for_ti_state_change)))          if None in acceptable_states:             ti_query = ti_query.filter(                 or_(TI.state == None, TI.state.in_(acceptable_states))  # noqa: E711             )         else:             ti_query = ti_query.filter(TI.state.in_(acceptable_states))          tis_to_set_to_queued = (             ti_query            .with_for_update()            .all())         if len(tis_to_set_to_queued) == 0:             self.log.info("No tasks were able to have their state changed to queued.")             session.commit()             return []          # set TIs to queued state         for task_instance in tis_to_set_to_queued:             task_instance.state = State.QUEUED             task_instance.queued_dttm = (timezone.utcnow()                                          if not task_instance.queued_dttm                                          else task_instance.queued_dttm)             session.merge(task_instance)          # Generate a list of SimpleTaskInstance for the use of que
actually enqueue them          :param SimpleDagBag simple_dag_bag:         :param list[models.TaskInstance] simple_task_instances: Code: def _enqueue_task_instances_with_queued_state(self, simple_dag_bag,                                                   simple_task_instances):                  TI = models.TaskInstance         # actually enqueue them         for simple_task_instance in simple_task_instances:             simple_dag = simple_dag_bag.get_dag(simple_task_instance.dag_id)             command = TI.generate_command(                 simple_task_instance.dag_id,                 simple_task_instance.task_id,                 simple_task_instance.execution_date,                 local=True,                 mark_success=False,                 ignore_all_deps=False
Enqueue task instance          :param SimpleDagBag simple_dag_bag: SimpleDagBag         :param SimpleTaskInstance simple_ti: SimpleTaskInstance Code: def _change_state_for_executable_task_instances(self,                                                      simple_tis,                                                      states,                                                      session=None):         """         Change state for executable task instances          :param list[SimpleTaskInstance] simple_tis: List of SimpleTaskInstance         :param list[State] states: List of State         :param Session session: Session          :returns: list[SimpleTaskInstance]         :rtype: list[SimpleTaskInstance]         """         if not session:             session = settings.Session()         try:             simple_tis_with_state_changed = []             for simple_ti in simple_tis:                 if simple_ti.state in states:                     continue                 if simple_ti.state == State.QUEUED:                     simple_ti.state = State.RUNNING                     simple_tis_with_state_changed.append(simple_ti)                 elif simple_ti.state == State.RUNNING:                     simple_ti.state = State.SUCCESS                     simple_tis_with_state_changed.append(simple
Set the following tasks to scheduled state          :param session: SQLAlchemy ORM Session         :type session: Session Code: def _change_state_for_tasks_failed_to_execute(self, session):                  if self.executor.queued_tasks:             TI = models.TaskInstance             filter_for_ti_state_change = (                 [and_(                     TI.dag_id == dag_id,                     TI.task_id == task_id,                     TI.execution_date == execution_date,                     # The TI.try_number will return
Code: def _process_executor_events(self, simple_dag_bag, session=
Code: def _process_task(self, dag, task, ti_keys_to_schedule):         """         Process a single task.          :param DAG dag: DAG containing the task         :param TaskInstanceBase task: Task to process         :param list[tuple] ti_keys_to_schedule: List of tuples of the form             (dag_id, task_id, execution_date) that should be scheduled         """         # If the task is not ready to run, skip it         if not task.are_dependencies_met(                 dep_context=DepContext(deps=QUEUE_DEPS, ignore_task_deps=True),                 session=self.session,                 verbose=True):             self.log.info("Skipping %s due to dependencies", task)             return          # If the task is already scheduled, skip it         if task.state == State.SCHEDULED:             self.log.info("Skipping %s since it's already scheduled", task)             return          # If the task is already running, skip it         if task.state == State.RUNNING:             self.log.info("Skipping %s since it's already running", task)             return          # If the task is already queued, skip it         if task.state == State.QUEUED:             self.log.info("Skipping %s since it's already queued", task)             return          # If the task is already failed, skip it         if task.state == State.FAILED:             self.log.info("
Code: def _update_counters(self, ti_status):                  for key, ti in list(ti_status.running.items()):             ti.refresh_from_db()             if ti.state == State.SUCCESS:                 ti_status.succeeded.add(key)                 self.log.debug("Task instance %s succeeded. Don't rerun.", ti)                 ti_status.running.pop(key)                 continue             elif ti.state == State.SKIPPED:                 ti_status.skipped.add(key)                 self.log.debug("Task instance %s skipped. Don't rerun.", ti)                 ti_status.running.pop(key)                 continue             elif ti.state == State.FAILED:                 self.log.error("Task instance %s failed", ti)                 ti_status.failed.add(key)                 ti_status.running.pop(key)                 continue             # special case: if the task needs to run again put it back             elif ti.state == State.UP_FOR_RETRY:                 self.log.warning("Task instance %s is up for retry", ti)                 ti_status.running.pop(key)                 ti_status.to_run[key] = ti             # special case: if the task needs to be rescheduled put it back             elif ti.state == State.UP_FOR_RESCHEDULE:                 self.log.warning("Task instance %s is up for reschedule", ti)                 ti_status.running.pop(key)                 ti_status.to_run[key] = ti             # special case: The state of the task can be set to NONE by the task itself             # when it reaches concurrency limits. It could also happen when the state             # is changed externally, e.g. by clearing tasks from the ui. We need to cover             # for that as otherwise those tasks would fall outside of the scope of             # the backfill suddenly.             elif ti.state == State.NONE:                 self.log.warning(                     "FIXME: task instance %s state was set to none externally or "                     "reaching concurrency limits. Re-adding task to queue.",                     ti                 )                 ti.set_state(State.SCHEDULED)                 ti_status.running.pop(key)                 ti_status.to_run[key] =
Code: def _manage_executor_state(self, running):                  executor = self.executor          for key, state in list(executor.get_event_buffer().items()):             if key not in running:                 self.log.warning(                     "%s state %s not in running=%s",                     key, state, running.values()                 )                 continue              ti
Code: def _get_dag_run(self, run_date, session=None):                  run_id = BackfillJob.ID_FORMAT_PREFIX.format(run_date.isoformat())          # consider max_active_runs but ignore when running subdags         respect_dag_max_active_limit = (True
Code: def _task_instances_for_dag_run(self, dag_run, session=None):                  tasks_to_run = {}          if dag_run is None:
Code: def _process_backfill_task_instances(self, ti_status, executor, pickle_id,                                           start_date, session=None):         """         Process backfill task instances          :param ti_status: TIStatus object         :type ti_status: TIStatus         :param executor: executor object         :type executor: BaseExecutor         :param pickle_id: pickle id         :type pickle_id: int         :param start_date: start date         :type start_date: datetime         :param session: session         :type session: Session         :return: processed dag run dates         :rtype: set         """         processed_dag_run_dates = set()         for dag_run in ti_status.to_run.values():             if dag_run.state == State.RUNNING:                 continue             if dag_run.state == State.FAILED:                 continue             if dag_run.state == State.UP_FOR_RETRY:                 continue             if dag_run.state == State.SUCCESS:                 continue             if dag_run.state == State.QUEUED:                 continue             if dag_run.state == State.NONE:                 continue             if dag_run.state == State.SHUTDOWN:                 continue             if dag_run.state == State.REMOVED:                 continue             if dag_run.state == State.NONE:                 continue             if dag_run.state == State.NONE:                 continue             if dag_run.state == State.NONE:                 continue             if dag_run.state == State.NONE:                 continue             if dag_run.state == State.NONE:                 continue             if dag_run.state == State.NONE:                 continue             if dag_run.state == State.NONE:                 continue             if dag_run.state == State.NONE:                 continue             if dag_run.state == State.NONE:                 continue             if dag_run.state == State.NONE:                 continue             if dag_run.state == State.NONE:                 continue             if dag_run.state == State.NONE:                 continue             if dag_run.state == State.NONE:                 continue             if dag_run.state == State.NONE:                 continue             if dag_run.state == State.NONE:                 continue             if dag_run.state == State.NONE:                 continue             if dag_
Code: def _set_unfinished_dag_runs_to_failed(self, dag_runs, session=None):                  for dag_run in dag_runs:             dag_run.update_state()             if dag_run.state not in State.finished():                 dag_run.set_state(State.FAILED)             session.merge
Execute the tasks for the given run dates.          :param list[datetime.datetime] run_dates: The dates to execute the tasks for         :param BackfillJob._DagRunTaskStatus ti_status: The status of the tasks         :param BaseExecutor executor: The executor to use         :param int pickle_id: The id of the pickle to use         :param datetime.datetime start_date: The start date of the dag         :param Session session: The session to use Code: def _collect_errors(self, ti_status, session):         """         Collects errors from the task instances and returns a string with the         errors.          :param BackfillJob._DagRunTaskStatus ti_status: The status of the tasks         :param Session session: The session to use         :return: A string with the errors
Code: def heartbeat_callback(self, session=None):                   if self.terminating:             # ensure termination if processes are created later             self.task_runner.terminate()             return          self.task_instance.refresh_from_db()         ti = self.task_instance          fqdn = get_hostname()         same_hostname = fqdn == ti.hostname         same_process = ti.pid == os.getpid()          if ti.state == State.RUNNING:             if not same_hostname:                 self.log.warning("The recorded hostname %s "                                  "does not match this instance's hostname "                                  "%s", ti.hostname, fqdn)                 raise AirflowException("Hostname of job runner does not match")             elif not same_process:                 current_pid = os.getpid()                 self.log.warning("Recorded pid %s does not match "                                  "the
Get a user channel by user sid and channel sid          :param str user_sid: User sid         :param str channel_sid: Channel sid          :returns: UserChannel         :rtype: UserChannel Code: def _get_user_channel_invites(self, user_sid, channel_sid):
Code: def get_instance(self, instance_id, project_id=None):                  instance = self._get_client(project_id=project_id).instance(instance_id=instance_id)         if not instance.exists():             return None
Get the instance ID from the instance name          :param str project_id: Project ID         :param str instance_name: Instance name          :returns: str         :rtype: str Code: def _get_instance_name(self, project_id, instance_id):         """         Get the instance name from the instance ID          :param str project_id: Project ID         :param str instance_id: Instance ID          :returns: str         :rtype: str         """         client = self._get_client(project_
Provide a friendly representation          :returns: Machine
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __unicode__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """
Get an instance IAM policy          :param str instance_id: Instance ID         :param str project_id: Project ID          :returns: googleapiclient.discovery.Resource         :rtype: googleapiclient.discovery.Resource Code: def _get_instance_iam_policy_
Build an instance of DatabaseInstance          :param str instance_id: The unique ID of the Instance.         :param str database_id: The unique ID of the Database.         :param str project_id: The unique ID of the Project.          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def get_database_instance_database(self, instance_id, database_id, project_id=None):         """         Build an instance of DatabaseInstanceDatabase          :param str instance_id: The unique ID of the Instance.         :param str database_id: The unique ID of the Database.         :param str project_id: The unique ID of the Project.          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """
Get an instance for the specified project.          :param str instance_id: The instance ID to use.         :param str project_id: The project ID to use. If not set, the             project_id from the connection is used.          :rtype: :class:`google.cloud.spanner_v1.Instance`         :returns: An instance for the specified project. Code: def _get_database(self, instance_id, database_id, project_id=None):         """         Get a database for the specified project.          :param str instance_id: The instance ID to use.         :param str database_id: The database ID to use.         :param str project_id: The project ID to use. If not set, the             project_id from the connection is used.
Get the table ID from the table name.          :param str table_id: The table name.          :returns: The table ID.         :rtype: str Code: def _get_column_id(self, column_id
Get a database.          :param str instance_id: The instance_id         :param str database_id: The database_id         :param str project_id
Code: def poke(self, context):                  self.log.info('Poking for %s', self.attachment_name)          with ImapHook(imap_conn_id=self.conn_id) as imap_hook:             return imap_hook.has_mail_attachment(                 name=self.attachment_name,                 mail_folder=self.mail_folder,                 check_regex=self.check_regex             ) Doc
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __unicode__(self):         """         Provide a friendly representation          :returns: Machine
Retrieve a single page of InviteInstance records from the API.         Request is executed immediately          :param str target_url: API-generated URL for the requested results page          :returns: Page of InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def get_page(self, target_url):         """         Retrieve a single page of InviteInstance records from the API.         Request is executed immediately          :param str target_url: API-generated URL for the requested results page          :returns: Page of InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         response = self._version.domain.twilio.request(             'GET',             target_url,         )          return InvitePage(self._version,
Get the column types from the table object.          :
Code: def __init__(self, keyspace, table, connection_factory=None,                  consistency_level=None, default_timeout=None,                  default_retry_policy=None, default_load_balancing_policy=None,                  default_reconnection_policy=None,                  default_metrics_enabled=None,                  default_metrics_reporters=None,                  default_credentials=None,                  default_ssl_options=None,                  default_protocol_options=None,                  default_control_connection_timeout=None,                  default_request_timeout=None,                  default_max_schema_agreement_wait=None,                  default_port=None,                  default_connect_timeout=None,                  default_keepalive=None,                  default_tcp_nodelay=None,                  default_tcp_keepalive=None,                  default_tcp_keepalive_idle=None,                  default_tcp_keepalive_cnt=None,                  default_tcp_keepalive_intvl=None,                  default_use_ssl=None,                  default_ssl_context_factory=None,                  default_ssl_context_factory_class=None,                  default_ssl_context_factory_kwargs=None,                  default_ssl_context_factory_verify_options=None,                  default_ssl_context_factory_ca_certs=None,                  default_ssl_context_factory_cert_reqs=None,                  default_ssl_context_factory_ciphers=None,                  default_ssl_context_factory_do_handshake_on_connect=None,                  default_ssl_context_factory_server_hostname=None,                  default_ssl_context_factory_check_hostname=None,                  default_ssl_context_factory_cert_file=None,                  default_ssl_context_factory_key_file=None,                  default_ssl_context_factory_password=None,                  default_ssl_context_factory_cert_reqs_str=None,                  default_ssl_context_factory_ciphers_str=None,                  default_ssl_context_factory_check_hostname_str=None,                  default_ssl_context_factory_cert_file_str=None,                  default_ssl_context_factory_key_file_str=None,                  default_ssl_context_factory_password
Get the path to the spark binary from the environment variable.          :return: path to the spark binary         :rtype: str Code: def _get_spark_binary_path_from_env_var_spark_home_bin(self):         """
Submit the Spark application          :param str application: The Spark application to submit         :param kwargs: Additional arguments to pass to subprocess.Popen Code: def _start_driver_status_tracking(self):         """         Start tracking the driver status.          :return: None         """         self.log.debug("Starting driver status tracking")          # We start with the SUBMITTED status as initial status         self._driver_status = "SUBMITTED"          # We keep track of the last time we checked the driver status         self._last_driver_status_check = time.time()          # We keep track of the last time we checked the driver status         self._last_driver_status_check = time.time()          # We keep track of the last time we checked the driver status         self._last_driver_status_check = time.time()          # We keep track of the last time we checked the driver status         self._last_driver_status_check = time.time()          # We keep track of the last time we checked the driver status         self._last_driver_status_check = time.time()          # We keep track of the last time we checked the driver status         self._last_driver_status_check = time.time()          # We keep track of the last time we checked the driver status         self._last_driver_status_check = time.time()          # We keep track of the last time we checked the driver status         self._last_driver_status_check = time.time()          # We keep track of the last time we checked the driver status         self._last_driver_status_check = time.time()          # We keep track of the last time we checked the driver status         self._last_driver_status_check = time.time()          # We keep track of the last time we checked the driver status         self._last_driver_status_check = time.time()          # We keep track of the last time we checked the driver status         self._last_driver_status_check = time.time()          # We keep track of the last time we checked the driver status         self._last_driver_status_check = time.time()          # We keep track of the last time we checked the driver status         self._last_driver_status_check = time.time()          # We keep track of the last time we checked
Code: def
Code: def _process_spark_status_log(self, itr):                  # Consume the iterator         for line in itr:             line = line.strip()              # Check if the log line is about the driver status and extract the status.             if "driverState" in
Code: def get_task_runner(local_task_job):          if _TASK_RUNNER == "StandardTaskRunner":         return StandardTaskRunner(local_task_job)     elif _TASK_RUNNER == "Cgroup
Code: def _wait_for_task_ended(self):                  try:             waiter = self.client.get_waiter('job_execution_complete')             waiter.config.max_attempts = sys.maxsize  # timeout is managed by airflow             waiter.wait(jobs=[self.jobId])         except ValueError:             # If waiter not available use expo             retry = True             retries = 0              while retries < self.max_retries and retry:                 self.log.info('AWS Batch retry in the next %s seconds', retries

Code: def _configure_yaml_stream_with_indent_and_sort_keys_and_default_flow_style_and_allow_unicode(self, file_handle, schema):         yaml_writer = yaml.dump(schema, file_handle, default_flow_style=True,                                 indent=2, sort_keys
Code: def _write_local_schema_file(self, cursor):                  schema_str = None         schema_file_mime_type = 'application/json'         tmp_schema_file_handle = NamedTemporaryFile(delete=True)         if self.schema is not None and isinstance(self.schema, string_types):             schema_str = self
Code: def _get_col_type_dict(self):                  schema = []         if isinstance(self.schema, string_types):             schema = json.loads(self.schema)         elif isinstance(self.schema, list):             schema = self.schema         elif self.schema is not None:             self.log.warn('Using default schema due to unexpected type.'                           'Should be a string or list.')          col_type_dict = {}         try:             col_type_dict = {col['name']: col['type'] for col in schema}         except KeyError:             self.log.
Get the channel sid from the channel sid          :param str channel_sid: The channel sid          :returns: The channel sid         :rtype: str Code: def _get_channel_sid_by_attributes(self, channel_attributes):         """         Get the channel sid from the channel attributes          :param str channel_attributes: The channel attributes          :returns: The channel sid         :rtype: str         """
Get the page of users from the response          :param requests.Response response: Response from the API          :returns: The page of users from the response         :rtype: list[dict] Code: def get_page_of
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """
Returns true if both instances are not equal, false otherwise          :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def __init__(self, version, payload, service_sid, channel_sid, ):         """         Initialize the InviteInstance          :returns: twilio.rest
Provide a friendly representation          :returns:
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """
Code: def __iter__(self):         """         Iterate over pages of InviteInstance          :returns: Generator that will yield up to limit results         :rtype: list[twilio.rest.chat.v2.service.
Initialize a user in the database.          :param str user_name: The name of the user to initialize.         :param str user_email: The email of the user to initialize.         :param str user_password: The password of the user to initialize.         :param str user_role: The role of the user to initialize.          :returns: The user instance.         :rtype: twilio.rest.chat.v2.service.user.UserInstance Code: def init_user_role(self, user_name, user_role):         """         Initialize a user role in the database.          :param str user_name: The name of the user to initialize.         :param str user_role: The role of the user to initialize.          :returns: The user instance.         :rtype: twilio.rest.chat.v2.service.user.UserInstance         """         user = self.find_user(user_name)         if not user:             user = self.add_user(user_name)         role = self.find_role(user_role)         if not role:             role = self.add_role(user_role)         user.roles.append(role)         self.get_session.merge(user
session = self.get_session         role = session.query(sqla_models.Role)\                      .filter(sqla_models.Role.name == role_name)\                      .first()         if role:             self.log.info("Deleting role '%s'", role_name)             session.delete(role)             session.commit()         else:             raise AirflowException("Role named '{}' does not exist".format(                 role_name)) Code: def get_instance(self, payload):
Code: def get_user_roles(self, user=None):                  if user is None:             user = g.user         if user.is_anonymous:             public_role = appbuilder.config.get('AUTH_ROLE_PUBLIC')             return [appbuilder.security_
Retrieve a single role assigned to the user.          :param friendly_name: The string that identifies the Role resources to fetch          :returns: twilio.rest.chat.v2.service.user.user_role.UserRoleInstance         :rtype: twilio.rest.chat.v2.service.user.user_role.UserRoleInstance Code: def get_user_roles_by_permission_and_view
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'created_by': payload.get('created_by'),             'created_by_identity': payload.get('created_by_identity'),             'role_sid': payload.get('role_sid'),             'date_created': deserialize.iso8601_datetime(payload.get('date_created')),             'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')),             'url': payload.get('url'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid
Returns true if both instances are not equal          :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance          :returns: twilio.rest.chat.v2
Retrieve a list of users          :param int limit: Upper limit for the number of records to return.             list() guarantees never to return more than limit.  Default is no             limit         :param int page_size: Number of records to fetch per request, when not set will use             the default value of 50 records.  If no page_size is defined             but a limit is defined, list() will attempt to read the limit             with the most efficient page size, i.e. min(limit, 1000)          :returns: Generator that will yield up
Merge permission and view_menu into a single permission_view_menu          :param str permission_name: Permission name         :param str view_menu_name: View menu name Code: def _merge_perm(self, permission_name, view_menu_name):                  permission = self.find_permission(permission_name)         view_menu = self.find_view_menu(view_menu_name)         pv = None         if permission and view_menu:             pv = self.get_session.query(self.permissionview_model).filter_by(                 permission=permission, view_menu=view_menu).first()         if not pv and permission_name and view_menu_
Code
Code: def _sync_dag_view_permissions(self, dag_id, access_control):                  def _get_or_create_dag_permission(perm_name):             dag_perm = self.find_permission_view_menu(perm_name, dag_id)             if not dag_perm:                 self.log.info(                     "Creating new permission '%s' on view '%s'",                     perm_name, dag_id                 )                 dag_perm = self.add_permission_view_menu(perm_name, dag_id)              return dag_perm          def _revoke_stale_permissions(dag_view):             existing_dag_perms = self.find_permissions_view_menu(dag_view)             for perm in existing_dag_perms:                 non_admin_roles = [role for role in perm.role                                    if role.name!= 'Admin']                 for role in non_admin_roles:                     target_perms_for_role = access_control.get(role.name, {})                     if perm.permission.name not in target_perms_for_role:                         self.log.info(                             "Revoking '%s' on DAG '%s' for role '%s'",                             perm.permission, dag_id, role.name                         )                         self.del_permission_role(role, perm)          dag_view = self.find_view_menu(dag_id)         if dag_view:             _revoke_stale_permissions(dag_view)          for rolename, perms in access_control.items():             role = self.find_role(rolename)             if not role:                 raise AirflowException(                     "The access_control mapping for DAG '{}' includes a role "                     "named '{}', but that role does not exist".format(                         dag_id,                         rolename))              perms = set(perms)             invalid_perms = perms - self.DAG_PERMS             if invalid_perms:                 raise AirflowException(                     "The access_control map for DAG '{}' includes the following "                     "invalid permissions: {}; The set of valid permissions "                     "is: {}".format(dag_id,                                     (perms - self.DAG_PERMS),                                     self.DAG_PERMS))              for perm_name in perms:                 dag_perm = _get_or_create_
Merge permission and view menu for all dag and role          :returns: True if permission and view menu are merged, False otherwise         :rtype: bool Code: def _merge_perm_for_all_dag_and_role_and_user(self):
Build an instance of InviteInstance          :param dict payload:
Code: def poke(self, context):                  if '.' in self.table_name:             self.database_name, self.table_name = self.table_name.split('.')         self.
Generate an absolute URL for this InviteList          :returns: Absolute URL for this InviteList         :rtype: unicode Code: def get_url(self):         """         Generate an absolute URL for this InvitePage          :returns: Absolute URL for this InvitePage         :rtype: unicode         """         return '/v2/Services/{service_
Code: def poke(self, context):                   sqs_hook = SQSHook(aws_conn_id=self.aws_conn_id)         sqs_conn = sqs_hook.get_conn()          self.log.info('SQSSensor checking for message on queue: %s', self.sqs_queue)          messages = sqs_conn.receive_message(QueueUrl=self.sqs_queue,                                             MaxNumberOfMessages=self.max_messages,                                             WaitTimeSeconds=self.wait_time_seconds)          self.log.info("reveived message %s", str(messages))          if 'Messages' in messages and len(messages['Messages']) > 0:              entries = [{'Id': message['MessageId'], 'ReceiptHandle': message['ReceiptHandle']}                        for message in messages['Messages']]              result = sqs_conn.delete_message_batch(QueueUrl=self.sqs_queue,                                                    Entries=entries)              if 'Successful' in result:                 context['ti'].xcom_push
Get the connection from the connection_id          :param str conn_id: The connection id to use          :returns: connection         :rtype: connection Code: def get_connection_from_hook(self, conn_id):         """         Get the connection from the connection_id          :param str conn_
Get the connection from the connection id          :param str conn_id: Connection id          :returns: Connection         :rtype: Connection Code: def get_connection(self, conn_id):         """         Get the connection from the connection id          :param str conn_id: Connection id          :returns: Connection
Return the content of a file in HDFS.          :param str hdfs_path: The path to the file in HDFS.          :returns: str         :rtype: str Code: def get_file_content_as_bytes(self, hdfs_path):         """         Return
List the files in a directory.          :param str path: The path to the directory.         :param bool recursive: Whether to list files recursively.         :param kwargs: Additional arguments to pass to the underlying             :py:class:`pyarrow.hdfs.connect` function.          :returns: A list of file paths.         :rtype: list[str] Code: def list_files
Get the connection pool verify ssl          :returns: bool         :rtype: bool Code: def get_conn_pool_verify_ssl_cert(self):         """         Get the connection pool verify ssl cert          :returns: str         :rtype: str
Get the connection pool          :returns: ConnectionPool object         :rtype: ConnectionPool Code: def get_connections_from_pool(self):         """         Get all connections from the connection pool          :returns: List of Connection objects         :rtype: list[Connection]         """         return
Code: def _convert_date_to_dict
Code: def _convert_time_to_dict(time):                  return
Get connection password from connection          :returns: Connection password         :rtype: str Code
Generate an API-ready query string for the request.          :returns: Twilio Request         :rtype: requests.Request Code: def get_url(self):         """         Generate an absolute URL for the InviteInstance          :returns: Absolute URL for the InviteInstance         :rtype: unicode         """         template = 'https://chat.twilio.com/v2/Services/{service_sid}/Channels/{channel_sid}/Invites'          url = self._version.domain.twilio.com.twilio.http.domain_twilio_com.twilio.http.base_url.base_url(template, service_sid=self._solution['service_sid
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._invites = None         self._members = None         self._messages = None         self._webhooks = None      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = InviteList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._invites      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._
Get an item from the list of resources          :param unicode key: The index of the resource to fetch          :returns: twilio.rest.chat.v2.service
Code: def _serialize_int(self
Provide a
Create the InviteInstance          :param unicode identity: The `identity` value that identifies the new resource's User         :param unicode role_sid: The SID of the Role to assign to the new resource         :param unicode ttl: An application-defined string that uniquely identifies the resource         :param unicode type: The type of push notification to send to the new resource's
Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def extra_links(self):                  dag_id = request.args.get('dag_id')         task_id = request.args.get('task_id')         execution_date = request.args.get('execution_date')         link_name = request.args.get('link_name')         dttm = airflow.utils.timezone.parse(execution_date)         dag = dagbag.get_dag(dag_id)          if not dag or task_id not in dag.task_ids:             response = jsonify(                 {'url': None,                  'error': "can't find dag {dag} or task_id {task_id}".format(                      dag=dag,                      task_id=task_id                  )}             )             response.status_code = 404             return response          task = dag.get_task(task_id)          try:             url = task.get_extra_links(dttm, link_name)         except ValueError as err:             response = jsonify({'url': None, 'error': str(err)})             response.status_code = 404             return response         if url:             response = jsonify({'error': None, 'url': url})             response.status_code = 200             return response         else:             response = jsonify(                 {'url': None, 'error': 'No URL found for {dest}'.format(dest=link_name)})             response.status_code

Code: def __init__(self, http_conn_id, webhook_token, message, attachments, channel, username, icon_emoji, link_names, proxy):         self.http_conn_id = http_
Get a field from the hook's extra field.          :param str field_name: The name of the field to get.         :param default_value: The default value to return if the field is not             found.         :type default_value: object          :return: The value of the field, or the default value if the field is             not found.         :rtype: object Code: def _get_credentials(self):                  key_path = self._get_field('key_path', False)         keyfile_dict = self._get_field('keyfile_dict', False)         scope = self._get_field('scope', None)         if scope:             scopes = [s.strip() for s in scope.split(',')]         else:             scopes = _DEFAULT_SCOPES          if not key_path and not keyfile_dict:             self.log.info('Getting connection using `google.auth.default()` '                          'since no key file is defined for hook.')             credentials, _ = google.auth.default(scopes=scopes)         elif key_path:             # Get credentials from a JSON file.             if key_path.endswith('.json'):                 self.log.debug('Getting connection using JSON key file %s' % key_path)                 credentials = (                     google.oauth2.service_account.Credentials.from_service_account_file(                         key_path, scopes=scopes)                 )             elif key_path.endswith('.p12'):                 raise AirflowException('Legacy P12 key file are not supported, '                                        'use a
Get service account info from a file.          :returns: Service account info         :rtype: dict Code: def _get_credentials_from_env(self):         """         Get credentials from the environment.          :returns: Credentials         :rtype: google.auth.credentials.Credentials         """         credentials = None         if self._environment_
Code: def __init__(self, *args, **kwargs):         super(GoogleCloudStorageHook, self).__init__(*args, **kwargs)         self.gcs_conn_id = kwargs.get('gcs_conn_id', 'google_cloud
Code: def _get_credentials(self):         if self.gcp_conn_id:             conn = self.get_connection(self.gcp_conn_id)             return json.loads(conn
Initialize the InvitePage          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def __getitem__(self, key):         """         Convenience method for accessing the first
Code: def _prepare_command(self, cmd):                  connection_cmd = ["spark-sql"]         if self._conf:             for conf_el in self._conf.split(","):                 connection_cmd += ["--conf", conf_el]         if self._total_executor_cores:             connection_cmd += ["--total-executor-cores", str(self._total_executor_cores)]         if self._executor_cores:             connection_cmd += ["--executor-cores", str(self._executor_cores)]         if self._executor_memory:             connection_cmd += ["--executor-memory",
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __str__(self):         """         Provide a friendly representation          :returns: Machine friendly
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._members = None         self._messages = None         self._invites = None         self._webhooks = None      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._messages = MessageList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._messages      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites =
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __unicode__(self):         """         Provide a friendly representation
Pad the given PIL Image on all sides with the given "pad" value.          :param img: PIL Image to be padded.         :type img: PIL Image         :param padding: Padding on each border. If a single int is provided this             is used to pad all borders. If tuple of length 2 is provided this is the padding             on left/right and top/bottom respectively. If a tuple of length 4 is provided             this is the padding for the left, top, right and bottom borders             respectively.         :type padding: int or tuple         :param fill: Pixel fill value for constant fill. Default is 0. If a tuple of             length 3, it is used to fill R, G, B channels respectively.         :type fill: int or tuple         :param padding_mode: Type of padding. Should be: constant, edge, reflect or symmetric. Default is constant.         :type padding_mode: str         :return: Padded image.         :rtype: PIL Image Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  attributes=values.unset, date_created=values.unset,                  date_updated=values.unset, created_by=values.unset,                  url=values.unset):         """         Initialize the InviteInstance          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to         :param sid: The unique string that identifies the resource         :param attributes: An optional string metadata field you can use to store any data you wish.         :param date_created: The ISO 8601 date and time in GMT when the resource was created         :param date_updated: The ISO 8601 date and time in GMT when the resource was last updated         :param created_by: The identity of the User that created the resource         :param url: The absolute URL of the resource          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __
Get an item from the list of resources          :param unicode key: The index of the resource to fetch          :returns
Code: def hflip(img):          if not _is_pil_image(img):         raise TypeError('img should be PIL Image. Got {}'.format(type(img)))
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset, links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': sid,             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def date_created(self):         """         :returns: The ISO 8601 date and time in GMT when the resource was created         :rtype: datetime         """         return self._properties['date_created']      @property     def date_updated(self):         """         :returns: The ISO 8601
Code: def _get_image_gps_altitude_ref(img):     exif = img.
5 crop the image into 5 parts and center crop the image.          :param img: PIL Image to be cropped.         :param size: Desired output size of the crop.         :return: 5 PIL Images.         :rtype: tuple         """     if isinstance(size, numbers.Number):         size = (int(size), int(size))     else:         assert len(size) == 2, "Please provide only two dimensions (h, w) for size."      w, h = img.size     crop_h, crop_w = size     if crop_w > w or crop_h > h:         raise ValueError("Requested crop size {} is bigger than input size {}".format(size,                                                                                       (h, w)))     tl = img.crop((0, 0, crop_w, crop_h))     tr = img.crop((w - crop_w, 0, w, crop_h))     bl = img.crop((0, h - crop_h, crop_w, h))     br = img.
Get the channel sid from the channel name          :param str channel_name: The channel name          :returns: The channel sid         :rtype: str Code: def _get_channel_sid(self, channel_name):         """         Get the channel sid from the channel name          :param str channel_name: The channel name          :returns: The channel sid         :rtype: str         """         channel = self.client.chat.channels.list(             service_sid=self.service_sid,             friendly_name=channel_name,         )         if len(channel) == 0:             raise TwilioRestException(                 'Channel with name {} does not
Initialize the InvitePage          :param Version version: Version that contains the resource         :param dict payload: A JSON response from the Twilio API          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def __init__(self, version, response, solution):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def __init__(self, version, response, solution):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: tw
Check if the input is a PIL Image.          :param img: Image to be checked         :type img: object         :return: True if the input is a PIL Image, False otherwise         :rtype: bool Code: def _is_pil_image(img):     return isinstance(img,
Get the channel sid from the channel          :param twilio.rest.chat.v2.channel.Channel channel: The channel          :returns: The channel sid         :rtype: str Code: def _get_channel
Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __
Determine if an object is a numpy array Code: def _is_tensor_image(img):     """     Determine if an object is a torch tensor     """     return torch.is_tensor(img)
Convert an image to RGBA.          :param img: PIL Image to be converted to RGBA.         :type img: PIL Image         :returns: PIL Image converted to RGBA.         :rtype: PIL Image Code: def to_ycbcr(img, y_only=False):     """Convert an image to YCbCr format.      :
Get an item from the list of resources in the response.          :returns: An instance of the resource at the given index, or None if                   that index does not exist.         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def __call__(self, sid):         """         Constructs a InviteContext          :param sid: The unique string that identifies the resource
Get an object that represents the params to update on the resource          :returns: dict         :rtype: dict Code: def _make_call_options(self, method, url, query_params, headers, payload, timeout, connect_timeout, idempotency_key, retry_opts):         """         Construct a RequestOptions object for this request          :param str method: HTTP method to use for the request         :param str url: The absolute URL for the request         :param dict query_params: The query parameters for the request         :param dict
Code: def read_image_file(data_dir, image_ext, n):           def PIL2array(_img):                  return np.array(_img.getdata(), dtype=np.uint8).reshape(64, 64)      def find_files(_data_dir, _image_ext):                  files = []         # find those files with the specified extension         for file_dir in os.listdir(_data_dir):             if file_dir.endswith(_image_ext):                 files.append(os.path.join(_data_dir, file_dir))         return sorted(files)  # sort files in ascend order to keep relations      patches = []     list_files = find_files(data_dir, image_ext)      for fpath in list_files:         img = Image.open(fpath)         for y in range(0, 1024, 64):             for x in range(0, 1024, 64):                 patch = img.crop((x, y, x + 6
Code: def read_info_file(data_dir, info_file):          labels = []     with open(os.path.join(data_dir, info_file), 'r') as f:         labels = [
Code: def read_matches_files(data_dir, matches_file):          matches = []     with open(os.path.join(data_dir, matches_file), 'r') as f:         for line in f:             line_split = line.split
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset,                  links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': sid,             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def date_created(self):         """         :returns: The RFC 2822 date and time in GMT when the resource was created         :rtype: datetime         """         return self._properties['date_created']      @property     def date_updated(self):         """         :returns: The RFC 282
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __repr__(self):         """         Provide a friendly representation          :returns: Machine
Build an instance of InviteInstance          :param dict payload:
Lists InviteInstance records from the API as a list.         Unlike stream(), this operation is eager and will load `limit` records into         memory before returning.          :param int limit: Upper limit for the number of records to return. list() guarantees                           never to return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, list() will attempt to read the limit                               with the most efficient page size, i.e. min(limit, 1000)          :returns: Generator that will yield up to limit results         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance] Code: def list_
Code: def list_files(root, suffix, prefix=False):          root = os.path.expanduser(root)     files = list(         filter(             lambda p: os.path.isfile(os.path.join(root, p)) and p.endswith(suffix),             os.listdir(root)         )     )      if prefix is True:         files = [
Code: def _get_file_mime_type(url):     return mimetypes.guess_type(url)[0]
Get the contents of a URL          :param str url: URL to fetch          :
Code: def get_params(width, height, distortion_scale):                  half_height = int(height / 2)         half_width = int(width / 2)         topleft = (random.randint(0, int(distortion_scale * half_width)),                    random.randint(0, int(distortion_scale * half_height)))         topright = (random.randint(width - int(distortion_scale * half_width) - 1, width - 1),                     random.randint(0, int(distortion_scale * half_height)))         botright = (random.randint(width - int(distortion_scale * half_width) - 1, width - 1),                     random.randint(height - int(distortion_scale * half_height) - 1, height - 1))         botleft = (random.randint(0, int(distortion_scale * half_
Code: def get_params(img, scale, ratio):                  area = img.size[0] * img.size[1]          for attempt in range(10):             target_area = random.uniform(*scale) * area             log_ratio = (math.log(ratio[0]), math.log(ratio[1]))             aspect_ratio = math.exp(random.uniform(*log_ratio))              w = int(round(math.sqrt(target_area * aspect_ratio)))             h = int(round(math.sqrt(target_area / aspect_ratio)))              if w <= img.size[0] and h <= img.size[1]:                 i = random.randint(0, img.size[1] - h
:param brightness: brightness range         :type brightness: list[float]         :param contrast: contrast range         :type contrast: list[float]         :param saturation: saturation range         :type saturation: list[float]         :param hue: hue range         :type hue: list[float]          :returns: transforms         :rtype: torchvision.transforms.Compose Code: def get_params_transform_2(brightness, contrast, saturation, hue):                  transforms = []          if brightness is not None:             brightness_factor = random.uniform(brightness[0], brightness[1])             transforms.append(Lambda(lambda img: F.adjust_brightness(img, brightness_factor)))          if contrast is not None:             contrast_factor = random.uniform(contrast[0], contrast[1])             transforms.append(Lambda(lambda img: F.adjust_contrast(img, contrast_
:param degrees: Range of degrees to select from. Should be a 2-element tuple             containing the minimum and maximum values.         :type degrees: tuple(float, float)         :param translate: Range of translation to select from. Should be a 2-element tuple
Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InviteList          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Marshaled Properties         self._properties = {             'invites': payload.get('invites'),            'meta': payload.get('meta'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,         }      @property     def invites(self):         """         :returns: The list of Invites         :rtype: unicode         """         return self._properties['invites']      @property     def meta(self):         """         :returns: The response metadata         :rtype: dict         """         return self._properties['meta']      def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         return '<Twilio.IpMessaging.V2.InviteList>'   class InvitePage(Page):     """ PLEASE NOTE that this class contains preview products that are subject     to change. Use them with caution. If you currently do not have developer     preview access, please contact <EMAIL>. """      def __init__(self, version, response, solution):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource is associated with          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init__(version, response)          # Path Solution         self._solution = solution      def get_instance(self, payload):         """         Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset, links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._version.account_sid,            'service_sid': service_sid,             'channel_sid': channel_sid,             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_
Code:
Code: def get_current_
Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'identity': payload.get('identity'),             'role_sid': payload.get('role_sid'),             'date_created': deserialize.iso8601_datetime(payload.get('date_created')),             'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')),             'url': payload.get('url'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': payload.get('sid'),         }      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property     def service_sid(self):         """         :returns: The SID of the Service that the resource is associated with         :rtype: unicode         """         return self._properties['service_sid']      @property     def channel_sid(self):         """         :returns: The SID of the Channel the resource belongs to         :rtype: unicode         """         return self._properties['channel_sid']      @property     def identity(self):         """         :returns: The identity of the User that was invited to the Channel         :rtype: unicode         """         return self._properties['identity']      @property     def role_sid(self):         """         :
Get a list of channel users          :param str channel_sid: The channel_sid          :returns: list[twilio.rest.chat.v2.service.channel.ChannelUserInstance]         :rtype: list[twilio.rest.chat.v2.service.channel.ChannelUserInstance]
Get the template context for a theme          :param str templates_path: Path to the templates directory         :param str theme: Theme to get the template context for         :param str template: Template to get the context for         :param dict context: Context to use
check if the searchQuery contain a bang, and create fitting autocompleter results          :param str full_query: Full query string          :returns: list -- List of autocompleter results         :rtype: list Code: def searx_query(full_query):     '''check if the searchQuery contain a bang, and create fitting autocompleter results'''     # check if there is a query which can be parsed     if len(full_query.getSearchQuery()) == 0:         return []      results = []      # check if current query stats with!bang     first_char = full_query.getSearchQuery()[0]     if first_char == '!' or first_char == '?':         if len(full_query.getSearchQuery()) == 1:             # show some example queries             # TODO, check if engine is not avaliable             results.append(first_char + "images")             results.append(first_char + "wikipedia")             results.append(first_char + "osm")         else:             engine_query = full_query.getSearchQuery()[1:]              # check if query starts with categorie name             for categorie in categories:                 if categorie.startswith(engine_query):                     results.append(first_char + '{categorie}'.format(categorie=categorie))              # check if query starts with engine name             for engine in engines:                 if engine.startswith(engine_query.replace('_','')):                     results.append(first_char + '{engine}'.format(engine=engine.replace(' ', '_')))              # check if query starts with engine shortcut             for engine_shortcut in engine_shortcuts:                 if engine_shortcut.startswith(engine_query):                     results.append(first_char + '{engine_shortcut}'.format(engine_shortcut=engine_shortcut))      # check if current query stats with :bang     elif first_char == ':':         if len(full_query.getSearchQuery()) == 1:             # show some example queries             results.append(":en")             results.append(":en_us")             results.append(":english")             results.append(":united_kingdom")         else:             engine_query = full_query.getSearchQuery()[1:]              for lc in language_codes:                 lang_id, lang_name, country, english_name
Initialize the InviteContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._invites = None         self._members = None         self._messages = None         self._webhooks = None      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = InviteList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._invites      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._
Code: def __init__(self, *args, **kwargs):         """Initialize the ChannelCumulativeStatisticsList          :returns: twilio.rest.chat.v2.service.channel.channel_cumulative_statistics.ChannelCumulativeStatisticsList         :rtype: twilio.rest.chat.v2.service.channel.channel_cumulative_statistics.ChannelCumulativeStatisticsList         """         super(ChannelCumulativeStatisticsList, self).__init__(*args, **kwargs)          # Path Solution         self._solution = {'service_sid': self._version.service_sid, 'channel_sid': self._version.channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/CumulativeStatistics'.format(**self._solution)      def stream(self, limit=None, page_size=None):         """         Streams ChannelCumulativeStatisticsInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until the limit         is reached.         The results are returned as a generator, so this operation is memory efficient.          :param int limit: Upper limit for the number of records to return. stream()                           guarantees to never return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, stream() will attempt to read the                               limit with the most efficient page size, i.e. min(limit, 1000)          :returns: Generator that will yield up to limit results         :rtype: list[twilio.rest.chat.v2.service.channel.channel_cumulative_statistics.ChannelCumulativeStatisticsInstance]         """         limits = self._version.read_limits(limit, page_size)          page = self.page(page_size=limits['page_size'], )          return self._version.stream(page, limits['limit'], limits['page_limit'])      def list(self, limit=None, page_size=None):         """         Lists ChannelCumulativeStatisticsInstance records from the API as a list.         Unlike stream(), this operation is eager and will load `limit` records into         memory before returning.          :param int limit: Upper limit for the number of records
Code: def eight_schools_joint_log_prob(     treatment_effects, treatment_
Fetch a ChannelInstance          :param unicode channel_sid: The sid          :returns: twilio.rest.chat.v2.service.channel.ChannelInstance         :rtype: twilio.rest.chat.v2.service.channel.ChannelInstance Code: def _get_channel_instance(self, channel_sid):         """         Fetch a ChannelInstance          :param unicode channel_sid: The sid          :returns: twilio.rest.chat.v2.service.channel.ChannelInstance         :rtype: twilio.rest.chat.v2.service.channel.ChannelInstance         """         params = values.of({'PageToken': self._solution['page_token'], })          payload = self._version.page(             'GET',             self._
Code: def __init__(self, version, service_sid, channel_sid):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def create(self, identity, role_sid=values.unset,                type=values.unset, url=values.unset, ttl=values.unset):         """         Create a new InviteInstance          :param unicode identity: The `identity` value that identifies the new resource's User         :param unicode role_sid: The SID of the Role to assign to the new resource         :param unicode type: The type of push notification to use. Can be: `gcm` or `apn` or `fcm` or `sms`         :param unicode url: The URL we should call using the `type` property to send a push notification         :param unicode ttl: An integer representing how long, in seconds, the notification should be retained. Can be an integer from 0 to 43200 (12 hours).          :returns: Newly created InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         data = values.of({             'Identity': identity,             'RoleSid': role_sid,             'Type': type,             'Url': url,             'Ttl': ttl,         })          payload = self._version.create(             'POST',             self._uri,             data=data,         )          return InviteInstance(             self._version,             payload,             service_sid=self._solution['service_sid'],             channel_sid=self._solution['channel_sid'],         )      def stream(self
Get the description of the distribution.          :param Distribution distribution: The distribution to get the description of.          :returns: The description of the distribution.         :rtype: str Code: def _get_distribution_tags(distribution):   """   Get
Code: def _build_custom_rv(distribution, sample_shape, value, name):      # Program transformations (e.g., `make_log_joint_fn`) assume that   # the traced constructor has `name` and `value` kwargs, enabling   # them to override the value of an RV according to
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  by=values.unset, role_sid=values.unset, identity=values.unset,                  url=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['account_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'by': by,             'role_sid': role_sid,             'identity': identity,             'url': url,         }          self._solution = {             'account_sid': account_sid,            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property     def service_sid(self):         """         :returns: The SID of the Service that the resource is associated with         :rtype: unicode         """         return self._properties['service_sid']      @property     def channel_sid(self):         """         :returns: The SID of the Channel the resource belongs to         :rtype: unicode         """         return self._properties['channel_sid']      @property     def date_created(self):         """         :returns: The RFC 282
Code: def _make_random_variable(distribution_cls):       @interceptable   @functools.wraps(distribution_cls, assigned=('__module__', '__name__'))   @docstring_util.expand_docstring(       cls=distribution_cls.__name__,       doc=inspect.cleandoc(distribution_cls.__init__.__doc__ or ''))   def func(*args, **kwargs):     # pylint: disable=g-doc-args          # pylint: enable=g-doc-args     sample_shape = kwargs.pop('sample_shape', ())     value = kwargs.pop('value', None)     return RandomVariable(distribution=distribution_cls(*args, **kwargs),
Code: def one_step_predictive(model, observed_time_series, parameter_samples):       with tf.compat.v1.name_scope(       'one_step_predictive', values=[observed_time_series, parameter_samples]):      [         observed_time_series,         is_missing     ] = sts_util.canonicalize_observed_time_series_with_mask(         observed_time_series)      # Run filtering over the training timesteps to extract the     # predictive means and variances.     num_timesteps = dist_util.prefer_static_value(         tf.shape(input=observed_time_series))[-2]     lgssm = model.make_state_space_model(         num_timesteps=num_timesteps, param_vals=parameter_samples)     (_, _, _, _, _, observation_means, observation_covs     ) = lgssm.forward_filter(observed
Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def forecast(model,              observed_time_series,              parameter_samples,              num_steps_forecast):       with tf.compat.v1.name_scope(       'forecast',       values=[observed_time_series, parameter_samples, num_steps_forecast]):     [         observed_time_series,         mask     ] = sts_util.canonicalize_observed_time_series_with_mask(         observed_time_series)      # Run filtering over the observed timesteps to extract the     # latent state posterior at timestep T+1 (i.e., the final     # filtering distribution, pushed through the transition model).     # This is the prior for the forecast model ("today's prior     # is yesterday's posterior").     num_observed_steps = dist_util.prefer_static_value(         tf.shape(input=observed_time_series))[-2]     observed_data_ssm = model.make_state_space_model(         num_timesteps=num_observed_steps, param_vals=parameter_samples)     (_, _, _, predictive_means, predictive_covs, _, _     ) = observed_data_ssm.forward_filter(observed_time_series, mask=mask)      # Build a batch of state-space models over the forecast period. Because     # we'll use MixtureSameFamily to mix over the posterior draws, we need to     # do some shenanigans to move the `[num_
Returns True if x is a datetime. Code: def _is_timedelta(x
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._invites = None         self._members = None         self._messages = None         self._webhooks = None      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = InviteList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._invites      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  identity=values.unset, role_sid=values.unset,                  last_consumed_message_index=values.unset,                  last_consumption_timestamp=values.unset, date_created=values.unset,                  date_updated=values.unset, url=values.unset, links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['account_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'identity': identity,             'role_sid': role_sid,             'last_consumed_message_index': last_consumed_message_index,             'last_consumption_timestamp': last_consumption_timestamp,             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self
Code: def _event_shape_tensor_internal_v2(event_shape, name=None):      with tf.compat.v1.name_scope(name, 'event_shape_tensor_internal_v2', [event_shape]):     event_shape = tf.convert_to_tensor(         value=event_shape, dtype=tf.int32, name='event_shape')      event_shape_const
Code: def _eval_all_one_hot(fn
Code: def _deserialize(identifier):   """Deserialize a string identifier into a function.    Args:     identifier: A string identifier.    Returns:     A function.    Raises:     ValueError: If the identifier cannot be deserialized.   """   if identifier.startswith('lambda'):     return _deserialize_lambda(identifier)   if identifier.startswith('lambda_'):     return _deserialize_lambda(identifier[7:])   if identifier.startswith('partial_'):     return _deserialize_partial(identifier[8:])   if identifier.startswith('partial'):     return _deserialize_partial(identifier[7:])   if identifier.startswith('partial_'):     return _deserialize_partial(identifier[8:])   if identifier.startswith('partial_'):     return _deserialize_partial(identifier[8:])   if identifier.startswith('partial_'):     return _deserialize_partial(identifier[8:])   if identifier.startswith('partial_'):     return _deserialize_partial(identifier[8:])   if identifier.startswith('partial_'):     return _deserialize_partial(identifier[8:])   if identifier.startswith('partial_'):     return _deserialize_partial(identifier[8:])   if identifier.startswith('partial_'):     return _deserialize_partial(identifier[8:])   if identifier.startswith('partial_'):     return _deserialize_partial(identifier[8:])   if identifier.startswith('partial_'):     return _deserialize_partial(identifier[8:])   if identifier.startswith('partial_'):     return _deserialize_partial(identifier[8:])   if identifier.startswith('partial_'):     return _deserialize_partial(identifier[8:])   if identifier.startswith('partial_'):     return _deserialize_partial(identifier[8:])   if identifier.startswith('partial_'):     return _deserialize_partial(identifier[8:])   if identifier.startswith('partial_'):     return _deserialize_partial(identifier[8:])   if identifier.startswith('partial_'):     return _deserialize_partial(identifier[8:])   if identifier.startswith('partial_'):     return _deserialize_partial(identifier[8:])   if identifier.startswith('partial_'):     return _deserialize_partial(identifier[8:])   if identifier.startswith('partial_'):     return _deserialize_partial(identifier[8:])   if identifier.startswith('partial_'):     return _deserialize_partial(identifier[8:])   if identifier.startswith
Returns the number of parameters in the distribution.          :returns: Number of parameters in the distribution.         :rtype: int Code: def _get_params_size(self):         """         Returns the number of parameters in the distribution.          :returns: Number of parameters in the distribution.         :rtype: int         """         return self._
Code: def get_resource_location(self, payload):         """
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  by=values.unset, role_sid=values.unset, url=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['account_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'by': by,             'role_sid': role_sid,             'url': url,         }          self._solution = {             'account_sid': account_sid,            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property     def service_sid(self):         """         :returns: The SID of the Service that the resource is associated with         :rtype: unicode         """         return self._properties['service_sid']      @property     def channel_sid(self):         """         :returns: The SID of the Channel the resource belongs to         :rtype: unicode         """         return self._properties['channel_sid']      @property     def date_created(self):         """         :returns: The RFC 2822 date and time in GMT when the resource was created         :
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __unicode__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         return unicode(self
Code: def toy_logistic_data(num_examples, input_size=2, weights_prior_stddev=5.0):      random_weights = weights_prior_stddev * np.random.randn(input_size)   random_bias = np.random.randn()   design_matrix = np.random.rand(num_examples, input_size) * 2 - 1   logits = np.reshape(       np.dot(design_matrix, random_weights) + random_bias,       (-1, 1))   p_
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset,                  links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': sid,             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def date_created(self):         """         :returns: The RFC 2822 date and time in GMT when the resource was created         :rtype: datetime         """         return self._properties['date_created']      @property     def date_updated(self):         """         :returns: The RFC 282
Code: def build_input_pipeline(x, y, batch_size):      training_dataset = tf.data.Dataset.from_tensor_slices((x, y))   training_batches = training_dataset.repeat().batch(batch_size)   training_iterator
Code: def _maybe_check_valid_map_values(map_values, validate_args):      assertions = []    message = 'Rank of map_values must be 1.'   if tensorshape_util.rank(map_values.shape) is not None:     if tensorshape_util.rank(map_values.shape)!= 1:       raise ValueError(message)   elif validate_args:     assertions.append(assert_util.assert_rank(map_values, 1, message=message))    message = 'Size of map_values must be greater than 0.'   if tensorshape_util.num_elements(map_values.shape) is not None:     if tensorshape_util.num_elements(map_values.shape) == 0:       raise ValueError(message)   elif validate_args:     assertions.append(         assert_util.assert_greater(             tf.size(input=map_values), 0, message=message))    if validate_args:     assertions.append(         assert_util.assert_
Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'created_by': payload.get('created_by'),             'created_by_identity': payload.get('created_by_identity'),             'created_at': deserialize.iso8601_datetime(payload.get('created_at')),             'date_created': deserialize.iso8601_datetime(payload.get('date_created')),             'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')),             'url': payload.get('url'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': payload.get('sid'),         }      @property     def sid(self) -> str:         """         :returns: The unique string that identifies the resource         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self) -> str:         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property     def service_sid(self) -> str:         """         :returns: The SID of the Service that the resource is associated with         :rtype: unicode         """         return self._properties['service_sid']      @property     def channel_sid(self) -> str:         """         :returns: The SID of the Channel the resource is associated with         :rtype: unicode         """         return self._properties['channel_sid']      @property     def created_by(self) -> str:         """         :returns: The identity of
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  identity=values.unset, role_sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  url=values.unset):         """         Initialize the InviteContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to         :param sid: The SID of the Invite resource to fetch          :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         super(InviteContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites/{sid}'.format(**self._solution)          # Dependents         self._channel = None         self._member = None          # Context         self._context = None         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid or self._properties['sid'], }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: The unique string that identifies the resource         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._members = None         self._messages = None         self._invites = None         self._webhooks = None      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._messages = MessageList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._messages      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites =
Get an item from the list of resources          :param unicode key: The index of the resource to fetch          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def __call__(self, sid):         """         Constructs a Invite
Code: def transform_log_prob_fn(log_prob_fn: PotentialFn,                           bijector: BijectorNest,                           init_state: State = None                          ) -> Union[PotentialFn, Tuple[PotentialFn, State]]:       def wrapper(*args):          bijector_ = bijector      args = tf.nest.map_structure(lambda x: 0. + x, args)     if len(args) == 1:       args = args[0]     elif isinstance(bijector_, list):       bijector_ = tuple(bijector_)
Get the channel unique name from the channel_sid or channel_unique_name          :param str channel_sid: The channel_sid         :param str channel_unique_name: The channel_unique_name          :returns: The channel unique name         :rtype: str Code: def _get_service_sid(self, service_sid):         """         Get the service sid from the service_sid or service_unique_name          :param str service_sid: The service_sid         :param str service_unique_name: The service_unique_name          :returns: The service sid         :rtype: str         """         if service_sid:             return service_sid         if service_unique_name:
Constructs a ChannelContext          :param channel_sid: The SID of the Channel resource to fetch          :returns: twilio.rest.chat.v2.service.channel.
Code: def hmc_step(     hmc_state: HamiltonianMonteCarloState,     target_log_prob_fn: PotentialFn,     step_size: Any,     num_leapfrog_steps: IntTensor,     momentum: State = None,     kinetic_energy_fn: PotentialFn = None,     momentum_sample_fn: MomentumSampleFn = None,     leapfrog_trace_fn: Callable[[LeapFrogStepState, LeapFrogStepExtras],                                 TensorNest] = lambda *args: (),     seed=None, ) -> Tuple[HamiltonianMonteCarloState, HamiltonianMonteCarloExtra]:      state = hmc_state.state   state_grads = hmc_state.state_grads   target_log_prob = hmc_state.target_log_prob   state_extra = hmc_state.state_extra    if kinetic_energy_fn is None:      # pylint: disable=function-redefined     def kinetic_energy_fn(*momentum):       return tf.add_n([           tf.reduce_sum(input_tensor=tf.square(x), axis=-1) / 2.           for x in tf.nest.flatten(momentum)       ]), ()    if momentum_sample_fn is None:      # pylint: disable=function-redefined     def momentum_sample_fn(*momentum):       ret = tf.nest.map_structure(           lambda x: tf.random.normal(tf.shape(input=x), dtype=x.dtype),           momentum)       if len(ret) == 1:         return ret[0]       else:         return ret    if momentum is None:     momentum = call_fn(momentum_sample_fn,                        tf.nest.map_structure(tf.zeros_like, state))   if target_log_prob is None:     target_log_prob, state_extra, state_grads = call_and_grads(         target_log_prob_fn, state)    kinetic_energy, _ = call_fn(kinetic_energy_fn, momentum)   current_energy = -target_log_prob + kinetic_energy   current_state = Hamil
Code: def _get_new
Code: def __init__(self,                  kernel_posterior_fn,                  kernel_posterior_tensor_fn,                  kernel_prior_fn,                  kernel_divergence_fn,                  bias_posterior_fn,                  bias_posterior_tensor_fn,                  bias_prior_fn,                  bias_divergence_fn,                  name=None,                  dtype=None,                  **kwargs):     """     Initialize the `tfd.LinearOperator` class.      Args:       kernel_posterior_fn: Python `callable` which returns a `tfd.LinearOperator`         instance representing the posterior distribution over the kernel.       kernel_posterior_tensor_fn: Python `callable` which returns a `Tensor`         representing the posterior distribution over the kernel.       kernel_prior_fn: Python `callable` which returns a `tfd.LinearOperator`         instance representing the prior distribution over the kernel.       kernel_divergence_fn: Python `callable` which returns a `Tensor`         representing the divergence between the prior and posterior         distributions over the kernel.       bias_posterior_fn: Python `callable` which returns a `tfd.LinearOperator`         instance representing the posterior distribution over the bias.       bias_posterior_tensor_fn: Python `callable` which returns a `Tensor`         representing the posterior distribution over the bias.       bias_prior_fn: Python `callable` which returns a `tfd.LinearOperator`         instance representing the prior distribution over the bias.       bias_divergence_fn: Python `callable` which returns a `Tensor`         representing the divergence between the prior and posterior         distributions over the bias.       name: Python `str` name prefixed to Ops created by this class.       dtype: `tf.DType` of the `LinearOperator` instance.       **kwargs: Additional keyword arguments passed to the `LinearOperator`         constructor.     """     self._kernel_posterior_fn = kernel_posterior_fn     self._kernel_posterior_tensor_fn = kernel_posterior_tensor_fn     self._kernel_prior_fn = kernel_prior_fn     self._kernel_divergence_fn = kernel_divergence_fn     self._bias_posterior_fn = bias_posterior_fn     self._bias_posterior_tensor_fn = bias_posterior_tensor_fn
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._invites = None         self._members = None         self._messages = None         self._webhooks = None      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = InviteList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._invites      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._
Code: def _create_scale_operator(self, identity_multiplier, diag, tril,                              perturb_diag,
Code
Code: def random_walk_truncated_normal_fn(mean=0., stddev=1., low=None, high=None, name=None):      def _fn(state_parts, seed):          with tf.compat.v1.name_scope(         name, 'random_walk_truncated_normal_fn',         values=[state_parts, mean, stddev, low, high, seed]):       means = mean if mcmc_util.is_list_like(mean) else [mean]       stddevs = stddev if mcmc_util.is_list_like(stddev) else [stddev]       if len(means) == 1:         means *= len(state_parts)       if len(stddevs) == 1:
Code: def _expand_to_event_rank(self, x):          expanded_x =
Code: def __init__(self, *args, **kwargs):         """         Initialize the Distribution.          :param args: Positional arguments for the base class.         :param kwargs: Keyword arguments for the base class.         """         super(Distribution, self).__init__(*args, **kwargs)         self._validate_args()         self._validate_sample()         self._validate_log_prob()         self._validate_entropy()         self._validate_mean()         self._validate_stddev()         self._validate_variance()         self._validate_sample_n()         self._validate_log_prob_n()         self._validate_entropy_n()         self._validate_mean_n()         self._validate_
Code: def _cat_probs(self, log_probs):          which_softmax = tf.nn.log_softmax if log_probs else tf.nn.softmax     cat_probs = which_softmax(self.cat.logits)     cat_probs = tf.unstack(cat_probs, num=self.num_
Code: def _maybe_validate_args(outcomes, logits, probs, validate_args):      assertions = []    def validate_equal_last_dim(tensor_a, tensor_b, message):     if tensor_a.shape.is_fully_defined() and tensor_
# pylint: disable=g-statement-before-imports      try:     import tensorflow as tf   except ImportError:     # Print more informative error message, then reraise.     print("\n\nFailed to import TensorFlow. Please note that TensorFlow is not "           "installed by default when you install TensorFlow Probability. This "           "is so that users can decide whether to install the GPU-enabled "           "TensorFlow package. To use TensorFlow Probability, please install "           "the most recent version of TensorFlow, by following instructions at "           "https://tensorflow.org/install.\n\n")     raise    import distutils.version    #   # Update this whenever we need to depend on a newer TensorFlow release.   #   required_tensorflow_version = "1.13"    if (distutils.version.LooseVersion(tf.__version__) <       distutils.version.LooseVersion(required_tensorflow_version)):     raise ImportError(         "This version of TensorFlow Probability requires TensorFlow "         "version >= {required}; Detected an installation of version {present}. "         "Please upgrade TensorFlow to proceed.".format(             required=required_tensorflow_version,             present=tf.__version__)) Code: def _ensure_tf_install():  # pylint: disable=g-statement-before-imports      try:     import tensorflow as tf   except ImportError:     # Print more informative error message, then reraise.     print("\n\nFailed to import TensorFlow. Please note that TensorFlow is not "           "installed by default when you install TensorFlow Probability. This "           "is so that users can decide whether to install the GPU-enabled "           "TensorFlow package. To use TensorFlow Probability, please install "           "the most recent version of TensorFlow, by following instructions at "           "https://tensorflow.org/install.\n\n")     raise    import distutils.version    #   # Update this whenever we need to depend on a newer TensorFlow release.   #   required_tensorflow_version = "1.13"    if (distutils.version.LooseVersion(tf.__version__) <       distutils.version.LooseVersion(required_tensorflow_version)):     raise ImportError(         "This version of TensorFlow Probability requires TensorFlow "         "version >= {required}; Detected an installation of version {present}. "         "Please upgrade TensorFlow to
Code: def logistic_regression(features):      coeffs
@param Page response: Page response
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the new resource belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._members = None         self._messages = None         self._invites = None         self._webhooks = None      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._messages = MessageList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._messages      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = Inv
Code: def __init__(self, service_sid, channel_sid, version, friendly_name=values.unset, attributes=values.unset, type=values.unset, date_created=values.unset, date_updated=values.unset, created_by=values.unset, url=values.unset):         """         Initialize the InviteList          :param unicode service_sid: The SID of the Service to create the resource under         :param unicode channel_sid: The SID of the Channel the new resource belongs to         :param Version version: Version that contains the resource         :param unicode friendly_name: A string to describe the resource         :param unicode attributes: A valid JSON string that contains application-specific data         :param unicode type: The type of push notification delivery mechanism to use         :param datetime date_created: The ISO 8601 date and time in GMT when the resource was created         :param datetime date_updated: The ISO 8601 date and time in GMT when the resource was last updated         :param unicode created_by: The identity of the User that created the resource         :param unicode url: The absolute URL of the resource          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)          # Path Parameters         self._properties = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)          # Filters         self._filters = {'friendly_name': friendly_name, 'attributes': attributes, 'type': type, 'date_created': deserialize.iso8601_datetime, 'date_updated': deserialize.iso8601_datetime, 'created_by': created_by, }         self._limit = None         self._page_size = None          if url is not None:             self._uri = url
Code: def __init__(self, service_sid, channel_sid, version, friendly_name=values.unset, attributes=values.unset, unique_name=values.unset, type=values.unset, date_created=values.unset, date_updated=values.unset, created_by=values.unset, url=values.unset):         """         Initialize the InviteList          :param unicode service_sid: The SID of the Service to create the resource under         :param unicode channel_sid: The SID of the Channel the new resource belongs to         :param Version version: Version that contains the resource         :param unicode friendly_name: A string to describe the resource         :param unicode attributes: An optional string metadata field you can use to store any data you wish.         :param unicode unique_name: An application-defined string that uniquely identifies the resource         :param unicode type: The type of push notification delivery mechanism to use         :param datetime date_created: The ISO 8601 date and time in GMT when the resource was created         :param datetime date_updated: The ISO 8601 date and time in GMT when the resource was last updated         :param unicode created_by: The identity of the User that created the resource         :param unicode url: The absolute URL of the resource          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)          # Path Parameters         self._properties = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)          # Options         self._options = {'friendly_name': friendly_name, 'attributes': attributes, 'unique_name': unique_name, 'type': type, 'date_created': serialize.iso8601_datetime(date_created), 'date_updated': serialize.iso8
Code: def _make_positive_axis(axis, ndims):      axis = _make_list_or_1d_tensor(axis)    ndims = tf.convert_to_tensor(value=ndims, name='ndims', dtype=tf.int32)   ndims_ = tf.get_static_value(ndims)    if _is_list_like(axis) and ndims_ is not None:     # Static case     positive_axis
Code: def _squeeze(x, axis):      x = tf.convert_to_tensor(value=x,
Code: def _z(self, x):          with tf.name_scope("standardize"):       return (x - self.loc) /
Code: def _inv_z(self, z):          with tf.name_scope("reconstruct"):       return z * self.scale +
semilocal_linear_trend_transition_matrix(autoregressive_coef)      # We want to write the following 2 x 2 matrix:   #  [[1., 1., ],    # level(t+1) = level(t) + slope(t)   #   [0., ar_coef], # slope(t+1) = ar_coef * slope(t)   # but it's slightly tricky to properly incorporate the batch shape of   # autoregressive_coef. E.g., if autoregressive_coef has shape [4,6], we want   # to return shape [4, 6, 2, 2]. We do this by breaking the matrix into its   # fixed entries, written explicitly, and then the autoregressive_coef part   # which we add in after using a mask to broadcast to the correct matrix shape.    fixed_entries = tf.constant(       [[1.,
Get the next batch of data from the queue.          :param int batch_size: The number of samples to return.          :returns: A tuple of (data, labels) where data is a list of                   numpy arrays and labels is a list of numpy arrays.         :rtype: tuple Code: def _get_next_batch_from_queue_with_labels(self, batch_size):         """         Get the next batch of data from the queue.          :param int batch_size: The number of samples to return.          :returns: A tuple of (data, labels) where data is a list of
Generate a sequence of random numbers from a Halton sequence.          The Halton sequence is a sequence of numbers that are uniformly         distributed in the unit cube. The Halton sequence is constructed by         starting with the first prime number, 2, and then constructing a         sequence of prime numbers by multiplying the previous prime number by         the next prime number. For example, the first 10 prime numbers are:         2, 3, 5, 7, 11, 13, 17, 19, 23, 29.          The Halton sequence is then constructed by starting with the first         prime number, 2, and then constructing a sequence of prime numbers by         multiplying the previous prime number by the next prime number. For         example, the first 10 prime numbers are:         2, 3, 5, 7, 11, 13, 17, 19, 23, 29.          The Halton sequence is then constructed by starting with the first         prime number, 2, and then constructing a sequence of prime numbers by         multiplying the previous prime number by the next prime number. For         example, the first 10 prime numbers are:         2, 3, 5, 7, 11, 13, 17, 19, 23, 29.          The Halton sequence is then constructed by starting with the first         prime number, 2, and then constructing a sequence of prime numbers by         multiplying the previous prime number by the next prime number. For         example, the first 10 prime numbers are:         2, 3, 5, 7, 11, 13, 17, 19, 23, 29.          The Halton sequence is then constructed by starting with the first         prime number, 2, and then constructing a sequence of prime numbers by         multiplying the previous prime number by the next prime number. For         example, the first 10 prime numbers are:         2, 3, 5, 7, 11, 13, 17, 19, 23, 29.          The Halton sequence is then constructed by starting with the first         prime number, 2, and then constructing a sequence of
Code: def _get_permutations(num_results, dims, seed=None):      sample_range = tf.range(num_results)   stream = distributions.SeedStream(seed, salt='MCMCSampleHaltonSequence3')   def
Code: def _get_indices(num_results, sequence_indices, dtype, name=None):      with tf.compat.v1.name_scope(name, '_get_indices',                                [num_results, sequence_indices]):     if sequence_indices is None:       num_results = tf.cast(num_results, dtype=dtype)       sequence_indices = tf.range(num_results, dtype=dtype)     else:       sequence_indices = tf.cast(sequence_indices, dtype)      # Shift the indices so they are 1 based.     indices = sequence_indices + 1      # Reshape to make space for the event dimension and the place value     # coefficients.     return tf.reshape(indices, [-
Code: def _base
Returns a list
Code: def _machine_eps(dtype):      if isinstance(dtype, tf.DType):     dtype = dtype.as_numpy_dtype
Prepare the arguments for the Hager-Zhang line search. Code: def _fix_step_size(value_and_gradients_function, val_initial, active,                        step_size_shrink_param):   """Fix the step size if necessary
Code: def _fix_step_size(value_and_gradients_function,                    val_c_input,                    active,                    step_size_shrink_param):      # The maximum iterations permitted are determined as the number of halvings   # it takes to reduce 1 to 0 in the given dtype.   iter_max = np.ceil(-np.log2(_machine_eps(val_c_input.x.dtype)))    def _cond(i, val_c, to_fix):     del val_c  # Unused.     return (i < iter_max) & tf.reduce_any(input_tensor=to_fix)    def _body(i, val_c, to_fix):     next_c = tf.where(to_fix, val_c.x * step_size_shrink_param, val_c.x)
Code: def _bracket_and_search(     value_and_gradients_function,     init_interval,     f_lim,     max_iterations,     shrinkage_param,     expansion_param,     sufficient_decrease_param,     curvature_param):      bracket_result = hzl.bracket(value_and_gradients_function, init_interval,                                f_lim, max_iterations, expansion_param)    converged = init_interval.converged | _very_close(       bracket_result.left.x, bracket_result.right.x)    # We fail if we have not yet converged but already exhausted all iterations.   exhausted_iterations = ~converged & tf.greater_equal(       bracket_result.iteration, max_iterations)    line_search_args = HagerZhangLineSearchResult(       converged=converged,       failed=
Code: def _line_search_inner_bisection(     value_and_gradients_function,     curr_interval,     should_check_shrinkage,     f_lim):     """     Perform an inner bisection search on the current interval.      :param callable value_and_gradients_function: Function that returns the         value and gradients of the function to be minimized.     :param HagerZhangLineSearchResult curr_interval: Current interval to be         searched.     :param bool should_check_shrinkage: Whether to check for sufficient         shrinkage.     :param float f_lim: Limit on the function value.      :returns: HagerZhangLineSearchResult     :rtype: HagerZhangLineSearchResult     """     def _inner_bisect_cond(curr_interval):       return (curr_interval.converged | curr_interval.failed) & (           ~curr_interval.converged)      def _inner_bisect_body(curr_interval):       midpoint = (curr_interval.left.x + curr_interval.right.x) / 2.0       midpoint_result = value_and_gradients_function(midpoint)       midpoint_f = midpoint_result.f       midpoint_g = midpoint_result.g       midpoint_x = midpoint_result.x       midpoint_converged = _very_close(midpoint_f, curr_interval.left.f)       midpoint_failed = midpoint_f > f_lim       midpoint_converged = midpoint_converged | midpoint_failed       midpoint_result = HagerZhangLineSearchResult(           converged=midpoint_converged,           failed=midpoint_failed,           iterations=curr_interval.iterations + 1,           func_evals=curr_interval.num_evals + 1,           left=curr_interval.left,           right=midpoint_result)        def _do_check_shrinkage():         old_width = curr_interval.right.x - curr_interval.left.x         new_width = midpoint_result.right.x - midpoint_result.left.x         sufficient_shrinkage = new_width < old_width * 0.5         func_is_flat = (             _very_close
Code: def _line_search_inner_bisection(     value_and_gradients_function,     search_interval,     active,     f_lim):      midpoint = (search_interval.left.x + search_interval.right.x) / 2   val_mid = value_and_gradients_function(midpoint)   is_valid_mid = hzl.is_finite(val_mid)    still_active = active & is_valid_mid   new_failed = active & ~is_valid_mid   next_inteval = search_interval._replace(       failed=search_interval.failed | new_failed,       func_evals=search_interval.func
Code: def _prepare_args(value_and_gradients_function,                   initial_step_size,                   val_initial,                   val_0,                   approximate_wolfe_threshold):      eval_count = 0   if val_initial is None:     if initial_step_size is not None:       initial_step_size = tf.convert_to_tensor(value=initial_step_size)     else:       initial_step_size = tf.convert_to_tensor(value=1.0, dtype=tf.float32)     val_initial = value_and_gradients_function(initial_step_size)     eval_count += 1    if val_0 is None:     x_0 = tf.zeros_like(val_initial.x)     val_0 = value_and_gradients_function(x_0)     eval_count += 1    f_lim = val_0.f + (approximate_wolfe_threshold * tf.abs(val_0.f))   return val_0, val_initial, f_lim, tf.convert_to
Code: def _print(pass_through_tensor, values):      flat_values = []   for value in values:     # Checks if it is a namedtuple.     if hasattr(value, '_fields'):       for field in value._fields:         flat_values.extend([field, _to_str(
Lists ChannelInstance records from the API as a list.         Unlike stream(), this operation is eager and will load `limit` records into         memory before returning.          :param int limit: Upper limit for the number of records to return. stream()                           guarantees to never return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not
Code: def quadrature_scheme_softmaxnormal_quantiles(     normal_loc, normal_scale, quadrature_size,     validate_args=False, name=None):      with tf.name_scope(name or "softmax_normal_grid_and_probs"):     normal_loc = tf.convert_to_tensor(value=normal_loc, name="normal_loc")     dt = dtype_util.base_dtype(normal
Code: def maybe_check_quadrature_param(param, name, validate_args):      with tf.name_scope("check_" + name):     assertions = []     if tensorshape_util.rank(param.shape) is not None:       if tensorshape_util.rank(param.shape) == 0:         raise ValueError("Mixing params must be a (batch of) vector; "                          "{}.rank={} is not at least one.".format(                              name, tensorshape_util.rank(param.shape)))     elif validate_args:       assertions.append(           assert
Returns the sample shape of the `Tensor`s that are the outputs of this     `Distribution
Code: def interpolate_loc(grid, loc):      if len(loc)!= 2:     raise NotImplementedError("Currently only bimixtures are supported; "                               "len(scale)={} is not 2.".format(len(loc)))   deg = tf.compat.dimension_value(       tensorshape_util.with_rank_at_least(grid.shape, 1)[-1])   if deg is None:     raise ValueError("Num quadrature grid points must be known prior "                      "to graph execution.")   with tf.name_scope("interpolate_loc"):     if loc is None or loc[0] is None and loc[1] is None:       return [None]*deg     # shape: [B, 1, k, deg
Code: def interpolate_scale(grid, scale):      if len(scale)!= 2:     raise NotImplementedError("Currently only bimixtures are supported; "                               "len(scale)={} is not 2.".format(len(scale)))   deg = tf.compat.dimension_value(       tensorshape_util.with_rank_at_least(grid.shape, 1)[-1])   if deg is None:     raise ValueError("Num quadrature grid points must be known prior "                      "to graph execution.")   with tf.name_scope("interpolate_scale"):     return [linop_add_lib.add_operators([         linop_scale(grid
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the new resource belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._members = None         self._invites = None         self._messages = None         self._webhooks = None      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = InviteList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._invites      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._messages
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset,                  links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid or self._properties['sid'], }         self._properties = {'date_created': deserialize.rfc2822_datetime(date_created), 'date_updated': deserialize.rfc2822_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites/{sid}'.format(**self._solution)          @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']          @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']          @property     def service_sid(self):         """         :returns: The SID of the Service that the resource is associated with         :rtype: unicode         """         return self._properties['service_sid']          @property     def channel_sid(self):         """         :returns: The SID of the Channel the resource belongs to         :rtype: unicode         """         return self._properties['channel_sid']          @property     def date_created(self):         """         :returns: The RFC 2822 date and time in GMT when the resource was created         :rtype: datetime         """         return self._properties['date_created']          @property     def date_updated(self):         """         :returns: The RFC 2822 date and time in GMT when the resource was last updated         :
Code: def _log_vector_matrix(vs, ms):       return tf.reduce_
Code: def _log_matrix_vector(ms
Code: def _vector_matrix(vs, ms):       return tf
Code: def _extract_log_probs(num_states, dist):       states = tf.reshape(tf.range(num_states),                       tf.concat([[num_states],                                  tf.ones_like(dist.batch
Code: def _marginal_hidden_probs(self):           initial_log_probs = tf.broadcast_to(self._log_init,                                         tf.concat([self.batch_shape_tensor(),                                                    [self._num_states]],                                                   axis=0))     # initial_log_probs :: batch_shape num_states      if self._num_steps > 1:       transition_log_probs = self._log_trans        def forward_step(log_probs, _):         return _log_vector_matrix(log_probs, transition_log_probs)        dummy_index = tf.zeros(self._num_steps - 1, dtype=tf.float32)        forward_log_probs = tf.scan(forward_step, dummy_index,                                   initializer=initial_log_probs,                                   name="forward_log_probs")        forward_log_probs = tf.concat([[initial_log_probs], forward_log_probs],                                     axis=0)     else:       forward_log_probs = initial_log_probs[tf.newaxis,...]      #
Code: def posterior_marginals(self, observations, name=None):           with tf.name_scope(name or "posterior_marginals"):       with tf.control_dependencies(self._runtime_assertions):         observation_tensor_shape = tf.shape(input=observations)          with self._observation_shape_preconditions(observation_tensor_shape):           observation_batch_shape = observation_tensor_shape[               :-1 - self._underlying_event_rank]           observation_event_shape = observation_tensor_shape[               -1 - self._underlying_event_rank:]            batch_shape = tf.broadcast_dynamic_shape(observation_batch_shape,                                                    self.batch_shape_tensor())           log_init = tf.broadcast_to(self._log_init,                                      tf.concat([batch_shape,                                                 [self._num_states]],                                                axis=0))           log_transition = self._log_trans            observations = tf.broadcast_to(observations,                                          tf.concat([batch_shape,                                                     observation_event_shape],                                                    axis=0))           observation_rank = tf.rank(observations)           underlying_event_rank = self._underlying_event_rank           observations = distribution_util.move_dimension(               observations, observation_rank - underlying_event_rank - 1, 0)           observations = tf.expand_dims(               observations,               observation_rank - underlying_event_rank)           observation_log_probs = self._observation_distribution.log_prob(               observations)            log_adjoint_prob = tf.zeros_like(log_init)            def forward_step(log_previous_step, log_prob_observation):             return _log_vector_matrix(log_previous_step,                                       log_transition) + log_prob_observation            log_prob = log_init + observation_log_probs[0]            forward_log_probs = tf.scan(forward_step, observation_log_probs[1:],                                       initializer=log_prob,                                       name="forward_log_probs")            forward_log_probs = tf.concat([[log_prob], forward_log_probs], axis=0)            def backward_step(log_previous_step, log_prob_observation):             return _log_matrix_vector(log_transition
Code: def posterior_mode(self, observations, name=None):           with tf.name_scope(name or "posterior_mode"):       with tf.control_dependencies(self._runtime_assertions):         observation_tensor_shape = tf.shape(input=observations)          with self._observation_shape_preconditions(observation_tensor_shape):           observation_batch_shape = observation_tensor_shape[               :-1 - self._underlying_event_rank]           observation_event_shape = observation_tensor_shape[               -1 - self._underlying_event_rank:]            batch_shape = tf.broadcast_dynamic_shape(observation_batch_shape,                                                    self.batch_shape_tensor())           log_init = tf.broadcast_to(self._log_init,                                      tf.concat([batch_shape,                                                 [self._num_states]],                                                axis=0))            observations = tf.broadcast_to(observations,                                          tf.concat([batch_shape,                                                     observation_event_shape],                                                    axis=0))           observation_rank = tf.rank(observations)           underlying_event_rank = self._underlying_event_rank           observations = distribution_util.move_dimension(               observations, observation_rank - underlying_event_rank - 1, 0)            # We need to compute the probability of each observation for           # each possible state.           # This requires inserting an extra index just before the           # observation event indices that will be broadcast with the           # last batch index in `observation_distribution`.           observations = tf.expand_dims(               observations,               observation_rank - underlying_event_rank)           observation_log_probs = self._observation_distribution.log_prob(               observations)            log_prob = log_init + observation_log_probs[0]            if self._num_steps == 1:             most_likely_end = tf.argmax(input=log_prob, axis=-1)             return most_likely_end[..., tf.newaxis]            def forward_step(previous_step_pair, log_prob_observation):             log_prob_previous = previous_step_pair[0]             log_prob = (log_prob_previous[..., tf.newaxis] +                         self._log_trans +                         log_prob_observation[..., tf.newaxis, :])             most
Get the current state of the model and the gradients of the loss with             respect to the current state.          :param dict state_dict: The state dictionary.          :returns: The current state of the model and the gradients of the loss with                   respect to the current state.         :rtype: tuple[list[tf.Tensor], list[tf.Tensor]] Code: def _get_new_state(self, current_state_parts, gradients):     """     Get the new state of the model.      :param list[tf.Tensor] current_state_parts
Pad x with zeros to have final_rank dimensions. Code: def _sample_next_with_target_log_prob(target_log
Code: def _maybe_call_fn(fn,                    fn_arg_list,                    fn_result=None,                    description='target_log_prob'):      fn_arg_list = (list(fn_arg_list) if mcmc_util.is_list
Code
Code: def one_step(self, current_state, previous_kernel_results):          with tf.compat.v1.name_scope(         name=mcmc_util.make_name(self.name,
Code: def _build_trainable_posterior(param, initial_loc_fn):      loc = tf.compat.v1.get_variable(       param.name + '_loc',       initializer=lambda: initial_loc_fn(param),       dtype=param.prior.dtype,       use_resource=True)   scale = tf.nn.softplus(       tf.compat.v1.get_variable(           param.name + '_scale',           initializer=lambda: -4 * tf.ones_like(initial_loc_fn(param)),           dtype=param.prior.dtype,           use_resource=True))    q = tfd.Normal(loc=loc, scale=scale)    # Ensure the `event_shape` of the variational distribution matches the   # parameter.   if (param.prior.event_shape.ndims is None       or param.prior.event_shape.ndims > 0):     q = tfd.Independent(         q, reinterpreted_batch_ndims=param.prior.event_shape.ndims
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['account_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,         }          self._solution = {             'account_sid': account_sid,            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset,                  links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': sid,             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def date_created(self):         """         :returns: The RFC 2822 date and time in GMT when the resource was created.         :rtype: datetime         """         return self._properties['date_created']      @property     def date_updated(self):         """         :returns: The RFC 28
Get the channel sid from the channel url          :param str channel_url: The channel url          :returns: The channel sid         :rtype: str Code: def _get_channel_sid_from_channel_unique_name(self, channel_unique_name):         """         Get the channel sid from the channel unique name          :param str channel_unique
Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the
Returns the static value
Retrieve the channel unique name from the channel_sid or channel_unique_name          :param str channel_sid: The channel_sid         :param str channel_unique_name: The channel_unique_name          :returns: The channel unique name         :rtype: str Code: def _get_service_sid(self, service_sid):         """         Retrieve the service sid from the service_sid or service_unique_name          :param str service_sid: The service_sid         :param str service_unique_name: The service_unique_name          :returns: The service sid         :rtype: str         """         if service_sid:             return service_sid         if service_unique_
Get the channel sid from the channel_sid or channel_unique_name          :param str channel_sid: The channel_sid         :param str channel_unique_name: The channel_unique_name          :returns: The channel sid         :rtype: str Code: def __init__(self, version, service_sid, channel_sid):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The service_sid         :param channel_sid: The channel_sid          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def create(self, identity, role_sid=values.unset,                channel_sid=values.unset, **kwargs):         """         Create the InviteInstance          :param unicode identity: The identity         :param unicode role_sid: The role_sid         :param unicode channel_sid: The channel_sid          :returns: The created InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         data = values.of({             'Identity': identity,             'RoleSid': role_sid,             'ChannelSid': channel_sid,         })          payload = self._version.create(             'POST
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._members = None         self._messages = None         self._invites = None         self._webhooks = None         self._last_read_message_index = None         self._last_read_timestamp = None         self._typing = None         self._invites_invited = None         self._invites_accepted = None         self._invites_rejected = None         self._invites_canceled = None         self._invites_timeout = None         self._invites_accepted_by_remote = None         self._invites_rejected_by_remote = None         self._invites_canceled_by_remote = None         self._invites_timeout_by_remote = None         self._webhooks_created = None         self._webhooks_updated = None         self._webhooks_deleted = None         self._webhooks_bounced = None         self._webhooks_bounced_unsubscribes = None         self._webhooks_bounced_bounces = None         self._webhooks_failed = None         self._webhooks_succeeded = None         self._webhooks_unsubscribes = None         self._webhooks_unsubscribes_deletes = None         self._webhooks_unsubscribes_bounces = None         self._webhooks_unsubscribes_bounces_deletes = None         self._webhooks_unsubscribes_failed = None         self._webhooks_unsubscribes_succeeded = None         self._webhooks_deleted_by
Code: def _maybe_expand_trailing_dim(observed_time_series_tensor):       with tf.compat.v1.name_scope(      'maybe_expand
Get the next batch of data from the queue.          :returns: A tuple of (batch_data, batch_labels)         :rtype: tuple Code: def _get_next_
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, response, solution):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service to fetch the resource from          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  by=values.unset, from_=values.unset, to=values.unset,                  order=values.unset, limit=None, page_size=None):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to read the resources from         :param channel_sid: The SID of the Channel the resource to fetch belongs to         :param sid: The SID of the Invite resource to fetch         :param date_created: The ISO 8601 date and time in GMT when the resource was created         :param date_updated: The ISO 8601 date and time in GMT when the resource was last updated         :param by: The identity of the User that created the Invite         :param from_: The identity of the User that created the Invite         :param to: The identity of the User that the Invite is for         :param order: The order to sort by         :param limit: Upper limit for the number of records to return. list() guarantees                           never to return more than limit.  Default is no limit         :param page_size: Number of records to fetch per request, when not set will use                           the default value of 50 records.  If no page_size is defined                           but a limit is defined, list() will attempt to read the limit                           with the most efficient page size, i.e. min(limit, 1000)          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)          # Query Params         self._query = {}         if sid is not None:             self._query['Sid'] = sid         if date_created is not None:             self._query['DateCreated
Compute the
Returns the default
Code: def _resolve_distribution_names(dist_fn_args, dist_names, leaf_name):      if dist_names is None:     dist_names = []   else:     dist
Code: def _get_required_args(fn):
Compute the KL divergence between two
Code: def _build(self, model):          if not isinstance(model, collections.Sequence):       raise TypeError('`model` must be `list`-like (saw: {}).'.format(           type(model).__name__))     self._dist_fn = model     self._dist_fn_wrapped, self._dist_fn

Code: def __init__(self, dist_fn, validate_args=False, name=None):         """Construct a new Independent distribution.          Args:           dist_fn: Python callable that returns a distribution instance.           validate_args: Python `bool`, default `False`. When `True` distribution             parameters are checked for validity despite possibly degrading runtime             performance. When `False` invalid inputs may silently render incorrect             outputs.           name: Python `str` name prefixed to Ops created by this class.         """         self._dist_fn = dist_fn         self._dist_fn_args = []         self._dist_fn_wrapped = []         self._validate_args = validate_args         self._name = name         self._dtype = None         self._parameters = {}         self._event_shape = ()         self._batch_shape = ()         self._sample_shape = ()         self._is_continuous = True         self._is_reparameterized = False         self._is_scalar_batch = True         self._is_scalar_event = True         self._batch_shape_tensor = None         self._event_shape_tensor = None         self._parameters_tensor = None         self._sample_shape_tensor = None         self._dtype_tensor = None         self._allow_nan_stats = True         self._reparameterization_type = reparameterization.FULLY_REPARAMETERIZED         self._use_static_shape = False         self._graph_parents = []         self._graph_parents_tensor = None         self._graph_parents_static_shape = None         self._graph_parents_dtype = None         self._graph_parents_validate_args = None         self._graph_parents_reparameterization_type = None         self._graph_parents_use_static_shape = None         self._graph_parents_allow_nan_stats = None         self._graph_parents_name = None         self._graph_parents_validate_args_tensor = None         self._graph_parents_reparameterization_type_tensor = None         self._graph_parents_use_static_shape_tensor = None         self._graph_parents_allow_nan_stats_tensor = None         self._graph_parents_name_tensor = None         self._graph_parents_validate_args_static_shape = None         self._
Code: def __init__(self, name, dtype, shape, initializer=None, regularizer=None, trainable=True, constraint=None, **kwargs):         super(Variable, self).__init__(             name
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the new resource belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._members = None         self._messages = None         self._invites = None         self._webhooks = None      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._messages = MessageList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._messages      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = Inv
Code: def _get_page(self, method, path, params=None, payload=None,                  response_key=None, **kwargs):         """         Perform a request to the Twilio API and return the response.          :param str method: HTTP method to use         :param str path: Path to request         :param dict params: Query parameters to include in the request         :param dict payload: Request body parameters to include in the request         :param str response_key: Key to use for the response body         :param kwargs: Additional keyword arguments to pass to the request          :returns: The response from the API         :rtype: requests.Response         """         if params is None:             params = {}         if payload is None:             payload = {}         if 'X-Twilio-Webhook-Enabled' not in params:             params['X-Twilio-Webhook-Enabled'] = '1'         if 'X-Twilio-Version' not in params:             params['X-Twilio-Version'] = self.version         if 'X-Twilio-Account-Sid' not in params:             params['X-Twilio-Account-Sid'] = self.account_sid         if 'X-Twilio-Auth-Token' not in params:             params['X-Twilio-Auth-Token'] = self.auth_token         if 'X-Twilio-Client' not in params:             params['X-Twilio-Client'] = self.client         if 'X-Twilio-Client-Version' not in params:             params['X-Twilio-Client-Version'] = self.client_version         if 'X-Twilio-Client-OS' not in params:             params['X-Twilio-Client-OS'] = self.client_os         if 'X-Twilio-Client-Language' not in params:             params['X-Twilio-Client-Language'] = self.client_language         if 'X-Twilio-Client-Platform' not in params:             params['X-Twilio-Client-Platform'] = self.client_platform         if 'X-Twilio-Client-Name' not in params:             params['X-Twilio-Client-Name'] = self.client_name         if 'X-Twilio-Client-Url' not in params:             params['X-Twilio-Client
Get the channel sid for the given channel unique name          :param str channel_unique_name: The channel unique name          :returns: The channel sid         :rtype: str Code: def _get_channel_sid_by_attributes(self, channel_attributes):         """
Get the channel sid from the channel url          :param str channel_url: The channel url          :returns: The channel sid         :rtype: str Code: def _get_channel_sid_from_channel_unique_name(self, channel_unique_name):         """         Get the channel
Get the channel sid from the channel url          :param str channel_url: The channel url          :returns: The channel sid         :rtype: str Code: def _get_channel_sid_from_channel_unique_name(self, channel_unique_name):         """         Get the channel sid from the channel unique
Code: def __init__(self, name, loc, scale_diag, validate_args=False, allow_nan_stats=True, name=None):         """Construct MultivariateNormalDiag with batch shape [B1,..., Bb, k].          The parameters `loc` and `scale_diag` must have compatible shapes.         E.g., `loc` is `[B1,..., Bb, k]` and `scale_diag` is `[B1,..., Bb, k]`.          Args:           loc: Floating-point `Tensor`. If this is set to `None`, `loc` is             implicitly `0`. When specified, may have shape `[B1,..., Bb, k]` where             `b >= 0` and `k` is the event size.           scale_diag: Positive floating-point `Tensor`. When specified, may have             shape `[B1,..., Bb, k]` where `b >= 0` and `k` is the event size.             Overrides `scale`.           validate_args: Python `Boolean`, default `False`. When `True` distribution             parameters are checked for validity despite possibly degrading runtime             performance. When `False` invalid inputs may silently render incorrect             outputs.           allow_nan_stats: Python `Boolean`, default `True`. When `True`, statistics             (e.g., mean, mode, variance) use the value "`NaN`" to indicate the             result is undefined. When `False`, an exception is raised if one or             more of the statistic's batch members are undefined.           name: Python `str` name prefixed to Ops created by this class.          Raises:           ValueError: if `loc` and `scale_diag` have incompatible shapes, or if             not `scale_diag` is specified.         """         parameters = dict(locals())         with tf.compat.v1.name_scope(name, values=[loc, scale_diag]) as name:             dtype = dtype_util.common_dtype([loc, scale_diag], tf.float32)             self._loc = tensor_util.convert_nonref_to_tensor(                 loc, name='loc', dtype=dtype)             self._scale_diag = tensor_util.convert_nonref_to_tensor(                 scale_diag, name='scale_diag', dtype=dtype)             super(MultivariateNormalDiag,
Code: def __call__(self, inputs, states):         prev_output, states = states         h_tm1, c_tm1 = states         dp_mask = self.get_dropout_mask_for_cell(inputs, training=self.training)         rec_dp_mask = self.get_recurrent_dropout_mask_for_cell(             h_tm1, training=self.training)         if 0 < self.dropout < 1:             inputs = inputs * dp_mask[0]         if 0 < self.recurrent_dropout < 1:             prev_output = prev_output * rec_dp_mask[0]         x_i = self.input_conv(inputs)         x_f = self.forget_conv(inputs)         x_c = self.cell_conv(inputs)         x_o = self.output_conv(inputs)         i = self
Initialize the parameters for an LSTM cell.      Args:       lstm_cell: An instance of `tf.nn.rnn_cell.LSTMCell`.       output_layer: An instance of `tf.layers.Dense`.       dimensions: The number of output dimensions.       state_is_tuple: If `True`, accepted and returned states are n-tuples, where         `n = len(cell.state_size)`.  If `False`, the states are all         concatenated into a single vector.       name: The name of the cell. Code: def __call__(self, inputs, state, scope=None):     """Long short-term memory cell (LSTM).      This implementation is based on:     https://arxiv.org/abs/1409.2329      We initialize forget gate bias to 1 in order to reduce the scale of forgetting     at the beginning of the training.      Args:       inputs: `2-D` tensor with shape `[batch_size x input_size]`.       state: An `LSTMStateTuple` of state tensors, each shaped         `[batch_size x cell.state_size]`.       scope: VariableScope for the created subgraph; defaults to         "LSTMCell".      Returns:       A pair containing:        - A `2-D, [batch_size x output_
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the new resource belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._members = None         self._messages = None         self._invites = None         self._webhooks = None      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._messages = MessageList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._messages      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = Inv
Initialize the InviteContext          :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext Code: def __call__(self, service_sid, channel_sid):         """         Initialize the InviteContext          :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext         :rtype: twilio.rest.chat.v2.service.channel.invite.Invite
Sample from the static posterior.          :param features: (..., batch, timesteps, hidden)         :param samples: number of samples to draw         :return: (..., batch, timesteps, hidden) Code: def sample_dynamic_posterior(self, features, samples, static_sample):     """Sample from the dynamic posterior.      :param features: (..., batch, timesteps, hidden)     :param samples: number of samples to draw     :param static_sample: (..., batch, timesteps, hidden)     :return: (..., batch, timesteps, hidden)     """     # (..., batch, timesteps, hidden)     dynamic_posterior_mean, dynamic
Code: def sample_static_prior(self,
Code: def sample_dynamic_prior(self, samples, batch_size, length, fixed=False):          if fixed:       sample_batch_size = 1     else:       sample_batch_size = batch_size      sample, state = self.dynamic_prior.zero_state([samples, sample_batch_size])     locs = []     scale_diags = []     sample_list = []     for _ in range(length):       dist, state = self.dynamic_prior(sample, state)       sample = dist.sample()       locs.append(dist.parameters["loc"])       scale_diags.append(dist.parameters["scale_diag"])       sample_list.append(sample)      sample = tf.stack(sample_list, axis=2)     loc = tf.stack(locs, axis=2)     scale_diag = tf.stack(scale_diags, axis=2)      if fixed:  # tile along the batch axis       sample = sample + tf.zeros([batch_size, 1, 1])      return sample, tfd.MultivariateNormalDiag(loc=loc
Returns log_prob(value) in terms of log_prob(x) and log_det_jacobian(x).          Args:           value: float or double Tensor.         Returns:           log_prob: float Tensor with shape broadcastable to             `batch_shape + event_shape`. Code: def _log_prob(self, value):     """     Returns log_prob(value) in terms of log_prob(x) and log_det_jacobian(x).      Args:       value: float or double Tensor.     Returns:       log_prob: float Tensor with shape
Code: def __init__(self, *args, **kwargs):         """         Initialize the Model.          :param dict kwargs: The keyword arguments to initialize the Model.         """         super(Model, self).__init__(*args, **kwargs)         self._program = None         self._inputs = None         self._outputs = None         self._input_shapes = None         self._output_shapes = None         self._input_dtypes = None         self._output_dtypes = None         self._input_names = None         self._output_names = None         self._input_tensors = None         self._output_tensors = None         self._input_placeholders = None         self._output_placeholders = None         self._input_feed_dict = None         self._output_feed_dict = None         self._input_feed_dict_list = None         self._output_feed_dict_list = None         self._input_feed_dict_dict = None         self._output_feed_dict_dict = None         self._input_feed_dict_list_dict = None         self._output_feed_dict_list_dict = None         self._input_feed_dict_list_list = None         self._output_feed_dict_list_list = None         self._input_feed_dict_list_list_dict = None         self._output_feed_dict_list_list_dict = None         self._input_feed_dict_list_list_list = None         self._output_feed_dict_list_list_list = None         self._input_feed_dict_list_list_list_dict = None         self._output_feed_dict_list_list_list_dict = None         self._input_feed_dict_list_list_list_list = None         self._output_feed_dict_list_list_list_list = None         self._input_feed_dict_list_list_list_list_dict = None         self._output_feed_dict_list_list_list_list_dict = None         self._input_feed_dict_list_list_list_list_list = None         self._output_feed_dict_list_list_list_list_list = None         self._input_feed_dict_list_list_list_list_list_dict = None
Convert a list of parameter values to a map.          :param list param_vals: A list of parameter values.         :returns: A map of parameter names to values.         :rtype: dict Code: def _initial_state_prior(self, param_vals):         """         Compute the prior distribution over initial states.
Code: def __init__(self,                  name,                  parameters,                  initial_state_prior,                  transition_matrix_prior,                  observation_matrix_prior,                  observation_noise_prior,                  transition_noise_prior,                  observation_noise_covariance_prior,                  transition_noise_covariance_prior,                  observation_noise_covariance_cholesky_prior,                  transition_noise_covariance_cholesky_prior,                  observation_noise_covariance_cholesky_inverse_prior,                  transition_noise_covariance_cholesky_inverse_prior,                  observation_noise_covariance_cholesky_inverse_logdet_prior,                  transition_noise_covariance_cholesky_inverse_logdet_prior,                  observation_noise_covariance_cholesky_inverse_logdet_lower_bound_prior,                  transition_noise_covariance_cholesky_inverse_logdet_lower_bound_prior,                  observation_noise_covariance_cholesky_inverse_logdet_upper_bound_prior,                  transition_noise_covariance_cholesky_inverse_logdet_upper_bound_prior,                  observation_noise_covariance_cholesky_inverse_logdet_upper_bound_lower_bound_prior,                  transition_noise_covariance_cholesky_inverse_logdet_upper_bound_lower_bound_prior,                  observation_noise_covariance_cholesky_inverse_logdet_upper_bound_upper_bound_prior,                  transition_noise_covariance_cholesky_inverse_logdet_upper_bound_upper_bound_prior,                  observation_noise_covariance_cholesky_inverse_logdet_upper_bound_upper_bound_lower_bound_prior,                  transition_noise_covariance_cholesky_inverse_logdet_upper_bound_upper_bound_lower_bound_prior,                  observation_noise_covariance_cholesky_inverse_logdet_upper_bound_upper_bound_upper_bound_prior,                  transition_noise_covariance_cholesky_inverse_logdet_upper_bound_upper_bound_upper_bound_prior,                  observation_noise_covariance_cholesky_inverse_logdet_upper_bound
Code: def _compute_min_event_ndims(bijector_list, compute_forward=True):      min_event_ndims = 0   # This is a mouthful, but what this encapsulates is that if not for rank   # changing bijectors, we'd only need to compute the largest of the min   # required ndims. Hence "max_min". Due to rank changing bijectors, we need to   # account for synthetic rank growth / synthetic rank decrease from a rank   # changing bijector.   rank_changed_adjusted_max_min_event_ndims = 0    if compute_forward:     bijector_list = reversed(bijector_list)    for b in bijector_list:     if compute_forward:       current_min_event_ndims = b.forward_min_event_ndims       current_inverse_min_event_ndims = b.inverse_min_event_ndims     else:       current_min_event_ndims = b.inverse_min_event_ndims       current_inverse_min_event_ndims = b.forward_min_event_ndims      # New dimensions were touched.     if rank_changed_adjusted_max_min_event_ndims < current_min_event_ndims:       min_event_ndims += (           current_min_event_ndims - rank_changed_adjusted_max_min_event_ndims)     rank_changed_adjusted_max_min_event_ndims = max(         current_min_event_ndims, rank_changed_adjusted_max_min_event_ndims)      # If the number of dimensions has increased via forward, then     # inverse_min_event_ndims > forward_min_event_ndims, and hence the     # dimensions we computed on, have moved left (so we have operated     # on additional dimensions).     # Conversely, if the number of dimensions has decreased via forward,     # then we have inverse_min_event_ndims < forward_min_event_ndims,     # and so we will have operated on fewer right most dimensions.      number_of_changed_dimensions = (         current_min_event_ndims - current_inverse_min_event_nd
Get the channel unique name from the channel_sid or channel_unique_name          :param str channel_sid: The channel_sid         :param str channel_unique_name: The channel_unique_name          :returns: The channel unique name         :rtype: str Code: def _get_channel_type(self, channel_type):         """         Get the channel type from the channel_type or channel_unique_name          :param str channel_type: The channel_type         :param str channel_unique_name: The channel_unique_name          :returns: The channel type         :rtype: str         """         if channel_type:             return channel_type         if self.channel_unique_name:             return self.client.channels(self.channel_unique_name).type         raise ValueError('Either
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, response, solution):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The service_sid          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__
Get an item from the list          :param unicode key: The index of the resource to fetch          :returns: twilio.
Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel
Get an item from the list of resources          :param unicode key: The index of the resource to fetch          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def __call__(self, sid):         """
Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel
Code: def log_ndtr(x, series_order=3, name="log_ndtr"):      if not isinstance(series_order, int):     raise TypeError("series_order must be a Python integer.")   if series_order < 0:     raise ValueError("series_order must be non-negative.")   if series_order > 30:     raise ValueError("series_order must be <= 30.")    with tf.name_scope(name):     x = tf.convert_to_tensor(value=x, name="x")      if dtype_util.base_equal(x.dtype, tf.float64):       lower_segment = LOGNDTR_FLOAT64_LOWER       upper_segment = LOGNDTR_FLOAT64_UPPER     elif dtype_util.base_equal(x.dtype, tf.float32):       lower_segment = LOGNDTR_FLOAT32_LOWER       upper_segment = LOGNDTR_FLOAT32_UPPER     else:       raise TypeError("x.dtype=%s is not supported." % x.dtype)      # The basic idea here was ported from:     #   https://root.cern.ch/doc/v608/SpecFuncCephesInv_8cxx_source.html     # We copy the main idea, with a few changes     # * For x >> 1, and X ~ Normal(0, 1),     #     Log[P[X < x]] = Log[1 - P[X < -x]] approx -P[X < -x],     #     which extends the range of validity of this function.     # * We use one fixed series_order for all of 'x', rather than adaptive.     # * Our docstring properly reflects that this is an asymptotic series, not a     #   Taylor series. We also provided a correct bound on the remainder.     # * We need to use the max/min in the _log_ndtr_lower arg to avoid nan when     #   x=0. This happens even though the branch is unchosen because when x=0     #   the gradient of a select involves the calculation 1*dy+0*(-inf)=nan     #   regardless of whether dy is finite. Note that the minimum is a NOP if     #   the branch is chosen.     return
Code: def _log_ndtr_asymptotic_series(x, series_order):      npdt = dtype_util.as_numpy_dtype(x.dtype)   if series_order <= 0:     return npdt(1)   x_2 = tf.square(x)   even_sum = tf.zeros_like(x)   odd_sum = tf.zeros
Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The
Code: def log_cdf_laplace(x, name="log_cdf_laplace"):       with tf.name_scope(name):     x = tf.convert_to_tensor(value=x, name="x")      # For x < 0, L(x) = 0.5 * exp{x} exactly, so Log[L(x)] = log(0.5) + x.     lower_solution = -np.log(2.) + x      # safe_exp_neg_x = exp{-x} for x > 0, but is     # bounded above by 1, which avoids     #   log[1 - 1] = -inf for x = log(1/2), AND     #   exp{-x} --> inf, for x << -1     safe_exp_neg_x = tf.exp(-tf.abs(x))      # log1p(z) = log(1 + z) approx z for |z| << 1.
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, response, solution):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.
Get the channel sid from the channel attributes          :param dict attributes: The channel attributes          :returns: The channel sid         :rtype: str Code: def _get
Code: def _is_univariate_marginal(self, index_points):          num_index_points = tf.compat.dimension_value(         index_points.shape[-(self.kernel.feature_ndims + 1)])     if num_index_points is None:       warnings.warn(           'Unable to detect statically whether
Code: def get_marginal_distribution(self, index_points=None):          with self._name_scope('get_marginal_distribution'):       # TODO(cgs): consider caching the result here, keyed on `index_points`.       index_points = self._get_index_points(index_points)       covariance = self._compute_covariance(index_points)       loc = self._mean_fn(index_points)       # If we're sure the number of index points is 1, we can just construct a       # scalar Normal. This has computational benefits and supports things like       # CDF that aren't otherwise straightforward
:param index_points: The index points to use for the KL divergence. If             `None`, then the index points used to instantiate the             `GaussianProcess` instance will be used.         :type index_points: `None` or `np.ndarray`         :returns: The index points to use for the KL divergence. If             `None`, then the index points used to instantiate the             `GaussianProcess` instance will be used.         :rtype: `None` or `np.ndarray` Code: def _get_index_points(self, index_points=None):          if self._index_points is None and index_points is None:       raise ValueError(           'This GaussianProcess instance was not instantiated with a value for '           'index_points. One must therefore be provided when calling sample, '           'log_prob, and other such methods. In particular, one can\'t compute '           'KL
Code: def make_iaf_stack(total_event_size,                    num_hidden_layers=2,                    seed=None,                    dtype=tf.float32):       seed = tfd.SeedStream(seed,'make_iaf_stack')    def make_iaf():          initializer = tf.compat.v2.keras.initializers.VarianceScaling(         2 * 0.01, seed=seed() % (2**31 - 1))      made = tfb
Flatten the state.          :param state: A `tf.Tensor` of flattened state.         :returns: A `tf.Tensor` of flattened state. Code: def _num_leapfrog_steps(self, step_size):         """         Compute the number of leapfrog steps to take.          :param step_size: A `tf.Tensor
Compute the variational distribution.          :returns: Variational distribution.         :rtype: tf.Distribution Code: def _flattened_target_log_prob(self, samples):         """         Compute the log probability of the samples under the target distribution.          :param samples: Samples to compute the log probability of.          :returns: Log probability of the samples under the target distribution.         :rtype: tf.Tensor         """         return self._target_log_prob_fn(samples)
Code: def _outer_squared_difference(x, y):      z = x - y   return z[..., tf.new
Code: def _value_and_batch_jacobian(f, x):      if tf.executing_eagerly():     with tf.GradientTape() as tape:       tape.watch(x)       value = f(x)     batch_jacobian = tape.batch_jacobian(value, x)   else
Code: def _prevent_2
Pad the sample dimensions of `x` to match the shape of the     distribution. Code: def _pad_sample_dims_for_log_prob(self, x):     """Pad the sample dimensions of `x` to match the shape of the     distribution.      Args:       x: `Tensor` with shape `[S, B,..., E]` where `S` is the number of         samples, `B` is the number of batch dimensions, and `E` is the event         size.      Returns:       `Tensor` with shape `[S, B, k, E]` where `k` is the number of components.     """     x_shape = tensorshape_util.as_list(x.shape)     x_rank = tensorshape_util.rank(x.shape)     x_event_ndims = x_rank -
Code: def _split_covariance_into_marginals(covariance, block_sizes
Splits a covariance matrix into a list of marginal covariance matrices.          :param covariance: A `Tensor` of shape `[..., num_timesteps, num_timesteps]`                            representing the covariance matrix of the latent state                            space model.         :type covariance: `tf.Tensor`         :param latent_sizes: A list of integers representing the size of the latent                              state space model for each component.         :type latent_sizes: `list` of `int`         :returns: A list of `Tensor`s of shape `[..., num_timesteps, latent_size]`                   representing the marginal covariance matrices of the latent                   state space model.
Code: def _decompose_from_posterior_marginals(model, posterior_means,                                             posterior_covs, parameter_samples):     """Decompose the posterior marginals into the components.      Args:       model: A `tfd.JointDistributionCoroutine` instance.       posterior_means: A `tf.Tensor` of shape `[num_timesteps, num_components]`.       posterior_covs: A `tf.Tensor` of shape `[num_timesteps, num_components]`.       parameter_samples: A `tf.Tensor` of shape `[num_samples, num_parameters]`.      Returns:       A `dict` of `tf.Tensor`s, where the keys are the names of the components       and the values are the corresponding `tf.Tensor`s.     """     # TODO(b/150911515): This is a temporary workaround to avoid the     # `tf.TensorShape` error when using `tf.function`.     # TODO(b/150911515): Remove this workaround once the error is fixed.     posterior_means = tf.convert_to_tensor(value=posterior_means)     posterior_covs = tf.convert_to_tensor(value=posterior_covs)     parameter_samples = tf.convert_to_tensor(value=parameter_samples)      # TODO(b/150911515): This is a temporary workaround to avoid the     # `tf.TensorShape` error when using `tf.function`.     # TODO(b/150911515): Remove this workaround once the error is fixed.     posterior_means = tf.convert_to_tensor(value=posterior_means)     posterior_covs = tf.convert_to_tensor(value=posterior_covs)     parameter_samples = tf.convert_to_tensor(value=parameter_samples)      # TODO(b/150911515): This is a temporary workaround to avoid the     # `tf.TensorShape` error when using `tf.function`.     # TODO(b/150911515): Remove this workaround once the error is fixed.     posterior_means = tf.convert_to_tensor(value=posterior_means
Code: def _decompose_from_posterior_marginals(model, forecast_latent_mean, forecast_latent_covs, parameter_samples):     """Decompose the forecast distribution into its components.      Args:       model: An instance of `tfd.JointDistributionCoroutine`.       forecast_latent_mean: A `Tensor` of shape `[num_posterior_draws,         num_timesteps, num_components, num_features]`.       forecast_latent_covs: A `Tensor` of shape `[num_posterior_draws,         num_timesteps, num_components, num_features, num_features]`.       parameter_samples: A `Tensor` of shape `[num_posterior_draws,         num_timesteps, num_components, num_parameters]`.      Returns:       A `tfd.JointDistributionCoroutine` instance.     """     # TODO(b/149115555): This is a temporary workaround to avoid a bug in     # `tfd.JointDistributionCoroutine` where the `sample` method does not     # support `sample_shape` argument.     # TODO(b/149115555): Remove this workaround once the bug is fixed.     if not isinstance(model, tfd.JointDistributionCoroutine):       raise ValueError('`model` must be an instance of `tfd.JointDistributionCoroutine`.')      # TODO(b/149115555): This is a temporary workaround to avoid a bug in     # `tfd.JointDistributionCoroutine` where the `sample` method does not     # support `sample_shape` argument.     # TODO(b/149115555): Remove this workaround once the bug is fixed.     if not isinstance(forecast_latent_mean, tf.Tensor):       raise ValueError('`forecast_latent_mean` must be a `Tensor`.')      # TODO(b/149115555): This is a temporary workaround to avoid a bug in     # `tfd.JointDistributionCoroutine` where the `sample` method does not     # support `sample_shape` argument.     # TODO(b/149115555): Remove this workaround once the bug is fixed.     if not isinstance(forecast_latent_covs,
Copied (with modifications) from:         tensorflow/contrib/layers/python/ops/sparse_ops.py.          with tf.compat.v1.name_scope(name, 'dense_to_sparse', [x, ignore_value]):           x = tf.convert_to_tensor(value=x, name='x')           if ignore_value is None:             if x.dtype.base_dtype == tf.string:               # Exception due to TF strings are converted to numpy objects by default.               ignore_value = ''             else:               ignore_value = x.dtype.as_numpy_dtype(0)             ignore_value = tf.cast(ignore_value, x.dtype, name='ignore_value')           indices = tf.where(tf.not_equal(x, ignore_value), name='indices')           return tf.SparseTensor(               indices=indices,               values=tf.gather_nd(x, indices, name='values'),               dense_shape=tf.shape(input=x, out_type=tf.int64, name='dense_shape')) Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param dict payload: A JSON response from the Twilio API          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init__(version, response=payload, service_sid=service_sid, channel_sid=channel_sid)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }      @property     def page_size(self):         """         :returns: How many resources there are per page         :rtype: int         """         return self._version.page_size      @property     def next_page_url(self):         """         :returns: The url of the next page         :rtype: unicode         """         return self._properties.get('next_page_url')      @property     def invites(self):         """         :returns: A list of instances of InviteInstance         :
Iterate over pages of Invites          :returns: Page of InviteInstance         :rtype: twilio.rest.chat.v2.service.channel
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __repr__(self):
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the new resource belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._invites = None         self._members = None         self._messages = None         self._webhooks = None      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = InviteList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._invites      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._messages
Code: def sample_shape_tensor(self, name="sample_shape_tensor"):          with tf.compat.v1.name_scope(name):       if isinstance(self._sample_shape, tf.Tensor):         return self
Code: def __init__(self, distribution, sample_shape=(), seed=None, name=None):         """Constructs a `Sample` op.          Args:           distribution: The `Distribution` instance to sample from.           sample_shape: 0D or 1D `int32` `Tensor`. Shape of the generated samples.           seed:
Returns true if both instances are not equal, false otherwise          :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def __init__(self, version, payload, service_sid, channel_sid, sid=None):         """         Initialize the InviteInstance          :returns
Returns true if both instances are not equal, true otherwise          :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def __init__(self, version, payload, service_sid, channel_sid, sid=None):         """         Initialize the InviteInstance          :returns: tw
Code: def __init__(self, *args, **kwargs):         """         Initialize the InviteList          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(*args, **kwargs)          # Path Solution         self._solution = {'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def stream(self, limit=None, page_size=None):         """         Streams InviteInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until the limit         is reached.         The results are returned as a generator, so this operation is memory efficient.          :param int limit: Upper limit for the number of records to return. stream()                           guarantees to never return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, stream() will attempt to read the                               limit with the most efficient page size, i.e. min(limit, 1000)          :returns: Generator that will yield up to limit results         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]         """         limits = self._version.read_limits(limit, page_size)          page = self.page(page_size=limits['page_size'], )          return self._version.stream(page, limits['limit'], limits['page_limit'])      def list(self, limit=None, page_size=None):         """         Lists InviteInstance records from the API as a list.         Unlike stream(), this operation is eager and will load `limit` records into         memory before returning.          :param int limit: Upper limit for the number of records to return. list() guarantees                           never to return more than limit.  Default is no limit         :param int page_size: Number of records
Code: def _fn(self, x, output_units, **condition_kwargs):     """     Args:       x: A Tensor of shape [batch_size, input_units].       output_units: An integer, the number of units in the output.       **condition_kwargs: Additional keyword arguments to pass to the template.      Returns:       A tuple of two Tensors, the first being the shift parameter and the second       being the log scale parameter.     """     if condition_kwargs:       raise NotImplementedError(           "Conditioning not implemented in the default template.")      if tensorshape_util.rank(x.shape) == 1:       x = x[tf.newaxis,...]       reshape_output = lambda
Code: def _uniform_unit_norm(dimension, shape, dtype, seed):      # This works because the Gaussian distribution is spherically symmetric.   # raw shape: shape + [dimension]   raw = normal.Normal(       loc=dtype_util.as_numpy_dtype(dtype)(0),       scale=dtype_util.as_numpy_dtype
Code: def _log_unnorm_prob(self, x, name=None):          with tf.name_scope(name or 'log_unnorm_prob_lkj'):       x = tf.convert_to_tensor(value=x, name='x')       # The density is det(matrix) ** (concentration
Code: def _log_normalization(self, name='log_normalization'):          # The formula is from D. Lewandowski et al [1], p. 1999, from the     # proof that eqs 16 and 17 are equivalent.     with tf.name_scope(name or 'log_normalization_lkj'):       logpi = np.log(np.pi)       ans = tf.zeros_like(self.concentration)       for k in range(
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the new resource belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._invites = None         self._members = None         self._messages = None         self._webhooks = None      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = InviteList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._invites      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._messages
Code: def _make_summary_statistic(attr):      def _fn(self, **kwargs):          x = getattr(self.distribution, attr)(**kwargs)     shape = prefer_static.concat([         self.distribution.batch_shape_tensor(),         prefer_static.ones(prefer_static.rank_from_shape(self.sample_shape),                            dtype=self.sample_shape.dtype),         self.distribution.event_shape_tensor(),     ], axis=0)     x = tf.reshape(x, shape=shape)     shape = prefer_static.concat([         self.distribution.batch_shape_tensor
Code: def _broadcast_to(tensor_to_broadcast, target_tensors):      output = tensor_to_
Code: def _
Code: def _effective_sample_size_single_state(state, filter_beyond_lag, filter_threshold):   """Computes the effective sample size of a single state.    Args:     state: A `Tensor` of shape `[num_steps, batch_size, state_size]`.     filter_beyond_lag: A `Tensor` of shape `[num_steps, batch_size]`.     filter_threshold: A `Tensor` of shape `[batch_size]`.    Returns:     A `Tensor` of shape `[batch_size]`.   """   # Compute the effective sample size.   ess = tf.reduce_sum(tf.cast(tf.greater(filter_beyond_lag, 0.), tf.float32), axis=0)   # Compute the effective sample size of the state.   ess_state = tf.reduce_sum(tf.cast(tf.greater(filter_threshold, 0.), tf.float32), axis=0)   # Compute the effective sample size of the state.   ess_state = tf.reduce_sum(tf.cast(tf.greater(filter_threshold, 0.), tf.float32), axis=0)   # Compute the effective sample size of the state.   ess_state = tf.reduce_sum(tf.cast(tf.greater(filter_threshold, 0.), tf.float32), axis=0)   # Compute the effective sample size of the state.   ess_state = tf.reduce_sum(tf.cast(tf.greater(filter_threshold, 0.), tf.float32), axis=0)   # Compute the effective sample size of the state.   ess_state = tf.reduce_sum(tf.cast(tf.greater(filter_threshold, 0.), tf.float32), axis=0)   # Compute the effective sample size of the state.   ess_state = tf.reduce_sum(tf.cast(tf.greater(filter_threshold, 0.), tf.float32), axis=0)   # Compute the effective sample size of the state.   ess_state = tf.reduce_sum(tf.cast(tf.greater(filter_threshold, 0.), tf.float32), axis=0)   # Compute the effective sample size of the state.
Compute the effective sample size of a single state.          :param states: A tensor of shape [N,...] where N is the number of             samples.         :param filter_beyond_lag: The maximum lag to use for filtering. If None,             then the full sequence is used.         :param filter_threshold: The threshold to use for filtering. If None,             then no filtering is done.          :returns: A tensor of shape [...] containing the effective sample size             of the state.         :rtype: tf.Tensor Code: def _effective_sample_size_single_state(states, filter_beyond_lag,                                         filter_threshold):       with tf.compat.v1.name_scope(       'effective_sample_
Code: def _potential_scale_reduction_single_state(state, independent_chain_ndims):      with tf.compat.v1.name_scope(       'potential_scale_reduction_single_state',       values=[state, independent
Code: def _axis_size(x, axis=None):      if axis is None:     return tf.cast(tf.size(input=x), x.dtype
Returns True if the object is not None, False otherwise.          :param obj: The object to check.          :returns: True if the object is not None, False otherwise.         :rtype: bool Code: def _is_not_empty(obj):     """     Returns True if the object is not empty, False otherwise.      :param obj: The object to check.      :returns: True if the object is not
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._invites = None         self._members = None         self._messages = None         self._webhooks = None      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = InviteList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._invites      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._members = None         self._invites = None         self._messages = None         self._webhooks = None      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = InviteList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._invites      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._
Initialize the Mapping.          :param x: Mapping to merge into this mapping.         :type x: Mapping         :param y: Mapping to merge into this mapping.         :type y: Mapping         :param ildj: Mapping to merge into this mapping.         :type ildj: Mapping         :param kwargs: Mapping to merge into this mapping.         :type kwargs: Mapping         :param mapping: Mapping to merge into this mapping.         :type mapping: Mapping Code: def __getitem__(self, key):
Returns true if both instances are not equal, false otherwise.          :param other: twilio.rest.ip_messaging.v2.service.channel.invite.InviteInstance          :returns: twilio.rest.ip_messaging.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.ip_messaging.v2.service.channel.invite.InviteInstance Code: def __init__(self, version, payload, service_sid, channel_sid, sid=None):         """         Initialize the InviteInstance          :returns: twilio.rest.ip_messaging.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.ip_messaging.v2.service.channel.invite.InviteInstance         """         self._version = version         self._solution = {'service_sid': service
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, service_sid, channel_sid, solution=None):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path
Code: def _left_doubling_increments(batch_shape, max_doublings, step_size, seed=None,                               name=None):      with tf.compat.v1.name_scope(name, 'left_doubling_increments',                                [batch_shape, max_doublings, step_size]):      step_size = tf.convert_to_tensor(value=step_size)     dtype = step_size.
Code: def _find_best_interval_idx(x, name=None):      with tf.compat.v1.name_scope(name, 'find_best_interval_idx', [x]):     # Returns max_doublings + 1
Compute the increments by which we need to step the upper and lower bounds   part of the doubling procedure.    Args:     batch_shape: Shape of the batch of points.     max_doublings: Maximum number of doublings.     step_size: Step size to use.     seed: Python integer to seed the random number generator.    Returns:     left_increments: Shape (max_doublings+1,) + batch_shape.     widths: Shape (max_doublings+1,) + batch_shape. Code: def _find_best_interval_idx(both_ok_f):   """Find the index of the best interval.    Args:     both_ok_f: Boolean tensor of shape (max_doublings+1, batch_shape).    Returns:     best_interval_idx
Code: def _test_acceptance(x_initial, target_log_prob, decided,                          log_slice_heights, x_proposed, step_size,                          lower_bounds, upper_bounds):   """Tests whether a proposed point is accepted.    Args:     x_initial: Tensor of shape `x_proposed.shape` containing the initial       position.     target_log_prob: Python callable that takes a Tensor of shape       `x_proposed.shape` and returns a Tensor of the same shape containing the       log-probability of the point.     decided: Boolean Tensor of shape `x_proposed.shape` indicating whether the       point has already been decided.     log_slice_heights: Tensor of shape `x_proposed.shape` containing the       log-slice-heights of the point.     x_proposed: Tensor of shape `x_proposed.shape` containing the proposed       position.     step_size: Scalar Tensor containing the step size.     lower_bounds: Tensor of shape `x_proposed.shape` containing the lower       bounds of the slice.     upper_bounds: Tensor of shape `x_proposed.shape` containing the upper       bounds of the slice.    Returns:     accept_res: Boolean Tensor of shape `x_proposed.shape` indicating whether       the point is accepted.   """   with tf.compat.v1.name_scope('test_acceptance'):     # Compute the log-acceptance ratio.     log_acceptance_ratio = target_log_prob(x_proposed) - target_log_prob(         x_initial)     # Compute the log-acceptance probability.     log_acceptance_prob = log_acceptance_ratio - log_slice_heights     # Compute the log-acceptance probability for the proposed point.     log_acceptance_prob_proposed = log_acceptance_ratio - log_slice_heights(         x_proposed)     # Compute the log-acceptance probability for the initial point.     log_acceptance_prob_initial = log_acceptance_ratio - log_slice_heights(         x_initial)     # Compute the log-acceptance probability for the proposed point.     log_acceptance_prob_proposed = log_acceptance_ratio - log_slice_height
Code: def slice_sampler_three_dim(target_log_prob, x_initial, step_size=0.01,                           max_doublings=30, seed=None, name=None):      with tf.compat.v1.name_scope(name,'slice_sampler_three_dim',                                [x_initial, step_size, max_doublings]):     x_initial = tf.convert_to_tensor(value=x_initial)     # Obtain the input dtype of the array.     dtype = x_initial.dtype.base_dtype     # Select the height of the slice.
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __call__(self, payload):         """         Constructs a InviteContext          :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         return InviteContext(             self._version,             service_sid=self._solution['service_sid'],             channel_sid=self._solution
Returns the return value of a function. Code: def _get_function_inputs_and_outputs(fn, kwargs):   """Returns a dictionary of the inputs and outputs from a function.    Args:     fn: A function.     kwargs: A dictionary of keyword arguments.    Returns:     A dictionary of the inputs and outputs from the function.   """   inputs = {}   outputs = {}   for arg in inspect.signature(fn).parameters.values():     if arg.name in kwargs:       if arg.kind == inspect.Parameter.VAR_POSITIONAL:         inputs[arg.name] = kwargs[arg.name]       elif arg.kind == inspect.Parameter.VAR_KEYWORD:         inputs.update(kwargs[arg.name])       else:         inputs[arg.name] = kwargs
Code: def _get_function_inputs(f, src_kwargs):      if hasattr(f, "_func"):  # functions returned by tf.make_template     f = f._func  # pylint: disable=protected-access    try:  # getargspec was deprecated in Python 3.6     argspec = inspect.getfullargspec(f)   except AttributeError:     argspec = inspect.getargspec(f)    fkwargs = {k: v for k, v in six
2D convolutional layer with batch normalization and ReLU activation.          :param tf.Tensor x: Input tensor.         :param int filters: Number of filters.         :param tuple kernel: Convolution kernel size.         :param tuple stride: Convolution stride.         :param tf.keras.layers.Layer kernel_posterior_fn: Kernel posterior             distribution.         :return: Output tensor.         :rtype: tf.Tensor Code: def _vggconv_block(x, filters, kernel, stride, kernel_posterior_fn):      out = tfp.layers.Convolution2DFlipout(       filters,       kernel,       padding='same',       kernel_posterior_fn=kernel_posterior_fn)(x)   out = tf.keras.layers.BatchNormalization()(out)   out = tf.keras.layers.Activation('relu')(out)    out = tfp.layers.Convolution2DFlipout(       filters,       kernel,       padding='same',       kernel_posterior_
Build a tree at the current state.          :param value_and_gradients_fn: Python callable which computes the             target log-density and its gradient with respect to the state.         :param current_state: Current state.         :param current_target_log_prob: Current target log-density.         :param current_grads_target_log_prob: Current gradient of the target             log-density with respect to the state.         :param current_momentum: Current momentum.         :param direction: Direction of the NUTS trajectory.         :param depth: Depth of the current tree.         :param step_size: Step size.         :param log_slice_sample: Log-slice sample.         :param seed: Python integer to seed the random number generator.         :returns: A list of tensors corresponding to the state, target log-             density, gradient of the target log-density with respect to the             state, momentum, forward state, forward target log-density, forward             gradient of the target log-density with respect to the state,             forward momentum, reverse state, reverse target log-density, reverse             gradient of the target log-density with respect to the state, number             of states in the tree, and a boolean indicating whether to continue             the NUTS trajectory.         :rtype: list[tf.Tensor] Code: def _has_no_u_turn(forward_state, reverse_state, momentum):   """
Code: def _embed_no_none_gradient_check(value_and_gradients_fn):      @functools.wraps(value_and_gradients_fn)   def func_wrapped(*args, **kwargs):          value, grads = value_and_gradients_fn(*args, **kwargs)     if
Code: def _has_no_u_turn(state_one, state_two, momentum):      dot_product = sum([       tf.reduce_sum(input_tensor=(s1 - s2) * m)       for s1, s2, m in zip(state_one, state_two, momentum)   ])   return dot
Code: def _leapfrog(value_and_gradients_fn,               current
Code: def _log_joint(current_target_log_prob, current_momentum):      momentum_log_prob = -sum(
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset,                  links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': None,            'service_sid': service_sid,             'channel_sid': channel_sid,             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property
Returns a default loc/scale
Returns the default mean field normal distribution function. Code: def _get_default_mean_field_normal_fn(     is_singular=False,     loc_initializer=tf.compat.v1.initializers.random_normal(stddev=0.
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the new resource belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._members = None         self._messages = None         self._invites = None         self._webhooks = None      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._messages = MessageList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._messages      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = Inv
Code: def deserialize_function(serial, function_type):      if function
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, service_sid, channel_sid):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def stream(self, limit=None, page_size=None):         """         Streams InviteInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until the limit         is reached.         The results are returned as a generator, so this operation is memory efficient.          :param int limit: Upper limit for the number of records to return. stream()                           guarantees to never return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, stream() will attempt to read the                               limit with the most efficient page size, i.e. min(limit, 1
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  identity=values.unset, role_sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  url=values.unset, links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites/{sid}'.format(**self._solution)                  self._properties = {'sid': sid, 'identity': identity, 'role_sid': role_sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'url': url, 'links': links, }                  self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites/{sid}'.format(**self._solution)                  self._context = None         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid or self._properties['sid'], }          @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']          @property     def identity(self):         """         :returns: The `identity` value that uniquely identifies the new resource's User.         :rtype: unicode         """         return self._properties['identity']          @property     def role_sid(self):         """         :returns: The SID of the Role assigned to the new resource.         :rtype: unicode         """         return self._properties['role_sid']          @property     def date_created(self):         """         :returns: The ISO 8601 date and time in GMT when the resource was created.         :rtype: datetime         """         return self._properties['date_created']          @property
Returns the shallow structure of `structure`. Code: def _convert_to_tensor_or
Converts the given `value` to a `Tensor`.    Args:     value: A `Tensor`, `SparseTensor`, or `IndexedSlices`.     dtype: Optional element type for the returned tensor. If missing, the type       is inferred from the type of `value`.     name: Optional name for the returned tensor.    Returns:     A `Tensor` with the same type as `value`.    Raises:     TypeError: If `value` cannot be converted to a `Tensor`. Code: def _convert_to_tensor_or_indexed_slices(value, dtype=None, name=None):   """Converts the given `value` to a `Tensor` or `IndexedSlices`.    Args:     value: A `Tensor`, `SparseTensor`, or `IndexedSlices`.     dtype: Optional element type for the returned tensor. If missing, the type       is inferred from the type of `value`.
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  identity=values.unset, role_sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  url=values.unset, links=values.unset):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to         :param sid: The unique string that identifies the resource          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites{sid}'.format(**self._solution)          # Path Parameters         self._solution['service_sid'] = service_sid         self._solution['channel_sid'] = channel_sid         self._solution['sid'] = sid          # Filters         self._filter = None         if identity is not None:             self.filter = identity         if role_sid is not None:             self.filter = role_sid         if date_created is not None:             self.filter = date_created         if date_updated is not None:             self.filter = date_updated         if url is not None:             self.filter = url         if links is not None:             self.filter = links      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._
Code: def _get_tensor_like_attributes():      # Enable "Tensor semantics" for distributions.   # See tensorflow/python/framework/ops.py `class Tensor` for details.   attrs = dict()   # Setup overloadable operators and white-listed members /
Get the channel sid from the channel url          :param str channel_url: The channel url          :returns: The channel sid         :rtype: str Code: def _get_channel_sid_from_channel_username(self, channel_username):         """         Get the channel sid from the channel
Code: def pack_images(images, rows, cols):      shape = tf.shape(input=images)   width = shape[-3]   height = shape[-2]   depth = shape[-1]   images = tf.reshape(images, (-1, width, height, depth))   batch = tf.shape(input=images)[0]   rows = tf.minimum(rows, batch)   cols = tf.minimum(batch // rows, cols)   images = images[:rows * cols]   images = tf.reshape(images, (rows, cols, width, height, depth))   images = tf.transpose(a
Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param dict payload: A JSON response from the Twilio API          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init__(version, response=payload, solution=service_sid)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._context      @property     def invites(self):         """         :returns: A list of instances of InviteInstance         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]         """         return self._proxy.invites      @property     def page_size(self):         """         :returns: How many resources to return in each list page. The default is 50, and the maximum is 1000.         :rtype: unicode         """         return self._properties['page_size']      def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         return '<Twilio.IpMessaging.V2.InvitePage>'   class InviteContext(InstanceContext):     """ PLEASE NOTE that this class contains preview products that are subject     to change. Use them with caution. If you currently do not have developer     preview access, please contact <EMAIL>. """      def __init__(self, version, service_sid, channel_sid
Get the channel sid from the channel name          :param str channel_name: The channel name          :returns: The channel sid         :rtype: str Code: def _get_user_sid(self, user_identity):         """         Get the user sid from the user identity          :param str user_identity: The user identity
Code: def _validate_block_sizes(block_sizes, bijectors, validate_args):      block_sizes_shape = block_sizes.shape   if tensorshape_util.is_fully_defined(block_sizes_shape):     if (tensorshape_util.rank(block_sizes_shape)!= 1 or         (tensorshape_util.num_elements(block_sizes_shape)!= len(bijectors))):       raise ValueError(           '`block_sizes` must be `None`, or a vector of the same length as '           '`bijectors`. Got a `Tensor` with shape {} and `bijectors` of '           'length {}'.format(block_sizes_shape, len(bijectors)))     return block_sizes   elif validate_args:     message = ('`block_sizes` must be `None`, or a vector of the same length '                'as `bijectors`.')     with tf.control_dependencies([         assert_util.assert_equal(
Code: def __init__(self, *args, **kwargs):         """Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the new resource belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._members = None         self._invites = None         self._messages = None         self._webhooks = None      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = InviteList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._invites      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._messages =
Get the channel sid from the channel url          :param str channel_url: The channel url          :returns: The channel sid         :rtype: str Code: def _get_channel_sid_from_channel_username(self, channel_username):         """         Get the channel sid from the channel
Code: def __init__(self, *args, **kwargs):         """         Initialize the Bernoulli
Code: def __init__(self,                  name,                  shape,                  dtype,                  initializer=None,                  regularizer=None,                  trainable=True,                  constraint=None,                  **kwargs):     """Constructs a variable.      Args:       name: The name of the variable.       shape: Shape of the variable.       dtype: Type of the variable.       initializer: Initializer instance (callable).       regularizer: Regularizer instance (callable).       trainable: If `True`, the default, also adds the variable to the graph         collection `GraphKeys.TRAINABLE_VARIABLES` (see         `tf.Variable`).       constraint: Constraint instance (callable).       **kwargs: Additional keyword arguments. Accepted values are         `getter`, `collections`, `validate_shape`, `caching_device`,         `expected_shape`, `use_resource`, and `synchronization`.     """     self._name = name     self._shape = shape     self._dtype = dtypes.as_dtype(dtype)     self._initializer = initializer     self._regularizer = regularizer     self._trainable = trainable     self._constraint = constraint     self._caching_device = kwargs.pop('caching_device', None)     self._validate_shape = kwargs.pop('validate_shape', True)     self._use_resource = kwargs.pop('use_resource', None)     self._synchronization = kwargs.pop('synchronization',                                        variables.VariableSynchronization.AUTO)     self._aggregation = kwargs.pop('aggregation',                                    variables.VariableAggregation.NONE)     self._getter = kwargs.pop('getter', None)     self._collections = kwargs.pop('collections', None)     self._expected_shape = kwargs.pop('expected_shape', None)     self._from_tensor = kwargs.pop('from_tensor', None)     self._from_tensor_fn = kwargs.pop('from_tensor_fn', None)     self._constraint_fn = kwargs.pop('constraint_fn', None)     self._constraint_args = kwargs.pop('constraint_args', None)     self._shape_fn = kwargs.pop('shape_fn', None)     self._shape_fn_args = kwargs.pop('shape_fn_args', None)     self._shape_out = kwargs.pop('shape_out', None)     self._shape_out
Code: def __init__(self,                  service_sid,                  channel_sid,                  version,                  friendly_name=values.unset,                  role_sid=values.unset,                  identity=values.unset,                  attributes=values.unset,                  x_twilio_webhook_enabled=values.unset):         """         Initialize the InviteList          :param unicode service_sid: The SID of the Service to create the resource under         :param unicode channel_sid: The SID of the Channel the new resource belongs to         :param Version version: Version that contains the resource         :param unicode friendly_name: A string to describe the resource         :param unicode role_sid: The SID of the Role to assign to the new member         :param unicode identity: The string that identifies the new resource's User         :param unicode attributes: A valid JSON string that contains application-specific data         :param unicode x_twilio_webhook_enabled: The X-Twilio-Webhook-Enabled HTTP request header          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)          # Path Parameters         self._properties = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)          # Options         self._options = {'friendly_name': friendly_name, 'role_sid': role_sid, 'identity': identity, 'attributes': attributes, 'x_twilio_webhook_enabled': x_twilio_webhook_enabled, }          self._headers = {'X-Twilio-Webhook-Enabled': x_twilio_webhook_enabled, }      @property     def service_sid(self):         """         :returns: The SID of the Service that the resource is associated with         :rtype: unicode         """         return self._properties['service_sid']      @property     def channel
Code: def _euler_method(random_draw_parts,                   state_parts,                   drift_parts,                   step_size_parts,                   volatility_parts,                   name=None):      with tf.compat.v1.name_scope(name,'mala_euler_method', [       random_draw_parts, state_parts, drift_parts, step_size_parts,       volatility_parts   ]):     proposed_state_parts = []
Code: def _get_drift(step_size_parts, volatility_parts, grads_volatility,                grads_target_log_prob,                name=None):       with tf.compat.v1.name_scope(name,
Compute the log acceptance correction for a single chain. Code: def _compute_log_acceptance_correction(current_state_parts,                                        proposed_state_parts,                                        current_volatility_parts,                                        proposed_volatility_parts,                                        current_drift_parts,                                        proposed_drift_parts,                                        step_size_parts,                                        independent_chain_ndims,                                        name=None):   r    with tf.compat.v1.name_scope(name, 'compute_log_acceptance_correction', [       current_state_parts, proposed_state_parts, current_volatility_parts,       proposed_volatility_parts, current_drift_parts, proposed_drift_parts,       step_size_parts, independent_chain_ndims   ]):      proposed_log_density_parts = []     dual_log_density_parts = []      for [         current_state,         proposed_state,         current_volatility,         proposed_volatility,         current_drift,         proposed_drift,         step_size,     ] in zip(         current_state_parts,         proposed_state_parts,         current_volatility_parts,         proposed_volatility_parts,         current_drift_parts,         proposed_drift_parts,         step_size_parts,     ):       axis = tf.range(independent_chain_ndims, tf.rank(current_state))        state_diff = proposed_state - current_state        current_volatility *= tf.sqrt(step_size)        proposed_energy = (state_diff - current_drift) / current_volatility        proposed_volatility *= tf.sqrt(step_size)       # Compute part of `q(proposed_state | current_state)`       proposed_energy = (           tf.reduce_sum(               input_tensor=mcmc_util.safe_sum(                   [tf.math.log(current_volatility),                    0.5 * (proposed_energy**2)]),               axis=axis))       proposed_log_density_parts.append(-proposed_energy)        # Compute part of `q(current_state | proposed_state)`       dual_energy = (state_diff + proposed_drift) / proposed_volatility       dual_energy =
Calls `grad_fn` if it is not None, otherwise returns `None`. Code: def _maybe_broadcast_grad_fn_results(grad_fn_results, state_parts):   """Broadcasts `grad_fn_results` to the shape of `state_parts`."""   if not mcmc_util.is_
Code: def _maybe_broadcast_volatility(volatility_parts,                                 state_parts):      return [v + tf.zeros_like(sp, dtype=sp.dtype.base_
Code: def make_ar_transition_matrix(coefficients):       top_row = tf.expand_dims(coefficients, -2)   coef_shape = dist_util.prefer_static_shape(coefficients)   batch_shape, order = coef_shape[:-1], coef_shape[-1]   remaining_rows = tf.concat([       tf.eye(order - 1, dtype=coefficients.dtype, batch_shape=batch_shape),       tf.zeros(tf.concat([batch_shape, (order - 1, 1)], axis=0),                dtype=coefficients.dtype)   ], axis=-1)   ar_matrix = tf.concat([top_row, remaining_rows], axis
Code: def _sample_shape(self, x):          x_ndims = (         tf.rank(x) if tensorshape_util.rank(x.shape) is None else         tensorshape_util.rank(x.shape))     event_ndims = (         tf.size(input=self.event_shape_tensor())         if tensorshape_util.rank(self.event_shape) is None else         tensorshape_util.rank(self.event_shape))     batch_ndims = (         tf.size(input=self._batch_shape_unexpanded)         if tensorshape_util.rank(self.batch_shape) is None else         tensorshape_util.rank(self.batch_shape))     sample_ndims = x_ndims - batch_ndims - event_ndims     if isinstance(sample_ndims, int):       static_sample_shape = x.shape[:sample_ndims]
Code: def _sample_shape(self, x):     """Sample shape of the distribution."""     if x is None:       return self.batch_shape, self.batch_shape     if not isinstance(x, tf.Tensor):       raise TypeError('`x` must be a `Tensor`.')     if not tensorshape_util.is_fully_defined(x.shape):       raise ValueError('`x` must have a fully-defined shape.')     if not tensorshape_util.is_fully_defined(self.batch_shape):       raise ValueError('`x` must have a fully-defined batch shape.')     if tensorshape_util.rank(x.shape)!= tensorshape_util.rank(         self.batch_shape):       raise ValueError('`x` must have the same rank as `batch_shape`.')     if tensorshape_util.rank(x.shape) == 0:       raise ValueError('`x` must have at least one dimension.')     if tensorshape_util.rank(x.shape) == 1:       if tensorshape_util.dimension_value(x.shape[0])!= 1:
Code: def _call_and_reshape_output(       self,       fn,       event_shape_list=None,       static_event_shape_list=None,       extra_kwargs=None):          # Note: we take `extra_kwargs` as a dict rather than `**extra_kwargs`     # because it is possible the user provided extra kwargs would itself     # have `fn`, `event_shape_list`, `static_event_shape_list` and/or     # `extra_kwargs` as keys.     with tf.control_dependencies(self._runtime_assertions):       if event_shape_list is None:         event_shape_
Code: def _bdtrc(k, n, p):      # Trick for getting safe backprop/gradients into n, k when   #   betainc(a = 0,..) = nan   # Write:   #   where(unsafe, safe_output, betainc(where(unsafe, safe_input, input)))   ones = tf.ones_like(n - k)   k_eq_n = tf.equal(k, n)   safe_dn = tf.where(k_eq_n, ones, n - k)   dk = tf.math.betainc(a=k + 1, b=safe_dn, x=p)   return tf.where(k_eq_n,
Initialize a JointDistributionCoroutine.      :param model: A callable that returns a generator of JointDistribution         instances.     :param seed: A seed for the random number generator. Code: def _flat_sample_distributions(self, sample_shape=(), seed=None, value=None):          ds = []     values_out = []     seed = seed_stream.SeedStream('JointDistributionCoroutine', seed)     gen = self._model()     index = 0     d = next(gen
Code: def list_members(self, limit=None, page_size=None):         """         Lists MemberInstance records from the API as a list.         Unlike stream(), this operation is eager and will load `limit` records
Code: def make_lda_variational(activation, num_topics, layer_sizes):      encoder_net = tf.keras.Sequential()   for num_hidden_units in layer_sizes:     encoder_net.add(         tf.keras.layers.Dense(             num_hidden_units,             activation=activation,             kernel_initializer=tf.compat.v1.
Code: def get_topics_strings(topics_words, alpha, vocabulary,                        topics_to_print=10, words_per_topic=10):      alpha = np.squeeze(alpha, axis=0)   # Use a stable sorting algorithm so that when alpha is fixed   # we always get the same topics.   highest_weight_topics = np.argsort(-alpha, kind="mergesort")   top_words = np.argsort(-topics_words
Fetch the next page of records          :param Response response: The response from Twilio          :returns: Page of InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def __init__(self, version, service_sid, channel_sid, ):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def stream(self, limit=None, page_size=None):         """         Streams InviteInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until the limit         is reached.         The results are returned as a generator, so this operation is memory efficient.          :param int limit: Upper limit for the number of records to return. stream()                           guarantees to never return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined,
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset,                  links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['account_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          self._solution = {             'account_sid': account_sid,            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property     def service_sid(self):         """         :returns: The SID of the Service that the resource is associated with         :rtype: unicode         """         return self._properties['service_sid']      @property     def channel_sid(self):         """         :returns: The SID of the Channel the resource belongs to         :rtype: unicode         """         return self._properties['channel_sid']      @property     def date_created(self):         """         :returns: The RFC 2822 date and time in GMT when the resource was created
Code: def build_input_fns(data_dir, batch_size):       with open(download(data_dir, "vocab.pkl"), "r") as f:     words_to_idx = pickle.load(f)   num_words = len(words_to_idx)    vocabulary = [None] * num_words   for word, idx in words_to_idx.items():     vocabulary[idx] = word    # Build an iterator over training batches.   def train_input_fn():     dataset = newsgroups_dataset(         data_dir, "train", num_words, shuffle_and_repeat=True)     # Prefetching makes training about 1.5x faster.     dataset = dataset.batch(batch_size).prefetch(32)     return tf.compat.v1.data.make_one_shot_iterator(dataset).get_next()    # Build an iterator over the heldout set.   def
Code: def minimize_one_step(gradient_unregularized_loss,                           hessian_unregularized_loss_outer,                           hessian_unregularized_loss_middle,                           x_start,                           l1_regularizer,                           l2_regularizer=None,                           maximum_full_sweeps=1,                           tolerance=1e-05,                           learning_rate=None):   """Minimizes a scalar function by one step of gradient descent.    Args:     gradient_unregularized_loss: A `Tensor` of shape `[d0,..., dN]` containing       the gradient of the unregularized loss function with respect to the       variables.     hessian_unregularized_loss_outer: A `Tensor` of shape `[d0,..., dN]`       containing the outer product of the gradient of the unregularized loss       function with respect to the variables.     hessian_unregularized_loss_middle: A `Tensor` of shape `[d0,..., dN]`       containing the middle product of the gradient of the unregularized loss       function with respect to the variables.     x_start: A `Tensor` of shape `[d0,..., dN]` containing the starting point       for the optimization.     l1_regularizer: A `Tensor` of shape `[d0,..., dN]` containing the L1       regularization coefficient.     l2_regularizer: A `Tensor` of shape `[d0,..., dN]` containing the L2       regularization coefficient.     maximum_full_sweeps: An `int` specifying the maximum number of full sweeps       to perform.     tolerance: A `float` specifying the tolerance for the optimization.     learning_rate: A `float` specifying the learning rate for the optimization.    Returns:     A tuple of `Tensor`s containing the updated point, a `bool` indicating     whether the optimization converged, and an `int` specifying the number of     iterations performed.   """   if learning_rate is None:     learning_rate = 1.0   if l2_regularizer is None:     l2_regularizer = tf.zeros_like(l1_regularizer)   if maximum_full_sweeps < 1:     raise ValueError('maximum_full_sweeps must be at least 1.')   if
Use an exponential moving average to update the codebook.          :param vector_quantizer:         :param one_hot_assignments:         :param codes:         :param commitment_loss:         :param decay:         :return:         """ Code: def add_ema_control_dependencies(vector_quantizer,                                  one_hot_assignments,                                  codes,                                  commitment_loss,                                  decay):      # Use an exponential moving average to update the codebook.   updated_ema_count = moving_averages.assign_moving_average(       vector_quantizer.ema_count,       tf.reduce_sum(input_tensor=one_hot_assignments
Get an item from the list of resources          :param unicode key: The index of the resource to fetch
Get the channel sid from the channel name          :param str channel_name: The channel name          :returns: The channel sid         :rtype: str Code: def _get_channel_sid(self, channel_name):         """         Get the channel sid from the channel name          :param str channel_name: The channel name          :returns: The channel sid         :rtype: str         """         channel = self.client.chat.channels.list(             friendly_name=channel_name
Code: def load_mnist_dataset(directory, split_name):   """Loads the MNIST dataset.    Args:     directory: The directory where the dataset is stored.     split_name: The name of the split to load.
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._invites = None         self._members = None         self._messages = None         self._webhooks = None      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = InviteList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._invites      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._
Returns the base dtype of the given dtype.          Args:             dtype: A `tf.DType` or a `tf.Tensor`.          Returns:             A `tf.DType`.         """         dtype = tf.as_dtype(dtype)         if hasattr(dtype, 'base_dtype'):             return dtype.base_dtype         return dtype Code: def _get_dtype(self,
Code: def is_dict(obj):      return isinstance(obj, dict)
Code: def is_complex(dtype):      dtype = tf.as
The SID of the Service that the resource is associated with Code: def _get_url(self):         """         :returns: The absolute URL of the Member resource         :rtype: unicode         """         return self._
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._invites = None         self._members = None         self._messages = None         self._webhooks = None      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = InviteList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._invites      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._invites = None         self._members = None         self._messages = None         self._webhooks = None      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = InviteList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._invites      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._
Create a new channel instance          :param unicode sid: A 34 character string that uniquely identifies this             resource.         :param unicode unique_name: An application-defined string that uniquely             identifies the resource. It can be used in place of the resource's             `sid`
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._members = None         self._messages = None         self._invites = None         self._webhooks = None      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._messages = MessageList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._messages      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites =
Prepare the arguments for the Nelder-Mead algorithm. Code: def _resolve_parameters(dim,                             reflection,                             expansion,                             contraction,                             shrinkage,
Code: def _inside_contraction_fn(objective_function,                                current_simplex,                                current_objective_values,                                face_centroid,                                best_index,                                worst_index,                                worst_objective_value,                                contraction,                                shrinkage,                                batch_evaluate_objective):   """   Perform an inside contraction.    :param callable objective_function: Objective function.   :param tf.Tensor current_simplex: Current simplex.   :param tf.Tensor current_objective_values: Current objective values.   :param tf.Tensor face_centroid: Face centroid.   :param int best_index: Index of best vertex.   :param int worst_index: Index of worst vertex.   :param float worst_objective_value: Objective value of worst vertex.   :param float contraction: Contraction factor.   :param float shrinkage: Shrinkage factor.   :param bool batch_evaluate_objective: Whether to evaluate the objective       function in a batch.   :returns: (converged, next_simplex, next_objective_at_simplex, num_evaluations)   :rtype: (tf.Tensor, tf.Tensor, tf.Tensor, int)   """   with tf.compat.v1.name_scope('inside_contraction'):     # Compute the centroid of the face opposite the worst vertex.     face_centroid = tf.reduce_sum(         input_tensor=current_simplex, axis=0) - current_simplex[worst_index]     face_centroid /= tf.cast(         tf.shape(current_simplex)[0] - 1, face_centroid.dtype.base_dtype)      # Perform an inside contraction.     next_simplex = tf.concat([         current_simplex[:worst_index],         face_centroid,         current_simplex[worst_index + 1:],     ], axis=0)     next_objective_at_simplex = objective_function(next_simplex)     num_evaluations = 1     converged = (         (next_objective_at_simplex < worst_objective_value) &         (next_objective_at_simplex >= best_objective_value))     return (         converged,         next_simplex,         next_objective_at_simplex,         num
Code: def _replace_worst_with_reflected():     next_simplex = _replace_at_index(simplex, worst_index, reflected)     next_objective_values = _replace_at_index(objective_values, worst_index,                                               objective_at_reflected)
Code: def _expand_and_maybe_replace():          expanded = face_centroid + expansion * (reflected - face_centroid)     expanded_objective_value = objective_function(expanded)     expanded_is_better = (expanded_objective_value <                           objective_at_reflected)
Code: def _shrink_towards_worst(objective_function,                             simplex,                             worst_index,                             shrinkage,                             batch_evaluate_objective):      def _shrink():     shrunk = simplex[worst_index] + shrinkage * (simplex[worst_index] - simplex[best_index])     objective_at_shrunk = objective_function(shrunk)     is_shrunk_acceptable = objective_at_shrunk <= objective_at_best     def _accept_shrink():       next_simplex = _replace_at_index(simplex, best_index, shrunk)       objective_at_next_simplex = _replace_at_index(           objective_values,           best_index,           objective_at_shrunk)       return (False
Evaluate the objective function for multiple points.          :param callable objective_function: Objective function to be minimized         :param numpy.ndarray simplex: Current simplex         :param callable batch_evaluate_objective: Function to evaluate the objective function for multiple points
Code: def _replace_at_index(x, index, replacement):      x_new = tf.concat([x[:index], tf.expand_dims(replacement, axis=0),                      x[(index + 1):]], axis=0)   return
Code: def _check_convergence(simplex,                        best_vertex,                        best_objective,                        worst_objective,                        func_tolerance,                        position_tolerance):      objective_convergence = tf.abs(worst_objective -                                  best_
Code: def _prepare_args_with_initial_vertex(objective_function,                                            initial_vertex,                                            step_sizes,                                            objective_at_initial_vertex,                                            batch_evaluate_objective):   """Prepares the arguments for the simplex method.    Args:     objective_function: A function that takes a vector of variables and       returns a scalar value.     initial_vertex: A vector representing the initial vertex.     step_sizes: A list of scalar values representing the step sizes for each       variable.     objective_at_initial_vertex: A scalar value representing the objective       function at the initial vertex.     batch_evaluate_objective: A function that takes a list of vectors and       returns a list of scalar values.    Returns:     A tuple of the following:       - A vector representing the initial vertex.       - A
Code: def _prepare_args_with_initial_simplex(objective_function,                                        initial_simplex,                                        objective_at_initial_simplex,                                        batch_evaluate_objective):      initial_simplex = tf.convert_to_tensor(value=initial_simplex)    # If d is the dimension of the problem, the number of vertices in the   # simplex should be d+1. From this, we can infer the number of dimensions   # as n - 1 where n is the number of vertices specified.   num_vertices = tf.shape(input=initial_simplex)[0]   dim = num_vertices - 1   num_evaluations = 0    if objective_at_initial_simplex is None:     objective_at_initial_simplex, n_evals = _evaluate_objective_multiple(         objective_function, initial_simplex, batch_evaluate_objective)     num_evaluations += n_evals   objective_at_initial_simplex = tf.convert_to_tensor(
Evaluate the objective function at multiple vertices.          Args:             objective_function: A callable that takes a single argument and returns a                 scalar.             simplex_vertices: A tensor of shape [num_vertices, dim].             batch_evaluate_objective: A callable that takes a tensor of shape                 [batch_size, dim] and returns a tensor of shape [batch_size].          Returns:             A tuple of (objective_at_simplex_vertices, num_evaluations). Code: def _find_best_vertex(objective_at_simplex_vertices,                           simplex_vertices,                           objective_at_initial_vertex):   """Find the vertex with the best objective value.    Args:     objective_at_simplex_vertices: A tensor of shape [num_vertices].     simplex_vertices: A tensor of shape [num_vertices, dim].     objective_at_initial_vertex: A scalar.    Returns:     The index of the vertex with the best objective value
Code: def _evaluate_objective_multiple(objective_function, arg_batch,                                  batch_evaluate_objective):      n_points = tf.shape(input=arg_batch)[0]   if batch_evaluate_objective:     return objective_function(arg_batch), n_points   return tf.map_fn(
Get the channel sid from the channel name          :param str channel_name: The channel name          :returns: The channel sid         :rtype: str Code: def _get_channel_sid(self, channel_name):         """         Get the channel sid from the channel name          :param str channel_name: The channel name          :returns: The channel sid
Code: def __init__(self, version, service_sid, channel_sid, ):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from          :returns: twilio.rest.ip_messaging.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.ip_messaging.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      @property     def page_size(self):         """         :returns: How many resources to return in each list page. The default is 50, and the maximum is 1000.         :rtype: unicode         """         return self._properties['page_size']
Code: def build_fake_data(num_examples=10):       class Dummy(object):     pass    num_examples = 10   mnist_data = Dummy()   mnist_data.train = Dummy()   mn
Code: def get_config(self):          return {         'initializers': [             tf.compat.v2
Code: def from_config(
Code: def _matmul(a, b,             transpose_a=False, transpose_b=False,             adjoint_a=False, adjoint_b=False,             a_is_sparse=False, b_is_sparse=False,             name=None):  # pylint: disable=unused-argument      if a_is_sparse or b_
Broadcasts a tensor to a given shape. Code: def _broadcast_static_shape(tensor, shape):     """Broadcasts a tensor to a given shape.      Args:       tensor: A `Tensor`.       shape: A `TensorShape`.      Returns:       A `TensorShape`.     """     tensor_shape = tensor.get_shape()     if tensor_shape.is_compatible_with(shape):         return tensor_shape     if tensor_shape.ndims is None:         raise ValueError("Cannot broadcast a tensor with unknown shape to shape %s"                          % shape)     if shape.ndims is None:         raise ValueError("Cannot broadcast a tensor with shape %s to an unknown shape"                          % tensor_shape)     if tensor_shape.ndims == 0:         return shape     if shape.ndims == 0:         return tensor_shape     if tensor_shape.ndims < shape.ndims:         tensor_shape = tensor_shape.concatenate([1])     if tensor_shape.ndims > shape.ndims:         shape = shape.concatenate([1])     return tensor_shape.concatenate
Get the channel sid or channel name or channel sid          :param str channel_name: The channel name          :returns: The channel sid or channel name or channel sid         :rtype: str Code: def _get_channel_sid_or_channel_name_or_channel_sid_or_channel_unique_name(         self, channel_name):         """         Get the channel sid or channel name or channel sid or channel unique         name          :param str channel_name: The channel name          :returns: The channel sid or channel name or channel sid or channel unique                   name         :rtype: str         """         if not
Code: def _make_columnar(self, x):          if tensorshape_util.rank(x.shape) is not None:       if tensorshape_util.rank(x.shape)
Code: def __init__(self, *args, **kwargs):         """         Initialize the InviteList          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(*args, **kwargs)          # Path Solution         self._solution = {'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def stream(self, limit=None, page_size=None):         """         Streams InviteInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until the limit         is reached.         The results are returned as a generator, so this operation is memory efficient.          :param int limit: Upper limit for the number of records to return. stream()                           guarantees to never return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, stream() will attempt to read the                               limit with the most efficient page size, i.e. min(limit, 1000)          :returns: Generator that will yield up to limit results         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]         """         limits = self._version.read_limits(limit, page_size)          page = self.page(page_size=limits['page_size'], )          return self._version.stream(page, limits['limit'], limits['page_limit'])      def list(self, limit=None, page_size=None):         """         Lists InviteInstance records from the API as a list.         Unlike stream(), this operation is eager and will load `limit` records into         memory before returning.          :param int limit: Upper limit for the number of records to return. list() guarantees                           never to return more than limit.  Default is no limit         :param int page_size: Number of records
Provide a friendly representation          :returns: Machine friendly representation         :
Code: def _pick_scalar_condition(pred, cond_true, cond_false):      # Note: This function is only valid if all of pred, cond_true, and cond_false   # are scalars. This means its semantics are arguably more like tf.cond than   # tf.where even though we use tf.where to implement it.   pred_ =
Code: def _maybe_rotate_dims(self, x, rotate_right=False):     """Rotates the dimensions of `x` to the right or left.      Args:       x: `Tensor` or `RaggedTensor` with shape `[..., event_ndims, batch_shape]`.       rotate_right: Python `bool
Code: def _maybe_rotate_dims(self, x, rotate_right):     """Rotate the dimensions of `x` to the right or left.      Args:       x: `Tensor` or `RaggedTensor` with shape `[..., event_ndims, batch_shape]`.       rotate_right: Python `bool`. If `True`, rotate the dimensions to the right.         If `False`, rotate the dimensions to the left.      Returns:       x: `Tensor` or `RaggedTensor` with shape `[..., batch_shape, event_ndims]`.     """
Code: def _maybe_rotate_dims(self, x, rotate_right=False):          needs_rotation_const = tf.get_static_value(self._needs_rotation)     if needs_rotation_const is
Code: def _undo_batch_normalization(x,                               mean,                               variance,                               offset,                               scale,                               variance_epsilon,                               name=None):   r   with tf.compat.v2.name_scope(name or "undo_batchnorm"):     # inv = tf.rsqrt(variance + variance_epsilon)     # if scale is not None:     #   inv *= scale     # return x * inv + (     #     offset - mean * inv if offset is not None else -mean * inv)     rescale = tf.sqrt(variance + variance_epsilon)     if scale is not None:       rescale /= scale     batch_unnormalized = x * rescale + (
Code: def _validate_bn_layer(self, layer):
Slice a list of parameters.          Args:             params: A list of parameters.             param_event_ndims: The number of event dimensions in each parameter.             slices: A list of slices.             dist_batch_shape: The batch shape of the distribution.          Returns:             A list of sliced parameters. Code: def _slice_multi_param_static(params, param_event_ndims, slices, dist_batch_shape):   """Slice a list of parameters.    Args:     params: A list of parameters.     param_event_ndims: The number of event dimensions in each parameter.     slices: A list of slices.     dist_batch_shape: The batch shape of the distribution.    Returns:     A list of sliced parameters
Slice a single parameter.          Args:             param: A `Tensor` representing the parameter.             param_event_ndims: The number of event dimensions in the parameter.             slices: A `Tensor` representing the slices to apply.             batch_shape: A `Tensor` representing the batch shape of the parameter.          Returns:             A `Tensor` representing the sliced parameter. Code: def _slice_params_to_dict(dist, params_event_ndims, slices):   """Slice a dictionary of parameters.    Args:     dist: A `Distribution` instance.     params_event_ndims: A dictionary mapping parameter names to the number of       event dimensions in the parameter.     slices: A `Tensor` representing the slices to apply.    Returns:     A dictionary mapping parameter names to `Tensor`s representing the sliced     parameters.   """   override_dict = {}   for param_name, param_event_ndims in six.iteritems(params_event_ndims):     # Verify that either None or a
Converts a slice into a dictionary of parameters.          Args:             dist: A `Distribution` instance.             params_event_ndims: A Python `int` representing the number of event               dimensions.             slices: A Python `list` of `slice` objects.          Returns:             params: A `dict` of parameters. Code: def _slice_params_to_dict(dist, params_event_ndims, slices):   """Converts a slice into a dictionary of parameters.    Args:     dist: A `Distribution` instance.     params_event_ndims: A Python `int` representing the number
Code: def _apply_single_step(dist, params_event_ndims, slices, overrides):   """Applies a single step of slice overrides to a distribution.    Args:     dist: The distribution to apply the overrides to.     params_event_ndims: The number of event dimensions in the distribution.     slices: The slices to apply the overrides to.     overrides: The overrides to apply.    Returns:     The distribution with the overrides applied.   """   if not slices:     return dist   if not overrides:     return dist   if not isinstance(overrides, dict):     raise ValueError('overrides must be a dict')   if not isinstance(slices, tuple):     raise ValueError('slices must be a tuple')   if len(slices)!= params_event_ndims:     raise ValueError('slices must have the same length as the number of '                      'event dimensions in the distribution')   if not isinstance(dist, tfd.Distribution):     raise ValueError('dist must be a tfd.Distribution')   if not isinstance(dist.event_shape, tuple):     raise ValueError('dist.event_shape must be a tuple')   if not isinstance(dist.batch_shape, tuple):     raise ValueError('dist.batch_shape must be a tuple')   if not isinstance(dist.batch_shape_tensor(), tf.TensorShape):     raise ValueError('dist.batch_shape_tensor() must be a tf.TensorShape')   if not isinstance(dist.event_shape_tensor(), tf.TensorShape):     raise ValueError('dist.event_shape_tensor() must be a tf.TensorShape')   if not isinstance(dist.batch_shape_tensor().as_list(), list):     raise ValueError('dist.batch_shape_tensor().as_list() must be a list')   if not isinstance(dist.event_shape_tensor().as_list(), list):     raise ValueError('dist.event_shape_tensor().as_list() must be a list')   if not isinstance(dist.batch_shape_tensor().as_list(), list):     raise ValueError('dist.batch_shape_tensor().as_list() must be a list')   if not isinstance(dist.event_shape_tensor().as_list(), list):     raise ValueError('dist.event_shape_tensor().as_list() must be a list')   if not isinstance(
Apply a slice to a distribution.    Args:     dist: The distribution to apply the slice to.     params_event_ndims: The number of event dimensions in the distribution's       parameters.     slices: A slice object.    Returns:     The distribution with the slice applied. Code: def _apply_copy
Code: def fit_one_step(     model_matrix,     response,     model,     model_coefficients_previous,     predicted_linear_response_previous,     l2_regularizer,     dispersion,     offset,     learning_rate,     fast_unsafe_numerics):   """   Fit one step of the gradient descent algorithm.    :param model_matrix: Model matrix.   :type model_matrix: tf.Tensor   :param response: Response.   :type response: tf.Tensor   :param model: Model.   :type model: tf.Tensor   :param model_coefficients_previous: Model coefficients from previous step.   :type model_coefficients_previous: tf.Tensor   :param predicted_linear_response_previous: Predicted linear response from previous step.   :type predicted_linear_response_previous: tf.Tensor   :param l2_regularizer: L2 regularizer.   :type l2_regularizer: tf.Tensor   :param dispersion: Dispersion.   :type dispersion: tf.Tensor   :param offset: Offset.   :type offset: tf.Tensor   :param learning_rate: Learning rate.   :type learning_rate: tf.Tensor   :param fast_unsafe_numerics: Whether to use fast unsafe numerics.   :type fast_unsafe_numerics: bool   :returns: Model coefficients, predicted linear response.   :rtype: tuple(tf.Tensor, tf.Tensor)   """   model_coefficients_next = model_coefficients_previous - learning_rate * (       tf.matmul(           tf.matmul(               tf.transpose(model_matrix),               model_matrix + l2_regularizer * tf.eye(                   tf.shape(model_matrix)[0], dtype=tf.float32)),           model_coefficients_previous) -       tf.matmul(           tf.matmul(               tf.transpose(model_matrix),               model_matrix + l2_regularizer * tf.eye(                   tf.shape(model_matrix)[0], dtype=tf.float32)),           predicted_linear_response_previous) +       tf.matmul(           tf.matmul(               tf.transpose(model_matrix),               model_matrix + l2_regularizer * tf.eye(                   tf.shape
Code: def convergence_criteria_small_relative_norm_weights_change(     tolerance=1e-5,     norm_order=2):      def convergence_criteria_fn(       is_converged_previous,  # pylint: disable=unused-argument       iter_,       model_coefficients_previous,       predicted_linear_response_previous,  # pylint: disable=unused-argument       model_coefficients_next,       predicted_linear_response_next,  # pylint: disable=unused-argument       response,  # pylint: disable=unused-argument       model,  # pylint: disable=unused-argument       dispersion):  # pylint: disable=unused-argument          relative_euclidean_norm = (         tf.norm(             tensor=model_coefficients_previous - model_coefficients_next,             ord=norm_order,             axis=-1) /         (1. +          tf.norm(tensor=model_coefficients_previous, ord=norm_order, axis=-1)))     return (iter_ > 0) & tf.reduce_all(         input_tensor=relative
Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InviteInstance          :returns: twilio.rest.ip_messaging.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.ip_messaging.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'identity': payload.get('identity'),             'role_sid': payload.get('role_sid'),             'date_created': deserialize.iso8601_datetime(payload.get('date_created')),             'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')),             'url': payload.get('url'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': payload.get('sid'),         }      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property     def service_sid(self):         """         :

Returns a tuple of (args, all_static) where args is a list of (args, kwargs) tuples and all_static is a boolean indicating whether all args are static. Code: def _get_static_args_and_kwargs(args, kwargs):   """Returns a tuple of (args, all_static) where args is a list of   (args,
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __call__(self, sid):         """         Constructs a InviteContext          :param sid: The sid          :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         return InviteContext(             self._version,             service_sid=self._solution['service_sid'],             channel_sid=self._solution['channel_sid'],             sid=sid,
Returns the static dtype of a tensor, if it has one. Code: def _get_static_shape_as_list(tensor):   """Returns the static shape of a tensor, if it has one."""   if isinstance(tensor, ops.EagerTensor):     return tensor.shape.as_list()   elif isinstance(tensor, ops.Tensor):     return tensor.shape.as_list()   else:     raise TypeError('`tensor` must be a Tensor. Found instead
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._members = None         self._messages = None         self._invites = None         self._webhooks = None      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._messages = MessageList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._messages      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites =
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,  # pylint: disable=unused-argument                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset,                  links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['account_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {             'account_sid': account_sid,            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_
Code: def _name_scope(self, name=None, default_name=None, values=None):          with tf.compat.v1.name_scope(self.name):       with
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel to fetch the resource from          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._members = None         self._messages = None         self._invites = None         self._webhooks = None         self._last_read_message_index = None         self._last_consumption_timestamp = None         self._notifications = None         self._post = None         self._typing = None         self._user = None      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._messages = MessageList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._messages      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service
Code: def make_diag_scale(loc=None,                     scale_diag=None,                     scale_identity_multiplier=None,                     shape_hint=None,                     validate_args=False,                     assert_positive=False,                     name=None):       def _maybe_attach_assertion(x):     if not validate_args:       return x     if assert_positive:       return with_dependencies([           assert_util.assert_positive(               tf.linalg.diag_part(x), message="diagonal part must be positive"),       ], x)     return with_dependencies([         assert_util.assert_none_equal(             tf.linalg.diag_part(x),             tf.zeros([], x.dtype),             message="diagonal part must be non-zero"),     ], x)    with tf.name_scope(name or "make_diag_scale"):      dtype = dtype_util.common_dtype(         [loc, scale_diag, scale_identity_multiplier],         preferred_dtype=tf.float32)     loc = _convert_to_tensor(loc, name="loc", dtype=dtype)     scale_diag = _convert_to_tensor(scale_diag, name="scale_diag", dtype=dtype)     scale_identity_multiplier = _convert_to_tensor(         scale_identity_multiplier,         name="scale_identity_multiplier",         dtype=dtype)    if scale_diag is not None:     scale_diag = _maybe_attach_assertion(scale_diag)     return tf.linalg.LinearOperatorDiag(         diag=scale_diag,         is_non_singular=True,         is_self_adjoint=True,         is_positive_definite=assert_positive)    if scale_identity_multiplier
Code: def _maybe_attach_assertion(x):     if not validate_args:       return x     if assert_positive:       return with_dependencies([           assert_util.assert_positive(               x, message="diagonal part must be positive"),       ], x)     return with_dependencies([         assert_util.assert_none_equal(             x, tf.zeros([], x.dtype), message
Returns the event shape of the distribution.          Returns:             event_shape: `TensorShape`, the event shape of the
Code: def is_diagonal
Code: def maybe_check_scalar_distribution(distribution, expected_base_dtype,                                     validate_args):      if distribution.dtype!= expected_base_dtype:     raise TypeError("dtype mismatch; "                     "distribution.dtype=\"{}\" is not \"{}\"".format(                         dtype_util
Send a packet to the server          :param twilio.rest.chat.v2
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the new Member belongs to          :returns: twilio.rest.chat.v2.service.channel.channel_context.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.channel_context.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._members = None         self._messages = None         self._invites = None         self._webhooks = None      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._messages = MessageList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._messages      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None
Get the channel unique name from the channel_sid or channel_unique_name          :param str channel_sid: The channel_sid         :param str channel_unique_name: The channel_unique_name          :returns: The channel unique name         :rtype: str Code: def _get_service_sid(self, service_sid):         """         Get the service sid from the service_sid or service_unique_name          :param str service_sid: The service_sid         :param str service_unique_name: The service_unique_name          :returns: The service sid         :rtype: str         """         if service_sid:             return service_sid         if service_unique_name:             return self._list_services

Get the channel unique name from the channel_sid or channel_unique_name          :param str channel_sid: The channel_sid         :param str channel_unique_name: The channel_unique_name          :returns: The channel unique name         :rtype: str Code: def _get_service_sid(self, service_sid):         """         Get the service sid from the service_sid or service_unique_name          :param str service_sid: The service_sid         :param str service_unique_name: The service_unique_name          :returns: The service sid         :rtype: str         """         if service_sid:             return service_sid         if service_unique_name:             return self.client.services.get(service_unique_name).sid         raise ValueError
Code: def __init__(self, *args, **kwargs):         """         Initialize the InviteList          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(*args, **kwargs)          # Path Solution         self._solution = {'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def stream(self, limit=None, page_size=None):         """         Streams InviteInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until the limit         is reached.         The results are returned as a generator, so this operation is memory efficient.          :param int limit: Upper limit for the number of records to return. stream()                           guarantees to never return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, stream() will attempt to read the                               limit with the most efficient page size, i.e. min(limit, 1000)          :returns: Generator that will yield up to limit results         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]         """         limits = self._version.read_limits(limit, page_size)          page = self.page(page_size=limits['page_size'], )          return self._version.stream(page, limits['limit'], limits['page_limit'])      def list(self, limit=None, page_size=None):         """         Lists InviteInstance records from the API as a list.         Unlike stream(), this operation is eager and will load `limit` records into         memory before returning.          :param int limit: Upper limit for the number of records to return. list() guarantees                           never to return more than limit.  Default is no limit         :param int page_size: Number of records
Code: def _is_known_unsigned_by_dtype(dt):      return {       tf.bool
Code: def _is_known_signed_by_dtype(dt):
Code: def _is_known_dtype(dt):   return dt
Code: def _smallest_integer_by_dtype(dt):      if not _
Code: def _is_known_dtype(dt):   return dt
Validates that `sample_shape` is a `TensorShape` and has rank at least 1. Code: def _validate_sample_shape_static(sample_shape, name="validate_sample_shape"):   """Validates that `sample_shape` is a `TensorShape` and has rank at least 1.    Args:     sample_shape: A `TensorShape` or `Tensor`.     name: Python `str` name prefixed to Ops created by this function.    Returns:     sample
Code: def log_combinations(n, counts, name="log_combinations"):      # First a bit about the number of ways counts could have come in:   #
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel to fetch the resource from          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._invites = None         self._members = None         self._messages = None         self._webhooks = None      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = InviteList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._invites      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._messages
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._invites = None         self._members = None         self._messages = None         self._webhooks = None      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = InviteList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._invites      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._
Code: def __init__(self,                  service_sid,                  channel_sid,                  version,                  friendly_name=values.unset,                  role_sid=values.unset,                  identity=values.unset,                  attributes=values.unset,                  x_twilio_webhook_enabled=values.unset):     """     Initialize the InviteList      :param unicode service_sid: The SID of the Service to create the resource under     :param unicode channel_sid: The SID of the Channel the new resource belongs to     :param Version version: Version that contains the resource     :param unicode friendly_name: A string to describe the new resource     :param unicode role_sid: The SID of the Role to assign to the new member     :param unicode identity: The string that identifies the new resource's User     :param unicode attributes: A valid JSON string that contains application-specific data     :param unicode x_twilio_webhook_enabled: The X-Twilio-Webhook-Enabled HTTP request header      :returns: twilio.rest.chat.v2.service.channel.invite.InviteList     :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList     """     super(InviteList, self).__init__(version)      # Path Solution     self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }     self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      # Values of this resource     self._friendly_name = friendly_name     self._role_sid = role_sid     self._identity = identity     self._attributes = attributes     self._x_twilio_webhook_enabled = x_twilio_webhook_enabled      # Headers     self._headers = {'X-Twilio-Webhook-Enabled': x_twilio_webhook_enabled, }    @property   def friendly_name(self):     """     :returns: The string that you assigned to describe the resource     :rtype: unicode     """     return self._friendly_name    @property   def role_sid(self):     """     :returns: The SID of the Role to assign to the new member     :rtype: unicode     """     return self._role_sid    @property   def identity(self):     """     :returns: The string that
Get an item from the list of resources          :param unicode key: The index of the resource to fetch          :returns
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the new resource belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._invites = None         self._members = None         self._messages = None         self._webhooks = None      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = InviteList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._invites      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._messages
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._invites = None         self._members = None         self._messages = None         self._webhooks = None      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = InviteList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._invites      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._
Code: def _process_quadrature_grid_and_probs(quadrature_grid_and_probs,                                       dtype,                                       validate_args,                                       name=None):      with tf.name_scope(name or "process_quadrature_grid_and_probs"):     if quadrature_grid_and_probs is None:       grid, probs = np.polynomial.hermite.hermgauss(deg=8)       grid = grid.astype(dtype_util.as_numpy_dtype(dtype))       probs = probs.astype(dtype_util.as_numpy_dtype(dtype))       probs /= np.linalg.norm(probs, ord=1, keepdims=True)       grid = tf.convert_to_tensor(value=grid, name="grid", dtype=dtype)       probs = tf.convert_to_tensor(value=probs, name="probs", dtype=dtype)       return grid, probs      grid, probs = tuple(quadrature_grid_and_probs)     grid = tf.convert_to_tensor(value=grid, name="grid", dtype=dtype)     probs = tf.convert_to_tensor(         value=probs, name="unnormalized_probs", dtype=dtype)     probs /= tf.norm(tensor=probs, ord=1, axis=-1, keepdims=True, name="probs")      def _static_event_size(x):              return tf.compat.dimension_value(           tensorshape_util.with_rank_at_least(x.shape, 1)[-1])      m, n = _static_event_size(probs), _static_event_size(grid)     if m is not None and n is not None:       if m!= n:         raise ValueError("`quadrature_grid_and_probs` must be a `tuple` of "                          "same-length zero-th-dimension `Tensor`s "                          "(saw lengths {}, {})".format(m, n))     elif validate_args:       assertions = [           assert_util.assert_equal(               dimension_size(probs, axis=-1),               dimension_size(grid, axis=-1),               message=("`quadrature_grid_and_probs` must be a `tuple` of "                        "same-length zero-th-dimension `Tensor`s
Get an item from the list of resources          :param unicode key: The index of the resource to fetch          :
Code: def expand_to_vector(x, tensor_name=None, op_name=None, validate_args=False):      with tf.name_scope(op_name or "expand_to_vector"):     x = tf.convert_to_tensor(value=x, name="x")     ndims = tensorshape_util.rank(x.shape)      if ndims is None:       # Maybe expand ndims from 0 to 1.       if validate_args:         x = with_dependencies([             assert_util.assert_rank_at_most(                 x, 1, message="Input is neither scalar nor vector.")         ], x)       ndims = tf.rank(x)       expanded_shape = pick_vector(
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the new resource belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._invites = None         self._members = None         self._messages = None         self._webhooks = None      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = InviteList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._invites      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._messages
Code: def _maybe_validate_rightmost_transposed_ndims(     rightmost_transposed_ndims, validate_args, name=None):      with tf.name_scope(name or'maybe_validate_rightmost_transposed_ndims'):     assertions = []     if not dtype_util.is_integer(rightmost_transposed_ndims.dtype):       raise TypeError('`rightmost_transposed_ndims` must be integer type.')      if tensorshape_util.rank(rightmost_transposed_ndims.shape) is not None:
Code: def _maybe_validate_perm(perm, validate_args, name=None):      with tf.name_scope(name or'maybe_validate_perm'):     assertions = []     if not dtype_util.is_integer(perm.dtype):       raise TypeError('`perm` must be integer type')      msg = '`perm` must be a vector.'     if tensorshape_util.rank(perm.shape) is not None:       if tensorshape_util.rank(perm.shape)!= 1:         raise ValueError(             msg[:-1] +             ', saw rank: {}.'.format(tensorshape_util.rank(perm.shape)))     elif validate_args:       assertions += [assert_util.assert_rank(perm, 1, message=msg)]      perm_ = tf.get_static_value(perm)     msg = '`perm` must be a valid permutation vector.'     if perm_ is not None:       if not np.
Code: def _event_shape(self, shape, static_perm_to_shape):          rightmost_ = tf.get_static_value(self.rightmost_transposed_ndims)     if tensorshape_util.rank(shape) is None or rightmost_ is None:       return tf.TensorShape(None)     if tensorshape_util.rank(shape) < rightmost_:       raise ValueError('Invalid shape: min event ndims={} but got {}'.format(           rightmost_, shape))     perm_ = tf.get_static_value(self.perm, partial=True)     if perm_ is None:       return shape[:tensorshape_util.rank(shape) - rightmost_].concatenate(           [None] * int(rightmost_))     # We can use elimination to reidentify a single None dimension.     if sum(p
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._invites = None         self._members = None         self._messages = None         self._webhooks = None      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = InviteList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._invites      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._
Generate an absolute URL for this Invite          :returns: Absolute URL for this Invite         :
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._invites = None         self._members = None         self._messages = None         self._webhooks = None      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = InviteList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._invites      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._
Code: def with_rank_
Code: def _check_equal_shape(name,                        static_shape,                        dynamic_shape,                        static_target_shape,                        dynamic_target_shape=None):       static_target_shape = tf.TensorShape(static_target_shape)   if tensorshape_util.is_fully_defined(       static_shape) and tensorshape_util.is_fully_defined(static_target_shape):     if static_shape!= static_target_shape:       raise ValueError("{}: required shape {} but found {}".                        format(name, static_target_shape, static_shape))     return None   else:     if dynamic_target_shape is None:       if tensorshape_util.is_fully_defined(static_target_shape):         dynamic_target_shape = tensorshape_util.as_list(static_target_shape)       else:         raise ValueError("{}: cannot infer target shape: no dynamic shape "                          "specified and static shape {} is not fully defined".                          format(name, static_target_shape))     return assert_util.assert_equal
Broadcasting is not supported; unexpected batch shape.          :param partial_batch_dist: Distribution with a partially-defined batch             shape.         :type partial_batch_dist: tf.contrib.distributions.Distribution         :param full_sample_and_batch_shape: Full sample and batch shape of the             distribution.         :type full_sample_and_batch_shape: tf.TensorShape         :param validate_args: Python `bool`, default `False`. When `True`             distribution parameters are checked for validity despite possibly             degrading runtime performance. When `False` invalid inputs may silently             render incorrect outputs.         :type validate_args: Python `bool`         :returns: Full sample and batch shape of the distribution.         :rtype: tf.TensorShape Code: def _augment_sample_shape(partial_batch_dist,                           full_sample_and_batch_shape,                           validate_args=False):      full_ndims = distribution_util.prefer_static_shape(       full_sample_and_batch_shape)[0]   partial_batch_ndims = (       tensorshape_util.rank(partial_batch_dist.batch_shape)  # pylint: disable=g-long-ternary       if tensorshape_util.rank(partial_batch_dist.batch_shape) is not None       else distribution_util.prefer_static_shape(           partial_batch_dist.batch_shape_tensor())[0])    num_broadcast_dims = full_ndims - partial_batch_ndims    expected_partial_batch_shape = (       full_sample_and_batch_shape[num_broadcast_dims:])   expected_partial_batch_shape_static = tf.get_static_value(       full_sample_and_batch_shape[num_broadcast_dims:])    # Raise errors statically if possible.   num_broadcast_dims_static = tf.get_static_value(num_broadcast_dims)   if num_broadcast_dims_static is not None:     if num_broadcast_dims_static < 0:       raise ValueError("Cannot broadcast distribution {} batch shape to "                        "target batch shape with fewer dimensions"                       .format(partial_batch_dist))   if (expected_partial_batch_shape_static is not None and       tensorshape_util.is_fully_
Code: def build_kalman_filter_with_smoothing(get_transition_matrix_for_timestep,                                             get_observation_matrix_for_timestep,                                             get_observation_covariance_for_timestep,                                             get_initial_state_mean,                                             get_initial_state_covariance):       def kalman_filter_with_smoothing(observations):           state = ForwardPassState(         forward_mean=get_initial_state_mean(),
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __call__(self, service_sid, channel_sid):         """         Constructs a InviteContext          :param unicode service_sid: The SID of the Service to fetch the resource         :param unicode channel_sid: The SID of the Channel the resource is associated with          :returns: twilio.rest
Get the observation noise for the given timestep.          :param int timestep: The timestep to get the observation noise for.          :returns: The observation noise for the given timestep.         :rtype: numpy.ndarray Code: def _get_transition
Code: def linear_gaussian_update(     prior_mean, prior_cov, observation_matrix, observation_noise, x_observed):       # If observations are scalar, we can avoid some matrix ops.   observation_size_is_static_and_scalar = (       tf.compat.dimension_value(observation_matrix.shape[-2]) == 1)    # Push the predicted mean for the latent state through the   # observation model   x_expected = _propagate_mean(prior_mean,                                observation_matrix,                                observation_noise)    # Push the predictive covariance of the latent state through the   # observation model:   #  S = R + H * P * H'.   # We use a temporary variable for H * P,   # reused below to compute Kalman gain.   tmp_obs_cov = observation_matrix.matmul(prior_cov)   predicted_obs_cov = (       observation_matrix.matmul(tmp_obs_cov, adjoint_arg=True)       + observation_noise.covariance())    # Compute optimal Kalman gain:   #  K = P * H' * S^{-1}   # Since both S and P are cov matrices, thus symmetric,   # we can take the transpose and reuse our previous   # computation:   #      = (S^{-1} * H * P)'   #      = (S^{-1} * tmp_obs_cov)'   #      = (S \ tmp_obs_cov)'   if observation_size_is_static_and_scalar:     gain_transpose = tmp_obs_cov/predicted_obs_cov   else:     predicted_obs_cov_chol = tf.linalg.cholesky(predicted_obs_cov)     gain_transpose = tf.linalg.cholesky_solve(predicted_obs_cov_chol,                                               tmp_obs_cov)    # Compute the posterior mean, incorporating the observation.   #  u* = u + K (x_observed - x_expected)   posterior_mean = (prior_mean +                     tf.linalg.matmul(gain_transpose, x_observed - x_expected,                                      adjoint_a=True))    # For the posterior covariance, we could use the simple update   #  P* = P - K * H * P   # but this is prone to numerical
Kalman filter update function.          :param numpy.array filtered_mean: mean of the filtered distribution         :param numpy.array filtered_cov: covariance of the filtered distribution         :param numpy.array measurement_matrix: measurement matrix         :param numpy.array measurement_noise: measurement noise         :param numpy.array measurement: measurement          :returns: updated mean and covariance         :rtype: numpy.array, numpy.array Code: def kalman_update_with_covariance(filtered_mean, filtered_cov,                       measurement_matrix, measurement_noise,                       measurement, measurement_covariance):       predicted_mean = _propagate_mean(filtered_mean,                                    measurement_matrix,                                    measurement_noise)   predicted_cov = _propagate_cov(filtered_cov,                                  measurement_matrix,                                  measurement_noise)   innovation = measurement - predicted_mean   innovation_cov = measurement_covariance   kalman_gain = _calculate_gain(predicted_cov,                                 innovation_cov)   updated_mean = predicted_mean + np.dot(kalman_gain, innovation)   updated_cov = predicted_cov
Code: def build_kalman_predict_step(get_transition_matrix_for_timestep,                            get_transition_noise_for_timestep,                            get_observation_matrix_for_timestep,                            get_observation_noise_for_timestep):       def predict_step(previous_means, previous_covariances, t):          previous_latent_mean, previous_latent_covariance = previous_means     previous_observation_covariance = previous_covariances      latent_mean = _propagate_mean(previous_latent_mean,                                   get_transition_matrix_for_timestep(t - 1),                                   get_transition_noise_for_timestep(t - 1))     latent_covariance = _propagate_covariance(         previous_latent_covariance,         get_transition_matrix_for_timestep(t - 1),         get_transition_noise_for_timestep(t - 1))     observation_mean = _propagate_mean(latent_mean,                                        get_observation_matrix_for_timestep(t),                                        get_observation_noise_for_timestep(t))     observation_covariance = _propagate_covariance(         previous_observation_covariance,         get_observation_matrix_for_timestep(
Code: def build_kalman_update(get_transition_matrix_for_timestep,                           get_transition_noise_for_timestep,                           get_observation_matrix_for_timestep,                           get_observation_noise_for_timestep):
Code: def build_kalman_sample_step(get_transition_matrix_for_timestep,                              get_transition_noise_for_timestep,                              get_observation_matrix_for_timestep,                              get_observation_noise_for_timestep,                              full_sample_and_batch_shape,                              stream,                              validate_args=False):       def sample_step(sampled_prev, t):          latent_prev, _ = sampled_prev      transition_matrix = get_transition_matrix_for_timestep(t - 1)     transition_noise = get_transition_noise_for_timestep(t - 1)      latent_pred = transition_matrix.matmul(latent_prev)     latent
Code: def _propagate_mean(mean, linop, dist):      return linop
Code: def _propagate_cov(cov, linop, dist):      # For linop A
Get the transition matrix for a single timestep.          :param tf.Tensor filtered_mean: The filtered mean of the state at the             previous timestep.         :param tf.Tensor filtered_cov: The filtered covariance of the state at             the previous timestep.         :param tf.Tensor predicted_mean: The predicted mean of the state at the             previous timestep.         :param tf.Tensor predicted_cov: The predicted covariance of the state at             the previous timestep.          :returns: tf.Tensor: The transition matrix for the current timestep. Code: def get_transition_matrix_for_timestep(self,                                             filtered_mean,                                             filtered_cov,                                             predicted_mean,                                             predicted_cov):         """         Get the transition matrix for a single timestep.          :param tf.Tensor filtered_mean: The filtered mean of the state at the             previous timestep.         :param tf.Tensor filtered_cov: The filtered covariance of the state at             the previous timestep.         :param tf.Tensor predicted_mean: The predicted mean of the state at the             previous timestep.         :param tf.Tensor predicted_cov: The predicted covariance of the state at             the previous timestep.          :returns: tf.Tensor: The transition matrix for the current timestep.         """         transition_matrix = self.transition_matrix_fn(             filtered_mean=filtered_mean,             filtered_cov=filtered_cov,
Code: def _joint_sample_n(self, n, seed=None):           with tf.name_scope("sample_n_joint"):       stream = seed_stream.SeedStream(           seed, salt="LinearGaussianStateSpaceModel_sample_n_joint")        sample_and_batch_shape = distribution_util.prefer_static_value(           tf.concat([[n], self.batch_shape_tensor()],                     axis=0))        # Sample the initial timestep from the prior.  Since we want       # this sample to have full batch shape (not just the batch shape       # of the self.initial_state_prior object which might in general be       # smaller), we augment the sample shape to include whatever       # extra batch dimensions are required.       with tf.control_dependencies(self.runtime_assertions):         initial_latent = self.initial_state_prior.sample(             sample_shape=_augment_sample_shape(                 self.initial_state_prior,                 sample_and_batch_shape,                 self.validate_args),             seed=stream())          # Add a dummy dimension so that matmul() does matrix-vector         # multiplication.         initial_latent = initial_latent[..., tf.newaxis]        initial_observation_matrix = (           self.get_observation_matrix_for_timestep(self.initial_step))       initial_observation_noise = (           self.get_observation_noise_for_timestep(self.initial_step))        initial_observation_pred = initial_observation_matrix.matmul(           initial_latent)       initial_observation = (initial_observation_pred +                              initial_observation_noise.sample(                                  sample_shape=_augment_sample_shape(                                      initial_observation_noise,                                      sample_and_batch_shape,                                      self.validate_args),                                  seed=stream())[..., tf.newaxis])        sample_step = build_kalman_sample_step(           self.get_transition_matrix_for_timestep,           self.get_transition_noise_for_timestep,           self.get_observation_matrix_for_timestep,           self.get_observation_noise_for_timestep,           full_sample_and_batch_shape=sample_and_batch_shape,           stream=stream,           validate_args=self.validate
Code: def __init__(self, *args, **kwargs):         """         Initialize the KalmanFilter          :param int n_dim_obs: Dimension of the observation space         :param int n_dim_state: Dimension of the state space         :param int n_dim_process: Dimension of the process noise         :param int n_dim_control: Dimension of the control input         :param int n_dim_measurement: Dimension of the measurement noise         :param bool log_likelihood: Whether to compute the log-likelihood         :param bool log_posterior: Whether to compute the log-posterior         :param bool log_marginal_likelihood: Whether to compute the log-marginal             likelihood         :param bool log_marginal_posterior: Whether to compute the log-marginal             posterior         :param bool log_marginal_likelihood_estimation: Whether to compute the             log-marginal likelihood estimation         :param bool log_marginal_posterior_estimation: Whether to compute the             log-marginal posterior estimation         :param bool log_marginal_likelihood_estimation_by_marginalization:             Whether to compute the log-marginal likelihood estimation by             marginalization         :param bool log_marginal_posterior_estimation_by_marginalization:             Whether to compute the log-marginal posterior estimation by             marginalization         :param bool log_marginal_likelihood_estimation_by_integration:             Whether to compute the log-marginal likelihood estimation by             integration         :param bool log_marginal_posterior_estimation_by_integration:             Whether to compute the log-marginal posterior estimation by             integration         :param bool log_marginal_likelihood_estimation_by_integration_and_marginalization:             Whether to compute the log-marginal likelihood estimation by             integration and marginalization         :param bool log_marginal_posterior_estimation_by_integration_and_marginalization:             Whether to compute the log-marginal posterior estimation by             integration and marginalization         :param bool log_marginal_likelihood_estimation_by_integration_and_marginalization_and_filtering:             Whether to compute the log-marginal likelihood estimation by             integration and marginalization and filtering         :param bool log_marginal_posterior_estimation_by_
Code: def _joint_covariance(self):           with tf.name_scope("covariance_joint"):        # The initial timestep is a special case, since we sample the       # latent state from the prior rather than the transition model.        with tf.control_dependencies(self.runtime_assertions):         # Broadcast to ensure we represent the full batch shape.         initial_latent_covariance = _broadcast_to_shape(             self.initial_state_prior.covariance()[..., tf.newaxis],             tf.concat([self.batch_shape_tensor(),                        [self.latent_size, 1, 1]], axis=0))        initial_observation_covariance = _propagate_covariance(           initial_latent_covariance,           self.get_observation_matrix_for_timestep(self.initial_step),           self.get_observation_noise_for_timestep(self.initial_step))        covariance_step = build_kalman_covariance_step(           self.get_transition_matrix_for_timestep,           self.get_transition_noise_for_timestep,           self.get_observation_matrix_for_timestep,           self.get_observation_noise_for_timestep)        # Scan over all timesteps following the initial step.       (latent_covariances, observation_covariances) = tf.scan(           covariance_step,           elems=tf.range(self.initial_step+1, self.final_step),           initializer=(initial_latent_covariance,                        initial_observation_covariance))        # Squish the initial step back on top of the other (scanned) timesteps       latent_covariances = tf.concat([initial_latent_covariance[tf.newaxis,...],                                       latent_covariances], axis=0)       observation_covariances = tf.concat([           initial_observation_covariance[tf.newaxis,...],           observation_covariances], axis=0)        # Put dimensions back in order. The samples we've computed have       # shape `[num_timesteps, batch_shape, size, size]`, where `size`       # is the dimension of the latent or observation spaces       # respectively, but we want to return values with shape       # `[batch
Code: def _joint_covariances(self):           with tf.name_scope("covariance_joint"):        with tf.control_dependencies(self.runtime_assertions):         initial_latent_cov = _broadcast_to_shape(             self.initial_state_prior.covariance(),             tf.concat([self.batch_shape_tensor(),                        [self.latent_size, self.latent_size]], axis=0))        initial_observation_cov = _propagate_cov(           initial_latent_cov,           self.get_observation_matrix_for_timestep(self.initial_step),           self.get_observation_noise_for_timestep(self.initial_step))        cov_step = build_kalman_cov_step(           self.get_transition_matrix_for_timestep,           self.get_transition_noise_for_timestep,           self.get_observation_matrix_for_timestep,           self.get_observation_noise_for_timestep)        # Scan over all timesteps following the initial step.       (latent_covs, observation_covs) = tf.scan(           cov_step,           elems=tf.range(self.initial_step+1, self.final_step),           initializer=(initial_latent_cov, initial_observation_cov))        # Squish the initial step back on top of the other (scanned) timesteps       latent_covs = tf.concat([initial_latent_cov[tf.newaxis,...],                                latent_covs], axis=0)       observation_covs = tf.concat([initial_observation_cov[tf.newaxis,...],                                     observation_covs], axis=0)        # Put dimensions back in order. The samples we've computed have       # shape `[num_timesteps, batch_shape, size, size]`, where `size`       # is the dimension of the state or observation spaces       # respectively, but we want to return values with shape       # `[batch_shape, num_timesteps, size, size]`.       latent_covs = distribution_util.move_dimension(latent_covs, 0, -3)       observation_covs = distribution_util.move_dimension(           observation_covs, 0, -3)       return
Code: def list_channel_webhooks(self, limit=None, page_size=None):         """         Lists ChannelWebhookInstance records from the API as a list.         Unlike stream(), this operation
Code: def _log_normalization(self):          event_dim = tf.compat.dimension_value(self.event_shape[0])     if event_dim is None:       raise ValueError('vMF _log_normalizer currently only supports '                       'statically known event shape')     safe_conc = tf.where(self.concentration > 0,                          self.concentration,                          tf.ones_like(self.concentration))     safe_lognorm = ((event_dim / 2 - 1) * tf.math.log(safe_conc) -                     (event_dim / 2) * np.log(2 * np.pi) -                     tf.math.log(_bessel_ive(event_dim / 2 - 1, safe_conc)) -                     tf.abs(safe_conc))     log_nsphere_surface_area = (         np.log(2.) + (event_dim / 2) *
Code: def _mode(self
Code: def _rotate(self, samples):          event_dim = (         tf.compat.dimension_value(self.event_shape[0]) or         self._event_shape_tensor()[0])     basis = tf.concat([[1.], tf.zeros([event_dim - 1], dtype=self.dtype)],                       axis=0),     u = tf.nn.l2_normalize(basis - self.mean_
2D von Mises Fisher distribution. Code: def _
Iterate over pages of results          :returns: Page of InviteInstance         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance] Code: def __getitem__(self, key):         """
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, service_sid, channel_sid):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def stream(self, limit=None, page_size=None):         """         Streams InviteInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until the limit         is reached.         The results are returned as a generator, so this operation is memory efficient.          :param int limit: Upper limit for the number of records to return. stream()                           guarantees to never return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, stream() will attempt to read the                               limit with the most efficient page size, i.e. min(limit, 1
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __str__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         return unicode(self).encode('utf
Code: def _get_samples(dist, z, n, seed):      with tf.compat.v1.name_scope('get_samples', values=[z, n]):     if (n is None) == (z is None):       raise ValueError(           'Must specify exactly one of arguments "n" and "z".  Found: '           'n = %s, z = %s' % (n, z))
:returns: Number of invites
Code: def _choose_base_case(is_accepted,                       accepted,                       rejected,                       name=None):      def _expand_is_accepted_like(x):          with tf.compat.v1.name_scope('expand_is_accepted_like'):       expand_shape = tf.concat([           tf.shape(input=is_accepted),           tf.ones([tf.rank(x) - tf.rank(is_accepted)], dtype=tf.int32),       ],                                axis=0)       multiples = tf.concat([           tf.ones([tf.rank(is_accepted)], dtype=tf.int32),           tf.shape(input=x)[tf.rank(is_accepted):],       ],                             axis=0)       m = tf.tile(tf.reshape(is_accepted, expand_shape),                   multiples)       m.set_shape(m.shape.
Code: def __getitem__(self, key):     """     Convenience method for accessing a single invited resource      :param unicode key: The sid      :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance     :rtype: twilio.rest.chat.v2.service.channel.invite.
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._invites = None         self._members = None         self._messages = None         self._webhooks = None      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = InviteList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._invites      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._
Code: def _value_and_gradients(fn, fn_arg_list, result=None, grads=None, name=None):      with tf.compat.v1.name_scope(name, 'value_and_gradients',                                [fn_arg_list, result, grads]):      def _convert_to_tensor(x, name):       ctt = lambda x_: x_ if x_ is None else tf.convert_to_tensor(           value=x_, name=name)       return [ctt(x_) for x_ in x] if is_list_like(x) else ctt(x)      fn_arg_list = (list(fn_arg_list) if is_list_like(fn_arg_list)                    else [fn_arg_list])     fn_arg_list = _convert_to_tensor(fn_arg_list, 'fn_arg')      if result is None:       result = fn(*fn_arg_list)       if grads is None and tf.executing_eagerly():         # Ensure we disable bijector cacheing in eager mode.         # TODO(b/72831017): Remove this once bijector cacheing is fixed for         # eager mode.         fn_arg_list = [0 + x for x in fn_arg_list]      result = _convert_to_tensor(result, 'fn_result')      if grads is not None:       grads = _convert_to_tensor(grads, 'fn_grad')       return result, grads      if is_list_like(result) and len(result) == len(fn_arg_list):       # Compute the block diagonal of Jacobian.       # TODO(b/79158574): Guard this calculation by an arg which explicitly       # requests block diagonal Jacobian calculation.       def fn_slice(i):                  return lambda x: fn(*(fn_arg_list[:i] + [x] + fn_arg_list[i+1:]))       grads = [           tfp_math_value_and_gradients(fn_slice(i), fn_arg_list[i])[1]           for i in range(len(result))       ]     else:       _, grads = tfp
Code: def maybe_call_fn_and_grads(fn,                             fn_arg_list,                             result=None,                             grads=None,                             check_non_none_grads=True,                             name=None):      with tf.compat.v1.name_scope(name,'maybe_call_fn_and_grads',                                [fn_arg_list, result, grads]):     fn_arg_list = (list(fn_arg_list) if is_list_like(fn_arg_list)                    else [fn_arg_list])     result, grads = _value_and_gradients(fn, fn_arg_list, result, grads)     if not all(r.dtype.is_floating                for r in (result if
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  by=values.unset, role_sid=values.unset, identity=values.unset,                  url=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['account_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'by': by,             'role_sid': role_sid,             'identity': identity,             'url': url,         }          self._solution = {             'account_sid': account_sid,            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property     def service_sid(self):         """         :returns: The SID of the Service that the resource is associated with         :rtype: unicode         """         return self._properties['service_sid']      @property     def channel_sid(self):         """         :returns: The SID of the Channel the resource belongs to         :rtype: unicode         """         return self._properties['channel_sid']      @property     def date_created(self):         """         :returns: The RFC 282
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def get_page(self, target_url):         """         Retrieve a specific page of InviteInstance records from the API.         Request is executed immediately          :param str target_url: API-generated URL for the requested results page          :returns: Page of InviteInstance         :rtype: twilio.rest.
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  identity=values.unset, role_sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  url=values.unset):         """         Initialize the InviteContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to         :param sid: The SID of the Invite resource to fetch          :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         super(InviteContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites/{sid}'.format(**self._solution)          # Dependents         self._channel = None         self._member = None          # Context         self._context = None         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid or self._properties['sid'], }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: The unique string that identifies the resource         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset,                  links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': None,            'service_sid': service_sid,             'channel_sid': channel_sid,             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property
Replaces the event shape in `input_tensorshape` with `event_shape_out`. Code
Code: def _validate_event_shape_in_tensorshape(     input_tensorshape, event_shape_in, event_shape_out):   """Validate that `event_shape_in` matches `event_shape_out`.    Args:     input_tensorshape: `TensorShape` of the input.     event_shape_in: `TensorShape` of the event shape of the input.     event_shape_out: `TensorShape` of the event shape of the output.    Returns:     `True` if `event_shape_in` matches `event_shape_out`, `False` otherwise.    Raises:     ValueError: if `event_shape_in` does not match `event_shape_out`.   """   event_shape_in_ = tf.get_static_value(event_shape_in)   if event_shape_in_ is None:     return True   event_shape_in_ = np.int32(
Code: def _maybe_check_valid_shape(shape, validate_args):      if not dtype_util.is_integer(shape.dtype):     raise TypeError('{} dtype ({}) should be `int`-like.'.format(         shape, dtype_util.name(shape.dtype)))    assertions = []    message = '`{}` rank should be <= 1.'   if tensorshape_util.rank(shape.shape) is not None:     if tensorshape_util.rank(shape.shape) > 1:       raise ValueError(message.format(shape))   elif validate_args:     assertions.append(assert_util.assert
Code: def converged_all(converged, failed):      return (tf.reduce_all
Code: def get_instance(self, payload):         """         Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         return InviteInstance(             self._version,             payload,             service_sid=self._solution['service_sid'],             channel_sid=self._solution['channel
Code: def _update_position(state, position_delta, objective_value,                          objective_gradient, grad_tolerance,                          f_relative_tolerance, x_tolerance):   """Update the position and return the new state."""   position_delta = tf.where(       state.failed,       tf.zeros_like(position_delta),       position_delta)   position = state.position + position_delta   objective_gradient = tf.where(       state.failed,       tf.zeros_like(objective_gradient),       objective_gradient)   objective_value = tf.where(       state.failed,       tf.zeros_like(objective_value),       objective_value)   converged = tf.reduce_all(       input_tensor=tf.logical_or(           tf.reduce_all(               input_tensor=tf.math.is_nan(position), axis=-1),           tf.reduce_all(               input_tensor=tf.math.is_nan(objective_value), axis=-1),           tf.reduce_all(               input_tensor=tf.math.is_nan(objective_gradient), axis=-1),           tf.reduce_all(               input_tensor=tf.math.is_inf(position), axis=-1),           tf.reduce_all(               input_tensor=tf.math.is_inf(objective_value), axis=-1),           tf.reduce_all(               input_tensor=tf.math.is_inf(objective_gradient), axis=-1),           tf.reduce_all(               input_tensor=tf.math.is_finite(position), axis=-1),           tf.reduce_all(               input_tensor=tf.math.is_finite(objective_value), axis=-1),           tf.reduce_all(               input_tensor=tf.math.is_finite(objective_gradient), axis=-1),           tf.reduce_all(               input_tensor=tf.math.is_finite(position_delta), axis=-1),           tf.reduce_all(               input_tensor=tf.math.is_finite(objective_gradient), axis=-1),           tf.reduce_all(               input_tensor=tf.math.is_finite(objective_value), axis=-1),           tf.reduce_all(               input_tensor
Code: def _restrict_along_direction(value_and_gradients_function,                               position,                               direction):      def _restricted_func(t):     t = _broadcast(t, position)     pt = position + tf.expand_dims(t, axis=-1) * direction     objective_value, gradient = value_and_gradients_function(pt)     return ValueAndGradient(         x=t,         f=objective_value,         df=
Code: def _check_convergence(position,                            next_position,                            objective_value,                            next_objective,                            objective_gradient,                            grad_tolerance,                            f_relative_tolerance,                            x_tolerance):   """   Check if the position has converged.    :param position: Current position.   :param next_position: Next position.   :param objective_value: Current objective value.   :param next_objective: Next objective value.   :param objective_gradient: Current objective gradient.   :param grad_tolerance: Gradient tolerance.   :param f_relative_tolerance: Relative tolerance for the objective function.   :param x_tolerance: Tolerance for the position.   :return: True if the position has converged, False otherwise.   """   converged = tf.reduce_all(       input_tensor=tf.math.is_finite(position) & tf.math.is_finite(           next_position) & tf.math.is_finite(objective_value) &       tf.math.is_finite(next_objective) & tf.math.is_finite(           objective_gradient))   converged = converged & tf.reduce_all(       input_tensor=tf.math.is_finite(position) & tf.math.is_finite(           next_position) & tf.math.is_finite(objective_value) &       tf.math.is_finite(next_objective) & tf.math.is_finite(           objective_gradient))   converged = converged & tf.reduce_all(       input_tensor=tf.math.is_finite(position) & tf.math.is_finite(           next_position) & tf.math.is_finite(objective_value) &       tf.math.is_finite(next_objective) & tf.math.is_finite(           objective_gradient))   converged = converged & tf.reduce_all(       input_tensor=tf.math.is_finite(position) & tf.math.is_finite(           next_position) & tf.math.is_finite(objective_value) &       tf.math.is_finite(next_objective) & tf.math.is_finite(           objective_gradient))   converged = converged & tf.reduce_all(       input_
Code: def _check_convergence(current_position,                        next_position,                        current_objective,                        next_objective,                        next_gradient,                        grad_tolerance,                        f_relative_tolerance,                        x_tolerance):      grad_converged = norm(next_gradient, dims=
Code: def _broadcast(value, target):      return tf.broadcast_to(       tf.convert_to_tensor(value=value, dtype=target.dtype),       distribution
Code: def _harmonic_number(x):      one = tf.ones([], dtype=x.dtype)   return tf.math.digamma(x
Code: def default_exchange_proposed_fn_(num_replica, seed=None):          seed_stream = distributions.SeedStream(seed, 'default_exchange_proposed_fn')      zero_start = tf.random.uniform([], seed=seed_stream()) > 0.5     if num_replica % 2 == 0:        def _exchange():         flat_exchange = tf.range(num_replica)         if num_replica > 2:           start = tf.cast(~zero_start, dtype=tf.int32)           end = num_replica - start           flat_exchange = flat_exchange[start:end]         return tf.reshape(flat_exchange, [tf.size(input=flat_
Code: def _get_field(kernel_results, field_name):      if hasattr(kernel_results, field_
Get the results of a replica.          Args:           replica_id: Replica id.          Returns:           A list of results. Code: def _get_replica_log_probs(self, replica_id):     """Get the log probs of a replica.      Args:       replica_id: Replica id.      Returns:       A list of log probs.     """     replica_log_probs = []     for log_
Code: def _variance_scale_term(self):          # Expand back the last dim so the shape of _variance_scale_term matches the     # shape of self
Converts a channel_unique_name to a Channel resource's sid if it is a         Channel resource's sid or a Channel resource's unique_name.          :param str channel_unique_name: The channel_sid or unique_name of the         Channel resource to fetch.          :returns: The sid of the Channel resource.         :rtype: str Code: def _get_channel_sid_or_unique_name(self, channel_sid_or_unique_name):         """         Converts a channel_sid_or_unique_name to a Channel resource's sid if it         is a Channel resource's sid or a Channel resource's unique_name.          :param str channel_sid_or_unique_name: The channel_sid or unique_name of         the Channel resource to fetch.          :returns: The sid of the Channel resource.         :rtype: str         """         if isinstance(channel
Initialize the InvitePage          :param Version version: Version that contains the resource         :param dict payload: A JSON response from the Twilio API          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def __init__(self, version, response, service_sid, channel_sid):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs
Get an item from the list of resources in the response.          :returns: An instance of the resource at the given index, or None if
Transforms the state from the unconstrained space to the constrained         space.          Args:           state_part: A `Tensor` representing the unconstrained state part.          Returns:           A `Tensor` representing the constrained state part. Code: def _forward
Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param dict payload: A JSON response from the Twilio API          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init__(version, response=payload, service_sid=service_sid, channel_sid=channel_sid)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._context      @property     def invites(self):         """         :returns: The list of invites         :rtype: unicode         """         return self._properties['invites']      @property     def has_more(self):         """         :returns: True if this page has another page of items available, otherwise False         :rtype: bool         """         return self._properties['has_more']      @property     def url(self):         """         :returns: The URL of this page         :rtype: unicode         """         return self._properties['url']      def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         return '<Twilio.IpMessaging.V2.InvitePage>'   class InviteContext(InstanceContext):     """ PLEASE NOTE that this class contains preview products that are subject     to change. Use them with caution. If you currently do not have developer     preview access, please contact <EMAIL>. """      def __init__(self,
Compute the secant of two values.          :param left: Left value         :type left: float         :param right: Right value         :type right: float          :returns: secant of left and right         :rtype: float Code: def _secant
Apply the `update` function on active branch members to squeeze their         bracketing interval.          :param callable value_and_gradients_function: Function that returns the             value and gradients of the function to be minimized.         :param _Secant2Result initial_args: Initial arguments.         :param tf.Tensor val_c: Current value of `c`.         :param tf.Tensor f_lim: Limit on the function value.         :param float sufficient_decrease_param: Sufficient decrease parameter.         :param float curvature_param: Curvature parameter.          :returns: _Secant2Result         :rtype: _Secant2Result Code: def _secant2_inner_update(value_and_gradients_function,                               initial_args,                               val_0,                               val_c,                               f_lim,                               sufficient_decrease_param,                               curvature_param):   # Apply the `update` function on active branch members to squeeze their   # bracketing interval.   update_result = update(value_and_gradients_function,                          initial_args.left,                          initial_args.right,                          val_c,                          f_lim,                          active=initial_args.active)    # Update active and failed flags, update left/right on non-failed entries.   active = initial_args.active & ~update_result.failed   failed = initial_args.failed | update_result.failed   val_left = val_where(active, update_result.left, initial_args.left)   val_right = val_where(active, update_result.right, initial_args.right)    # Check if new `c` points should be generated.   updated_left = active & tf.equal(val_left.x, val_c.x)   updated_right = active & tf.equal(val_right.x, val_c.x)   is_new = updated_left | updated_right    next_c = tf.where(updated_left,                     _secant(initial_args.left, val_left),                     val_c.x)   next_c = tf.where(updated_right,                     _secant(initial_args.right, val_right),                     next_c)   in_range = (val_left.x <= next
Code: def _secant2_inner_update(value_and_gradients_function,                           initial_args,                           val_0,                           val_c,                           f_lim,                           sufficient_decrease_param,                           curvature_param):      # Fail if `val_c` is no longer finite.   new_failed = initial_args.active & ~is_finite(val_c)   active = initial_args.active & ~new_failed   failed = initial_args.failed | new_failed    # We converge when we find a point satisfying the Wolfe conditions, in those   # cases we set `val_left = val_right = val_c`.   found_wolfe = active & _satisfies_wolfe(       val_0, val_c, f_lim, sufficient_decrease_param, curvature_param)   val_left = val_where(found_wolfe, val_c, initial_args.left)   val_right = val_where(found_wolfe, val_c, initial_args.right)   converged = initial_args.converged | found_wolfe   active = active & ~found_wolfe    # If any active batch members remain, we apply the `update` function to   # squeeze further their corresponding left/right bracketing interval.   def _apply_update():     update_result = update(         value_and_gradients_function, val_left, val_right, val_c, f_lim,         active=active)     return _Secant2Result(         active=tf.zeros_like(active),  # End of secant2, no actives anymore.         converged=converged,         failed=failed | update_result.failed,         num_evals=initial_args.num_evals + update_result.num_evals,         left=update_result.left,         right=update_result.right)    # Otherwise just return the current results.   def _default():     return _Secant2Result(         active=active,         converged=converged,         failed=failed,         num_evals=initial_args.num_evals,         left=val_left,         right=val_right)    return prefer_static.
Code: def __init__(self, service_sid, channel_sid, version):         """         Initialize the InviteList          :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the new resource belongs to         :param version: Version that contains the resource          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def create(self, identity, role_sid=values.unset,                type=values.unset, ttl=values.unset,                attributes=values.unset):         """         Create the InviteInstance          :param unicode identity: The `identity` value that identifies the new resource's User         :param unicode role_sid: The SID of the Role to assign to the new resource         :param unicode type: The type of push notification to use. Can be: `gcm` or `apn`.         :param unicode ttl: The time-to-live of the notification, in seconds.         :param unicode attributes: An optional string metadata field you can use to store any data you wish.          :returns: The created InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         data = values.of({             'Identity': identity,             'RoleSid': role_sid,             'Type': type,             'Ttl': ttl,             'Attributes': attributes,         })          payload = self._version.create(             'POST',             self._uri,             data=data,         )          return InviteInstance(             self._version,             payload,             service_sid=self._solution['service_sid'],             channel_sid=self._solution['channel_sid'],         )      def stream(self, limit=None, page_size=None):         """         Streams InviteInstance records from the API as a generator stream.         This operation lazily loads
Code: def _bisect(value_and_gradients_function, search_interval, f_lim):   """   Bisection algorithm to find a minimum of a function.    :param value_and_gradients_function: Function to be minimized.   :type value_and_gradients_function: callable   :param search_interval: Initial interval to search.   :type search_interval: _IntermediateResult   :param f_lim: Maximum value of the objective function.   :type f_lim: float   :returns: _IntermediateResult   :rtype: _IntermediateResult   """   already_stopped = search_interval.failed | search_interval.converged    # If the slope at right end point is positive, step B1 in [2], then the given   # initial points already bracket a minimum.   bracketed = search_interval.right.df >= 0    # Bisection is needed, step B2, if right end point almost works as a new left   # end point but the objective value is too high.   needs_bisect = (       search_interval.right.df < 0) & (search_interval.right.f > f_lim)    # In these three cases bracketing is already `stopped` and there is no need   # to perform further evaluations. Otherwise the bracketing loop is needed to   # expand the interval, step B3, until the conditions are met.   initial_args = _IntermediateResult(       iteration=search_interval.iterations,       stopped=already_stopped | bracketed | needs_bisect,       failed=search_interval.failed,       num_evals=search_interval.func_evals,       left=search_interval.left,       right=search_interval.right)    def _loop_cond(curr):     return (curr.iteration <             max_iterations) & ~tf.reduce_all(input_tensor=curr.stopped)    def _loop_body(curr):          # The loop maintains the invariant that curr.stopped is true if we have     # either: failed, successfully bracketed, or not yet bracketed but needs     # bisect. On the only remaining case, step B3 in [2]. case we need to     # expand and update the left/right values appropriately.     new_right = value_and_gradients_function(0.5 *
Code: def _bisect(value_and_gradients_function,            bisect_args,            f_lim):   """   Bisection algorithm for finding the root of a function.    Args:     value_and_gradients_function: A callable that takes a single argument       and returns a tuple of the value of the function and its gradient.     bisect_args: A namedtuple containing the following fields:       iteration: The current iteration number.       stopped: A boolean tensor indicating whether the bisection algorithm         should stop.       failed: A boolean tensor indicating whether the bisection algorithm         failed to converge.       num_evals: The number of function evaluations performed.       left: A namedtuple containing the following fields:         x: The left endpoint of the interval.         df: The derivative of the function at the left endpoint.         f: The value of the function at the left endpoint.       right: A namedtuple containing the following fields:         x: The right endpoint of the interval.         df: The derivative of the function at the right endpoint.         f: The value of the function at the right endpoint.    Returns:     A namedtuple containing the following fields:       iteration: The current iteration number.       stopped: A boolean tensor indicating whether the bisection algorithm         should stop.       failed: A boolean tensor indicating whether the bisection algorithm         failed to converge.       num_evals: The number of function evaluations performed.       x: The root of the function.       df: The derivative of the function at the root.       f: The value of the function at the root.   """   def _bisect_step(bisect_args):     """     Performs a single iteration of the bisection algorithm.      Args:       bisect_args: A namedtuple containing the following fields:         iteration: The current iteration number.         stopped: A boolean tensor indicating whether the bisect algorithm           should stop.         failed: A boolean tensor indicating whether the bisect algorithm           failed to converge.         num_evals: The number of function evaluations performed.         left: A namedtuple containing the following fields:           x: The left endpoint of the interval.           df: The derivative of the function at the left endpoint.           f: The value of the function at the left endpoint.         right: A namedtuple containing the following fields:           x: The right endpoint of
Code: def _bisect(value_and_gradients_function, initial_args, f_lim):      def _loop_cond(curr):     # TODO(b/112524024): Also take into account max_iterations.     return ~tf.reduce_all(input_tensor=curr.stopped)    def _loop_body(curr):          mid = value_and_gradients_function((curr.left.x + curr.right.x) / 2)      # Fail if function values at mid point are no longer finite; or left/right     # points are so close to it that we can't distinguish them any more.     failed = (curr.failed | ~is_finite(mid) |               tf.equal(mid.x, curr.left.x) | tf.equal(mid.x, curr.right.x))      # If mid point has a negative slope and the function value at that point is     # small enough, we can use it as a new left end point to narrow down the     # interval. If mid point has a positive slope, then we have found a suitable     # right end point to bracket a minima within opposite slopes. Otherwise, the     # mid point has a negative slope but the function value at that point is too     # high to work as left end point, we are in the same situation in which we     # started the loop so we just update the right end point and continue.     to_update = ~(curr.stopped | failed)     update_left = (mid.df < 0) & (mid.f <= f_lim)     left = val_where(to_update & update_left, mid, curr.left)     right = val_where(to_update & ~update_left, mid, curr.right)      # We're done when the right end point has a positive slope.     stopped = curr.stopped | failed | (right.df >= 0)      return [_IntermediateResult(         iteration=curr.iteration,         stopped=stopped,         failed=failed,         num_evals=curr.num_evals + 1,         left=left,         right=right)]    # The interval needs updating if the right end point has a negative slope and   # the value of the function at that point is too high. It is not a valid left   #
Code: def is_finite(val_1, val_2=None):      val_1_finite = tf.math.is_finite(val_1.f) & tf.math.is_finite(val_1.df)   if val_2 is
Update the current iterate at the start of the next iteration.          :param val_c: Current value of the objective function         :type val_c: Val Code: def _update_x_c(self, val_c):   """   Update the current iterate at the start of the next iteration
Code: def _secant(val_a, val_b):
Code: def make_simple_step_size_update_policy(num_adaptation_steps,                                         target_rate=0.75,                                         decrement_multiplier=0.01,                                         increment_multiplier=0.01,                                         step_counter=None):      if step_counter is None and num_adaptation_steps is not None:     step_counter = tf.compat.v1.get_variable(         name='step_size_adaptation_step_counter',         initializer=np.array(-1, dtype=np.int32),         # Specify the dtype for variable sharing to work correctly         # (b/120599991).         dtype=tf.int32,         trainable=False,         use_resource=True)    def step_size_simple_update_fn(step_size_var, kernel_results):           if kernel_results is None:       if mcmc_util.is_list_like(step_size_var):         return [tf.identity(ss) for ss in step_size_var]       return tf.identity(step_size_var)     log_n = tf.math.log(         tf.cast(             tf.size(input=kernel_results.log_accept_ratio),             kernel_results.log_accept_ratio.dtype))     log_mean_accept_ratio = tf.reduce_logsumexp(         input_tensor=tf.minimum(kernel_results.log_accept_ratio, 0.)) - log_n     adjustment = tf.where(         log_mean_accept_ratio < tf.cast(             tf.math.log(target_rate), log_mean_accept_ratio.dtype),         -decrement_multiplier / (1. + decrement_multiplier),         increment_multiplier)      def build_assign_op():       if mcmc_util.is_list_like(step_size_var):         return [             ss.assign_add(ss * tf.cast(adjustment, ss.dtype))             for ss in step_size_var         ]       return step_size_var.assign_add(           step_size_var * tf.cast(adjustment, step_size_var.dtype))      if num_adaptation_steps is None:       return
Code: def _leapfrog_integrator_one_step(     target_log_prob_fn,     independent_chain_ndims,     step_sizes,     current_momentum_parts,     current_state_parts,     current_target_log_prob,     current_target_log_prob_grad_parts,     state_gradients_are_stopped=False,     name=None):      # Note on per-variable step sizes:   #   # Using per-variable step sizes is equivalent to using the same step   # size for all variables and adding a diagonal mass matrix in the   # kinetic energy term of the Hamiltonian being integrated. This is   # hinted at by Neal (2011) but not derived in detail there.   #   # Let x and v be position and momentum variables respectively.   # Let g(x) be the gradient of `target_log_prob_fn(x)`.   # Let S be a diagonal matrix of per-variable step sizes.   # Let the Hamiltonian H(x, v) = -target_log_prob_fn(x) + 0.5 * ||v||**2.   #   # Using per-variable step sizes gives the updates   # v'  = v  + 0.5 * matmul(S, g(x))   # x'' = x  + matmul(S, v')   # v'' = v' + 0.5 * matmul(S, g(x''))   #   # Let u = matmul(inv(S), v).   # Multiplying v by inv(S) in the updates above gives the transformed dynamics
Code: def _compute_log_acceptance_correction(current_momentums,                                        proposed_momentums,                                        independent_chain_ndims,                                        name=None):      with tf.compat.v1.name_scope(       name, 'compute_log_acceptance_correction',       [independent_chain_ndims, current_momentums, proposed_momentums]):     log_current_kinetic, log_proposed_kinetic = [], []     for current_momentum, proposed_momentum in zip(         current_momentums, proposed_momentums):       axis = tf.range(independent_chain_ndims, tf.rank(current_momentum))       log_current_kinetic.append(_log_sum_sq(current_momentum, axis))       log_proposed_kinetic.append(_log_sum_sq(proposed_momentum, axis))     current
Code: def __init__(self,                  target_log_prob_fn,                  step_size,                  num_leapfrog_steps,                  step_size_update_fn=None,                  state_gradients_are_stopped=False,                  name=None):         """Construct a new Hamiltonian Monte Carlo transition kernel.          Args:           target_log_prob_fn: Python callable which takes an argument like             `current_state` (or `*current_state` if it's a list) and returns its             (possibly unnormalized) log-density under the target distribution.           step_size: `Tensor` or Python `list` of `Tensor`s representing the             step size for the leapfrog integrator. Must broadcast with the shape             of `current_state`. Larger step sizes lead to faster progress, but             too-large step sizes make rejection exponentially more likely. When             possible, it's often helpful to match per-variable step sizes to the             standard deviations of the target distribution in each variable.           num_leapfrog_steps: Python `int` number of steps to run the leapfrog             integrator for. Total progress per HMC step is roughly proportional             to `step_size * num_leapfrog_steps`.           step_size_update_fn: Python callable which takes a `Tensor` or Python             `list` of `Tensor`s representing the current step size and returns a             `Tensor` or Python `list` of `Tensor`s representing the new step size.             If `None`, no step size adaptation will be performed.           state_gradients_are_stopped: Python `bool` indicating whether gradients             should be computed for the state variables. If `True`, gradients will             not be computed for the state variables, and the returned kernel will             not be differentiable.           name: Python `str` name prefixed to Ops created by this function.             Default value: `None` (i.e., 'hmc').         """         self._target_log_prob_fn = target_log_prob_fn         self._step_size = step_size         self._num_leapfrog_steps = num_leapfrog_steps         self._step_size_update_fn = step_size_update_fn         self._state_gradients_are
Bootstrap the results of the HMC kernel.          :param init_state: Initial state of the chain.         :type init_state: `~numpy.ndarray`         :
ResNet block. Code: def _resnet_block(x, filters, kernel_size, strides, kernel_posterior_fn):   """ResNet block."""   x = tfp.layers.Convolution2DFlipout(       filters,       kernel_size,       strides=strides,       padding='same',       kernel_posterior_fn=kernel_posterior_fn)(x)   x = tf.keras.layers.BatchNormalization()(x)   x = tf.keras.layers.Activation('relu')(x)   x = tfp.layers.Convolution2DFlip
Code: def _resnet_block(x, filters, kernel, stride, kernel_posterior_fn):      x = tf

Code: def make_decoder(num_topics, num_words):      topics_words_logits = tf.compat.v1.get_variable(       "topics_words_logits",       shape=[num_topics, num_words],       initializer=tf.compat.v1.glorot_normal_initializer())   topics_words = tf.nn.softmax(topics_words_logits, axis=-1)    def decoder(topics):     word_probs = tf.matmul(topics, topics_words)     # The observations are bag of words and therefore not one-hot. However,     # log_prob of OneHot
Retrieve the service sid from the service_sid or service_unique_name          :param str service_sid: Service sid         :param str service_unique_name: Service unique name          :returns: str         :rtype: str Code: def _get_user_sid(self, user_sid):         """         Retrieve the user sid from the user_sid or user_unique_name          :param str user_sid: User sid         :param str user_unique_name: User unique name          :returns: str         :rtype: str         """         if user_sid:             return user_sid         if user_unique_name:             return self._version.chat.users.stream(                 user_unique_name=user_unique_name).first().sid         raise ValueError(             'Either user_sid or user_unique_name must
Code: def sample_chain(     num_results,     current_state,     previous_kernel_results=None,     kernel=None,     num_burnin_steps=0,     num_steps_between_results=0,     trace_fn=lambda current_state, kernel_results: kernel_results,     return_final_kernel_results=False,     parallel_iterations=10,     name=None, ):      if not kernel.is_calibrated:     warnings.warn("supplied `TransitionKernel` is not calibrated. Markov "                   "chain may not converge to intended target distribution.")   with tf.compat.v1.name_scope(       name, "mcmc_sample_chain",       [num_results, num_burnin_steps, num_steps_between_results]):     num_results = tf.convert_to_tensor(         value=num_results, dtype=tf.int32, name="num_results")     num_burnin_steps = tf.convert_to_tensor(         value=num_burnin_steps, dtype=tf.int32, name="num_burnin_steps")     num_steps_between_results = tf.convert_to_tensor(         value=num_steps_between_results,         dtype=tf.int32,         name="num_steps_between_results")     current_state = tf.nest.map_structure(         lambda x: tf.convert_to_tensor(value=x, name="current_state"),         current_state)     if previous_kernel_results is None:       previous_kernel_results = kernel.bootstrap_results(current_state)      if trace_fn is None:       # It simplifies the logic to use a dummy function here.       trace_fn = lambda *args: ()       no_trace = True     else:       no_trace = False     if trace_fn is sample_chain.__defaults__[4]:       warnings.warn("Tracing all kernel results by default is deprecated. Set "                     "the `trace_fn` argument to None (the future default "                     "value) or an explicit callback that traces the values "                     "you are interested in.")      def _trace_scan_fn(state_and_results, num_steps):
Code: def __init__(self, version, response, service_sid, channel_sid):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init__(version, response)          # Path Solution         self._solution = {'service_sid': service
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, service_sid, sid):         """         Initialize the ChannelContext          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)         # Path Solution         self._solution = {'service_sid': service_sid,'sid': sid, }         self._uri = '/Services/{service_sid}/Channels/{sid}'.format(**self._solution)
Get the channel sid from the channel name          :param str channel_name: The channel name          :returns: The channel sid         :rtype: str Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  by=values.unset, from_=values.unset, to=values.unset,                  body=values.unset, url=values.unset, links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites/{sid}'.format(**self._solution)                  self._properties = {'sid': sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'by': by, 'from': from_, 'to': to, 'body': body, 'url': url, 'links': links, }                  self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites/{sid}'.format(**self._solution)                  self._context = None         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid or self._properties['sid'], }          @property     def sid(self):         """         :returns: The unique string that identifies the resource
Code: def load_nips2011_papers(path):      path = os.path.expanduser(path)   filename = "NIPS_1987-2015.csv"   filepath = os.path.join(path, filename)   if not os.path.exists(
Code: def _validate_args(self, amplitude, length_scale):     if amplitude is not None:         amplitude = tf.convert
Code: def _registered_kl(type_a, type_b):      hierarchy_a = tf_inspect.getmro(type_a)   hierarchy_b = tf_inspect.getmro(type_b)   dist_to_children = None   kl_fn = None   for mro_to_a, parent_a in enumerate(hierarchy_a):     for mro_to_b, parent_b in enumerate(hierarchy_b):       candidate_dist = mro_to
Code: def read_image(filepath):      im_bytes = tf.io.read_file(filepath)   im = tf.image.decode_image(im_bytes, channels=CHANNELS)   im = tf.image.convert_image_dtype(im, tf.float32)   return
Returns the
Code: def create_character(skin, hair, top, pants):      dtype = skin.dtype   hair_mask = tf.cast(hair[..., -1:] <= 0, dtype)   top_mask = tf.cast(top[..., -1:] <= 0, dtype)   pants_mask = tf.cast(pants[..., -1:] <= 0, dtype)   char = (skin * hair_mask) + hair   char = (char * top_mask) + top   char = (char * pants_mask
Code: def create_seq(character, action_metadata, direction, length=8, start=0):      sprite_start = (action_metadata[0]+direction) * FRAME_SIZE   sprite_end = (action_metadata[0]+direction+1) * FRAME_SIZE   sprite_line = character[sprite_start:sprite_end,...]    # Extract 64x64 patches that are side-by-side in the sprite, and limit   # to the actual number of frames for the given action.   frames = tf.stack(tf.split(sprite_line, 13, axis=1))  # 13 is a hack   frames = frames[0:action_metadata[1]]    # Extract a slice of the desired length.   # NOTE: Length could be longer than the number of frames, so tile as needed.   frames = tf.roll(frames, shift=-start, axis=0)   frames = tf.tile(frames, [2, 1, 1, 1])  #
Create a sequence of actions.          :param character: The character to use for
Code: def create_sprites_dataset(characters, actions, directions, channels=3,                            length=8, shuffle=False, fake_data=False):      if fake_data:     dummy_image = tf.random.normal([HEIGHT, WIDTH, CHANNELS])   else:     basedir = download_sprites()    action_names = [action.name for action in actions]   action_metadata = [(action.start_row, action.frames) for action in actions]    direction_rows = [direction.row_offset for direction in directions]    chars = tf.data.Dataset.from_tensor_slices(characters)   act_names = tf.data.Dataset.from_tensor_slices(action_names).repeat()   acts_metadata = tf.data.Dataset.from_tensor_slices(action_metadata).repeat()   dir_rows = tf.data.Dataset.from_tensor_slices(direction_rows).repeat()    if shuffle:     chars = chars.shuffle(len(characters))    dataset = tf.data.Dataset.zip((chars, act_names, acts_metadata, dir_rows))    skin_table = tf.contrib.lookup.index_table_from_tensor(sorted(SKIN_COLORS))   hair_table = tf.contrib.lookup.index_table_from_tensor(sorted(HAIRSTYLES))   top_table = tf.contrib.lookup.index_table_from_tensor(sorted(TOPS))   pants_table = tf.contrib.lookup.index_table_from_tensor(sorted(PANTS))   action_table = tf.contrib.lookup.index_table_from_tensor(sorted(action_names))    def process_example(attrs, act_name, act_metadata, dir_row_offset):          skin_name = attrs[0]     hair_name = attrs[1]     top_name = attrs[2]     pants_name = attrs[3]      if fake_data:       char = dummy_image     else:       skin = read_image(basedir + os.sep + skin_name)       hair = read_image(basedir + os.sep + hair_name)       top = read_image(basedir + os.sep + top_name)       pants = read_image(basedir + os.
Code: def _maybe_validate_distributions(distributions, dtype_override, validate_args):      assertions = []    if not _is_iterable(distributions) or not distributions:     raise ValueError('`distributions` must be a list of one or more '                      'distributions.')    if dtype_override is None:     dts = [         dtype_util.base_dtype(d.dtype)         for d in distributions         if d.dtype is not None     ]     if dts[1:]!= dts[:-1]:       raise TypeError('Distributions must have same dtype; found: {}.'.format(           set(dtype_util.name(dt) for dt in dts)))    # Validate event_ndims.   for d in distributions:     if tensorshape_util.rank(d.event_shape) is not None:       if tensorshape_util.rank(d.event_shape)!= 1:         raise ValueError('`Distribution` must be vector variate, '                          'found event nimds: {}.'.format(                              tensorshape_util.rank(d.event_shape)))     elif validate_args:       assertions.append(           assert_util.assert_equal(               1, tf.size(input=d.event_shape_tensor()),               message='`Distribution` must be vector variate.'))    batch_shapes = [d.batch_shape for d in distributions]   if all(tensorshape_util.is_fully_defined(b) for b in batch_shapes):     if batch_shapes[1:]!= batch_shapes[:-1]:       raise ValueError('Distributions must have the same `batch_shape`; '                        'found: {}.'.format(batch_shapes))   elif validate_args:     batch_shapes = [         tensorshape_util.as_list(d.batch_shape)  # pylint: disable=g-complex-comprehension         if tensorshape_util.is_fully_defined(d.batch_shape) else         d.batch_shape_tensor() for d in distributions     ]     assertions.extend(         assert_util.assert_equal(  # pylint: disable=g-complex-comprehension             b1, b2,             message='Distribution `batch_shape`s must be identical.')         for b1, b2 in zip(batch_shapes[1:],
Returns the size of the kernel.          :param stride: The stride of
Code: def _flatten_multip
Code: def build_fake_data():      num_examples = 10   x_train = np.random.rand(num_examples, *IMAGE_SHAPE).astype(np.float32)   y_train = np.
Returns the number of dimensions of a tensor, or None if it's dynamic. Code: def _move_dims_to_flat_end(tensor,                                dims,                                ndims,                                right_end=True,                                name=None):   """Moves the dimensions in `dims` to the end of the tensor.    Args:     tensor: A `Tensor`.     dims: A list of ints, the dimensions to move.     ndims: The number of dimensions in `tensor`.     right_end: If True, move the dimensions to the right end of the tensor,       otherwise
Get a member instance          :param str identity: Identity          :returns: twilio.rest.chat.v2.service.channel.member.MemberInstance         :rtype: twilio.rest.chat.v2
Code: def histogram(x,               edges,               axis=None,               extend_lower_interval=False,               extend_upper_interval=False,               dtype=None,               name=None):      with tf.compat.v1.name_scope(name, 'histogram', values=[x, edges, axis]):      # Tensor conversions.     in_dtype = dtype_util.common_dtype([x, edges], preferred_dtype=tf.float32)      x = tf.convert_to_tensor(value=x, name='x', dtype=in_dtype)     edges = tf.convert_to_tensor(value=edges, name='edges', dtype=in_dtype)      # Move dims in axis to the left end as one flattened dim.     # After this, x.shape = [n_samples] + E.     if axis is None:       x = tf.reshape(x, shape=[-1])     else:       x_ndims = _get_static_ndims(           x, expect_static=True, expect_ndims_at_least=1)       axis = _make_static_axis_non_negative_list(axis, x_ndims)       if not axis:         raise ValueError('`axis` cannot be empty.  Found: {}'.format(axis))       x = _move_dims_to_flat_end(x, axis, x_ndims, right_end=False)      # bins.shape = x.shape = [n_samples] + E,     # and bins[i] is a shape E Tensor of the bins that sample `i` fell into.     # E is the "event shape", which is [] if axis is None.     bins = find_bins(         x,         edges=edges,         # If not extending intervals, then values outside the edges will return         # -1, which gives an error when fed to bincount.         extend_lower_interval=extend_lower_interval,         extend_upper_interval=extend_upper_interval,         dtype=tf.int32)      # TODO(b/124015136) Use standard tf.math.bincount once it supports `axis`.     counts = count_integers(         bins,         # Ensure we get correct output, even if x did not fall into
Code: def __init__(self,                  name,
Code: def _get_static_ndims(x,                       expect_static=False,                       expect_ndims=None,                       expect_ndims_no_more_than=None,                       expect_ndims_at_least=None):      ndims = x.shape.ndims   if ndims is None:     shape_const = tf.get_static_value(tf.shape(input=x))     if shape_const is not None
Code: def _insert_back_keep_dims(x, axis):      for i in sorted(axis):     x = tf.expand_
Code: def _make_static_axis_non_negative_list(axis, ndims):      axis = distribution_util.make_non_negative_axis(axis, ndims)    axis_const = tf.get_static_value(axis)   if axis_const is None:     raise ValueError(         'Expected argument `axis` to be statically available.  Found: %s' %
Code: def _move_dims_to_flat_end(x, axis, x_ndims, right_end=True):       if not axis:     return x    # Suppose x.shape = [a, b, c, d]   # Suppose axis = [1, 3]    # other_dims = [0, 2] in example above.   other_dims = sorted(set(range(x_ndims)).difference(axis))   # x_permed.shape = [a, c, b, d]   perm = other_dims + list(axis) if right_end else list(axis) + other_dims   x_permed = tf.transpose
Code: def _sort_tensor(tensor):      sorted_, _ = tf.nn.top_k(tensor, k=tf.shape(input=tensor)[-1])
Convert a list of parameter values to a map from parameter name to value.          :param list param_vals: List of parameter values.          :returns: dict         :rtype: dict Code: def _default_param_vals(self):     """     Return the default parameter
Retrieve the channel sid from the channel_sid or channel_unique_name          :param str channel_sid: The channel_sid         :param str channel_unique_name: The channel_unique_name          :returns: The channel sid         :rtype: str Code: def _get_service_sid(self, service_sid):         """         Retrieve the service sid from the service_sid or service_unique_name          :param str service_sid: The service_sid         :param str service_unique_name: The service_unique_name          :returns: The service sid         :rtype: str         """         if service_sid:             return service_sid         if service_unique_name:             return self._version.service.service_sid_by_unique
Initialize the KLReverse layer.          :param int units: Positive integer, dimensionality of the output space.         :param float alpha: Float, controls the amount of reconstruction error.         :param bool self_normalized: Boolean, whether to normalize the input.         :param str name: A name for the layer (string). Code: def __init__(self, *args, **kwargs):         """         Initialize the KLReverse layer.          :param int units: Positive integer, dimensionality of the output space.         :param
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._invites = None         self._members = None         self._messages = None         self._webhooks = None      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = InviteList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._invites      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._
Code: def __init__(self, *args, **kwargs):         """Initialize the ChannelInstance          :returns: twilio.rest.chat.v2.service.channel.ChannelInstance         :rtype: twilio.rest.chat.v2.service.channel.ChannelInstance         """         super(ChannelInstance, self).__init__(*args, **kwargs)          self._properties = {'account_sid': self._properties['account_sid'], 'created_by': self._properties['created_by'], 'created_by_identity': self._properties['created_by_identity'], 'created_by_role_sid': self._properties['created_by_role_sid'], 'created_by_role_identity': self._properties['created_by_role_identity'], 'created_by_user_sid': self._properties['created_by_user_sid'], 'created_by_user_identity': self._properties['created_by_user_identity'], 'created_by_user_friendly_name': self._properties['created_by_user_friendly_name'], 'created_by_user_avatar_url': self._properties['created_by_user_avatar_url'], 'created_by_user_attributes': self._properties['created_by_user_attributes'], 'created_by_user_url': self._properties['created_by_user_url'], 'created_by_user_links': self._properties['created_by_user_links'], 'created_by_user_channel_count': self._properties['created_by_user_channel_count'], 'created_by_user_last_consumed_message_index': self._properties['created_by_user_last_consumed_message_index'], 'created_by_user_last_consumed_timestamp': self._properties['created_by_user_last_consumed_timestamp'], 'created_by_user_last_seen_activity_at': self._properties['created_by_user_last_seen_activity_at'], 'created_by_user_notifications_count': self._properties['created_by_user_notifications_count'], 'created_by_user_notifications_last_read_at': self._properties['created_by_user_notifications_last_read_at'], 'created_by_user_notifications_last_
Computes the squared Hellinger distance between two distributions.  The squared Hellinger distance between two distributions is defined as  .. math::      H^2(p, q) = \\frac{1}{2} \\int_{\\mathbb{R}} \\sqrt{p(x) - q(x)}^2 dx  where :math:`p` and :math:`q` are the input distributions.  This function is only defined for distributions with positive support.  Args:   logu:  A `Tensor` of type `float32`.  The logarithm of the first     distribution.   name: A name for the operation (optional).  Returns:   A `Tensor` of type `float32`.  The squared Hellinger distance between the   distributions.  Raises:   ValueError:  If the input distributions do not have positive support.  Example:  >>> p = tf.constant([0.1, 0.2, 0.3, 0.4]) >>> q = tf.constant([0.1, 0.2, 0.3, 0.4]) >>> tf.contrib.distributions.squared_hellinger(p, q) <tf.Tensor: shape=(), dtype=float32, numpy=0.0> >>> p = tf.constant([0.1, 0.2, 0.3, 0.4]) >>> q = tf.constant([0.1, 0.2, 0.3, 0.4]) >>> tf.contrib.distributions.squared_hellinger(p, q) <tf.Tensor: shape=(), dtype=float32, numpy=0.0> >>> p = tf.constant([0.1, 0.2, 0.3, 0.4]) >>> q = tf.constant([0.1, 0.2, 0.3, 0.4]) >>> tf.contrib.distributions.squared_hellinger(p, q) <tf.Tensor: shape=(), dtype=float32, numpy=0.0> >>> p = tf.constant([0.1, 0.2, 0.3, 0.4]) >>> q = tf.constant([0.1, 0
Initialize the Triangular distribution.          :param float loc: Location parameter.         :param float scale: Scale parameter.         :param float c: Mode parameter. Code: def __init__(self, *args, **kwargs):         """         Initialize the Triangular distribution.          :param float loc: Location parameter.         :param float scale: Scale parameter.         :param float c: Mode parameter.         """         super(Triangular, self).__init__(*args, **kwargs)         self._validate_scale(self.scale)         self._validate_loc(self.loc)         self._validate_c(self
Code: def __init__(self, *args, **kwargs):         """         Initialize the InviteList          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(*args, **kwargs)          # Path Solution         self._solution = {'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def stream(self, limit=None, page_size=None):         """         Streams InviteInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until the limit         is reached.         The results are returned as a generator, so this operation is memory efficient.          :param int limit: Upper limit for the number of records to return. stream()                           guarantees to never return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, stream() will attempt to read the                               limit with the most efficient page size, i.e. min(limit, 1000)          :returns: Generator that will yield up to limit results         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]         """         limits = self._version.read_limits(limit, page_size)          page = self.page(page_size=limits['page_size'], )          return self._version.stream(page, limits['limit'], limits['page_limit'])      def list(self, limit=None, page_size=None):         """         Lists InviteInstance records from the API as a list.         Unlike stream(), this operation is eager and will load `limit` records into         memory before returning.          :param int limit: Upper limit for the number of records to return. list() guarantees                           never to return more than limit.  Default is no limit         :param int page_size: Number of records
1 + 1/np.exp(x) element-wise. Code: def log1p_inverse_expm1(logu, name=None):       with tf.compat.v1.name_scope(name, "log1p_inverse_expm1", [logu]):     logu = tf.convert_to_tensor(value=logu, name="logu
Code: def jeffreys(logu, name=None):       with tf.compat.v1.name_scope(name, "jeffreys", [logu]):     logu = tf.convert_to_tensor(value=logu, name="log
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the new resource belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._members = None         self._messages = None         self._invites = None         self._webhooks = None      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._messages = MessageList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._messages      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = Inv
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(**kwargs)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._messages = MessageList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._messages      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = InviteList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._invites      @property     def webhooks(self):         """         Access the webhooks          :returns: twilio.rest.chat.v2.service
Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite
Get the channel unique name from the channel_sid or channel_unique_name          :param str channel_sid: The channel_sid         :param str channel_unique_name: The channel_unique_name          :returns: The channel unique name         :rtype: str Code: def _get_service_sid(self, service_sid):         """         Get the service sid from the service_sid or service_unique_name          :param str service_sid: The service_sid         :param str service_unique_name: The service_unique_name          :returns: The service sid         :rtype: str         """         if service_sid:             return service_sid         if service_unique_name:
Compute the log-soosum of the input log-probabilities.          :param logu: Log-probabilities.          :returns: Log-soosum of the input log-probabilities.         :rtype: tf.Tensor Code: def _get_log_avg_u_and_log_sooavg_u(self, logu):     """     Compute the log-average and log-soosum of the input log-probabilities.      :param logu: Log-probabilities.      :returns: Tuple of log-average and log-soosum of the input log-probabilities.     :rtype: tuple     """     log_avg_u = self._get_log_avg_u(logu
Code: def _assert_ndims_statically(x,                              expect_ndims=None,                              expect_ndims_at_least=None,                              expect_static=False):      ndims = x.shape.ndims   if ndims is None:     if expect_static:       raise ValueError('Expected static ndims. Found: {}'.format(x))     return   if expect_ndims is not None and ndims!= expect_ndims:     raise ValueError('ndims must be {}.  Found: {}'.format(expect_ndims, ndims))   if expect_ndims_at_least is not None and ndims <
Code: def _batch_gather_with_broadcast(params, indices, axis):      # batch_gather assumes...   #   params.shape =  [A1,...,AN, B1,...,BM]   #   indices.shape = [A1,...,AN, C]   # which gives output of shape   #                   [A1,...,AN, C, B1,...,BM]   # Here we broadcast dims of each to the left of `axis` in params, and left of   # the rightmost dim in indices, e.g. we can   # have   #   params.shape =  [A1,...,AN, B1,...,BM]   #   indices.shape = [a1,...,aN, C],   #
Code: def _broadcast_cat_event_and_params(event, params, base_dtype):      if dtype_util.is_integer(event.dtype):     pass   elif dtype_util.is_floating(event.dtype):     # When `validate_args=True` we've already ensured int/float casting     # is closed.     event = tf.cast(event, dtype=tf.int32)   else:     raise TypeError("`value` should have integer `dtype` or "                     "`self.dtype` ({})".format(base_dtype))   shape_known_statically = (       tensorshape_util.rank(params.shape) is not None and       tensorshape_util.is_fully_defined(params.shape[:-1]) and       tensorshape_util.is_fully_defined(event.shape))   if not shape_known_statically or params.shape[:-1]
Returns the mean of log_values in logspace.          Args:             log_values: Tensor of log values.          Returns:             Tensor of means. Code: def _get
Code: def _broadcast_event_and_samples(event, samples, event_ndims):      # This is the shape of self.samples, without the samples axis, i.e. the shape   # of the result of a call to dist.sample(). This way we can broadcast it with   # event to get a properly-sized event, then add the singleton dim back at   # -event
Compute the search direction. Code: def _inv_hessian_control_inputs(inv_hessian):     """Compute control inputs to ensure that the inverse Hessian is positive     definite and symmetric.      Args:       inv_hessian: A `Tensor` representing the inverse Hessian estimate.      Returns:       A list of `Tensor`s representing the control inputs.     """     # Compute the eigenvalues of the inverse Hessian.     eigenvalues = tf.linalg.eigvalsh(inv_hessian)      # Compute the control inputs.     control_inputs = [         tf.cast(tf.reduce_all
The easiest way to validate if the inverse Hessian is positive definite is         to compute its Cholesky decomposition.          :param tf.Tensor inv_hessian: The inverse Hessian to validate          :returns: A list of control dependencies         :rtype: list Code: def _inv_hessian_control_inputs(inv_hessian):      # The easiest way to validate if the inverse Hessian is positive definite is   # to compute its Cholesky decomposition.   is_positive_definite = tf.reduce_all(       input_tensor=tf.math.is_finite(tf.linalg.cholesky(inv_hessian)),       axis=[-1, -2])    # Then check that the supplied inverse Hessian is symmetric.   is_symmetric = tf.equal(bfgs_utils.norm(       inv_hessian - _batch_transpose(inv_hessian), dims=2), 0)    # Simply adding a control dependencies
Code: def _update_inv_hessian(prev_state, next_state):      # Only update the inverse Hessian if not already failed or converged.   should_update = ~next_state.converged & ~next_state.failed    # Compute the normalization term (y^T. s), should not update if is singular.   gradient_delta = next_state.objective_gradient - prev_state.objective_gradient   position_delta = next_state.position - prev_state.position   normalization_factor = tf.reduce_sum(       input_tensor=gradient_delta * position_delta, axis=-1)   should_update = should_update & ~tf.equal(normalization_factor, 0)    def _do_update_inv_hessian():     next_inv_hessian = _bfgs_inv_hessian_update(         gradient
The quadratic form: y^T.H.y; where H is the inverse Hessian and y is the         gradient change. Code: def _bfgs_inv_hessian_update(grad_delta, position_delta, normalization_factor,                              inv_hessian_estimate):      # The quadratic form: y^T.H.y; where H is the inverse Hessian and y is the   # gradient change.   conditioned_grad_delta = _mul_right(inv_hessian_estimate, grad_delta)   conditioned_grad_delta_norm = tf.reduce_sum(       input_tensor=conditioned_grad_delta * grad_delta, axis=-1)

Code: def _tensor_product(t1, t2):      return tf.matmul(tf.expand_dims(t1, axis=-1), tf.expand_dims(t2, axis
Code: def _batch_transpose(mat):      n = distribution_util.prefer_static_rank(mat)   perm = tf.range(n)   perm =
Get the channel unique name from the channel_sid or channel_unique_name          :param str channel_sid: The channel_sid         :param str channel_unique_name: The channel_unique_name          :returns: The channel unique name         :rtype: str Code: def _get_service_sid(self, service_sid):         """         Get the service sid from the service_sid or service_unique_name          :param str service_sid: The service_sid         :param str service_unique_name: The service_unique_name          :returns: The service sid         :rtype: str         """         if service_sid:             return service_sid         if service_unique_name:             return self.client.services.get(service_unique_name).sid         raise ValueError('Either service_
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._invites = None         self._members = None         self._messages = None         self._webhooks = None      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = InviteList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._invites      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._members = None         self._messages = None         self._invites = None         self._webhooks = None      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._messages = MessageList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._messages      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites =
Code: def maybe_get_common_dtype(arg_list):      # Note that `all` defaults to `True` if `arg_list` is empty.
Returns the initial state for the BFGS algorithm. Code: def _get_search_direction(current_state):   """Returns the search direction for the current state of the algorithm.    Args:     current_state: A `BFGSOptimizerResults` tuple representing the current       state of the algorithm.    Returns:     A `Tensor` representing the search direction.   """   position_deltas = current_state.position_deltas   gradient_deltas = current_state.gradient_deltas   inverse_hessian_estimate = current_state.inverse_hessian_estimate   position_deltas_squared = tf.square(position_deltas)   gradient_deltas_squared = tf.square(gradient_deltas)   hessian_estimate = tf.matmul(       tf.transpose(position_deltas), gradient_deltas)   hessian_estimate = tf.matmul(hessian_estimate,
Returns the next state of the optimizer.          Args:             value_and_gradients_function: A function that returns the value of the               objective function and its gradient.             current_state: The current state of the optimizer.             num_correction_pairs: The number of correction pairs to be used.             tolerance: The tolerance for the optimization.          Returns:             The next state of the optimizer. Code: def _get_next_position(current_state,                            num_correction_pairs,                            tolerance):   """Returns the next position of the optimizer.    Args:     current_state: The current state of the optimizer.
Code: def _get_search_direction(state):      # The number of correction pairs that have been collected so far.   num_elements = tf.minimum(       state.num_iterations,       distribution_util.prefer_static_shape(state.position_deltas)[0])    def _two_loop_algorithm():          # Correction pairs are always appended to the end, so only the latest     # `num_elements` vectors have valid position/gradient deltas.     position_deltas = state.position_deltas[-num_elements:]     gradient_deltas = state.gradient_deltas[-num_elements:]      # Pre-compute all `inv_rho[i]`s.     inv_rhos = tf.reduce_sum(         input_tensor=gradient_deltas * position_deltas, axis=-1)      def first_loop(acc, args):       _, q_direction = acc       position_delta, gradient_delta, inv_rho = args       alpha = tf.reduce_sum(           input_tensor=position_delta * q_direction, axis=-1) / inv_rho       direction_delta = tf.expand_dims(alpha, axis=-1) * gradient_delta       return (alpha, q_direction - direction_delta)      # Run first loop body computing and collecting `alpha[i]`s, while also     # computing the updated `q_direction` at each step.     zero = tf.zeros_like(inv_rhos[0])     alphas, q_directions = tf.scan(         first_loop, [position_deltas, gradient_deltas, inv_rhos],         initializer=(zero, state.objective_gradient), reverse=True)      # We use `H^0_k = gamma_k * I` as an estimate for the initial inverse     # hessian for the k-th iteration; then `r_direction = H^0_k * q_direction`.     gamma_k = inv_rhos[-1] / tf.reduce_sum(         input_tensor=gradient_deltas[-1] * gradient_deltas[-1], axis=-1)     r_direction = tf.expand_dims(gamma_k, axis=-1) * q_directions[0]      def second_loop(r_direction, args):       alpha,
Code: def _make_empty_queue_for(k,
Pop the oldest element from the queue. Code: def _queue_pop(queue, should_update):   """Pop the oldest element from the queue."""   update_pattern = tf.broadcast_to(       should
Code: def _psd_mask(x):      # Allegedly   # https://scicomp.stackexchange.com/questions/12979/testing-if-a-matrix-is-positive-semi-definite   # it is more efficient to test for positive semi-definiteness by   # trying to compute the Cholesky decomposition -- the matrix is PSD   # if you succeed and not PSD if you fail.  However, TensorFlow's   # Cholesky raises an exception if _any_ of the input matrices are   # not PSD, from which I don't know how to extract _which ones_, so I   # proceed by explicitly computing all the eigenvalues and checking   # whether they are all positive or not.   #   # Also, as was discussed in the answer, it is somewhat dangerous to   # treat SPD-ness as binary in floating-point arithmetic. Cholesky   # factorization can complete and 'look' like everything is
For the curious: I wonder whether it is possible and desirable to         use a Cholesky decomposition-based algorithm for this, since the         only matrices whose determinant this code cares about will be PSD.         Didn't figure out how to code that in TensorFlow.         Expert opinion is that it would be about twice as fast since         Cholesky is roughly half the cost of Gaussian Elimination with         Partial Pivoting. But this is less of an impact than the switch in         _psd_mask. Code: def _psd_mask(x, psd_bounds):   """   Return a mask of the same shape as x, where the elements are True   if the corresponding element of x is positive semidefinite.    :param x: A tensor of shape [..., n, n]   :param psd_bounds: A tensor of shape [...]   :return: A tensor of shape [...]   """   # The following is equivalent to tf.linalg.cholesky(x)   # but is faster.   #   # The following is equivalent to tf.linalg.cholesky(x)   # but is faster.   #   # The following is equivalent to tf.linalg.cholesky(x)   # but is faster.   #   # The following is equivalent to tf.linalg.cholesky(x)   # but is faster.   #   # The following is equivalent to tf.linalg.cholesky(x)   # but is faster.   #   # The following is equivalent to tf.linalg.cholesky(x)   # but is faster.   #   # The following is equivalent to tf.linalg.cholesky(x)   # but is faster.   #   # The following is equivalent to tf.linalg.cholesky(x)   # but is faster.   #   # The following is equivalent to tf.linalg.cholesky(x)   # but is faster.   #   # The following is equivalent to tf.linalg.cholesky(x)   # but is faster.   #   # The following is equivalent to tf.linalg.cholesky(x)   # but is faster.   #   # The following is equivalent to tf.linalg.cholesky(x)   # but is faster.   #   # The following is equivalent to tf.linalg.cho
Code: def _uniform_correlation_like_matrix(num_rows, batch_shape, dtype, seed):      num_entries = num_rows * (num_rows + 1) / 2   ones = tf.ones(shape=[num_entries], dtype=dtype)   # It seems wasteful to generate random values for the diagonal since   # I am going to throw them away, but `fill_triangular` fills the   # diagonal, so I probably need them.   # It's not impossible that it would be more efficient to just fill   # the whole matrix with random values instead of messing with   # `fill_triangular`.  Then would need to filter almost half out with   # `matrix_band_part`.   unifs = uniform.Uniform(-ones, ones).sample(batch_shape, seed=seed)   tril = util.fill_triangular(unifs)   symmetric = tril + tf.linalg.matrix_transpose(tril)   diagonal_ones = tf.ones(       shape=util.pad(batch_shape, axis=
Code: def _uniform_correlation_like_matrix(dim, sample_shape, dtype, seed):     """     Returns a batch of matrices with the same shape as sample_shape,     and with the same correlation structure as a matrix with shape     [dim, dim].      :param dim: The dimension of the matrix.     :type dim: int     :param sample_shape: The shape of the batch of matrices.     :type sample_shape: Tuple[int]     :param dtype: The data type of the matrices.     :type dtype: tf.DType     :param seed: The seed for the random number generator.     :type seed: int     :return: A batch of matrices with the same shape as sample_shape,              and with the same correlation structure as a matrix with shape              [
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __call__(self, service_sid,
Get the channel sid from the channel name          :param str channel_name: The channel name          :returns: The channel sid         :rtype: str Code: def _get_channel_sid(self, channel_name):         """         Get the channel sid from the channel name          :param str channel_name: The channel name          :returns: The channel sid         :rtype: str         """         channel = self.client.channels.list(             friendly_name
Code: def _von_mises_cdf_series(x, concentration, num_terms, dtype):      # Keep the number of terms as a float. It should be a small integer, so   # exactly representable as a float.   num_terms = tf.cast(num_terms, dtype=dtype)    def loop_body(n, rn, drn_dconcentration, vn, dvn_dconcentration):           denominator = 2. * n / concentration + rn     ddenominator_dk = -2. * n / concentration ** 2 + drn_dconcentration     rn = 1. / denominator     drn_dconcentration = -ddenominator_dk / denominator ** 2      multiplier = tf.sin(n * x) / n + vn     vn = rn * multiplier     dvn_dconcentration = (drn_dconcentration * multiplier +                           rn * dvn_dconcentration)     n -= 1.      return n, rn, drn_dconcentration, vn, dvn_dconcentration    (_, _, _, vn, dvn_dconcentration) = tf.while_loop(       cond=lambda n, *_: n > 0.,       body=loop_body,       loop_vars=(           num_terms,  # n           tf.zeros_like(x, name="rn"),           tf.zeros_like(x, name="drn_dconcentration"),           tf.zeros_like(x, name="vn"),           tf.zeros_like(x, name="dvn_dconcentration"),       ),   )    cdf =.5 + x / (2. * np.pi) + vn / np.pi   dcdf_dconcentration = dvn_dconcentration / np.pi    # Clip the result to [0, 1].   cdf_clipped = tf.clip_by_value(cdf, 0., 1.)   # The clipped values do not depend on concentration anymore, so set their   # derivative to zero.   dcdf_dconcentration *= tf.cast((cdf >= 0.) & (cdf <= 1.), dtype)    return cdf_clipped, dcdf_dconcentration
Code: def _von_mises_cdf_normal(x, concentration, dtype):       def cdf_func(concentration):          # z is an "almost Normally distributed" random variable.     z = ((np.sqrt(2. / np.pi) / tf.math.bessel_i0e(concentration)) *          tf.sin(.5 * x))      # This is the correction described in [1] which reduces the error     # of the Normal approximation.     z2 = z ** 2     z3 = z2 * z     z4 = z2 ** 2     c = 24. * concentration     c1 = 56.      xi = z - z3 / ((c - 2. * z2 - 16.) / 3. -                    (z4 + (7. / 4.) * z2 + 167. / 2.) / (c - c1 - z2 + 3.)) ** 2      distrib = normal.Normal(tf.cast(0
Construct the mutated solution vectors. There is one for each member of   the population.    Args:     population: A list of `Tensor`s representing the population.     population_size: The size of the population.     mixing_indices: A `Tensor` of indices into the population.     differential_weight: A `Tensor` of differential weights.    Returns:     A list of `Tensor`s representing the mutated solution vectors. Code: def _binary_crossover(population, population_size, mutants, crossover_prob,                           seed=None):   """Perform recombination between the parents and the mutants.    Args:     population: A list of `Tensor`s representing the population.     population_size: The size of the population.     mutants: A list of `Tensor`s representing the mutants.     crossover_prob: A `Tensor` of crossover probabilities.     seed: A Python integer. Used to seed the random number generator.    Returns:     A list of `Tensor`s representing the recombined solution vectors.   """   candidates = []   for i in range(population_size):     if tf.random.uniform(shape=[], minval=0, maxval=1, seed=seed) < crossover_prob:       candidates.append(population[i] * crossover_prob + mutants[i] * (1 - crossover_prob))     else:       candidates.append(population[i])   return
Get the initial population and values
Ensures that x is a list.          Args:             x: A value.          Returns:             A list. Code: def _get_best_position(population_values,                            population,                            func_tolerance,                            position_tolerance):   """Returns the best position in the population.    Args:     population_values: A list of values.     population: A list of positions.     func_tolerance: The function tolerance.     position_tolerance: The position tolerance.
Find the best individual in the population.          :param population: A list of individuals.         :
Code: def _check_convergence(population,                        population_values,                        func_tolerance,                        position_tolerance):      # Check func tolerance   value_range = tf.math.abs(       tf.math.reduce_max(input_tensor=population_values) -       tf.math.reduce
Returns the best fitness in the population.          :param list[float] population: A list of positions.         :param callable fitness_fn: A function that takes a position and returns a fitness value.          :returns: float         :rtype: float Code: def _get_best_position_and_fitness(population, fitness_fn):   """Returns the best position and fitness in the population.    Args:     population: A list of positions.     fitness_fn: A function that takes a position and
Code: def _binary_crossover(population,                       population_size,                       mutants,                       crossover_prob,                       seed):      sizes = [tf.cast(tf.size(input=x), dtype=
Code: def _get_mutants(population,                  population_size,                  mixing_indices,                  differential_weight):      mixing_indices = tf.reshape(mixing_indices, [-1])   weights = tf.stack([1.0, differential_weight, -differential_weight])   def _mutant_part(population_part):     donors = tf.gather(population_part, mixing_indices)     donors = tf.transpose(         a=tf.reshape(donors, [population_size, 3, -1]), perm=[0, 2, 1])     return tf.math.reduce_sum(input_tensor=donors
Code: def _get_mixing_indices(size, seed=None, name=None):      with tf.compat.v1.name_scope(       name, default_name='get_mixing_indices', values=[size]):     size = tf.convert_to_tensor(value=size)     dtype = size.dtype     seed_stream = distributions.Seed
Code: def _ensure_list
If tol is None, return 0. If tol is a Tensor, return it. If tol is a         float, convert it to a Tensor with dtype matching dtype and return it.         If validate_args is True, then assert that tol is non-negative.          Args:           tol: A Tensor or a Python `float`.           dtype: The dtype of the returned Tensor.           validate_args: Python `bool`, default `False`. If `True` distribution             parameters are checked for validity despite possibly degrading runtime             performance. When `True` distribution parameters may be checked for             validity despite possibly degrading runtime performance.          Returns:           tol: A Tensor with the same dtype as `dtype`. Code: def _get_tol(tol, dtype, validate_args):      if tol is None:     return tf.convert_to_tensor(value=0, dtype=dtype)    tol = tf.convert_to_tensor(value=tol, dtype=dtype)   if validate_args:     tol = distribution_util.with_dependencies([         assert_util.assert_non_negative(             tol, message="Argument 'tol' must be non-negative")     ],
Create the InviteInstance          :param unicode identity: The unique string that identifies the resource's User         :param unicode role_sid: The SID of the Role assigned to the new member         :param unicode ttl: An application-defined expiration date for the Invite. If an Invite expires, it is no longer valid and the member is removed from the Channel. If no value is
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the new resource belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._members = None         self._invites = None         self._messages = None         self._webhooks = None      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = InviteList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._invites      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._messages
Code: def build_input_pipeline(train_images, batch_size):       training_dataset = tf.data.Dataset.from_
Get the user sid from the user identity          :param str user_identity: The user identity          :returns: The user sid         :rtype: str Code: def _get_user_sid_from_channel(self, channel_sid):         """         Get the user sid from the channel sid          :param str channel_sid: The channel sid          :returns: The user sid         :rtype: str         """         channel = self.client.chat.channels.list(             service_sid=self.service_sid,
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the new resource belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._members = None         self._messages = None         self._invites = None         self._webhooks = None      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._messages = MessageList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._messages      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = Inv
Code: def __init__(self,                  grammar,                  latent_size,                  lstm_size,                  lstm_layers,                  output_size,                  dropout_rate,                  learning_rate,                  batch_size,                  max_epochs,                  optimizer,                  checkpoint_dir,                  checkpoint_interval,                  log_dir,                  log_interval,                  save_interval,                  restore_checkpoint,                  restore_checkpoint_dir,                  restore_checkpoint_interval,                  restore_checkpoint_epoch,                  restore_checkpoint_step,                  restore_checkpoint_optimizer,                  restore_checkpoint_learning_rate,                  restore_checkpoint_batch_size,                  restore_checkpoint_max_epochs,                  restore_checkpoint_optimizer_state,                  restore_checkpoint_learning_rate_state,                  restore_checkpoint_batch_size_state,                  restore_checkpoint_max_epochs_state,                  restore_checkpoint_optimizer_state_epoch,                  restore_checkpoint_optimizer_state_step,                  restore_checkpoint_learning_rate_state_epoch,                  restore_checkpoint_learning_rate_state_step,                  restore_checkpoint_batch_size_state_epoch,                  restore_checkpoint_batch_size_state_step,                  restore_checkpoint_max_epochs_state_epoch,                  restore_checkpoint_max_epochs_state_step,                  restore_checkpoint_optimizer_state_epoch_step,                  restore_checkpoint_learning_rate_state_epoch_step,                  restore_checkpoint_batch_size_state_epoch_step,                  restore_checkpoint_max_epochs_state_epoch_step,                  restore_checkpoint_optimizer_state_epoch_step_step,                  restore_checkpoint_learning_rate_state_epoch_step_step,                  restore_checkpoint_batch_size_state_epoch_step_step,                  restore_checkpoint_max_epochs_state_epoch_step_step,                  restore_checkpoint_optimizer_state_epoch_step_step_step,                  restore_checkpoint_learning_rate_state_epoch_step_step_step,                  restore_checkpoint_batch_size_state_epoch_step_step_step,                  restore_checkpoint_max_epochs_state_epoch_step_step_step_step,                  restore_checkpoint_optimizer_state_epoch_step_step_step_step_step,
Initialize the VAE network.          :param tf.keras.Model encoder_net: The encoder network.         :param tf.keras.Model decoder_net: The decoder network.         :param int latent_
Code: def _hat_integral(self, x):          x
Code: def _hat_integral_inverse(self, x):          x = tf.cast(x, self.power.dtype)     t = self.power - 1.     return tf.math.expm1(-(tf.math.log
Get the channel sid from the channel name          :param str channel_name: The channel name          :returns: str         :rtype: str Code: def _get_channel_sid(self, channel_name):         """         Get the channel sid from the channel name          :param str channel_name: The channel name          :returns: str         :rtype: str         """         channel_sid = None         if channel_name:             channel_sid = self.client.channels.list(                 service_sid=self.service_sid,                 friendly_name=
Fetch a UserInstance          :param unicode user_sid: The user_sid          :returns: twilio.rest.chat.v2.service.user.UserInstance         :rtype: twilio.rest.chat.v2.service.user.UserInstance Code: def _get_invite_instance(self, sid):         """         Fetch a InviteInstance          :param unicode sid: The sid          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.Invite
Code: def _lu_solve_assertions(lower_upper, perm, rhs, validate_args):     """Asserts that the inputs satisfy the assertions required for the     `lu_solve` op.      Args:       lower_upper:  A `Tensor` of shape `[..., n, n]` whose inner-most 2         dimensions form an `n x n` lower triangular matrix.       perm:  A `Tensor` of shape `[..., n]` whose entries are indices into the         first dimension of `lower_upper`.       rhs:  A `Tensor` of shape `[..., n, r]` whose inner
Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource is associated with          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2
Code: def _lu_reconstruct_assertions(lower_upper, perm, validate_args):      assertions = []    message = 'Input `lower_upper` must have at least 2 dimensions.'   if lower_upper.shape.ndims is not None:     if lower_upper.shape.ndims < 2:       raise ValueError(message)   elif validate_args:     assertions.append(         tf.compat.v1.assert_rank_at_least(lower_upper, rank=2, message=message))    message = '`rank(lower_upper)` must equal `rank(perm) + 1`'   if lower_upper.shape.ndims is not None and perm.shape.
Code: def _lu_solve_assertions(lower_upper, perm, rhs, validate_args):      assertions = _lu_reconstruct_assertions(lower_upper, perm, validate_args)    message = 'Input `rhs` must have at least 2 dimensions.'   if rhs.shape.ndims is not None:     if rhs.shape.ndims < 2:       raise ValueError(message)   elif validate_args:     assertions.append(         tf.compat.v1.assert_rank_at_least(rhs, rank=2, message=message))    message = '`lower_upper.shape[-1]` must equal `rhs.shape[-1]`.'   if (tf.compat.dimension_value(lower_upper.shape[-1]) is not None and       tf.compat.dimension_value(rhs.shape[-2]) is not None):     if lower_upper.shape[-1]!= rhs.shape[-2]:       raise ValueError(message)   elif validate_args:     assertions.append(         tf.compat.v1.assert
Construct the matrix [[M, N], [1, 0], [0, 1]] which would map the index         (b, i, j) to (Mb + i, Nb + j). This effectively creates a block-diagonal         matrix of dense shape [B * M, B * N].         Note that this transformation doesn't increase the number of non-zero         entries in the SparseTensor. Code: def _sparse_block_diag(sp_a):      # Construct the matrix [[M, N], [1, 0], [0, 1]] which would map the index   # (b, i, j) to (Mb + i, Nb + j). This effectively creates a block-diagonal   # matrix of dense shape [B * M, B * N].   # Note that this transformation doesn't increase the number of non-
Code: def _maybe_validate_matrix(a, validate_args):      assertions = []   if not a.dtype.is_floating:     raise TypeError('Input `a` must have `float`-like `dtype` '                     '(saw {}).'.format(a.dtype.name))   if a.shape.ndims is not None:     if a.shape.ndims < 2:       raise ValueError('Input `a` must have at least 2 dimensions '                        '(saw: {}).'.format(a.shape.ndims))   elif validate_args:     assertions.append(tf.compat.v1.assert_rank_at_least(         a, rank=2, message='Input `a` must
Code: def _grad_neg_log_likelihood_and_fim(model_matrix, linear_response, response,                                      model):      # TODO(b/111926503): Determine whether there are some practical cases where it   # is computationally favorable to compute the full FIM.   mean, variance, grad_mean = model(linear_response)    is_valid = (       tf.math.is_finite(grad_mean) & tf.not_equal(grad_mean, 0.)       & tf.math.is_finite(variance) & (variance > 0.))    def _mask_if_invalid(x, mask):     mask = tf.fill(         tf.shape(input
Build an instance of InviteInstance          :param dict payload:
TODO(b/67594795): Better support of dynamic shape.          :param int num_blocks: Number of blocks to split the input into.         :param int n_in: Number of input channels.         :param int n_out: Number of output channels.         :param str mask_type: Type of mask to use.          :returns: List of slices.         :rtype: List[Tuple[slice, slice]] Code: def _gen_slices(num_blocks, n_in, n_out, mask_type=MASK_EXCLUSIVE):      # TODO(b/67594795): Better support of dynamic shape.   slices = []   col = 0   d_in = n_in // num_blocks   d_out = n_out // num_blocks   row = d_out if mask_type == MASK_EXCLUSIVE else 0   for _ in range(num_blocks):     row_slice = slice(row, None)     col_slice = slice(col, col + d_in)     slices.append([row_slice, col_
TODO(b/
Get or create a channel          :param sid: Channel sid          :returns: twilio.rest.chat.v2.service.channel.ChannelInstance         :rtype: twilio.rest.chat.v2.service.channel.ChannelInstance Code: def _get_or_create_user(self, sid):         """         Get or create a user          :param sid: User sid          :returns: twilio.rest.chat.v2.service.user.UserInstance         :rtype: twilio
Code: def _create_input_order(input_size, input_order="left-to-right"):      if isinstance(input_order, six.string_types):     if input_order == "left-to-right":       return np.arange(start=1, stop=input_size + 1)     elif input_order == "right-to-left":       return np.arange(start=input_size, stop=0, step=-
Code: def _create_hidden_order(input_size, hidden_units, hidden_degrees):   if hidden_units is None:     return []   elif isinstance(hidden_units, six.
Code: def _create_masks(degrees):      return [       # Create input->hidden and hidden->hidden masks.       inp[:, np.newaxis] <= out       for inp, out in zip(degrees[:-1], degrees[1:])   ] + [       # Create hidden->output mask.       degrees[-1][:, np.newaxis] < degrees
Code: def _make_masked_initializer(mask, initializer):      initializer = tf.keras.initializers.get
Forward pass.          :param tf.Tensor inputs: Tensor of shape `[batch_size, event_size]`.          :returns: Tensor of shape `[batch_size, event_size * self._params]`.         :rtype: tf.Tensor Code: def get_config(self):     """     Returns the config of the layer.      :returns: Dictionary of layer config.     :rtype: dict     """     config = {         'params': self._params,         'hidden_units': self._hidden_units,         'hidden_degrees': self._hidden_degrees,         'input_order': self._input_order,         'input_order_param': self._input_order_param,         'kernel_initializer': tf.keras.initializers.serialize(             self._kernel_initializer),         'activation': self._activation,         'use_bias': self._use_bias,         'dtype': self.
Code: def __init__(self,                  units,                  activation=None,                  use_bias=True,                  kernel_initializer='glorot_uniform',                  bias_initializer='zeros',                  kernel_regularizer=None,                  bias_regularizer=None,                  activity_regularizer=None,                  kernel_constraint=None,                  bias_constraint=None,                  **kwargs):         super(Dense, self).__init__(**kwargs)         self.units = units         self.activation = activations.get(activation)         self.use_bias = use_bias         self.kernel_initializer = initializers.get(kernel_initializer)         self.bias_initializer = initializers.get(bias_initializer)         self.kernel_regularizer = regularizers.get(kernel_regularizer)         self.bias_regularizer = regularizers.get(bias_regularizer)         self.activity_regularizer = regularizers.get(activity_regularizer)         self.kernel_constraint = constraints.get(kernel_constraint)         self.bias_constraint = constraints.get(bias_constraint)         self
Get the next page of results          :param Response response: Response from the API          :returns: Page of results         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def _get_next_page(self, response):         """         Get the next page of results          :param Response response: Response from the API          :returns: Page of results         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         previous_page = self._page.get('previous_page_url')          if previous_page is None:             raise TwilioException('There are no more pages')          response = self._version.domain.twilio.
Code: def _zero_dimensional_mvndiag(dtype):      dummy_mvndiag = tfd.MultivariateNormalDiag(       scale_diag=tf.ones([0], dtype=dtype))
Code: def _observe_timeseries_fn(timeseries):      def observation_noise_fn(t):     current_slice = timeseries[..., t, :]     return tfd.MultivariateNormalDiag(
Code: def __init__(self,                  weights_prior_scale,                  weights_prior_scale_variance,                  weights_prior_scale_noncentered,                  weights_prior_scale_noncentered_variance,                  weights_prior_scale_noncentered_mean,                  weights_prior_scale_noncentered_stddev,                  weights_prior_scale_noncentered_stddev_variance,                  weights_prior_scale_noncentered_stddev_mean,                  weights_prior_scale_noncentered_stddev_stddev,                  weights_prior_scale_noncentered_stddev_stddev_variance,                  weights_prior_scale_noncentered_stddev_stddev_mean,                  weights_prior_scale_noncentered_stddev_stddev_stddev,                  weights_prior_scale_noncentered_stddev_stddev_stddev_variance,                  weights_prior_scale_noncentered_stddev_stddev_stddev_mean,                  weights_prior_scale_noncentered_stddev_stddev_stddev_stddev,                  weights_prior_scale_noncentered_stddev_stddev_stddev_stddev_variance,                  weights_prior_scale_noncentered_stddev_stddev_stddev_stddev_mean,                  weights_prior_scale_noncentered_stddev_stddev_stddev_stddev_stddev,                  weights_prior_scale_noncentered_stddev_stddev_stddev_stddev_stddev_variance,                  weights_prior_scale_noncentered_stddev_stddev_stddev_stddev_stddev_mean,                  weights_prior_scale_noncentered_stddev_stddev_stddev_stddev_stddev_stddev,                  weights_prior_scale_noncentered_stddev_stddev_stddev_stddev_stddev_stddev_variance,                  weights_prior_scale_noncentered_stddev_stddev_stddev_stddev_stddev_stddev_mean,                  weights_prior_scale_noncentered_stddev_stddev_stddev_stddev_stddev_stddev_stddev,                  weights_prior_scale_noncentered_stddev_stddev_stddev_stddev_stddev_stddev_std
Code: def _depth(g):      def _explore(v):     if v.depth < 0:       v.depth = ((1 + max([-1
Compute depth of
Code: def _prob_chain_rule_flatten(named_makers):      def _make(dist_fn, args):     if args is None:       return lambda *_: dist_fn     if not args:       return lambda *_: dist_fn()     def _fn(*xs):       kwargs = dict(zip(args, reversed(xs[-len(args):])))       kwargs.pop('_', None)       return dist_fn(**kwargs)     return _fn   named_makers = _convert_to_dict(named_makers)   g = {k: (None if distribution_util.is_distribution_instance(v)            else joint_distribution_sequential._get_required_args(v))  # pylint: disable=protected-access        for k, v in named_makers.items()}   g = _best_order(g)   dist_fn_name
Code: def _build(self, model):          if not _is_dict_like(model):       raise TypeError('`model` must be convertible to `dict` (s
The variational loss is a negative ELBO. The ELBO can be broken down       into three terms:        1. a likelihood term        2. a trace term arising from the covariance of the posterior predictive          kzx = self.kernel.matrix(self._inducing_index_points,                                  observation_index_points)          kzx_linop = tf.linalg.LinearOperatorFullMatrix(kzx)         loc = (self._mean_fn(observation_index_points) +                kzx_linop.matvec(self._kzz_inv_varloc, adjoint=True))          likelihood = independent.Independent(             normal.Normal(                 loc=loc,                 scale=tf.sqrt(self._observation_noise_variance + self._jitter),                 name='NormalLikelihood'),             reinterpreted_batch_ndims=1)         obs_ll = likelihood.log_prob(observations)          chol_kzz_linop = tf.linalg.LinearOperatorLowerTriangular(self._chol_kzz)         chol_kzz_inv_kzx = chol_kzz_linop.solve(kzx)         kzz_inv_kzx = chol_kzz_linop.solve(chol_kzz_inv_kzx, adjoint=True)          kxx_diag = tf.linalg.diag_part(             self.kernel.matrix(                 observation_index_points, observation_index_points))         ktilde_trace_term = (             tf.reduce_sum(input_tensor=kxx_diag, axis=-1) -             tf.reduce_sum(input_tensor=chol_kzz_inv_kzx ** 2, axis=[-2, -1]))          # Tr(SB)         # where S = A A.T, A = variational_inducing_observations_scale         # and B = Kzz^-1 Kzx Kzx.T Kzz^-1         #         # Now Tr(SB) = Tr(A A.T Kzz^-1 Kzx Kzx.T Kzz^-1)         #            = Tr(A.T Kzz^-1 Kzx Kzx.T Kzz^-1 A)         #            = sum_ij (A.T Kzz
Solves the linear system `chol_sigma_inv @ kzx_obs`. Code: def _add_diagonal_shift(matrix, jitter):     """Adds a small diagonal shift to the matrix.      Args:       matrix: A `Tensor` of shape `[..., n_rows, n_cols]`.       jitter:
Code: def build_is_last_day_of_season(num_steps_per_season):      num_steps_per_cycle = np.sum(num_steps_per_season)   changepoints = np.cumsum(np.ravel(num_steps_per_season)) - 1   def is_last_day_of_season(t):     t_
Get the channel sid from the channel sid          :param str channel_sid: The channel sid          :returns: The channel sid         :rtype: str Code: def _get_channel_sid_from_channel_unique_name(self, channel_unique_name):         """         Get the channel sid from the channel unique name          :param str channel_unique_name: The channel unique name          :returns: The channel sid         :rtype: str         """         channel_sid = None         if channel_unique_name:             channel_sid = self.client.channels.list(
Code: def build_seasonal_transition_matrix(     num_seasons, is_last_day_of_season, dtype,     basis_change_matrix=None, basis_change_matrix_inv=None):       with tf.compat.v1.name_scope('build_seasonal_transition_matrix'):     # If the season is changing, the transition matrix permutes the latent     # state to shift all seasons up by a dimension, and sends the current     # season's effect to the bottom.     seasonal_permutation = np.concatenate(         [np.arange(1, num_seasons), [0]], axis=0)     seasonal
Code: def build_seasonal_transition_noise(
Code: def build_seasonal_transition_noise(     drift_scale, num_seasons, is_last_day_of_season):       # Conceptually, this method takes the noise covariance on effects L @ L'   # computed by `build_seasonal_transition_noise`, with scale factor   #       L = [ 0, 0,..., 0   #            ...   #             0, 0,..., drift_scale],   # and transforms it to act on the constrained-residual representation.   #   # The resulting noise covariance M @ M' is equivalent to   #    M @ M' = effects_to_residuals @ LL' @ residuals_to_effects   # where `@` is matrix multiplication. However because this matrix is   # rank-deficient, we can't take its Cholesky decomposition directly, so we'll   # construct its lower-triangular scale factor `M` by hand instead.   #   # Concretely, let `M = P @ R @ L` be the scale factor in the   # transformed space, with matrices `R`, `P` applying the reparameterization   # and zero-mean constraint respectively as defined in the   # "Mathematical Details" section of `ConstrainedSeasonalStateSpaceModel`. It's   # easy to see (*) that the implied covariance   # `M @ M' = P @ R @ L @ L' @ R' @ P'` is just the constant matrix   #  `M @ M' = [ 1, 1,..., 1, 0   #              1, 1,..., 1, 0   #             ...   #              1, 1,..., 1, 0   #              0, 0,..., 0, 0] * (drift_scale / num_seasons)**2`   # with zeros in the final row and column. So we can directly construct   # the lower-triangular factor   #  `Q = [ 1, 0,...  0   #         1, 0,..., 0   #        ...   #         1, 0,..., 0   #         0, 0,..., 0 ] * drift_scale/num_seasons`   # such that Q @ Q' = M @ M'. In practice, we don't
If both input locations and observations are `None`, we consider this         "empty" observation data. Code: def _is_empty_observation_data(     feature_ndims, observation_index_points, observations):      # If both input locations and observations are `None`, we consider this   # "empty" observation data.   if observation_index_points
Check that observation index points and observation counts broadcast.
Code: def add(self, scheduler, max_iteration, bigdl_type="float"):                  return callBigDlFunc(bigdl_type, "addScheduler", self.value, scheduler, max
Code: def set_checkpoint(self, checkpoint_trigger,                        checkpoint_path, isOverWrite=True):                  if not os.path.exists(checkpoint_path):             mkpath(checkpoint_path)         callBigDlFunc(self.bigdl_type, "setCheckPoint", self.value,                       checkpoint_trigger, checkpoint_path, isOverWrite)
Code: def set_gradclip_value_and_norm(self, max_value, max_norm):                  callBigDlFunc(self.bigdl_type, "setNormValueClip", self.value, max_value
Code: def __init__(self, n_input_plane, n_output_plane, kernel_w
Code: def
Code: def set_val_summary(self, summary):                  callBigDlFunc(self.bigdl_type, "setValSummary", self.value,                       summary)         return self
Set the validation dataset.          :param rdd: the validation dataset         :param batch_size: batch size         :param val_method: the validation method, "top1" or "top5"         :return: self Code: def set
Code: def set_traindata(self, training_rdd, batch_
Code: def summary_scope(
Code: def read_data_sets(train_dir, data_type="train"):          TRAIN_IMAGES = 'train-images-idx3-ubyte.gz'     TRAIN_LABELS = 'train-labels-idx1-ubyte.gz'     TEST_IMAGES = 't10k-images-idx3-ubyte.gz'     TEST_LABELS = 't10k-labels-idx1-ubyte.gz'      if data_type == "train":         local_file = base.maybe_download(TRAIN_IMAGES, train_dir,                                          SOURCE_URL + TRAIN_IMAGES)         with open(local_file, 'rb') as f:
Code: def get_news20(source_dir="./data/news20/"):          news_dir = download_news20(source_dir)     texts = []  # list of text samples     label_id = 0     for name in sorted(os.listdir(news_dir)):         path = os.path.join(news_dir, name)         label_id +=
Code: def get_glove_w2v(source_dir="./data/news20/", dim=100):          w2v_dir = download_glove_w2v(source_dir)     w2v_path = os.path.join(w2v_dir, "glove.6B.%sd.txt" % dim)     if sys.version_info < (3,):         w2v_f
Convert the given optimizer method to the corresponding BigDL optimizer.  :param method: Optimizer method :return: BigDL optimizer Code: def __convert_criterion(self, criterion):         """         Convert the given loss function to the corresponding BigDL criterion.         :param criterion: Loss function         :return: BigDL criterion         """         if criterion == "mse":             return "MSECriterion"         elif criterion == "mae":             return "MAECriterion"         elif criterion == "smoothl1":             return "SmoothL1Criterion"         elif criterion == "bce":             return "BCECriterion"         elif criterion == "bcewithlogits":             return "BCEWithLogitsCriterion"         elif criterion == "crossentropy":             return "CrossEntropyCriterion"         elif criterion == "cosine":             return "CosineDistanceCriterion"         elif criterion == "hinge":             return "HingeEmbeddingCriterion"         elif criterion == "kullbackleiblerdivergence":             return "KLDCriterion"         elif criterion == "l1":             return "L1Criterion"         elif criterion == "l2":             return "L2Criterion"         elif criterion == "marginranking":             return "MarginRankingCriterion"         elif criterion == "multilabelmargin":             return "MultiLabelMarginCriterion"         elif criterion == "multilabelsoftmargin":             return "MultiLabelSoftMarginCriterion"         elif criterion == "nll":             return "ClassNLLCriterion"
Load a pre-trained Bigdl model.          :param path: The path containing the pre-trained model.
Evaluate the model on the given data.          :param x: input data         :param y: label data         :param batch_size: batch size         :return: loss value and accuracy         :rtype: list[float] Code: def get_instance(self, payload):         """         Build an instance of MessageInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.message.MessageInstance         :rtype: twilio.rest.chat.v2.service.channel.message.MessageInstance         """         return MessageInstance(             self._version,             payload,
Predicts the label of the input data.          :param x: Input data.         :type x: RDD         :return: Predicted label.         :rtype: RDD Code: def predict_proba_local(self, x):         """         Predicts the probability
Code: def get_mnist(sc, data_type="train", location="/tmp/mnist"):          (images, labels) = mnist.
Normalize the image by subtracting the mean and dividing by the standard         deviation.          :param image: image to normalize         :param mean: mean to subtract         :param std: standard deviation to divide by         :
Code: def get_trigger_value_unit_value_unit_type(options):          if options.triggerType.lower() == "epoch":
Convenience method to access members of the contained list          :param unicode key: The index of the resource to fetch          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.
Code: def __init__(self, version, service_sid, channel_sid, ):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def stream(self, limit=None, page_size=None):         """         Streams InviteInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until the limit         is reached.         The results are returned as a generator, so this operation is memory efficient.          :param int limit: Upper limit for the number of records to return. stream()                           guarantees to never return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, stream() will attempt to read the                               limit with the most efficient page size, i.e. min(limit, 1000)
Code: def __init__(self, bigdl_type, *args):     super(JavaValue, self).__init__(bigdl_type,
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __unicode__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         return unicode(self
Code: def _to_java_object_rdd(rdd):          rdd = rdd._reserialize(Auto
Convert a Spark RDD partition iterator to a Java RDD partition iterator. Code: def _to_java_object_dataframe_rdd(df):     """
Code: def get_activation_by_name(activation_name, activation_
Code: def from_tensor_rdd_variable(cls, a_tensor_rdd_variable, bigdl_type="float"):                  if
Code: def get_label(self):                  label = callBigDlFunc(self.bigdl
Code: def read_parquet(cls, path, sc, bigdl_type="float"):                  return DistributedImageFrame
Code: def write_parquet(cls, path, output, sc,
Get the image frame from the image          :param str url: The url to the image         :param str float_key: The key to use for the float values         :param bool to_chw: Whether to convert the image to CHW format          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def get_image_frame_from_file(self, file_path, float_
Code: def get_image(self, float_key="floats", to_chw=True):                  tensors
Code: def get_label(
Code: def get_predict_local_image_label(self, key="predict"):                  predicts = callBigDlFunc(self.bigdl_type, "imageFrameToPredict", self.value, key)         return predicts.map(lambda predict: (predict[0], predict[1].to_ndarray()) if predict[1] else (
Code: def __init__(self, bmodel, **kwargs):         """         Initialize the model.          :param bmodel: the model to be wrapped         :type bmodel: :class:`pyspark.mllib.regression.LinearRegressionModel`         """         self.bmodel = bmodel         self.input_dim = bmodel.weights.shape[0]         self.output_dim = bmodel.weights.shape[1]         self.intercept = bmodel.intercept         self.weights = bmodel.weights.toArray()         self.intercept = bmodel.intercept         self.input_names = kwargs.get('input_names', None)         self.output_names = kwargs.get('output_names', None)         self.feature_names = kwargs.get('feature_names', None)         self.feature_types = kwargs.get('feature_types', None)         self.feature_importances = kwargs.get('feature_importances', None)         self.feature_importances_std = kwargs.get('feature_importances_std', None)         self.feature_importances_mean = kwargs.get('feature_importances_mean', None)         self.feature_importances_std_mean = kwargs.get('feature_importances_std_mean', None)         self.feature_importances_std_std = kwargs.get('feature_importances_std_std', None)         self.feature_importances_std_mean_std = kwargs.get('feature_importances_std_mean_std', None)         self.feature_importances_std_mean_std_mean = kwargs.get('feature_importances_std_mean_std_mean', None)         self.feature_importances_std_mean_std_mean_std = kwargs.get('feature_importances_std_mean_std_mean_std', None)         self.feature_importances_std_mean_std_mean_std_mean = kwargs.get('feature_importances_std_mean_std_mean_std_mean', None)         self.feature_importances_std_mean_std_mean_std_mean_std = kwargs.get('feature_importances_std_mean_std_mean_std_mean_std', None)         self.feature
Build an instance of InviteInstance          :param dict payload:
Code
Code: def save_keras_definition(keras_model, path):          model_json = keras_model.to_json()     with open(path, "w") as json
Code: def build_keras_model():          from keras.models import Sequential     from keras.layers import Dense
```  ### 2.2.8. 调用BigDL的API  ```python Code: def predict_class_distributed(self, data_rdd):                  result = callBigDlFunc(self.bigdl_type,                                "modelPredictClass", self.value
Code: def set_weights(self, weights):                  tensors = [JTensor.from_ndarray(param, self.bigdl
Code: def get_weights(self):                  tensorWeights = callBigDlFunc(self.bigdl_type,                               "getWeights", self.value)         if tensorWeights is not None:             return [tensor.to_ndarray() for tensor in tensorWeights]         else:             print("The layer does not have weight/bias")             return None Code: def get_weights(self):                  tensorWeights = callBigDlFunc(self.bigdl_type,                               "getWeights", self.value)         if tensorWeights is not None:             return [tensor.to_ndarray() for tensor in tensorWeights]         else:             print("The layer does not have weight/bias")             return None Code: def get_weights(self):                  tensorWeights = callBigDlFunc(self.bigdl_type,                               "getWeights", self.value)         if tensorWeights is not None:             return [tensor.to_ndarray() for tensor in tensorWeights]         else:             print("The layer does not have weight/bias")             return None Code: def get_weights(self):                  tensorWeights = callBigDlFunc(self.bigdl_type,                               "getWeights", self.value)         if tensorWeights is not None:             return [tensor.to_ndarray() for tensor in tensorWeights]         else:             print("The layer does not have weight/bias")             return None Code: def get_weights(self):                  tensorWeights = callBigDlFunc(self.bigdl_type,                               "getWeights", self.value)         if tensorWeights is not None:             return [tensor.to_ndarray() for tensor in tensorWeights]         else:             print("The layer does not have weight/bias")             return None Code: def get_weights(self):                  tensorWeights = callBigDlFunc(self.bigdl_type,                               "getWeights", self.value)         if tensorWeights is not None:             return [tensor.to_ndarray() for tensor in tensorWeights]         else:             print("The layer does not have weight/bias")             return None Code: def get_weights(self):                  tensorWeights = callBigDlFunc(self.bigdl_type,                               "getWeights", self.value)         if tensorWeights is not None:             return [tensor.to_ndarray() for tensor in tensor
Code: def save_tensorflow(self, inputs, path, byte_order="little_endian", data_format="nhwc"):                  callBigDlFunc(
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, payload):         """         Initialize the AccountContext          :returns: twilio.rest.api.v2010.account.AccountContext         :rtype: twilio.rest.api.v2010.account.AccountContext         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': payload.get('sid'),             'date_created': deserialize.rfc2822_datetime(payload.get('date_created')),             'date_updated': deserialize.rfc2822_datetime(payload.get('date_updated')),             'friendly_name': payload.get('friendly_name'),             'uri': payload.get('uri'),            'subresource_uris': payload.get('subresource_uris'),         }          # Context         self._context = None         self._solution = {'sid': sid or self._properties['sid'], }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: AccountContext for this AccountInstance         :rtype: twilio.rest.api.v2010.account.AccountContext         """         if self._context is None:             self._context = AccountContext(self._version, sid=self._solution['sid'], )         return self._context      @property     def sid(self):         """         :returns: The unique string that identifies the resource         :rtype: unicode         """         return self._properties['sid']      @property     def date_created(self):
Load a pre-trained Caffe model.   :param model: A bigdl model definition
Code: def load_weights_from_hdf5_path(self, filepath):         """         Load weights from HDF5 file.          :param filepath: path to the HDF5 file         """         from bigdl.keras.converter import DefinitionLoader, WeightLoader         kmodel, bmodel = DefinitionLoader.from_hdf5_path(filepath)         WeightLoader.load_weights_from_kmodel(
Code: def __init__(self, bigdl_type="float"):         super(Criterion, self
加载权重          :param str def_json: 权重定义文件路径         :param str weights_hdf5: 权重文件路径         :param bool by_name: 是否按名称加载权重          :returns: keras.models.Model         :rtype: keras.models.Model Code: def load_weights_from_json_hdf5(def_json, weights_hdf5, by_name=False):                  bmodel = DefinitionLoader.from_json_path(def_json)         def_value = BCommon.text_from_path(def_json)         kmodel = model_from_json(def_value)         WeightLoader.load_weights_from_hdf5
Code: def load_imdb():
Code: def build_keras_model():          from keras.models import Sequential     from keras.layers import Dense, Dropout, Activation     from keras.layers import Embedding     from keras.layers import LSTM     from keras.layers import Convolution1D, MaxPooling1D     keras_model = Sequential()     keras_model.add(Embedding(20000, 128
Get the model parameters which containing: weight, bias, gradBias, gradWeight          :return: dict(layername -> dict(parametername -> ndarray))         :rtype: dict(str -> dict(str -> ndarray)) Code: def get_parameters_table(self):         """         Get the model parameters which containing: weight, bias, gradBias, gradWeight          :return: dict(layername -> dict(parametername -> ndarray))         :rtype: dict(str -> dict(str -> ndarray))         """         name_to_params = callBigDlFunc(self.bigdl_type,                                        "modelGetParameters",                                        self.value)          def to_ndarray(params):             return dict((param_name,                          np.array(values[0], dtype=self.get_dtype()).reshape(                              values[1])) for param_name, values in                         params.items())          return dict((layer_name, to_ndarray(params)) for layer_name, params in
Get the model parameters which containing: weight, bias, gradBias, gradWeight          :return: dict(layername -> dict(parametername -> ndarray))         :rtype: dict(str -> dict(str -> ndarray)) Code: def get_state(self):         """
Code: def get_mnist(data_type="train", location="/tmp/mnist"):          X, Y = mnist.read_data_sets(location
Code: def read_data_sets(data_dir):          WHOLE_DATA ='ml-1m.zip'     local_file = base.maybe_download(WHOLE_DATA, data_dir,
Code: def
Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param dict payload: A JSON response from the Twilio API          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init__(version, response=payload, solution=service_sid)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._context      @property     def invites(self):         """         :returns: A list of instances of InviteInstance         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]         """         return self._proxy.invites      @property     def page_size(self):         """         :returns: How many resources to return in each list page. The default is 50, and the maximum is 1000.         :rtype: unicode         """         return self._properties['page_size']      @property     def start(self):         """         :returns: The index of the first resource to return in the response         :rtype: unicode         """         return self._properties['start']      @property     def end(self):         """         :returns: The index of the last resource in the response         :rtype: unicode         """         return self._properties['end']      @property     def uri(self):         """         :returns: The URI of the resource, relative to `https://chat.twilio
Code: def export_checkpoint(checkpoint_path):          reader = tf.train.NewCheckpointReader(checkpoint_path)      # Get tensor name list     tensor_names = filter(lambda n: n!='global_step',                           reader.get_variable_to_shape_map().keys())     # Prepare key-value dictionary     tensors = {}     for tn in tensor_names:         tensors[tn] = reader.get
Code: def save_variable_bigdl(tensors, target_path, bigdl_type="float"):          import numpy as np     jtensors
Code: def expand_tile(units, axis):          assert axis in (1, 2)     n_time
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset,                  links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': sid,             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def date_created(self):         """         :returns: The ISO 8601 date and time in GMT when the resource was created         :rtype: datetime         """         return self._properties['date_created']      @property     def date_updated(self):         """         :returns: The ISO 860
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._invites = None         self._members = None         self._messages = None         self._webhooks = None      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = InviteList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._invites      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the new resource belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._invites = None         self._members = None         self._messages = None         self._webhooks = None      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = InviteList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._invites      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._messages
Extracts all n-grams upto a given maximum order from an input segment. Code: def _compute_bleu(reference_corpus, translation_corpus, max_order=4,                  smooth=False):      matches_by_order = [0] * max_order   possible_matches_by_order = [0] * max_order   reference_length = 0   translation_length = 0   for (references, translation) in zip(reference_corpus,                                        translation_corpus):     reference_length += min(len(r) for r in references)     translation_length += len(translation)      merged_ref_ngram_counts = collections.Counter()     for reference in references:       merged_ref_ngram_counts |= _get_ngrams(reference, max_order)     translation_ngram_counts = _get_ngrams(translation, max_order)     overlap = translation_ngram_counts & merged_ref_ngram_counts     for ngram in overlap:       matches_by_order[len(ngram)-1] += overlap[ngram]     for order in range(1, max_order+1):       possible_matches = len(translation) - order + 1       if possible_matches > 0:         possible_matches_by_order[order-1] += possible_matches    precisions = [0] * max_order   for i in range(0, max_order):     if smooth:       precisions[i
Code: def _get_timestamp_utc_str(self):         """         Get the current UTC timestamp as a string          :returns: UTC timestamp as a string         :rtype: str         """         return datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3] Docstring
Get the current timestamp in local string format with timezone.          :returns: The current timestamp in local string format with timezone.         :rtype: str Code: def _get_timestamp_local_str_with_tz_and_offset(self):         """         Get the current timestamp in local string format with timezone and offset.          :returns: The current timestamp in local string format with timezone and offset.         :rtype: str         """         return datetime.now(tz=
Makes the request and returns the response.          :param str target_url: API-generated URL for the requested results page          :returns: Response from the API         :rtype: twilio.rest.resources.base.ResourcePage Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  by=values.unset, order=values.unset, limit=None, page_size=None):         """         Initialize the ChannelList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to read the resources from         :param channel_sid: The SID of the Channel the member belongs to         :param sid: The SID of the Member resource to fetch         :param date_created: The ISO 8601 date and time in GMT when the resource was created         :param date_updated: The ISO 8601 date and time in GMT when the resource was last updated         :param by: The `identity` value of the User that created the Member resource         :param order: How to sort by date created         :param limit: Upper limit for the number of records to return. list() guarantees                           never to return more than limit.  Default is no limit         :param page_size: Number of records to fetch per request, when not set will use                           the default value of 50 records.  If no page_size is defined                           but a limit is defined, list() will attempt to read the limit                           with the most efficient page size, i.e. min(limit, 1000)          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2
Code: def dump_weights(tf_save_dir, outfile, options):           def _get_outname(tf_name):         outname = re.sub(':0$', '', tf_name)         outname = outname.lstrip('lm/')         outname = re.sub('/rnn/', '/RNN/', outname)         outname = re.sub('/multi_rnn_cell/', '/MultiRNNCell/', outname)         outname = re.sub('/cell_', '/Cell', outname)         outname = re.sub('/lstm_cell/', '/LSTMCell/', outname)         if '/RNN/' in outname:             if 'projection' in outname:                 outname = re.sub('projection/kernel', 'W_P_0', outname)             else:                 outname = re.sub('/kernel', '/W_0', outname)                 outname = re.sub('/bias', '/B', outname)         return outname      ckpt_file = tf.train.latest_checkpoint(tf_save_dir)      config = tf.ConfigProto(allow_soft_placement=True)     with tf.Graph().as_default():         with tf.Session(config=config) as sess:             with tf.variable_scope('lm'):                 LanguageModel(options, False)  # Create graph                 # we use the "Saver" class to load the variables                 loader = tf.train.
Code: def read_data_by_config(config: dict):          dataset_config = config.get('dataset', None)      if dataset_config:         config.pop('dataset')         ds_type = dataset_config['type']         if ds_type == 'classification':             reader = {'class_name': 'basic_classification_reader'}             iterator = {'class_name': 'basic_classification_iterator'}             config['dataset_reader'] = {**dataset_config, **reader}             config['dataset_iterator'] = {**dataset_config, **iterator}         else:             raise Exception("Unsupported dataset type: {}".format(ds_type))      try:         reader_config = dict(config['dataset_reader'])     except KeyError:         raise ConfigError("No dataset reader is provided in the JSON config.")      reader = get_model(reader_config.pop('class_name'))()     data_path = reader_config.pop('data_path', '')     if isinstance(data_path, list):         data_path = [expand_path(x
Code: def train_evaluate_model_from_config(config: Union[str, Path, dict],                                      iterator: Union[DataLearningIterator, DataFittingIterator] = None, *,                                      to_train: bool = True,                                      evaluation_targets: Optional[Iterable[str]] = None,                                      to_validate: Optional[bool] = None,                                      download: bool = False,                                      start_epoch_num: Optional[int] = None,                                      recursive: bool = False) -> Dict[str, Dict[str, float]]:          config = parse_config(config)      if download:         deep_download(config)      if to_train and recursive:         for subconfig in get_all_elems_from_json(config['chainer'], 'config_path'):             log.info(f'Training "{subconfig}"')             train_evaluate_model_from_config(subconfig, download=False, recursive=True)      import_packages(config.get('metadata', {}).get('imports', []))      if iterator is None:         try:             data = read_data_by_config(config)         except ConfigError as e:             to_train = False             log.warning(f'Skipping training. {e.message}')         else:             iterator = get_iterator_from_config(config, data)      if 'train' not in config:         log.warning('Train config is missing. Populating with default values')     train_config = config.get('train')      if start_epoch_num is not None:         train_config['start_epoch_num'] = start_epoch_num      if 'evaluation_targets' not in train_config and ('validate_best' in train_config                                                      or 'test_best' in train_config):         log.warning('"validate_best" and "test_best" parameters are deprecated.'                    'Please, use "evaluation_targets" list instead')          train_config['evaluation_targets'] = []         if train_config.pop('validate_best', True):             train_config['evaluation_targets'].append('valid')         if train_config.pop('test_best', True):             train_config['evaluation_targets'].append('test')      trainer_class = get_model(train_config.pop('class_name', 'nn_trainer'))     trainer =
Code: def interact_alice(agent: Agent):          data = request.get_json()     text = data['request'].get('command', '').strip()     payload = data['request'].get('payload')      session_id = data['session']['session_id']     user_id = data['session']['user_id']     message_id = data['session']['message_id']      dialog_id = DialogID(user_id, session_id)      response = {        'response': {             'end_session': True,             'text': ''         },         "session": {            'session_id': session_id,            'message_id': message_id,             'user_id': user_id         },        'version': '1.0'     }      agent_response: Union[str, RichMessage] = agent([payload or text], [dialog_id])[0]     if isinstance(agent_response, RichMessage):         response['response']['text'] = '\n'.join([j['content']                                                   for j in agent_
Get an item from the list of resources in the response.          :returns: An instance of the resource at the given index, or None if                   that
Code: def proba2labels(proba: [list, np.ndarray], confident_threshold: float, classes:  [list, np.ndarray]) -> np.ndarray:          return np.array([np.argmax(
Code: def _get_session():         """         Get a session for the current thread.          :returns: A session for the current thread.         :rtype: tf.Session         """         if not hasattr(thread_local,'session'):             thread_local
Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :
Get the optimizer          :returns: The optimizer         :rtype:
:param float learning_rate: Learning rate         :param float momentum: Momentum Code: def _update_graph_variables(self, learning
Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         return '<Twilio.Chat.V2.InvitePage>' Docstring
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __
Get the channel sid from the channel name          :param str channel_name: The channel name          :returns: The channel sid         :rtype: str Code: def _get_channel_sid(self, channel_name):         """         Get the channel sid from the channel name          :param str channel_name: The channel name          :returns: The channel sid         :rtype: str         """         channel_sid = None         if channel_name:             channel_sid = self.client.channels.list(                 service_sid=
Get an invite instance from the invite_sid          :param str invite_sid: The invite_sid          :returns: twilio.rest.chat.v2.service.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.invite.InviteInstance Code: def _get_
Get the channel sid from the channel sid          :param str channel_sid: The channel sid          :returns: The channel sid         :rtype: str Code: def _get_channel_sid_by_attributes(self, attributes):         """         Get the channel sid from the channel attributes          :param dict attributes: The channel attributes          :returns: The channel sid         :rtype: str         """         channel_sid = None         if
Get the channel sid from the channel instance or sid          :param twilio.rest.chat.v2.service.channel.ChannelInstance channel_instance_or_sid: The channel instance or sid          :returns: The channel sid         :rtype: str Code: def _get_channel_sid_from_channel_name(self, channel_name):         """         Get the channel sid from the channel name          :param str channel_name:
Code: def get_instance(self, payload):         """         Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         return InviteInstance(             self._version,             payload,             service_sid=self._solution['service_sid
Code: def __call__(self, inputs, state, scope=None):         """Run the RNN cell on inputs, starting from the given state
Get the channel sid from the channel name          :param str channel_name: The channel name          :returns: The channel sid         :rtype: str Code: def _get_channel_sid(self, channel_name):         """         Get the channel sid from the channel name          :param str channel_name: The channel name          :returns: The channel sid         :rtype: str         """         channel_sid = None         if channel_name:             channel_sid = self.client.channels.list(                 service_sid=
Get the channel sid from the channel name          :param str channel_name: The channel name          :returns: The channel sid         :rtype: str Code: def _get_channel_sid(self, channel_name):         """         Get the channel sid from the channel name          :param str channel_name: The channel name          :returns: The channel sid         :rtype: str         """         channel_sid = None         if channel_name:             channel_sid = self.client.channels.list(                 service_sid=
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the new Member belongs to          :returns: twilio.rest.chat.v2.service.channel.channel_context.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.channel_context.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._members = None         self._messages = None         self._invites = None         self._webhooks = None      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._messages = MessageList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._messages      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None
Get the channel sid from the channel name          :param str channel_name: The channel name          :returns: The channel sid         :rtype: str Code: def _get_channel_sid(self, channel_name):         """         Get the channel sid from the channel name          :param str channel_name: The channel name          :returns: The channel sid         :rtype: str         """         channel_sid = None         if channel_name:             channel_sid = self._client.channels.list(                 service
Get the channel sid from the channel name          :param str channel_name: The channel name          :returns: The channel sid         :rtype: str Code: def _get_channel_sid(self, channel_name):         """         Get the channel sid from the channel name          :param str channel_name: The channel name          :returns: The channel sid         :rtype: str         """         channel_sid = None         if channel_name:             channel_sid = self.client.channels.list(                 service_sid=
Get the channel sid from the channel name          :param str channel_name: The channel name          :returns: The channel sid         :rtype: str Code: def _get_channel_sid(self, channel_name):         """         Get the channel sid from the channel name          :param str channel_name: The channel name          :returns: The channel sid         :rtype: str         """         channel_sid = None         if channel_name:             channel_sid = self._client.channels.list(                 service_sid=
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the new resource belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._members = None         self._messages = None         self._invites = None         self._webhooks = None      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._messages = MessageList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._messages      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = Inv
Build a basic network          :param word_outputs: Output layer for word embeddings          :returns: Output layer for word embeddings         :rtype: keras.layers.core.Dense Code: def _build_word_cnn(self, word_inputs):         """         Build a CNN for word embeddings          :param word_inputs: Input layer for word embeddings          :returns: Output layer for word embeddings         :rtype: keras.layers.core.Dense         """         word_embeddings = word_inputs         for i, (filter_size, dense_dim) in enumerate(self.word_filters):             word_embeddings = kl.Conv1D(filters=dense_dim, kernel_size=filter_size,                                         padding="same", activation="relu")(word_embeddings)         word_embeddings
Code: def _build_word_cnn(self, inputs):                  inputs = kl.Lambda(kb.one_hot, arguments={"num_classes": self.symbols_number_},                            output_shape=lambda x: tuple(x) + (self.symbols_number_,))(inputs)         char_embeddings = kl.Dense(self.char_embeddings_size, use_bias=False)(inputs)         conv_outputs = []         self.char_output_dim_ = 0         for window_size, filters_number in zip(self.char_window_size, self.char_filters):             curr_output = char_embeddings             curr_filters_number = (min(self.char_filter_multiple * window_size, 200)                                    if filters_number is None else filters_number)             for _ in range(self.char_conv_layers - 1):                 curr_output = kl.Conv2D(curr_filters_number, (1, window_size),                                         padding="same", activation="relu",                                         data_format="channels_last")(curr_output)                 if self.conv_dropout > 0.0:                     curr_output = kl.Dropout(self.conv_dropout)(curr_output)             curr_output = kl.Conv2D(curr_filters_number, (1, window_size),                                     padding="same", activation="relu",                                     data_format="channels_last")(curr_output)             conv_outputs.append(curr_output)             self.char_output_dim_ += curr_filters_number         if len(conv_outputs) > 1:             conv_output = kl.Concatenate(axis=-1)(conv_outputs)         else:             conv_output = conv_outputs[0]         highway_input = kl.Lambda(kb.max, arguments={"axis": -2})(conv_output)         if self.intermediate_dropout > 0.0:             highway_input = kl.Dropout(self.intermediate_dropout)(highway_input)         for i in range(self.char_highway_layers - 1):             highway_input = Highway(activation="relu")(highway_input)             if self.highway_dropout > 0.0:                 highway_input = kl.Dropout(self.
Build the network          :param word_outputs: Output of the word embedding layer         :type word_outputs: keras.layers.Layer          :returns: keras.layers.Layer         :rtype: keras.layers.Layer Code: def _build_network_with_attention(self, word_outputs):         """         Build the network with attention          :param word_outputs: Output of the word embedding layer         :type word_outputs: keras.layers.Layer          :returns: keras.layers.Layer         :rtype: keras.layers.Layer         """         if self.word_dropout > 0.0:             lstm_outputs = kl.Dropout(self.word_dropout)(word_outputs)         else:             lstm_outputs = word_outputs         for j in range(self.word_lstm_layers-1):             lstm_outputs = kl.Bidirectional(                 kl.LSTM(self.word_lstm_units[j], return_sequences=True,                         dropout=self.lstm_dropout))(lstm_outputs)         lstm_outputs = kl.Bidirectional(
Transform a single label into a format that can be used by the model.          :param list label: Label          :returns: Transformed label         :rtype: np.ndarray Code: def _transform_batch(self, data: List[Iterable], labels: Iterable[list]) -> Tuple[np.ndarray, np.ndarray]:         """         Transform a batch of data and labels into a format that can be used by         the model.          :param list data: List of data points         :param list labels: List of labels          :
Transform batch of data to numpy array          :param list data: list of data to transform          :returns: numpy array of transformed data         :rtype: numpy.ndarray Code: def _transform(self, data: Union[list, tuple]) -> np.ndarray:         """         Transform data to numpy array          :param list data: list of data to transform          :returns: numpy array of transformed data         :rtype: numpy.ndarray         """         if isinstance(data, list):             data = np.array(data)         if isinstance(data, tuple):             data =
Code: def _make_sent_vector(self, sent: List, bucket_length: int =None) -> np.ndarray:                  bucket_length = bucket_length or len(sent)         answer = np.zeros(shape=(bucket_length, MAX_WORD_LENGTH+2), dtype=np.int32)         for i, word in enumerate(sent):             answer[i, 0] = self.tags.tok2idx("BEGIN")             m = min(len(word), MAX_WORD_LENGTH)             for
:param list[str] tags: List of tags to be encoded         :param int bucket_length: Length of the vector to be returned. If not specified, defaults to the
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the new resource belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._members = None         self._messages = None         self._invites = None         self._webhooks = None      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._messages = MessageList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._messages      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = Inv
Convenience method for accessing the first page of         :func:`twilio.rest.chat.v2.service.channel.invite.InviteList.list`          :param str key: The key-value pair of the resources to fetch          :returns: twilio.rest.chat.v2.service.channel.invite.Invite
Get the client key from the environment.          :returns: A PKey object.         :rtype: crypto.PKey Code: def _get_client_key_passphrase(self) -> Optional[str]:         """         Get
Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'identity': payload.get('identity'),             'role_sid': payload.get('role_sid'),             'date_created': deserialize.rfc2822_datetime(payload.get('date_created')),             'date_updated': deserialize.rfc2822_datetime(payload.get('date_updated')),             'url': payload.get('url'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': payload.get('sid'),         }      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property     def service_sid(self):         """         :returns: The SID of the Service that the resource is associated with         :rtype: unicode         """         return self._properties['service_sid']      @property     def channel_sid(self):         """         :returns: The SID of the Channel the resource belongs to         :rtype: unicode         """         return self._properties['channel_sid']      @property     def identity(self):         """         :returns: The identity of the User that created the resource         :rtype: unicode         """         return self._properties['identity']      @property     def role_sid(self):         """         :returns: The
Iterate over all of the instances in this page          :returns: Iterator of all instances, or an iterable of results         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance] Code: def __getitem__(self, key: str) -> InviteInstance:         """         Access the instances of the Channel          :returns: The requested ChannelInstance         :rtype: tw
Code: def verify_sc_url(signature_chain_url: str) -> bool:     """     Verify Amazon signature chain url      :param str signature_chain_url: Amazon signature chain url      :returns: True if Amazon signature chain url is valid, False otherwise     :rtype: bool     """     try:         sc_url_get = requests.get(signature_chain_url)     except requests.exceptions.ConnectionError as e:         log.error(f'Amazon signature chain url get error: {e}')         return False      sc_url_txt = sc_url_get.text     sc_url_txt = sc_url_txt.replace('\n', '')     sc_url_txt = sc_url_txt.replace('\r', '')     sc_url_txt = sc_url_txt.replace(' ', '')      sc_url_txt_split = sc_url_txt.split('-----BEGIN CERTIFICATE-----')     sc_url_txt_split = sc_url_txt_split[1:]      sc_url_txt_split = [x for x in sc_url_txt_split if x]      sc_url_txt_split = [x.strip() for x in sc_url_txt_split]      sc_url_txt_split = [x for x in sc_url_txt_split if x]      sc_url_txt_split = [x.strip() for x in sc_url_txt_split]      sc_url_txt_split = [x for x in sc_url_txt_split if x]      sc_url_txt_split = [x.strip() for x in sc_url_txt_split]      sc_url_txt_split = [x for x in sc_url_txt_split if x]      sc_url_txt_split = [x.strip() for x in sc_url_txt_split]      sc_url_txt_split = [x for x in sc_url_txt_split if x]      sc_url_txt_split = [x.strip() for x in sc_url_txt_split]      sc_url_txt_split = [x for x in sc_url_txt_split if x]      sc_url_txt_split = [x.strip() for x in
Returns true if both instances are not equal, false otherwise          :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance          :returns: True if other is not a InviteInstance and they are not equal, False otherwise         :rtype: bool Code: def __init__(self, version, payload, service_sid, channel_sid, ) -> None:         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version         self._solution = {            'service_sid': service_sid,             'channel_sid
Code: def __iter__(self):         """         Iterate
Returns true if both instances are not equal, false otherwise          :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance          :returns: True if other is not a InviteInstance and they are not equal, False otherwise         :rtype: bool Code: def __init__(self, version, payload, service_sid, channel_sid, ) -> None:         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version         self._solution = {            'service_sid': service_sid,             'channel_
Convenience method for accessing the first page of         :func:`ip_messaging.v2.service.channel.invite.InviteList.list`          :param str key: The key-value pair of the resources to fetch          :returns: twilio.rest.chat.v2.service.channel
Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'created_by': payload.get('created_by'),             'created_by_identity': payload.get('created_by_identity'),             'role_sid': payload.get('role_sid'),             'date_created': deserialize.iso8601_datetime(payload.get('date_created')),             'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')),             'url': payload.get('url'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': payload.get('sid'),         }      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property     def service_sid(self):         """         :returns: The SID of the Service that the resource is associated with         :rtype: unicode         """         return self._properties['service_sid']      @property     def channel_sid(self):         """         :returns: The SID of the Channel the resource is associated with         :rtype: unicode         """         return self._properties['channel_sid']      @property     def created_by(self):         """         :returns: The identity of the User that created the resource         :rtype: unicode         """
Code: def __init__(self, version, service_sid, channel_sid):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the new resource belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def stream(self, limit=None, page_size=None):         """         Streams InviteInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until the limit         is reached.         The results are returned as a generator, so this operation is memory efficient.          :param int limit: Upper limit for the number of records to return. stream()                           guarantees to never return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, stream() will attempt to read the                               limit with the most efficient page size, i.e. min(limit, 1000)          :returns: Generator that will yield up to limit results         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]         """         limits = self._version.read_limits(limit, page_size)          page = self.page(page_size=limits['page_size'], )          return self._version.stream(page, limits['limit'], limits['page_limit'])      def list(self, limit=None, page_size=None):         """         Lists InviteInstance records from the API as a list.         Unlike stream(), this operation is eager and will load `limit` records into         memory before returning.          :param int limit
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset, identity=values.unset,                  role_sid=values.unset, channel_sid=values.unset,                  date_expires=values.unset, expiration_period=values.unset,                  date_accepted=values.unset, date_rejected=values.unset,                  date_canceled=values.unset, date_revoked=values.unset,                  from_=values.unset, to=values.unset, body=values.unset,                  media=values.unset, index=values.unset, attributes=values.unset,                  x_twilio_webhook_enabled=values.unset):         """         Initialize the InviteContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to         :param sid: The SID of the Invite resource to fetch          :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         super(InviteContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites/{sid}'.format(**self._solution)          # Dependents         self._channel = None         self._member = None          # Context         self._context = None         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid or self._properties['sid'], }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, response, service_sid, channel_sid, ) -> None:         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to          :returns: twilio.rest.chat.v2.service.
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __repr__(self):
Code: def _pretrained_initializer(varname, weight_file, embedding_weight_file=None):          weight_name_map = {}     for i in range(2):         for j in range(8):  # if we decide to add more layers             root = 'RNN_{}/RNN/MultiRNNCell/Cell{}'.format(i, j)             weight_name_map[root + '/rnn/lstm_cell/kernel'] = \                 root + '/LSTMCell/W_0'             weight_name_map[root + '/rnn/lstm_cell/bias'] = \                 root + '/LSTMCell/B'             weight_name_map[root + '/rnn/lstm_cell/projection/kernel'] = \                 root + '/LSTMCell/W_P_0'      # convert the graph name to that in the checkpoint     varname_in_file = varname[5:]     if varname_in_file.startswith('RNN'):         varname_in_file = weight_name_map[varname_in_file]      if varname_in_file == 'embedding':         with h5py.File(embedding_weight_file, 'r') as fin:             # Have added a special 0 index for padding not present             # in the original model.             embed_weights = fin[varname_in_file][...]             weights = np.zeros(                 (embed_weights.shape[0] + 1, embed_weights.shape[1]),                 dtype=DTYPE             )             weights[1:, :] = embed_weights     else:         with h5py.File(weight_file, 'r') as fin:             if varname_in_file == 'char_embed':                 # Have added a special 0 index for padding not present                 # in the original model.                 char_embed_weights = fin[varname_in_file][...]                 weights = np.zeros(                     (char_embed_weights.shape[0] + 1,                      char_embed_weights.shape[1]),                     dtype=DTYPE                 )                 weights[1:, :] = char_embed_weights             else:                 weights = fin[varname_in_file][...]      # Tensorflow initializers are callables that accept a shape parameter     # and some optional kwargs     def ret(shape, **kwargs):         if
Convenience method for accessing the invites of a channel.          :param sid: The sid          :returns: twilio.rest.chat.v
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, service_sid, channel_sid, sid):         """         Initialize the InviteContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to         :param sid: The SID of the Invite
Get an instance of a user from the page
Initialize the InvitePage          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to         :param dict response: Response from the API          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def __getitem__(self, key: str) -> InviteInstance:         """         Convenience method for accessing the
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  identity=values.unset, role_sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  url=values.unset, links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._version.account_sid,            'service_sid': service_sid,             'channel_sid': channel_sid,             'identity': identity,             'role_sid': role_sid,             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :
Get a list of all variables that are not optimizer variables.          :param tuple exclude_scopes: Scopes to exclude from the list of variables.          :returns: List of all variables that are not optimizer variables.         :rtype: List[tf.Variable] Code: def _get_saveable_variables(self, exclude_scopes: tuple = ('Optimizer',)) -> List[tf.Variable]:         """         Get a list of all variables that are not optimizer variables.          :param tuple exclude_scopes: Scopes to exclude from the list of variables.          :returns: List of all variables that are not optimizer variables.         :rtype: List[tf.Variable]         """         variables = tf.get_collection(tf.GraphKeys.GLOBAL_VARIABLES)         optimizer_variables = tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES, scope='Optimizer')         return [var for var in
Get all variables that are not in the exclude_scopes from the checkpoint          :param str checkpoint_path: Path to the checkpoint          :param tuple exclude_scopes: Scopes to exclude
Code: def get_train_op(self,                      loss,                      learning_rate,                      optimizer=None,                      clip_norm=None,                      learnable_scopes=None,                      optimizer_scope_name=None,                      **kwargs):                  if optimizer_scope_name is None:             opt_scope = tf.variable_scope('Optimizer')         else:             opt_scope = tf.variable_scope(optimizer_scope_name)         with opt_scope:             if learnable_scopes is None:                 variables_to
:param str word: The word to search for.         :param int d: The maximum edit distance.         :param bool allow_spaces: Whether to allow spaces in the word.         :param bool return_cost: Whether to return the cost of the edit.         :returns: A list of tuples of the form (word, cost)         :rtype: list[tuple[str, int]] Code: def _trie_search(self, word, d, allow_spaces=True, return_cost=True):         """         Search the trie for the given word.          :param str word: The word to search for.         :param int d: The maximum edit distance.         :param bool allow_spaces: Whether to allow spaces in the word.         :param bool return_cost: Whether to return the cost of the edit.         :returns: A list of tuples of the form (word, cost)         :rtype: list[tuple[str, int]]         """         if not allow_spaces and " " in word:             raise ValueError("Spaces are not allowed in the word")         if not word:             return []         if word in self.words:             return [(word, 0)] if return_cost else [word]         if len(word) > d:             return []         if len(word) == 1:             return [(w, 1) for w in self.words if w[0] == word] if return_cost else [w for w in self.words if w[0] == word]         if len(word) == 2:             return [(w, 2) for w in self.words if w[0:2] == word] if return_cost else [w for w in self.words if w[0:2] == word]         if len(word) == 3:             return [(w, 3) for w in self.words if w[0:3] == word] if return_cost else [w for w in self.words if w[0:3] == word]         if len(word) == 4:             return [(w, 4) for w in self.words if w[0:4] == word] if return_cost else [w for w in self.words if w[0:4] == word]         if len(word) == 5:             return
Code: def _make_default_operation_costs(self, allow_spaces=False):
Send a packet to the server          :param packet: Packet to send         :type packet: twilio.rest.chat.v2.service.channel.invite.packet.Packet Code: def _receive_packet(self, packet: packet.Packet) -> None:         """         Receive a packet from the server          :param packet: Packet to receive         :type packet: twilio.rest.chat.v2.service.channel.invite.packet.Packet         """         self.logger.debug('Received packet: %s', packet)         if packet.type == packet.PONG:             self.pong_received = True         elif packet.type == packet.ERROR:             self.queue.put(None)         elif packet.type == packet.MESSAGE:             self.queue.put(packet)         elif packet.type == packet.INVITE:             self.queue.put(packet)         elif packet.type == packet.CHANNEL_UPDATE:             self.queue.put(packet)         elif packet.type == packet.CHANNEL_DELETE:             self.queue.put(packet)         elif packet.type == packet.MEMBER_UPDATE:             self.queue.put(packet)         elif packet.type == packet.MEMBER_DELETE:             self.queue.put(packet)         elif packet.type == packet.COMMAND:             self.queue.put(packet)         elif packet.type == packet.PRESENCE_UPDATE:             self.queue.put(packet)         elif packet.type == packet.PRESENCE_DELETE:             self.queue.put(packet)         elif packet
This background task sends a PING to the server at
Code: def _act(self
Get the session ID from the API          :param dict request: Request to send to the API          :returns: Session ID from the API         :rtype
Send a packet to the server          :param packet.Packet packet: Packet to send          :returns: None         :rtype: None Code: def _handle_packet(self, packet: packet.Packet) -> None:         """         Handle a packet from the server          :param packet.Packet packet: Packet to handle          :returns: None         :rtype: None         """         self.logger.debug(f'Handling packet: {packet}')         if packet.type == packet.MESSAGE:             self.queue.put(packet.data)         elif packet.type == packet.PONG:             self.pong_received = True         elif packet.type == packet.ERROR:             self.logger.error(f'Error from server: {packet.data}')             self.queue.put(
Handle session timeout request          :param dict request: Request payload          :returns: dict         :rtype: dict Code: def _handle_session_start(self, request: dict) -> dict:
Handle invalid session response from Alexa          :param dict request: Request payload          :returns: dict         :rtype
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __call__(self, service_sid, channel_sid, sid):         """         Constructs a InviteContext          :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the new resource belongs to         :param sid
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset, links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['account_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource
Get a role instance from the role_sid          :param str role_sid: The sid of the role to get          :returns: twilio.rest.chat.v2.service.role.RoleInstance         :rtype: twilio.rest.chat
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset,                  links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['service_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset, date_created=values.unset, date_updated=values.unset, created_by=values.unset, url=values.unset, links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['service_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def sid(self) -> str:         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self) -> str:         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property     def service_sid(self) -> str:         """         :returns: The SID of the Service that the resource is associated with         :rtype: unicode         """         return self._properties['service_sid']      @property     def channel_sid(self) -> str:         """         :returns: The SID of the Channel the resource belongs to         :rtype: unicode         """         return self._properties['channel_sid']      @property     def date_created(self) -> datetime:         """         :returns: The RFC 2822 date and time in GMT when the resource was
Read a file with the format:  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment  # comment
Build an instance of InviteInstance          :param dict payload:
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset,                  links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': sid,             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def date_created(self):         """         :returns: The ISO 8601 date and time in GMT when the resource was created         :rtype: datetime         """         return self._properties['date_created']      @property     def date_updated(self):         """         :returns: The ISO 860
Code: def get_metric_
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, response, solution):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service that the resource is associated with          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init__(version, response)                  self._solution = solution Doc
Code: def _get_best(values: List[float], losses: List[float],                   max_loss_div: float = 0.9, min_val_div: float = 10.0) -> float:                  assert len(values) == len(losses), "lengths of values and losses should be equal"         min_ind = np.argmin(losses)         for i in range(min_ind - 1, 0, -1):             if (losses[i] * max_loss_div > losses[min_ind]) or\                     (values[i] * min_val_div < values[min_ind]):                 return values[i + 1]         return values[min_ind] / min_val
Get the word vectors for a given list of tokens          :param List[str] tokens: List of tokens to get the vectors for          :returns: List of word vectors         :rtype: List[np.ndarray] Code: def _get_word_vectors_mean(self, tokens: List[str]) -> np.ndarray:         """         Get the mean of the word vectors for a given list of tokens          :param List[str] tokens: List of tokens to get the vectors for          :returns: Mean of the word vectors         :rtype: np.ndarray         """         return np.mean(self._
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, service_sid, channel_sid):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def get_instance(self, payload):         """         Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         return InviteInstance(             self._version,             payload,             service_sid=self._solution['service_sid'],             channel_sid=self._solution['channel_sid
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset,                  links=values.unset):         """         Initialize the InviteInstance          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to         :param sid: The unique string that identifies the resource         :param date_created: The RFC 2822 date and time in GMT when the resource was created         :param date_updated: The RFC 2822 date and time in GMT when the resource was last updated         :param created_by: The identity of the User that created the resource         :param url: The absolute URL of the resource         :param links: The absolute URLs of the Channel and User resources related to the Invite          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['account_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'date_created': deserialize.rfc2822_datetime(date_created),             'date_updated': deserialize.rfc2822_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype:
Code: def export2hub(weight_file, hub_dir, options):           spec = make_module_spec(options, str(weight
Convenience method for accessing the first page of         :func:`twilio.rest.chat.v2.service.channel.invite.InviteList.list`          :param str key: The key-value pair of the resources to fetch          :returns: twilio.rest.chat.v2.service.channel.invite.

Run the bot framework server.      :param callable agent_generator: A function that returns an agent.     :param str app_id: The Microsoft Teams app ID.     :param str app_secret: The Microsoft Teams app secret.     :param bool stateful: Whether the server should be stateful. Code: def send_message(self, message):         """         Send a message to the channel.          :param str message: The message to send.          :returns: The response from the API.         :rtype: dict         """         data = {
Iterate over pages of Invites          :returns: Page of InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def __getitem__(self, key):         """         Get an instance of a InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         return self._version.get
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  identity=values.unset, role_sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  url=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['account_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'identity': identity,             'role_sid': role_sid,             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'url': url,         }          self._solution = {             'account_sid': account_sid,            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property     def service_sid(self):         """         :returns: The SID of the Service that the resource is associated with         :rtype: unicode         """         return self._properties['service_sid']      @property     def channel_sid(self):         """         :returns: The SID of the Channel the resource belongs to         :rtype: unicode         """         return self._properties['channel_sid']      @property     def identity(self):         """         :returns: The identity of the User that created the resource         :rtype: unicode         """         return self._

Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, service_sid, channel_sid, ):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      @property     def page_size(self):         """         :returns: How many resources to return in each list page. The default is 50, and the maximum is 1000.         :rtype: unicode         """         return self._properties['page_size']      @property     def next_page_url(self):         """         :returns: The URL of the next page in the list         :rtype: unicode         """         return self._properties['next_page_url']      @property     def
:returns: Number
Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def __repr__(self):         """         Provide a friendly
Returns true if both instances are not equal, false otherwise          :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance          :returns: True if other is not a InviteInstance and they are not equal, False otherwise         :rtype: bool Code: def __init__(self, version, payload, service_sid, channel_sid, ) -> None:         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': payload.get('
Returns true if both instances are not equal, false otherwise          :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance          :returns: True if other is not a InviteInstance and they are not equal, False otherwise         :rtype: bool Code: def __init__(self, version, payload, service_sid, channel_sid, ) -> None:         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version         self._solution = {            'service_sid': service_sid,             'channel_
Returns true if both instances are not equal, false otherwise          :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance          :returns: True if other is not a InviteInstance and they are not equal, False otherwise         :rtype: bool Code: def __init__(self
Returns true if both instances are not equal, false otherwise          :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance          :returns: True if other is not a InviteInstance and they are not equal, False otherwise         :rtype: bool Code: def __init__(self, version, payload, service_sid, channel_sid, ) -> None:         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': payload.get('
Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'identity': payload.get('identity'),             'role_sid': payload.get('role_sid'),             'date_created': deserialize.iso8601_datetime(payload.get('date_created')),             'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')),             'url': payload.get('url'),             'links': payload.get('links'),         }
Code: def squad_v2_f1(y_true: List[List[str]], y_predicted: List[str]) -> float:          f1_total = 0.0     for ground_truth, prediction in zip(y_true, y_predicted):         prediction_tokens = normalize_answer(prediction).split()         f1s = []         for gt in ground_truth:             gt_tokens = normalize_answer(gt).split()             if len(gt_tokens) == 0 or len(prediction_tokens) == 0:                 f1s.append(float(gt_tokens == prediction_tokens))                 continue             common = Counter(prediction_tokens) & Counter(gt_tokens)             num_same = sum(common.values())             if num_same == 0:                 f1s.append(0.0)                 continue             precision = 1.0 * num_same / len(prediction_tokens
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset,                  links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': None,            'service_sid': service_sid,             'channel_sid': channel_sid,             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property
Code: def _get_gpu_memory_fraction():     global _gpu_available     if _gpu_available is None:         _gpu_available = check_gpu_existence()     if _gpu_available:         try:             from tensorflow.python.client import device_lib             local_device_protos = device_lib.list_local_devices()             gpu_device = [x.name for x in local_device_protos if x.device_type == 'GPU']             if len(gpu_device) > 0:                 gpu_memory_fraction = 0.5                 return gpu_memory_fraction             else:                 return 0.0
Code: def _parse_config_property(item: _T,
Recursively parse config properties          :param dict config: Config         :param dict variables: Variables          :returns: Parsed config         :rtype: dict Code: def _parse_config_property(config: dict, variables: dict) -> dict:
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  identity=values.unset, role_sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  url=values.unset):         """         Initialize the InviteContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to         :param sid: The SID of the Invite resource to fetch          :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         super(InviteContext, self).__init__(version)          # Path Solution         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites/{sid}'.format(**self._solution)          # Dependents         self._channel = None         self._member = None          # Context         self._context = None         self._properties = {'identity': identity, 'role_sid': role_sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'url': url, }          if sid is not None:             self._properties['sid'] = sid      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property
Code: def _init_param(param: Any, mode: str = 'infer') -> Any:     if isinstance(param, dict):         return {k: _init_param(v, mode) for k, v in param.items()}     elif isinstance(param, list):         return [_init_param(v, mode) for v in param]     elif isinstance(param, str):         if param.startswith('$'):             return _refs[param[1:]]         elif param.startswith('${'):             return _refs[param[2:-1]]         elif param.startswith('${'):             return _refs[param[2:-1]]         elif param.startswith('${'):             return _refs[param[2:-1]]         elif param.startswith('${'):             return _refs[param[2:-1]]         elif param.startswith('${'):             return _refs[param[2:-1]]         elif param.startswith('${'):             return _refs[param[2:-1]]         elif param.startswith('${'):             return _refs[param[2:-1]]         elif param.startswith('${'):             return _refs[param[2:-1]]         elif param.startswith('${'):             return _refs[param[2:-1]]         elif param.startswith('${'):             return _refs[param[2:-1]]         elif param.startswith('${'):             return _refs[param[2:-1]]         elif param.startswith('${'):             return _refs[param[2:-1]]         elif param.startswith('${'):             return _refs[param[2:-1]]         elif param.startswith('${'):             return _refs[param[2:-1]]         elif param.startswith('${'):             return _refs[param[2:-1]]         elif param.startswith('${'):             return _refs[param[2:-1]]         elif param.startswith('${'):             return _refs[param[2:-1]]         elif param.startswith('${'):             return _refs[param[2:-1]]         elif param.startswith('${'):             return _refs[param[2:-1]]         elif param.startswith('${'):             return _refs[param[2:-1]]         elif param.startswith('${'):             return _refs[param[2:-1]]         elif param.startswith('${'):             return _
Handle a request          :param Request request: The request to handle          :returns: The response to the request         :rtype: Response Code: def _handle_get_request(self, request: Request) -> Response:         """         Handle a GET request          :param Request request: The request to handle          :returns: The response to the request         :rtype: Response         """         if request.path[0] == '':             raise TwilioException('Empty pathname')         response = Response()         if request.path[0] == 'v2':             if request.path[1] == 'Services':                 response = self.handle_get_v2_services(request)             elif request.path[1] == 'Services/':                 response = self.handle_get_v2_services(request)             elif request.path[1] == 'Services/default':                 response = self.handle_get_v2_services_default(request)             elif request.path[1] == 'Services/default/Channels':                 response = self.handle_get_v2_services_default_channels(request)             elif request.path[1] == 'Services/default/Channels/':                 response = self.handle_get_v2_services_default_channels(request)             elif request.path[1] == 'Services/default/Channels/Members':                 response = self.handle_get_v2_services_default_channels_members(request)             elif request.path[1] == 'Services/default/Channels/Members/':                 response = self.handle_get_v2_services_default_channels_members(request)             elif request.path[1] == 'Services/default
Get a conversation by unique_name          :param str unique_name: The unique_name of the conversation to get          :returns: The conversation with the given unique_name         :rtype: Optional[twilio.rest.chat.v2.service.channel.conversation.
Update the list of valid certificates.          :param valid_certificates: List of valid certificates         :type valid_certificates: List[str] Code: def __init__(self, version, service_sid, channel_sid, ) -> None:         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.
Send a packet to the server          :param packet: Packet to send         :type packet: twilio.rest.chat.v2.service.channel.invite.packet.Packet          :returns: None         :rtype: None Code: def _handle_packet(self, packet: packet.Packet) -> None:         """         Handle a packet from the server          :param packet: Packet to handle         :type packet: twilio.rest.chat.v2.service.channel.invite.packet.Packet          :returns: None         :rtype: None         """         if packet.type == packet.MESSAGE:             self.on_message(packet)         elif packet.type == packet.PONG:             self.pong_received = True
Initialize the agent          :returns: The agent         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def _get_conversation(self, conversation_key: str) -> Conversation:         """
Get an item from the list of resources          :param unicode key: The index of the resource to fetch          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def __call__(self, sid):         """         Constructs a Invite
Get an item from the list of resources in the response.          :returns: An instance of the resource at the given index         :rtype: twilio
Generate the payload for the request          :returns: Payload for the request         :rtype: dict Code: def get_resource_location(self, payload: dict) -> str:         """         Magic method to get the resource
Build an instance of InviteInstance          :param dict payload: Payload response
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, response, solution):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.
Code: def from_kvs(keyvals):                  obj = H2OCluster()         obj._retrieved_at = time.time()         for k, v in keyvals
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, response, solution):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The service_sid          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init__(version, response)                  # Path Solution         self._solution = solution
Code: def __iter__(self):         """         Iterate over list of invites          :returns: List of invites         :rtype: list[twilio
List the H2O clouds available in the network.          :returns: list of H2O clouds         :rtype: list Code: def list_nodes(self):         """         List the H2O nodes in the cluster.          :returns: list of H2O nodes         :rtype: list         """         return h2o.api("GET /3/Nodes") Doc
Retrieve a list of all Messages for the Channel          :param int limit: Upper limit for the number of records to return. list() guarantees                           never to return more than limit.  Default is no limit         :param str order: The sort order of the returned messages. Can be: 'asc' or 'desc' and the default is 'asc'         :param str from_: The Message Sid or index of the first Message to read          :returns: generator of twilio.rest.chat.v2.service.channel.message.MessageInstance         :rtype: list[twilio.rest.chat.v2.service.channel.message.MessageInstance] Code: def list_messages_by_index(self, limit=None, order='asc', from_=''):         """         Retrieve a list of all Messages for the Channel          :param int limit: Upper limit for the number of records to return. list() guarantees                           never to return more than limit.  Default is no limit         :param str order: The sort order of the returned messages. Can be: 'asc' or 'desc' and the default is 'asc'         :param str from_: The Message Sid or index of the first Message to read          :returns: list of twilio.rest.chat.v2.service.channel.message.MessageInstance         :rtype: list[twilio.rest.chat.v2.service.channel.message.MessageInstance]         """         return list(self.stream_messages_by
Code
Returns true if both instances are not equal, false otherwise          :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def __init__(self, version, payload, service_sid, channel_sid, sid=None):         """         Initialize the InviteInstance          :returns: twilio
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, payload, service_sid, channel_sid, ):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'identity': payload.get('identity'),             'role_sid': payload.get('role_sid'),             'date_created': deserialize.iso8601_datetime(payload.get('date_created')),             'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')),             'url': payload.get('url'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :
Initialize the InvitePage          :param Version version: Version that contains the resource         :param dict payload: A JSON response from the Twilio API          :returns: twilio.
Return the summary for a single column for a single Frame in the h2o cluster.            :param str key: The key of the Frame to get the summary for.         :param str column: The column to get the summary for.         :param int timeoutSecs: The timeout in seconds for the request.         :param dict kwargs: Additional parameters to pass to the request.          :returns: The summary for the column in the Frame.         :rtype: dict         '''         params_dict = {              # 'offset': 0,             # 'len': 100         }         h2o_methods.check_params_update_kwargs(params_dict, kwargs,'summary', True)                  result = self.do_json_request('3/Frames.json/%s/columns/%s/summary' % (key, column), timeout=timeoutSecs, params=params_dict)         h2o_sandbox.check_sandbox_for_errors()         return result Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelInstance          :returns: twilio.rest.chat.v2.service.channel.ChannelInstance         :rtype: twilio.rest.chat.v2.service.channel.ChannelInstance         """         super(ChannelInstance, self).__init__(*args, **kwargs)          # Marshaled Properties         self
Delete a model view on the h2o cluster, given its key.          :param str key: The key of the model view to delete.         :param bool ignoreMissingKey: If True,
Return a model metrics or all of the model metrics known to the         h2o cluster.  The model metrics are contained in a dictionary         called "model_metrics" at the top level of the result.  The         dictionary maps algorithm names to parameters lists.  Each of the         parameters contains all the metdata required by a client to         present a model building interface to the user.          if parameters = True, return the parameters? Code: def model_metrics_list(self, algo=None, timeoutSecs=10, **kwargs):     '''     Return a model metrics list or all of the model metrics lists known to the     h2o cluster.  The model metrics lists are contained in a dictionary     called "model_metrics_list" at the top level of the result.  The     dictionary maps algorithm names to parameters lists.  Each of the     parameters contains
Check a dictionary of model builder parameters on the h2o cluster          using the given algorithm and model parameters.          :param str algo: The algorithm to use for the model builder.         :param str training_frame: The training frame to use for the model builder.         :param dict parameters: The parameters to use for the model builder.         :param int timeoutSecs: The timeout in seconds for the REST call.         :param kwargs: Additional parameters to pass to the REST call.          :returns: The response from the REST call.         :rtype: dict Code: def validate_model_parameters(self, algo, training_frame, parameters, timeoutSecs=60, **kwargs):     '''     Check a dictionary of model builder parameters on the h2o cluster      using the given algorithm and model parameters.     '''     assert algo is not None, '"algo" parameter is null'     # Allow this now: assert training_frame is not None, '"training_frame" parameter is null'     assert parameters is not None, '"parameters" parameter is null'      model_builders = self.model_builders(timeoutSecs=timeoutSecs)     assert model_builders is not None, "/ModelBuilders REST call failed"     assert algo in model_builders['model_builders']     builder = model_builders['model_builders'][algo]          # TODO: test this assert, I don't think this is working...     if training_frame is not None:         frames = self.frames(key=training_frame)         assert frames is not None, "/Frames/{0} REST call failed".format(training_frame)          key_name = frames['frames'][0]['key']['name']         assert key_name==training_frame, \             "/Frames/{0} returned Frame {1} rather than Frame {2}".format(training_frame, key_name, training_frame)          parameters['training_frame'] = training_frame      # TODO: add parameter existence checks     # TODO: add parameter value validation      # FIX! why ignoreH2oError here?     result = self.do_json_request('/3/ModelBuilders.json/' + algo + "/parameters", cmd='post',          timeout=timeoutSecs, postData=parameters, ignoreH2oError=True, noExtraErrorCheck=True)      verboseprint("model parameters validation: " + repr(result))     return result Doc
Create a new ChannelInstance          :param unicode service_sid: The SID of the Service to create the resource under         :param unicode friendly_name: A string to describe the resource         :param unicode attributes: A valid JSON string that contains application-specific data         :param unicode type: The visibility of the channel. Can be: `public` or `private` and defaults to `public`         :param unicode unique_name: An application-defined string that uniquely identifies the resource         :param unicode x_twilio_webhook_enabled: The X-Twilio-Webhook-Enabled HTTP request header          :returns
Code: def model_metrics(self, timeoutSecs=60, **kwargs):     '''     ModelMetrics list.      '''     result = self.do_json_request('/3/ModelMetrics.
Get all models from the h2o cluster.          :param bool ignoreMissingKey: If True, do not raise an exception if the model does not exist.         :param int
Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def __getitem__(self, key):         """         Get an item from the list of resources          :param unicode key: The index of the resource to fetch          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         return self._version.get(             'GET',             self._uri,             params={                 'PageToken': self._solution['page_token'],                 'Page': self._solution['page
Create a new reservation for count instances          :param int count: Number of instances to create         :param dict ec2_config: Configuration for the EC2 instance         :param str region: Region to create the EC2 instance in         :param bool waitForSSH: Wait for SSH to come up         :param dict tags: Tags to add to the EC2 instance          :returns: Reservation object         :rtype: boto.ec2.reservation.Reservation Code: def run_instances_with_ssh(count, ec2_config, region, tags=None):     '''Create a new reservation for count instances'''      ec2params = inheritparams(ec2_config, EC2_API_RUN_INSTANCE)     ec2params.setdefault('min_count', count)     ec2params.setdefault('max_count', count)      reservation = None     conn = ec2_connect(region)     try:         reservation = conn.run_instances(**ec2params)         log('Reservation: {0}'.format(reservation.id))         log('Waiting for {0} EC2 instances {1} to come up, this can take 1-2 minutes.'.format(len(reservation.instances), reservation.instances))         start = time.time()         time.sleep(1)         for instance in reservation.instances:             while instance.update() == 'pending':                time.sleep(1)                h2o_cmd.dot()              if not instance.state == 'running':                 raise Exception('\033[91m[ec2] Error waiting for running state. Instance is in state {0}.\033[0m'.format(instance.state))          log('Instances started in {0} seconds'.format(time.time() - start))         log('Instances: ')         for inst in reservation.instances: log("   {0} ({1}) : public ip: {2}, private ip: {3}".format(inst.public_dns_name, inst.id, inst.ip_address, inst.private_ip_address))                  # kbn: changing to private address, so it should fail if not in right domain         # used to have the public ip address         wait_for_ssh([ i.private_ip_address for i in reservation.instances ])          # Tag instances         try:             if tags:                 conn.create_tags([i.
Get the instance state from the instance ids          :param list[str] instance_ids: List of instance ids          :returns: list[str]         :rtype: list[str] Code: def _get_instance_tags(self, instance_ids):         """         Get the instance tags from the instance ids          :param list[
Get the default page size Code: def _get_page_size(self):         """         Get the default page size          :returns: int         :rtype: int         """         return self._version
Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def start_instances(instances, region):     '''Start all the instances given by its ids'''
Get the default page size Code: def _get_page_size(self):         """         Get the default page size          :returns: int         :rtype: int         """         return self._version.page_size Doc
Wait for ssh service to appear on given hosts'''     log('Waiting for SSH on following hosts: {0}'.format(ips))     for ip in ips:         if not skipAlive or not ssh_live(ip, port):              log('Waiting for SSH on instance {0}...'.format(ip))             count = 0             while count < requiredsuccess:                 if ssh_live(ip, port):                     count += 1                 else:                     count = 0                 time.sleep(1)                 h2o_cmd.dot() Code: def wait_for_ssh(ips, port=22, skipAlive=True, requiredsuccess=3):     ''' Wait for ssh service to appear on given hosts'''     log('Waiting for SSH on following hosts: {0}'.format(ips))     for ip in ips:         if not skipAlive or not ssh_live(ip, port):              log('Waiting for SSH on instance {0}...'.format(ip))             count = 0             while count < requiredsuccess:                 if ssh_live(ip, port):                     count += 1                 else:                     count = 0
Code: def __iter__(self):         """
Get the module of a function.          :param function: The function to get the module of.         :type function: function          :returns: The module of the function.         :rtype: module Code: def _get_function_source(function):     """     Get the source code of a function.      :param function: The function to get the source code of.     :type function: function      :returns: The source code of the function.     :rtype: str     """     if not inspect.isfunction(function):         raise TypeError("Expected a function, got %s" % type(function))     return inspect.getsource
Code: def _get_args_str(func, highlight=None):          if not func: return ""     s = str(inspect.signature(func))[1:-1]     if highlight:         s = re
Code: def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         return '<Twilio.IpMessaging.
Code: def _resolve_model(self, model_key, model_json):         """         Resolve the model from the model key.          :param str model_key: The model key.         :param dict model_json: The model JSON.         """         model_type = model_json["output"]["model_category"]         if model_type == "Binomial":             self._model = h2o.gbm.H2OGradientBoostingEstimator(**model_json["parameters"])         elif model_type == "Multinomial":             self._model = h2o.gbm.H2OGradientBoostingEstimator(**model_json["parameters"])         elif model_type == "AutoEncoder":             self._model = h2o.deeplearning.H2ODeepLearningEstimator(**model_json["parameters"])         elif model_type == "Clustering":             self._model = h2o.kmeans.H2OKMeansEstimator(**model_json["parameters"])         elif model_type == "DeepLearning":             self._model = h2o.deeplearning.H2ODeepLearningEstimator(**model_json["parameters"])         elif model_type == "DimReduction":             self._model = h2o.decomposition.H2OPCAEstimator(**model_json["parameters"])         elif model_type == "GeneralizedLinear":             self._model = h2o.glm.H2OGeneralizedLinearEstimator(**model_json["parameters"])         elif model_type == "IsolationForest":             self._model = h2o.isolation_forest.H2OIsolationForestEstimator(**model_json["parameters"])         elif model_type == "NaiveBayes":             self._model = h2o.naive_bayes.H2ONaiveBayesEstimator(**model_json["parameters"])         elif model_type == "Regression":             self._model = h2o.glm.H2OGeneralizedLinearEstimator(**model_json["parameters"])         elif model_type == "StackedEnsemble":             self._model = h2o.stack.H2OStackedEnsembleEstimator(**model_json["parameters"])         elif model_type == "AutoEncoder":             self._model = h2o.deeplearning.H2ODeepLearningEstimator(**model_json["parameters"])         elif model_type == "Word
Code: def _train(self, x=None, y=None, training_frame=None, offset_column=None, fold_column=None,                weights_column=None, validation_frame=None, max_runtime_secs=None, ignored_columns=None,                model_id=None, verbose=False):         """         Train a model.          :param x: The names or indices of the predictor variables.         :type x: list of str or int         :param y: The name or index of the response variable.         :type y: str or int         :param training_frame: The H2OFrame containing the training data.         :type training_frame: H2OFrame         :param offset_column: The name or index of the offset column.         :type offset_column: str or int         :param fold_column: The name or index of the fold column.         :type fold_column: str or int         :param weights_column: The name or index of the weights column.         :type weights_column: str or int         :param validation_frame: The H2OFrame containing the validation data.         :type validation_frame: H2OFrame         :param max_runtime_secs: Maximum allowed runtime in seconds for model training. Use 0 to disable.         :type max_runtime_secs: float         :param ignored_columns: Names of columns to ignore for training.         :type ignored_columns: list of str         :param model_id: The unique id assigned to the resulting model.         :type model_id: str         :param verbose: Whether to print information about the progress of the model training.         :type verbose: bool         """         if training_frame is None:             raise H2OValueError("training_frame cannot be None")         if x is None:             raise H2OValueError("x cannot be None")         if y is None:             raise H2OValueError("y cannot be None")         if not isinstance(x, (list, tuple)):             x = [x]         if not isinstance(y, (list, tuple)):             y = [y]         if not isinstance(training_frame, H2OFrame):             raise H2OValueError("training_frame must be an H2OFrame")         if not isinstance(offset_column, (list, tuple)):             offset_column
Code: def fit(self, X, y=None, **params):                  stk = inspect.stack()[1:]         warn = True         for s in stk:             mod = inspect.getmodule(s[0])             if mod:                 warn = "sklearn" not in mod.__name__                 if not warn: break         if warn:             warnings.warn("\n\n\t`fit` is not recommended outside of the sklearn framework. Use `train` instead.",                           UserWarning, stacklevel=2)         training_frame = X.cbind(y) if y is not None else X         x = X.names         y = y.names[0] if y is not None else None         self
Code: def get_params(self, deep=True):                  out = dict()         for key, value in self.
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  identity=values.unset, role_sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  url=values.unset):         """         Initialize the InviteContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to create the resource under         :param channel_sid: The SID of the Channel the new resource belongs to         :param sid: The SID of the Invite resource to fetch         :param identity: The `identity` value that identifies the new resource's User         :param role_sid: The SID of the Role to assign to the new resource         :param date_created: The ISO 8601 date and time in GMT when the resource was created         :param date_updated: The ISO 8601 date and time in GMT when the resource was last updated         :param url: The absolute URL of the resource          :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         super(InviteContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites/{sid}'.format(**self._solution)          # Dependents         self._channel = None         self._user = None          # Context         self._context = None         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid or self._properties['sid'], }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._
Get the identity from the identity argument or the identity property         of the channel.          :returns: The identity         :rtype: unicode Code: def _get_role_sid(self):         """         Get the role sid from the role_sid argument or the role_sid property of         the channel.          :returns: The role sid         :rtype: unicode         """         if self._role_sid is not None:             return self._role_sid         elif self._
Code: def remove_sandbox(parent_dir, dir_name):          if "Rsandbox" in dir_name:         rsandbox_dir = os.path.join(parent_dir, dir_name)         try:             if sys.platform == "win32":                 os.system(r'C:/cygwin64/bin/rm.exe -r -f "{0}"'.format(rsandbox_dir))             else:                 shutil.rmtree(rsandbox_dir)         except OSError as e:             print("")             print("ERROR: Removing RSandbox directory failed: " + rsandbox_dir)             print("       (errno {0}): {1}".format(e.errno, e.strerror
Code: def scrape
Code: def scrape_cloudsize_from_stdout(self, nodes_per_cloud):                  retries = 60         while retries > 0:             if self.terminated: return             f = open(self.output_file_name, "r")             s = f.readline()             while len(s) > 0:                 if self.terminated: return                 match
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  by=values.unset, role_sid=values.unset, url=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['account_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'by': by,             'role_sid': role_sid,             'url': url,         }          self._solution = {             'account_sid': account_sid,            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property     def service_sid(self):         """         :returns: The SID of the Service that the resource is associated with         :rtype: unicode         """         return self._properties['service_sid']      @property     def channel_sid(self):         """         :returns: The SID of the Channel the resource belongs to         :rtype: unicode         """         return self._properties['channel_sid']      @property     def date_created(self):         """         :returns: The RFC 2822 date and time in GMT when the resource was created         :
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str
Lists NodeInstance records from the API as a list.         Unlike stream(), this operation is eager and will load `limit` records into         memory before returning.          :returns: List of twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance] Code: def get_page(self, target_url):         """         Retrieve a specific page of InviteInstance records from the API.         Request is executed immediately          :param str target_url: API-generated URL for the requested results page          :returns: Page of InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         response = self._version.domain.twilio.request(             'GET
Code: def get_port(self):                  if len(self.client_nodes) > 0:             node = self.client_nodes
Code: def __init__(self, version, service_sid, channel_sid):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def stream(self, limit=None, page_
first_column = self.pre_trained.types[self.pre_trained.columns[0]]          if first_column!='string':             raise H2OValueError("First column of given pre_trained model %s is required to be a String",                                 self.pre_trained.frame_id)          if list(self.pre_trained.types.values()).count('string') > 1:             raise H2OValueError("There are multiple columns in given pre_trained model %s with a String type.",                                 self.pre_trained.frame_id)          self.vec_size = self.pre_trained.dim[1] - 1; Code: def _determine_vec_size(self):                  first_column = self.pre_trained.types[self.pre_trained.columns[0]]          if first_column!='string':             raise H2OValueError("First column of given pre_trained
Code: def huber_loss(y_actual, y_predicted, weights=None, delta=1.0):     """     Huber loss function.      Parameters     ----------     y_actual : array-like, shape = (n_samples,)         Ground truth (correct) target values.      y_predicted : array-like, shape = (n_samples,)         Estimated target values.      weights : array-like, shape = (n_samples,), optional         Sample weights.      delta : float, optional         Threshold value for the Huber loss.      Returns     -------     loss : float         Huber loss.      """
Code: def hinge(y_actual, y_predicted, weights=None):     """     Hinge loss function.      Parameters     ----------     y_actual : array-like, shape = (n_samples,)         Ground truth (correct) target values.      y_predicted : array-like, shape = (n_samples,)         Estimated target values.      weights : array-like, shape = (n_samples,), optional (default=None)         Sample weights.      Returns     -------     loss : float         Hinge loss of `y_actual` and `y_predicted`.      Notes     -----     The hinge loss is used for classification problems.      The hinge loss is defined as:     .. math::          L(y, \\hat{y}) = \\max(0, 1 - y \\hat{y})      Examples     --------     >>> from sklearn.metrics import hinge_loss     >>> y_true = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]     >>> y_pred = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]     >>> hinge_loss(y_true, y_pred)     0.0     >>> y_true = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]     >>> y_pred = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1.1]     >>> hinge_loss(y_true, y_pred)     0.0     >>> y_true = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]     >>> y_pred = [1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9]     >>> hinge_loss(y_true, y_pred)     0.1     >>> y_true = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]     >>> y_pred
Computes the gradient of the Huber loss between y_actual and y_predicted.      :param y_actual: The actual values.     :param y_predicted: The predicted values.     :param delta: The delta value for the Huber loss.     :return: The gradient of the Huber loss. Code: def huber_loss_hessian(y_actual, y_predicted, delta=1.0):     """     Computes the hessian of the Huber loss between y_actual and y_predicted.      :param y_actual: The actual values
Gini impurity is a measure of the inequality of a variable.         It is defined as the sum of the weighted squared differences between the         predicted and actual values.          :param y_actual: Actual values         :type y_actual: array-like, shape = [n_samples]         :param y_predicted: Predicted values         :type y_predicted: array-like, shape = [n_samples]         :param weights: Sample weights         :type weights: array-like, shape = [n_
Code: def _get_type_name(type_obj, dump=None):     if isinstance(type_obj, type):         return type_obj.__name__     elif isinstance(type_obj, U):         return "Union[%s]" % ", ".join(_get_type_name(t) for t in type_obj.types)     elif isinstance(type_obj, Tuple):         return "Tuple[%s]" % ", ".join(_get_type_name(t) for t in type_obj.types)     elif isinstance(type_obj, Dict):         return "Dict[%s, %s]" % (_get_type_name(type_obj.key_type), _get_type_name(type_obj.value_type))     elif isinstance(type_obj, Iterable):         return "Iterable[%s]" % _get_type_name(type_obj.type)     elif isinstance(type_obj, Callable):         return "Callable"     elif isinstance(type_obj, type(None)):         return "None"     elif isinstance(type_obj, type(Ellipsis)):         return "Ellipsis"     elif isinstance(type_obj, type(NotImplemented)):         return "NotImplemented"     elif isinstance(type_obj, type(True)):         return "bool"     elif isinstance(type_obj, type(False)):         return "bool"     elif isinstance(type_obj, type(0)):         return "int"     elif isinstance(type_obj, type(0.0)):         return "float"     elif isinstance(type_obj, type("")):         return "str"     elif isinstance(type_obj, type(b"")):         return "bytes"     elif isinstance(type_obj, type(set())):         return "set"     elif isinstance(type_obj, type(frozenset())):         return "frozenset"     elif isinstance(type_obj, type(tuple())):         return "tuple"     elif isinstance(type_obj, type(list())):         return "list"     elif isinstance(type_obj, type(dict())):         return "dict"     elif isinstance(type_obj, type(re.Pattern)):         return "re.Pattern"     elif isinstance(type_obj, type(re.Match)):         return "re.Match"     elif isinstance(type_obj, type
Get an item from the list of resources in the response.          :returns: An instance of the resource at the given index, or None if                   that
Get an item from the list of resources in the response.          :returns: An instance of the resource at the given index, or None if
Code:
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __repr__(self):         """
Code: def _get_lambda_source_code
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __unicode__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :
Code: def __
Iterate over list of Invites and return a generator yielding one Invite instance each          :returns: Generator that will yield up to limit results         :rtype: list[twilio.rest.chat.v2.service
Code: def get_config():                  self = H2OConfigReader._get_instance()         if not self._config_loaded:             self._read_config()         return self._config
Read the log file and return the last 100 lines.          :returns: log file contents         :rtype: str Code: def _read_log_files(self):         """         Read the log files and return the last 100 lines.          :returns: log file contents         :rtype: str         """         if not self._config_loaded:             self._read_config()         if not self._config:
Code: def _candidate_log_files():                  # Search for.
Code: def _store_model_progress(self, res, now):         """         Store the progress of the model.          :param numeric res: The progress of the model.         :param numeric now: The current time moment.         """         self._x0 = self._x0 + self._v0 * (now - self._t0)         self._v0 = self._v0 + self._ve * (now - self._t0)         self._t0 = now         self._x1 = self._x0 + self._v0 * (now - self._t0)         self._v1 = self._v0 + self._ve * (now - self._t0)         self._t1 = now         self._x2 = self._x1 + self._v1 * (now - self._t1)         self._v2 = self._v1 + self._ve * (now - self._t1)         self._t2 = now         self._x3 = self._x2 + self._v2 * (now - self._t2)         self._v3 = self._v2 + self._ve * (now - self._t2)         self._t3 = now         self._x4 = self._x3 + self._v3 * (now - self._t3)         self._v4 = self._v3 + self._ve * (now - self._t3)         self._t4 = now         self._x5 = self._x4 + self._v4 * (now - self._t4)         self._v5 = self._v4 + self._ve * (now - self._t4)         self._t5 = now         self._x6 = self._x5 + self._v5 * (now - self._t5)         self._v6 = self._v5 + self._ve * (now - self._t5)         self._t6 = now         self._x7 = self._x6 + self._v6 * (now - self._t6)         self._v7 = self._v6 + self._ve * (now - self._t6)         self._t7 = now         self._x8 = self._x7 + self._v7 * (now - self._t7)         self._v
Code: def _guess_next_poll_interval(self):         """         Guess the next poll interval based on the current progress.          :returns: The next poll interval in seconds         :rtype: int         """         if not self._progress_data:             return self.MIN_PROGRESS_CHECK_INTERVAL          # We want to make sure that the next poll is at least 1 second after the last one.         # This is to avoid the situation where the last poll is too fast and we miss the         # progress update.         last_poll_time, last_progress = self._progress_data[-1]         next_poll_time = last_poll_time + 1         if next_poll_time < last_poll_time:             next_poll_time = last_poll_time + 1          # We want to make sure that the next poll is at most 10 seconds after the last one.         # This is to avoid the situation where the last poll is too slow and we miss the         # progress update.         if next_poll_time + 10 < last_poll_time:             next_poll_time = last_poll_time + 10          # We want to make sure that the next poll is at least 1 second after the last one.         # This is to avoid the situation where the last poll is too fast and we miss the         # progress update.         if next_poll_time < last_poll_time:             next_poll_time = last_poll_time + 1          # We want to make sure that the next poll is at most 10 seconds after the last one.         # This is to avoid the situation where the last poll is too slow and we miss the         # progress update.         if next_poll_time + 10 < last_poll_time:             next_poll_time = last_poll_time + 10          # We want to make sure that the next poll is at least 1 second after the last one.         # This is to avoid the situation where the last poll is too fast and we miss the         # progress update.         if next_poll_time < last_poll_time:             next_poll_time = last_poll_time + 1          # We want to make sure that the next poll is at most 10 seconds after the last one.
Estimate the time delta when the progress will reach 100%          :param datetime.datetime now: Current time          :returns: datetime.timedelta         :rtype: datetime.timedelta Code: def _estimate_progress_completion_time_delta_impl_impl(self, now):         """         Estimate the time delta when the progress will reach 100%          :param datetime.datetime now: Current time          :returns: datetime.timedelta         :rtype: datetime.timedelta         """         if self._x0 == 1:             return datetime.timedelta(0)         return self._estimate_
Calculate the approximate speed of the raw progress based on recent data          :param float now: Current time          :returns: float         :rtype: float Code: def _poll_progress(self, now):         """         Poll the progress of the invite          :param float now: Current time          :returns: float         :rtype: float         """         if self._progress_data:             tlast, wlast = self._progress_data[-1]             if tlast >= now:                 return wlast             else:                 self._progress_data.append((now, wlast))         else:             self._progress_data.append((now, 0))          # If we've reached 100%, then we're done         if wlast == self._maxval:             self.queue.put(None)             return wlast          # If we've reached 50%, then we're done         if wlast == self._maxval / 2:             self.queue.put(None)             return wlast          # If we've reached 25%, then we're done         if wlast == self._maxval / 4:             self.queue.put(None)             return wlast          # If we've reached 12.5%, then we're done         if wlast == self._maxval / 8:             self.queue.put(None)             return wlast          # If we've reached 6.25%, then we're done         if wlast == self._maxval / 16:             self.queue.put(None)             return wlast          # If we've reached 3.125%, then we're done         if wlast == self._maxval / 32:             self.queue.put(None)             return wlast          # If we've reached 1.5625%, then we're done         if wlast == self._maxval / 64:             self.queue.put(None)             return wlast          # If we've reached 0.78125%, then we're done         if wlast == self._maxval / 128:             self.queue.put(None)             return wlast          # If we've reached 0.390625%, then we're done         if wlast == self._maxval / 25
Get the time of the progress data of the stream.          :returns: The time of the progress data of the stream.         :rtype: float Code: def _get_progress_data_time_
Code: def _compute_progress_at_time
Compute the progress at a given time          :param float t: Time to compute the progress at          :returns: (float, float)         :rtype: (float, float) Code: def _get_time_at_progress(self, x_target):                  t, x, v = self._t0, self._x0, self._v0         # The convergence should be achieved in just few iterations, however in unlikely situation that it doesn't         # we don't want to loop forever...         for _ in range(2
Code: def _draw_line_with_progress_and_percent_and_time(self, txt, final=False):         if not self._file_mode:             # If the user presses Ctrl+C this ensures we still start writing from the beginning of the line             sys.stdout.write("\r")         sys.stdout.write(txt)         if final and not isinstance(self._widget, _HiddenWidget):             sys.stdout.write("\n")         else:             if not self._file_mode:                 sys.stdout.write("\r")             sys.stdout.flush()
Render the footer remaining time
Iterate over pages of results          :returns: Page of InviteInstance         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance] Code:
Get an item from the list of resources          :param unicode key: The index of the resource to fetch          :returns: twilio.rest.chat.v2.service.channel
Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.
Get a frame from the H2O cluster by its path.          :param str path: The path of the frame to get.          :returns: A H2OFrame object.         :rtype: H2OFrame
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __str__(self):         return
Code: def __init__(self, ex, frame_id, col_names, col_types, row_count, row_names, row_ids, col_count, col_ids,                  col_major, chunk_id, chunk_size, chunk_offset, chunk_len, chunk_row_count, chunk_row_names,                  chunk_row_ids, chunk_col_count, chunk_col_names, chunk_col_ids, chunk_col_major, chunk_compression,                  chunk_checksum, chunk_checksum_offset, chunk_checksum_len, chunk_checksum_algo,                  chunk_checksum_algo_offset, chunk_checksum_algo_len, chunk_checksum_algo_name,                  chunk_checksum_algo_name_offset, chunk_checksum_algo_name_len, chunk_checksum_algo_name_encoding,                  chunk_checksum_algo_name_encoding_offset, chunk_checksum_algo_name_encoding_len,                  chunk_checksum_algo_name_encoding_name, chunk_checksum_algo_name_encoding_name_offset,                  chunk_checksum_algo_name_encoding_name_len, chunk_checksum_algo_name_encoding_name_encoding,                  chunk_checksum_algo_name_encoding_name_encoding_offset,                  chunk_checksum_algo_name_encoding_name_encoding_len, chunk_checksum_algo_name_encoding_name_encoding_name,                  chunk_checksum_algo_name_encoding_name_encoding_name_offset,                  chunk_checksum_algo_name_encoding_name_encoding_name_len,                  chunk_checksum_algo_name_encoding_name_encoding_name_encoding,                  chunk_checksum_algo_name_encoding_name_encoding_name_encoding_offset,                  chunk_checksum_algo_name_encoding_name_encoding_name_encoding_len,                  chunk_checksum_algo_name_encoding_name_encoding_name_encoding_encoding,                  chunk_checksum_algo_name_encoding_name_encoding_name_encoding_encoding_offset,                  chunk_checksum_algo_name_encoding_name_encoding_name_encoding_encoding_len,                  chunk_checksum_algo_name_encoding_name_encoding_name_encoding_encoding_encoding,                  chunk
Code: def __init__(self, service_sid, channel_sid, version, payload):         """         Initialize the InviteList          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Marshaled Properties         self._properties = {             'invites': payload.get('invites'),            'meta': payload.get('meta'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,         }      @property     def invites(self):         """         :returns: The list of Invites         :rtype: list[unicode]         """         return self._properties['invites']      @property     def meta(self):         """         :returns: The response metadata properties for the request         :rtype: dict
Code: def __le__(self, other):

Code: def __init__(self, service_sid, channel_sid, version, payload):         """         Initialize the InviteList          :param unicode service_sid: The SID of the Service to fetch the resource from         :param unicode channel_sid: The SID of the Channel the resource to fetch belongs to         :param Version version: Version that contains the resource         :param dict payload: The instance payload          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Marshaled Properties         self._properties = {             'invites': payload.get('invites'),            'meta': payload.get('meta'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,         }      @property     def invites(self):         """         :returns: The list of Invites         :rtype: unicode         """         return self._properties['invites']      @property     def meta(self):         """         :returns: The response metadata properties for the request         :rtype: dict         """         return self._properties['meta']      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._context      @property     def service_sid(self):         """         :returns: The SID of the Service that the resource is associated with         :rtype: unicode         """         return self._properties['service_sid']      @property     def channel_sid(self):         """         :returns: The SID of the Channel the resource to fetch belongs to         :rtype: unicode         """         return self._properties['channel_sid

Initialize the InvitePage          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def __getitem__(self, key):         """
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, service_sid, channel_sid):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def stream(self, limit=None, page_size=None):         """         Streams InviteInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until the limit         is reached.         The results are returned as a generator, so this operation is memory efficient.          :param int limit: Upper limit for the number of records to return. stream()                           guarantees to never return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, stream() will attempt to read the                               limit with the most efficient page size, i.e. min(limit, 1
Code: def set_level(self, level):                  return H2OF
Code: def set_levels(self, levels):                  assert_is_type(levels, [str])         return H2OFrame._expr
Code: def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         return '<Twilio.IpMessaging.V2.InviteList>' Doc
Delete the value of a column or
:param col: Column name or index         :type col: int, str, None         :param types: New column types         :type types: dict Code: def
Code: def isin(self, item):                  if is_type(item, list, tuple, set):             if self.ncols == 1 and (self.type(0) =='str' or self.type(0) == 'enum'):                 return self.match(item)             else:                 return functools.reduce(H2OFrame.__or__, (self == i for i in item))         else:             return self == item Doc
Code: def modulo_kfold
Code: def stratified_kfold_column(self, n_folds=3, seed=-1):                  return H2OFrame._expr(             expr=ExprNode("stratified_kfold_column", self, n_folds, seed))
Code: def __gt__(self, other):         return self.as_data_frame(use
Code: def __unicode__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str
Code: def __init__(self, expr, cache, nrows, ncols, names, types, **kwargs):         super(H2OF
Code: def __init__(self, expr, env):         super(H2
Concatenate a list of DataFrames along a particular axis.          :param list frames: List of DataFrames to concatenate.         :param int axis: Axis to concatenate along.          :returns: Concatenated DataFrame.         :rtype: pandas.DataFrame Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param dict payload: A JSON response from the Twilio API.          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Marshaled Properties         self._properties = {             'invites': payload.get('invites'),            'meta': payload.get('meta'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,         }      @property     def invites(self):         """         :returns: The list of Invites         :rtype: list[unicode]         """         return self._properties['invites']      @property     def meta(self):         """         :returns: The response metadata         :rtype: dict         """         return self._properties['meta']      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._context      def __getitem__(self, key):         """         Convenience method to access the list of invites          :returns: The list of invites         :rtype: list[unicode]         """         return self._proxy[key]      def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation
Code: def __init__(self, *args, **kwargs):         super(H2OFrame, self).__init__(*
Code: def __init__(self, session, service_sid, channel_sid, sid=None, **kwargs):         """         Initialize the InviteList          :param Session session: The session that owns this InviteList instance         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource is associated with         :param sid: The unique string that identifies the resource          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version=session.version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)          # Path Properties         self._properties = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      @property     def service_sid(self):         """         :returns: The SID of the Service that the resource is associated with         :rtype: unicode         """         return self._properties['service_sid']      @property     def channel_sid(self):         """         :returns: The SID of the Channel the resource is associated with         :rtype: unicode         """         return self._properties['channel_sid']      @property     def sid(self):         """         :returns: The unique string that identifies the resource         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property     def service_unique_name(self):         """         :returns: The unique string that identifies the resource's parent         :rtype: unicode         """         return self._properties['service_unique_name']      @property     def channel_unique_name(self):         """         :returns:
Split the frame into multiple frames based on the provided ratios.          :param list[float] ratios: The ratios to split the frame into.         :param list[str] destination_frames: The destination frames to split the frame into.         :param int seed: The seed to use for the random number generator.          :returns: list[H2OFrame]         :rtype: list[H2OFrame] Code: def split_frame(self, ratios=None, destination_frames=None, seed=None):                  assert_is_type(ratios, [numeric], None)         assert_is_type(destination_frames, [str], None)         assert_is_type(seed, int, None)          if ratios is None:             ratios = [0.75]         if not ratios:             raise ValueError("Ratios array may not be empty")          if destination_frames is not None:             if len(ratios) + 1!= len(destination_frames):                 raise ValueError("The number of provided destination_frames must be one more "                                  "than the number of provided ratios")          num_slices = len(ratios) + 1         boundaries = []          last_boundary = 0         i = 0         while i < num_slices - 1:             ratio = ratios[i]             if ratio < 0:                 raise ValueError("Ratio must be greater than 0")             boundary = last_boundary + ratio             if boundary >= 1.0:                 raise ValueError("Ratios must add up to less than 1.0")             boundaries.append(boundary)             last_boundary = boundary             i += 1          splits = []         tmp_runif = self.runif(seed)         tmp_runif.frame_id = "%s_splitter" % _py_tmp_key(h2o.connection().session_id)          i = 0         while i < num_slices:             if i == 0:                 # lower_boundary is 0.0                 upper_boundary = boundaries[i]                 tmp_slice = self[(tmp_runif <= upper_boundary), :]             elif i == num_slices - 1:                 lower_boundary = boundaries[i - 1]                 # upper_boundary is 1.0                 tmp_slice = self[(tmp
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, service_sid, channel_sid):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def stream(self, limit=None, page_size=None):         """         Streams InviteInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until the limit         is reached.         The results are returned as a generator, so this operation is memory efficient.          :param int limit: Upper limit for the number of records to return. stream()                           guarantees to never return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined
Iterate over the rows of this H2OFrame.          :return: An iterator over the rows of
Return a boolean H2OFrame indicating if the values are
Merge two H2OFrames.          :param other: The other H2OFrame to merge with.         :param all_x: If True, then all columns from the left frame are used.         :param all_y: If True, then all columns from the right frame are used.         :param by_x: The columns from the left frame to use.         :param by_y: The columns from the right frame to use.         :param method: The method to use for merging.          :returns: A new H2OFrame containing the merged data.         :rtype: H2OFrame Code: def merge(self, other, all_x=False, all_
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __repr__(self):         """         Provide
Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def page(self, page_token=values.unset, page_number=values.unset,              page_size=values.unset):         """         Retrieve a single page
Code: def var(self, y=None, na_rm=False, use=None):                  symmetric = False         if y is None:             y = self             symmetric = True         if use is None: use = "complete.obs" if na_rm else "everything"         if self.nrow == 1 or (self.ncol == 1 and y.ncol == 1):             return ExprNode
Code: def _repr_html_(self):         return self.as
Constructs a InviteContext          :param sid: The sid

Set an item or slice from this H2OFrame.          :param key: The item or slice to set.         :param value: The value to set the item or slice to. Code: def __delitem__(self, key):         """         Delete an item or slice from this H2OFrame.          :param key: The item or slice to delete.         """         if isinstance(key, slice):             self.slice(key.start, key.stop, key.step)[:] = None         elif isinstance(key, int):             self.iloc[key] = None         elif isinstance(key, (list, tuple)):             self.iloc[key] = None         elif isinstance(key, str):             self[
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         return '<Twilio.IpMessaging.V2.UserList {}>'.format
Set an item or slice from this H2OFrame.          :param key: The item or slice to set.         :param value: The value to set the item or slice to. Code: def __delitem__(self, key):         """         Delete an item or slice from this H2
Get an item from the list of resources          :param unicode key: The index of the resource to fetch          :returns: twilio.
Code: def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, response, service_sid, channel_sid):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.
Code: def __init__(self, raw_column_names, raw_column_types, raw_column_formats, raw_column_modes, raw_column_missing_values, raw_column_missing_count, raw_column_mean, raw_column_std, raw_column_min, raw_column_max, raw_column_sum, raw_column_count, raw_column_unique_count, raw_column_top_levels, raw_column_top_values, raw_column_top_counts, raw_column_quantiles, raw_column_modes_ext, raw_column_missing_values_ext, raw_column_mean_ext, raw_column_std_ext, raw_column_min_ext, raw_column_max_ext, raw_column_sum_ext, raw_column_count_ext, raw_column_unique_count_ext, raw_column_top_levels_ext, raw_column_top_values_ext, raw_column_top_counts_ext, raw_column_quantiles_ext, raw_column_modes_ext_ext, raw_column_missing_values_ext_ext, raw_column_mean_ext_ext, raw_column_std_ext_ext, raw_column_min_ext_ext, raw_column_max_ext_ext, raw_column_sum_ext_ext, raw_column_count_ext_ext, raw_column_unique_count_ext_ext, raw_column_top_levels_ext_ext, raw_column_top_values_ext_ext, raw_column_top_counts_ext_ext, raw_column_quantiles_ext_ext, raw_column_modes_ext_ext_ext, raw_column_missing_values_ext_ext_ext, raw_column_mean_ext_ext_ext, raw_column_std_ext_ext_ext, raw_column_min_ext_ext_ext, raw_column_max_ext_ext_ext, raw_column_sum_ext_ext_ext, raw_column_count_ext_ext_ext, raw_column_unique_count_ext_ext_ext, raw_column_top_levels_ext_ext_ext, raw_column_top_
Code: def hist(self, breaks="sturges", plot=True, **kwargs):                  server = kwargs.pop("server") if "server" in kwargs else False         assert_is_type(breaks, int, [numeric], Enum("
Code: def is_uuid_v4(
Code: def __init__(self, expr, env):         super(H2
Code: def
Code: def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, service_sid, channel_sid):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def stream(self, limit=None, page_size=None):         """         Streams InviteInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until the limit         is reached.         The results are returned as a generator, so this operation is memory efficient.          :param int limit: Upper limit for the number of records to return. stream()                           guarantees to never return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, stream() will attempt to read the                               limit with the most efficient page size, i.e. min(limit, 1
Code: def __repr__(self):         """         Provide a friendly representation          :returns:
Code: def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """
Code: def month_name_year(self):                  fr = H2OFrame._expr(expr=ExprNode("month_name_year", self), cache=self._ex._cache)         if fr._ex._cache.types_valid():             fr._ex._cache.types = {
Iterate over pages of results          :returns: Page of InviteInstance         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance] Code: def __len__(self):         """         :returns: Number of instances in
Code: def __init__(self, raw_expr, env=None):         """         Initialize a new H2OFrame.          :param H2OFrame raw_expr: The H2OFrame to wrap.         :param dict env: The environment to use for the H2OFrame.         """         self._ex = raw_expr         self._env = env         self._nrows = raw_expr._nrows         self._ncols = raw_expr._ncols         self._types = raw_expr._types         self._names = raw_expr._names         self._row_names = raw_expr._row_names         self._col_names = raw_expr._col_names         self._frame_id = raw_expr._frame_id         self._key = raw_expr._key         self._summary = raw_expr._summary         self._summary_frame = raw_expr._summary_frame         self._frame_data = raw_expr._frame_data         self._frame_data_raw = raw_expr._frame_data_raw         self._frame_data_raw_size = raw_expr._frame_data_raw_size         self._frame_data_raw_offset = raw_expr._frame_data_raw_offset         self._frame_data_raw_length = raw_expr._frame_data_raw_length         self._frame_data_raw_type = raw_expr._frame_data_raw_type         self._frame_data_raw_encoding = raw_expr._frame_data_raw_encoding         self._frame_data_raw_checksum = raw_expr._frame_data_raw_checksum         self._frame_data_raw_checksum_valid = raw_expr._frame_data_raw_checksum_valid         self._frame_data_raw_checksum_type = raw_expr._frame_data_raw_checksum_type         self._frame_data_raw_checksum_value = raw_expr._frame_data_raw_checksum_value         self._frame_data_raw_checksum_offset = raw_expr._frame_data_raw_checksum_offset         self._frame_data_raw_checksum_length = raw_expr._frame_data_raw_checksum_length         self._frame_data_raw_checksum_encoding = raw_expr._frame_data
Convert a pandas DataFrame to a H2OFrame.          :param pandas_frame: pandas DataFrame to convert.          :returns: H2OFrame.         :rtype: H2OFrame Code: def _get_frame_from_scipy(self, scipy_frame):         """         Convert a scipy sparse matrix to a H2OFrame.          :param scipy_frame: scipy sparse matrix to convert.          :returns: H2OFrame.         :rtype: H2OFrame         """         if scipy_frame is None:             return None         if isinstance(scipy_frame, H2OFrame):             return scipy
Code: def insert(self, i, value):         """         Insert a value into the frame at the given index.          :param int i: Index to insert the value at.         :param value: Value to insert.         :returns: self         """         if isinstance(value, H2OFrame):             if value.nrow!= 1 or value.ncol!= 1:                 raise ValueError("Can only insert a single value into a H2OFrame")             value = value.iloc[0,0]         if isinstance(value, H2OVec):             raise ValueError("Can only insert a single value into a H2OFrame")         if isinstance(value, H2OVec):             raise ValueError("Can only insert a single value into a H2OFrame")         if isinstance(value, H2OVec):             raise ValueError("Can only insert a single value into a H2OFrame")         if isinstance(value, H2OVec):             raise ValueError("Can only insert a single value into a H2OFrame")         if isinstance(value, H2OVec):             raise ValueError("Can only insert a single value into a H2OFrame")         if isinstance(value, H2OVec):             raise ValueError("Can only insert a single value into a H2OFrame")         if isinstance(value, H2OVec):             raise ValueError("Can only insert a single value into a H2OFrame")         if isinstance(value, H2OVec):             raise ValueError("Can only insert a single value into a H2OFrame")         if isinstance(value, H2OVec):             raise ValueError("Can only insert a single value into a H2OFrame")         if isinstance(value, H2OVec):             raise ValueError("Can only insert a single value into a H2OFrame")         if isinstance(value, H2OVec):             raise ValueError("Can only insert a single value into a H2OFrame")         if isinstance(value, H2OVec):             raise ValueError("Can only insert a single value into a H2OFrame")         if isinstance(value, H2OVec):             raise ValueError("Can
Code: def __init__(self, expr, env):         super(H2
Iterate over list of invites          :returns: List of InviteInstance         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance] Code: def __len__(self):
Code: def parse_file(
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __repr__(self):         """         Provide a friendly representation
Code: def __init__(self, version, service_sid, channel_sid):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_
Code: def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         return '<Twilio
:returns: Number of invites
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, service_sid, channel_sid, ):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      @property     def has_previous_page(self):         """         :returns: True if there is a previous page of records, else False         :rtype: bool         """         return self._version.page(method='GET', uri=self._previous_page_url, ) is not None      @property     def has_next_page(self):         """         :returns: True if there is a next page of records, else False         :rtype: bool         """         return self._version.page(method='GET', uri=
Code: def _connect_with_conf(config):     """     Connect to H2O cluster using the configuration provided in the config file.     """     if "connect_params" in config:         connect_params = config["connect_params"]     else:         connect_params = config     if "ip" in connect_params:         ip = connect_params["ip"]     else:         ip = None     if "port" in connect_params:         port = connect_params["port"]     else:         port = None     if "https" in connect_params:         https = connect_params["https"]     else:         https = None     if "verify_ssl_certificates" in connect_params:         verify_ssl_certificates = connect_params["verify_ssl
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset, **kwargs):         """         Initialize the InviteContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to         :param sid: The SID of the Invite resource to fetch          :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         super(InviteContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites/{sid}'.format(**self._solution)          # Dependents         self._channel = None      @property     def sid(self):         """         :returns: The SID of the Invite resource         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property     def service_sid(self):         """         :returns: The SID of the Service that the resource is associated with         :rtype: unicode         """         return self._properties['service_sid']      @property     def channel_sid(self):         """         :returns: The SID of the Channel the resource to fetch belongs to         :rtype: unicode         """         return self._properties['channel_sid']      @property     def role_sid(self):         """         :returns: The SID of the Role assigned to the user when they join the Channel         :rtype: unicode         """         return self._properties['role_sid']      @property     def identity(self):         """         :returns: The identity of the User when they join the Channel         :rtype: unicode         """         return self._properties['identity']      @property     def date_created(self):         """         :returns: The RFC 2822 date and time in
Code: def __init__(self, *args, **kwargs):         """         Initialize the H2OConnection object          :param str url: The URL of the H2O cluster         :param str token: The token to use for authentication         :param int port: The port to use for the connection         :param str scheme: The scheme to use for the connection         :param str proxy_host: The host of the proxy to use for the connection         :param int proxy_port: The port of the proxy to use for the connection         :param str proxy_scheme: The scheme of the proxy to use for the connection         :param str proxy_user: The username to use for the proxy         :param str proxy_password: The password to use for the proxy         :param str proxy_auth: The authentication type to use for the proxy         :param str proxy_workstation: The workstation to use for the proxy         :param str proxy_domain: The domain to use for the proxy         :param str proxy_workstation: The workstation to use for the proxy         :param str proxy_domain: The domain to use for the proxy         :param str proxy_workstation: The workstation to use for the proxy         :param str proxy_domain: The domain to use for the proxy         :param str proxy_workstation: The workstation to use for the proxy         :param str proxy_domain: The domain to use for the proxy         :param str proxy_workstation: The workstation to use for the proxy         :param str proxy_domain: The domain to use for the proxy         :param str proxy_workstation: The workstation to use for the proxy         :param str proxy_domain: The domain to use for the proxy         :param str proxy_workstation: The workstation to use for the proxy         :param str proxy_domain: The domain to use for the proxy         :param str proxy_workstation: The workstation to use for the proxy         :param str proxy_domain: The domain to use for the proxy         :param str proxy_workstation: The workstation to use for the proxy         :param str proxy_domain: The domain to use for the proxy         :param str proxy_workstation: The workstation to use for the proxy         :param str proxy_domain: The domain to use for the proxy         :param str proxy_workstation: The workstation to use for
Lists InviteInstance records from the API as a list.         Unlike stream(), this operation is eager and will load `limit` records into         memory before returning.          :param int limit: Upper limit for the number of records to return. list() guarantees                           never to return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, list() will attempt to read the limit                               with the most efficient page size, i.e. min(limit, 1000)          :returns: Generator that will yield up to limit results         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance] Code: def list_instance(self, limit=None, page_size=None):         """         Lists InviteInstance records from the API as a list.         Unlike stream(), this operation is eager and will load `limit` records into         memory before returning.          :param int limit: Upper limit for the number of records to return. list() guarantees                           never to return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, response, solution):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service that the resource is associated with          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init
Code: def import_file(path=None, destination_frame=None, parse=True, header=0, sep=None, col_names=None, col_types=None
Code: def import_sftp(host, port, user, password, path, database=None, table=None, partitions=None, allow_multi_format=False):              assert_is_type(host, str)     assert_is_type(port, int)     assert_is_type(user, str)     assert_is_type(password, str)     assert_is_type(path, str)     assert_is_type(database, str, None)     assert_is_type(table, str)     assert_is_type(partitions, [[str]], None)     p = { "host": host, "port": port, "user": user, "password": password, "path": path, "database": database, "table": table, "partitions": partitions, "allow_multi_format
Code: def import_sql_table(connection_url, table, username, password, columns=None, optimize=True, fetch_mode=None):          assert_is_type(connection_url, str)     assert_is_type(table, str)     assert_is_type(username, str)     assert_
Code: def import_sql_select(connection_url, select_query, username, password, optimize=True,                        use_temp_table=None, temp_table_name=None, fetch_mode=None):          assert_is_type(connection_url, str)     assert_is_type(select_query, str)     assert_is_type(username, str)     assert_is_type(password, str)     assert_is_type(optimize, bool)     assert_is_type(use_temp_table, bool, None)     assert_is_type(temp_table_name, str, None)     assert_is_type(fetch_mode, str, None)     p = {"connection_url": connection_url, "select_query": select_query, "username": username, "password": password,          "use_temp_table": use_temp_table, "temp_table_name": temp_table_name, "fetch_mode": fetch_mode}     j = H2OJob(api("POST /99/ImportSQL
Get an item from the list of resources          :param unicode key: The index of the resource to fetch          :returns
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __call__(self, service_sid, channel_sid):         """         Constructs a InviteContext          :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         return InviteContext(             self._version,             service_sid
Code: def get_model_ids(model_ids):     assert_is_type(model_ids, list)     model_jsons = api("GET /3/Models", {"model_ids": model_ids})["models"]     models = []     for model_json in model_jsons:         algo = model_json["algo"]         if algo == "svd":            m = H2OSVD()         elif algo == "pca":          m = H2OPrincipalComponentAnalysis
Get a model ID from the H2O cloud.          :param str model_id: The model ID to get.          :returns: A model ID.         :rtype: str Code: def get_models_by_key(model_id):     """     Get a list of models from the H2O cloud.      :param str model_id: The model ID to get.      :returns: A list
Get the frame info for a given frame.          :param str name: The frame name.          :returns: The frame info.         :rtype: dict Code: def get_frame
Build an instance of InviteInstance          :param dict payload:
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset,                  expiration_date=values.unset, date_expires=values.unset,                  role_sid=values.unset, identity=values.unset,                  invited_by=values.unset, channel_type=values.unset,                  member_count=values.unset, unique_members_count=values.unset,                  attributes=values.unset, friendly_name=values.unset,                  date_deleted=values.unset, deleted_by=values.unset,                  links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['account_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'expiration_date': deserialize.iso8601_datetime(expiration_date),             'date_expires': deserialize.iso8601_datetime(date_expires),             'role_sid': role_sid,             'identity': identity,             'invited_by': invited_by,             'channel_type': channel_type,            'member_count': member_count,             'unique_members_count': unique_members_count,             'attributes': attributes,             'friendly_name': friendly_name,             'date_deleted': deserialize.iso8601_datetime(date_deleted),             'deleted_by': deleted_by,             'links': links,         }          # Context         self._context = None
Initialize the InvitePage          :param Version version: Version that contains the resource         :param dict payload: A JSON response from the Twilio API          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def __init__(self, version, response, service_sid, channel_sid):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API
Code: def export_file(frame, path, force=False, parts=1):
Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param dict payload: A JSON response from the Twilio API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Marshaled Properties         self._properties = {             'invites': payload.get('invites'),            'meta': payload.get('meta'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,         }      @property     def invites(self):         """         :returns: The list of Invites         :rtype: list[unicode]         """         return self._properties['invites']      @property     def meta(self):         """         :returns: The response metadata properties for the request         :rtype: dict         """         return self._properties['meta']      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._context      def __call__(self, sid):         """         Constructs a InviteContext          :param sid: The unique string that identifies the resource          :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         return InviteContext(             self._version,             service_sid=self._solution['service_sid'],             channel_sid=self._solution['channel_sid'],             sid=sid,
Code: def demo(funcname, interactive=True, echo=True, test=False):          import h2o.demos as h2odemo     assert_is_type(funcname, str)     assert_is_type(interactive, bool)     assert_is_type(echo, bool)     assert_is_type(
Load a model from a string.          :param str model_string: The string containing the model.          :returns: A model object.         :rtype: H2OModel Code: def load_model_from_json(model_json):     """     Load a model from a JSON string.      :param str model_json: The JSON string containing the model.      :returns: A model object.     :rtype: H2OModel     """     return H2OModel(model_json
Make scoring history on a frame.          :param H2OFrame frame: Frame to make scoring history on.         :param list domain: Domain of the prediction.         :param str distribution: Distribution of the prediction.          :returns: H2OFrame
Code: def _delete_key_value_by_key(key_name, key):          ret = api("POST /3/DeleteKeyValueByKey?
Get the name of the class Code: def _get_class_name(func):     """     Get the name of the class      :param func: Function to get the name of      :
Code: def _get_frame_id(self, frame_id):     if frame_id is None:         return     if frame_id.strip() == "":         raise H2OValueError("Frame id cannot be an empty string: %r" % frame_id)     for i, ch in enumerate(frame_id):         # '$' character has special meaning at the beginning of the string; and prohibited anywhere else         if ch == "$" and i == 0: continue         if ch not in _id_allowed_characters:             raise H2OValueError("Character '%s' is illegal in frame
Convert seconds to a human-readable duration.          :param int seconds: Seconds to convert          :returns: Human-readable duration         :rtype: str Code: def get_human_readable_number(number):     """     Convert a number to a human-readable string.      :param int number: Number to convert      :returns: Human-readable number     :rtype: str     """     if number == 0: return "0"     if number is None: return ""     assert_is_type(number, int)     assert number >= 0, "`number` cannot be negative, got %d" % number     if number < 1000:         return str(number)     if number < 1000000:         return "%dK" % (number / 1000)     if number < 1000000000:         return "%dM" % (number / 1000000)     return "%dB" % (number / 10000
Code: def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset, date_created=values.unset, date_updated=values.unset, by=values.unset, from_=values.unset, to=values.unset, url=values.unset):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to         :param sid: The SID of the Invite resource to fetch          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites{sid}'.format(**self._solution)          # Dependents         self._invites = None      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = InviteList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._invites      def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         return '<Twilio.IpMessaging.V2.InviteList>'   class InvitePage(Page):     """ PLEASE NOTE that this class contains preview products that are subject     to change. Use them with caution. If you currently do not have developer     preview access, please contact <EMAIL>. """          def __init__(self, version, response, solution):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :
Code: def mojo_predict_csv(input_csv_path, mojo_zip_path, output_csv_path, genmodel_jar_path=None, classpath=None, java_options=None, verbose=False):     """     Predict using a MOJO model.      :param str input_csv_path: Path to the CSV file containing the input data.     :param str mojo_zip_path: Path to the MOJO model.     :param str output_csv_path: Path to the CSV file where the predictions will be written.     :param str genmodel_jar_path: Path to the GenModel JAR file.     :param str classpath: Additional classpath entries.     :param str java_options: Additional Java options.     :param bool verbose: Whether to print verbose output.      :returns: The number of rows in the output CSV file.     :rtype: int     """     if not can_use_pandas():         raise RuntimeException('Cannot import pandas')     import pandas     assert_is_type(input_csv_path,'str')     assert_is_type(mojo_zip_path,'str')     assert_is_type(output_csv_path,'str')     assert_is_type(genmodel_jar_path,'str', optional=True)     assert_is_type(classpath,'str', optional=True)     assert_is_type(java_options,'str', optional=True)     assert_is_type(verbose, 'bool', optional=True)     if verbose:         print('Predicting using MOJO model...')     if genmodel_jar_path is None:         genmodel_jar_path = os.path.join(os.path.dirname(__file__), 'genmodel.jar')     if classpath is None:         classpath = os.path.join(os.path.dirname(__file__), 'genmodel.jar')     if java_options is None:         java_options = '-Xmx1024m'     if verbose:         print('  input_csv_path = %s' % input_csv_path)         print('  mojo_zip_path = %s' % mojo_zip_path)         print('  output_csv_path = %s' % output_csv_path)         print('  gen
Code: def mojo_predict_csv(input_csv_path, mojo_zip_path, output_csv_path=None, genmodel_jar_path=None, classpath=None, java_options=None, verbose=False):          default_java_options = '-Xmx4g -XX:ReservedCodeCacheSize=256m'     prediction_output_file = 'prediction.csv'      # Checking java     java = H2OLocalServer._find_java()     H2OLocalServer._check_java(java=java, verbose=verbose)      # Ensure input_csv exists     if verbose:         print("input_csv:\t%s" % input_csv_path)     if not os.path.isfile(input_csv_path):         raise RuntimeError("Input csv cannot be found at %s" % input_csv_path)      # Ensure mojo_zip exists     mojo_zip_path = os.path.abspath(mojo_zip_path)     if verbose:         print("mojo_zip:\t%s" % mojo_zip_path)     if not os.path.isfile(mojo_zip_path):         raise RuntimeError("MOJO zip cannot be found at %s" % mojo_zip_path)      parent_dir = os.path.dirname(mojo_zip_path)      # Set output_csv if necessary     if output_csv_path is None:         output_csv_path = os.path.join(parent_dir, prediction_output_file)      # Set path to h2o-genmodel.jar if necessary and check it's valid     if genmodel_jar_path is None:         genmodel_jar_path = os.path.join(parent_dir, gen_model_file_name)     if verbose:         print("genmodel_jar:\t%s" % genmodel_jar_path)     if not os.path.isfile(genmodel_jar_path):         raise RuntimeError("Genmodel jar cannot be found at %s" % genmodel_jar_path)      if verbose and output_csv_path is not None:         print("output_csv:\t%s" % output_csv_path)      # Set classpath if necessary     if classpath is None:         classpath = genmodel_jar_path     if verbose
Get an item from the list of resources in the response.          :returns: An instance of the resource at the given index, or None if                   that index
Code: def __init__(self, version, service_sid, channel_sid, identity, friendly_name=values.unset, role_sid=values.unset, attributes=values.unset, x_twilio_webhook_enabled=values.unset):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to create the resource under         :param channel_sid: The SID of the Channel the new resource belongs to         :param identity: The unique string that identifies the resource's User         :param friendly_name: A string to describe the resource         :param role_sid: The SID of the Role to assign to the new member         :param attributes: A valid JSON string that contains application-specific data         :param x_twilio_webhook_enabled: The X-Twilio-Webhook-Enabled HTTP request header          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, 'identity': identity, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)          # Dependents         self._invites = None          # Filters         self._filter = None         if friendly_name is not None:             self.filter(friendly_name=friendly_name, )         if role_sid is not None:             self.filter(role_sid=role_sid, )         if attributes is not None:             self.filter(attributes=attributes, )          self._x_twilio_webhook_enabled = x_twilio_webhook_enabled      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = InviteList(                 self._version,                 service_sid=self._solution['service_
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, service_sid):         """         Initialize the ServiceContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch          :returns: twilio.rest.chat.v2.service.ServiceContext         :rtype: twilio.rest.chat.v2.service.ServiceContext         """         super(ServiceContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, }         self._uri = '/Services/{service_sid}'.format(**self._solution)          # Dependents         self._channels = None         self._users = None         self._roles = None         self._bindings = None         self._invites = None         self._roles_bindings = None         self._roles_invites = None      @property     def channels(self):         """         Access the channels          :returns: twilio.rest.chat.v2.service.channel.ChannelList         :rtype: twilio.rest.chat.v2.service.channel.ChannelList         """         if self._channels is None:             self._channels = ChannelList(self._version, service_sid=self._solution['service_sid'], )         return self._channels      @property     def users(self):         """         Access the users          :returns: twilio.rest.chat.v2.service.user.UserList         :rtype: twilio.rest.chat.v2.service.user.UserList         """         if self._users is None:             self._users = UserList(self._version, service_sid=self._solution['service_sid'], )         return self._users      @property     def roles(self):         """         Access the roles          :returns: twilio.rest.chat.v2.service.role.RoleList         :rtype: twilio.rest.chat.v2.service.role.RoleList         """         if self._roles is None:             self._roles = RoleList(
Constructs a InviteContext          :param service_sid: The SID of
Return a sorted table of the best models based on the metric specified Code: def train(self, hyper_params=None, **kwargs):         """         Train a model on the training data          :param dict hyper_params: Hyperparameters to use for training the model          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         if not hyper_params:             hyper_params = self.hyper_params         self.models.append(self.model(hyper_params, **kwargs))         self.models[-1].train(self.train_data, self.train_labels)         return self.
:param id: The index or id of the model to get the hyperparameters for.         :type id: int or str         :param display: Whether to print the hyperparameters to the console.         :type display: bool, default True         :returns: The hyperparameters for the model.         :rtype: list         """         idx = id if is_type(id, int) else self.model_ids.index(id)         model = self[idx]          # if cross-validation is turned on, parameters in one of the fold model actuall contains the max_runtime_secs         # parameter and not the main model that is returned.         if model._is_xvalidated:             model = h2o.get_model(model._xval_keys[0])          res = [model.params[h]['actual'][0] if isinstance(model.params[h]['actual'], list)                else model.params[h]['actual']                for h in self.hyper_params]         if display: print('Hyperparameters: [' + ', '.join(list(self.hyper_params.keys())) + ']')         return res Code: def get_hyperparams(self, id, display=
Code: def get_hyperparams_dict(self, id, display=True):                  idx = id if is_type(id, int) else self.model_ids.index(id)         model = self[idx]          model_params = dict()          # if cross-validation is turned on
Retrieve a single page of InviteInstance records from the API.         Request is executed immediately          :param str page_token: PageToken provided by the API         :param int page_number: Page Number, this value is simply for client state         :param int page_size: Number of records to return, defaults to 50          :returns: Page of InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def get_page(self, page_token=values.unset, page_number=values.unset,                  page_size=values.unset):         """         Retrieve a single page of InviteInstance records from the API.         Request is executed immediately          :param str page_token: PageToken provided by the API         :param int page_number: Page Number, this value is simply for client state         :param int page_size: Number of records to return, defaults to 50          :returns: Page of InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         params = values.of({             'PageToken': page_token,             'Page': page_number,             'PageSize': page_size,         })          response = self._version.page(             'GET',             self._uri,             params=
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, service_sid):         """         Initialize the ServiceContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch          :returns: twilio.rest.chat.v2.service.ServiceContext         :rtype: twilio.rest.chat.v2.service.ServiceContext         """         super(ServiceContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, }         self._uri = '/Services/{service_sid}'.format(**self._solution)          # Dependents         self._channels = None         self._users = None         self._roles = None         self._bindings = None         self._invites = None         self._roles_bindings = None         self._roles_invites = None      @property     def channels(self):         """         Access the channels          :returns: twilio.rest.chat.v2.service.channel.ChannelList         :rtype: twilio.rest.chat.v2.service.channel.ChannelList         """         if self._channels is None:             self._channels = ChannelList(self._version, service_sid=self._solution['service_sid'], )         return self._channels      @property     def users(self):         """         Access the users          :returns: twilio.rest.chat.v2.service.user.UserList         :rtype: twilio.rest.chat.v2.service.user.UserList         """         if self._users is None:             self._users = UserList(self._version, service_sid=self._solution['service_sid'], )         return self._users      @property     def roles(self):         """         Access the roles          :returns: twilio.rest.chat.v2.service.role.RoleList         :rtype: twilio.rest.chat.v2.service.role.RoleList         """         if self._roles is None:             self._roles = RoleList(
Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service that the resource is associated with
Code: def __init__(self, model_id, model_json, model_category, model_key, model_label, model_parameters, model_output, model_score, model_type, model_uri, model_version, model_checksum, model_description, model_owner, model_status, model_training_time, model_training_frame, model_validation_frame, model_nfolds, model_fold_column, model_fold_assignment, model_fold_column_validation_frame, model_hyper_params, model_hyper_params_search, model_grid_id, model_grid_search_criteria, model_grid_search_results, model_grid_search_status, model_grid_search_runtime, model_grid_search_runtime_secs, model_grid_search_runtime_millis, model_grid_search_runtime_micros, model_grid_search_runtime_nanos, model_grid_search_runtime_minutes, model_grid_search_runtime_hours, model_grid_search_runtime_days, model_grid_search_runtime_weeks, model_grid_search_runtime_months, model_grid_search_runtime_years, model_grid_search_runtime_decades, model_grid_search_runtime_centuries, model_grid_search_runtime_millenia, model_grid_search_runtime_undecimillenia, model_grid_search_runtime_decimillenia, model_grid_search_runtime_centimillenia, model_grid_search_runtime_millimillenia, model_grid_search_runtime_micromillenia, model_grid_search_runtime_nanomillenia, model_grid_search_runtime_picomillenia, model_grid_search_runtime_femtomillenia, model_grid_search_runtime_attomillenia, model_grid_search_runtime_zeptomillenia, model_grid_search_runtime_yoctomillenia, model_grid_search_runtime_zettabytes, model_grid_search_runtime_exabytes, model_grid_search_runtime_petabytes, model_grid_search_runtime_terabytes, model_grid_search_runtime_gigaby
Initialize the InvitePage          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def __init__(self, version, service_
Code: def __iter__(self):         """         Iterate over pages of InviteInstance          :returns: Page of InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.Invite
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __repr__(self):
Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def extractRunInto(javaLogText):          global g_initialXY     global g_reguarlize_Y     global g_regularize_X_objective     global g_updateX     global g_updateY     global g_objective     global g_stepsize     global g_history       if os.path.isfile(javaLogText):          run_result = dict()         run_result["total time (ms)"] = []         run_result["initialXY (ms)"] = []         run_result["regularize Y (ms)"] = []         run_result["regularize X and objective (ms)"] = []         run_result["update X (ms)"] = []         run_result["update Y (ms)"] = []         run_result["objective (ms)"] = []         run_result["step size (ms)"] = []         run_result["update history (ms)"] = []          total_run_time = -1         val = 0.0         with open(javaLogText, 'r') as thefile:   # go into tempfile and grab test run info             for each_line in thefile:                 temp_string = each_line.split()                  if len(temp_string) > 0:                     val = temp_string[-1].replace('\\','')                  if g_initialXY in each_line:    # start of a new file                     if total_run_time > 0:  # update total run time
Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'created_by': payload.get('created_by'),             'created_by_identity': payload.get('created_by_identity'),             'role_sid': payload.get('role_sid'),             'date_created': deserialize.iso8601_datetime(payload.get('date_created')),             'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')),             'url': payload.get('url'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': payload.get('sid'),         }      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property     def service_sid(self):         """         :returns: The SID of the Service that the resource is associated with         :rtype: unicode         """         return self._properties['service_sid']      @property     def channel_sid(self):         """         :returns: The SID of the Channel the resource belongs to         :rtype: unicode         """         return self._properties['channel_sid']      @property     def created_by(self):         """         :returns: The identity of the User that created the resource         :rtype: unicode         """         return
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset,                  links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['service_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property     def service_sid(self):         """         :returns: The SID of the Service that the resource is associated with         :rtype: unicode         """         return self._properties['service_sid']      @property     def channel_sid(self):         """         :returns: The SID of the Channel the resource belongs to         :rtype: unicode         """         return self._properties['channel_sid']      @property     def date_created(self):         """         :returns: The RFC 2822 date and time in GMT when the resource was created         :
Convenience method for accessing a InviteInstance          :param key: The sid          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :
Send a packet to the server. Code: def _receive_packet(self, packet):         """         Receive a packet from the server.         """         if packet.type == packet.MESSAGE:             self.queue.put(MessageInstance(                 self._version,                 packet.payload,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             ))         elif packet.type == packet.INVITE:             self.queue.put(InviteInstance(                 self._version,                 packet.payload,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             ))         elif packet.type == packet.COMMAND:             self.queue.put(CommandInstance(                 self._version,                 packet.payload,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             ))         elif packet.type == packet.PRESENCE:             self.queue.put(PresenceInstance(                 self._version,                 packet.payload,                 service_sid=
Constructs a InviteContext          :param sid: A 34 character string that uniquely identifies this resource.          :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext Code: def __unicode__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         return unicode
:param str filename: The path to the file to upload.          :returns: A dictionary of file names and file objects.         :rtype: dict         :raises: H2OValueError if the file does not exist. Code: def _prepare_payload(self, data=values.unset, role_sid=values.unset,                          last_consumed_message_index=values.unset,                          last_consumption_timestamp=values.unset,                          attributes=values.unset, date_created=values.unset,                          date_updated=values.unset, url=values.unset,                          links=values.unset, identity=values.unset,                          address=values.unset, date_enqueued=values.unset,                          expiration_date=values.unset, body=values.unset,                          from_=values.unset, to=values.unset, media_url=values.unset,                          media_sid=values.unset, status_callback=values.unset,                          status_callback_method=values.unset,                          status_callback_event=values.unset,                          application_sid=values.unset,                          fallback_url=values.unset, fallback_method=values.unset,                          method=values.unset, if_machine=values.unset,                          if_none_match=values.unset, if_modified_since=values.unset,                          if_unmodified_since=values.unset,                          if_match=values.unset, if_none_match_name=values.unset,                          if_modified_since_name=values.unset,                          if_unmodified_since_name=values.unset,                          if_match_name=values.unset,                          if_none_match_value=values.unset,                          if_modified_since_value=values.unset,                          if_unmodified_since_value=values.unset,                          if_match_value=values.unset,                          if_none_match_param=values.unset,                          if_modified_since_param=values.unset,                          if_unmodified_since_param=values.unset,                          if_match_param=values.unset,                          if_none_match_header=values.unset,                          if_modified_since_header=values.unset,                          if_unmodified_since_header=values.unset,                          if_match_header
Log a message to the log file.          :param str msg: The message to log. Code: def _log_end_transaction(self, response):         """         Log the end of a transaction.          :param requests.Response response: The response object.         """         if not self._is_logging: return         msg = "\n---- %d --------------------------------------------------------\n" % self._requests_counter         msg += "[%s] %s\n" % (time.strftime("%H:%M:%S"), response.request.url)         msg += "     status: %s\n" % response.status_code         msg += "     reason: %s\n" % response.reason         msg += "     headers: %s\n" % response.headers         msg += "     content: %
Code: def _make_request(self, method, url, data=None, headers=None, timeout=None,                       connect_timeout=None, proxy=None, stream=False,                       idempotency_key=None, retry_policy=None):         """         Perform a request to the Twilio API.          :param str method: HTTP method to use         :param str url: URL to request         :param dict data: Data to send with the request         :param dict headers: Headers to send with the request         :param int timeout: Timeout in seconds         :param int connect_timeout: Timeout in seconds for establishing a connection         :param str proxy: Proxy to use         :param bool stream: Whether to stream the response         :param str idempotency_key: Idempotency key to use         :param retry_policy: Retry policy to use          :returns: Response from the API         :rtype: requests.Response         """         if not self._is_logging: return         start_time = time.time()         headers = headers or {}         headers['User-Agent'] = self.user_agent         if idempotency_key:             headers['Idempotency-Key'] = idempotency_key         if self.auth:             headers['Authorization'] = self.auth.get_authorization(method, url, data, headers)         if self.proxy:             proxy = self.proxy         if self.timeout:             timeout = self.timeout         if self.connect_timeout:             connect_timeout = self.connect_timeout         if self.stream:             stream = self.stream         if self.retry_policy:             retry_policy = self.
Code: def _log_message(self, msg):                  if is_type(self._logging_dest, str):             with open(self._logging_dest, "at", encoding="utf-8") as f:                 f.write(msg)         else:             self._
200 = "Ok", 201 = "Created", 202 = "Accepted", 204 = "No Content"         :param requests.Response response: Response from the API          :returns: Response data         :rtype: str         """         status_code = response.status_code         if status_code == 200 and save_to:             if save_to.startswith("~"): save_to = os.path.expanduser(save_to)             if os.path.isdir(save_to) or save_to.endswith(os.path.sep):                 dirname = os.path.abspath(save_to)                 filename = H2OConnection._find_file_name(response)             else:                 dirname, filename = os.path.split(os.path.abspath(save_to))             fullname = os.path.join(dirname, filename)             try:                 if not os.path.exists(dirname):                     os.makedirs(dirname)                 with open(fullname, "wb") as f:                     for chunk in response.iter_content(chunk_size=65536):                         if chunk:  # Empty chunks may occasionally happen                             f.write(chunk)             except OSError as e:                 raise H2OValueError("Cannot write to file %s: %s" % (fullname, e))             return fullname          content_type = response.headers.get("Content-Type", "")         if ";" in content_type:  # Remove a ";charset=..." part             content_type = content_type[:content_type.index(";")]          # Auto-detect response type by its content-type. Decode JSON, all other responses pass as-is.         if content_type == "application/json":             try:                 data = response.json(object_pairs_hook=H2OResponse)             except (JSONDecodeError, requests.exceptions.ContentDecodingError) as e:                 raise H2OServerError("Malformed JSON from server (%s):\n%s" % (str(e), response.text))         else:             data = response.text          # Success (200 = "Ok", 201 = "Created", 202 = "Accepted", 204 = "No Content")         if status_code in {200,
Provide a friendly representation          :returns: Machine friendly representation         :
Code: def get_automl(project_name):          automl_json = h2o.api("GET /99/AutoML/%s" % project_name)     project_name = automl_json["project_name"]     leaderboard_list = [key["name"] for key in automl_json['leaderboard']['models']]      if leaderboard_list is not None and len(leaderboard_list) > 0:         leader_id = leaderboard_list[0]     else:         leader_id = None      leader = h2o.get_model(leader_id)     # Intentionally mask the progress bar here since showing multiple progress bars is confusing to users.     # If any failure happens, revert back to user's
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __repr__(self):         """         Provide a friendly representation          :returns: Machine
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __repr__(self):         """         Provide a friendly representation          :returns: Machine
Build an instance of InviteInstance          :param dict payload:
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, service_sid, channel_sid):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset,                  links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['account_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {             'account_sid': account_sid,            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, service_sid, channel_sid, ):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def get_instance(self, payload):         """         Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         return InviteInstance(             self._version,             payload,             service_sid=self._solution['service_sid'],             channel_sid=self._solution['channel_sid
Code: def find_node_name(each_line,temp_func_list):          global g_node_name     global g_failed_test_info_dict      if g_node_name in each_line:         temp_strings = each_line.split()
Code: def find_git_hash_branch(each_line,temp_func_list):          global g_git_hash_branch     global g_failed_test_info_dict      if g_git_hash_branch in each_line:         [start,found,endstr] = each_line.partition(g_git_hash_branch)         temp_strings = endstr.strip().split()          if len(temp_strings) > 1:             g_failed_test_info_dict["4.git_hash"] = temp_strings[0]             g_failed_test_info_dict["5.git_branch"] = temp_strings[1]          temp_func_list
11.test_timeout was found, no need to continue mining the console text Code: def find_test_failure_with_timeout(each_line,temp_func_list):          global g_test_failure_with_timeout     global g_failed_test_info_dict     global g_failure_occurred      if g_test_failure_with_timeout in each_line:         g_failed_test_info_dict["12.test_failure_with_timeout"] =
Code: def find_build_failure(each_line,temp_func_list):          global g_build_success     global g_build_success_tests     global g_failed_test_info_dict     global g_failure_occurred     global g_build_failed_message      for ind in range(0,len(g_build_failed_message)):         if g_build_failed_message[ind] in each_line.lower():             if ((ind == 0) and (len(g_failed_jobs) > 0)):                 continue             else:                 g_failure_occurred = True                 g_failed_test_
Code: def find_build_id(each_line,temp_func_list):          global g_before_java_file     global g_java_filenames     global g_build_id_text     global g_jenkins_url     global g_output_filename     global g_output_pickle_filename       if g_build_
Code: def extract_job_build_url(url_string):          global g_failed_test_info_dict     global g_jenkins_url     global g_view_name          tempString = url_string.strip('/').split('/')      if len(tempString) < 6:         print "Illegal URL resource address.\n"         sys.exit(1)              g_failed_test_info_dict["1.jobName"] = tempString[6]              g_jenkins_url = tempString
Code: def grab_java_messages():     global g_java_general_bad_messages     global g_java_general_bad_message_types     global g_java_message_type     global g_all_java_message_type      if os.path.isfile(g_temp_filename): # open temp file containing content of some java_*_0.out.txt         java_file = open(g_temp_filename,'r')          g_java_general_bad_messages = []         g_java_general_bad_message_types = []          for each_line in java_file:             temp_strings = each_line.strip().split()              if (len(temp_strings) >= 6) and (temp_strings[5] in g_all_java_message_type):                 if (temp_strings[5] not in g_java_general_bad_message_types):                     g_java_general_bad_message_types.append(temp_strings[5])                 if (each_line not in g_java_general_bad
Write out a general build message          :param str keyName: Key name         :param list val: List of values         :param file text_file: File
Code: def write_file_content(tempfile,filename):     with open(filename,'r') as file:         for
Get the channel sid from the channel name          :param str channel_name: The channel name          :returns: The channel sid         :rtype: str Code: def _get_channel_sid(self, channel_name):         """         Get the channel sid from the channel name          :param str channel_name: The channel name          :returns: The channel sid         :rtype: str         """         channel_sid = None         for channel
Code: def write_message_to_file_python(key,val,text_file):           text_file.
Code: def load_messages_to_ignore():
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, service_sid, channel_sid, ):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init__(version)                  # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)                  # Path Properties         self._properties = {'invites': None, }                  self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)                  # Dependents         self._invites = None              @property     def invites(self):         """         :returns: The list of Invites         :rtype: unicode         """         if self._properties['invites'] is None:             self._properties['invites'] = self._version.stream(                 method='GET',
Code: def __init__(self, model_id, model_type, model_category, model_description, model_friendly_name, model_url, model_keywords, model_status, model_date_created, model_date_updated, model_parameters, model_training_time, model_validation_metrics, model_validation_metrics_context, model_validation_metrics_interpretation, model_validation_metrics_interpretation_context, model_error_count, model_warnings, model_warnings_context, model_warnings_interpretation, model_warnings_interpretation_context, model_scoring_history, model_scoring_history_context, model_scoring_history_interpretation, model_scoring_history_interpretation_context, model_scoring_history_metrics, model_scoring_history_metrics_context, model_scoring_history_metrics_interpretation, model_scoring_history_metrics_interpretation_context, model_scoring_history_metrics_values, model_scoring_history_metrics_values_context, model_scoring_history_metrics_values_interpretation, model_scoring_history_metrics_values_interpretation_context, model_scoring_history_metrics_values_values, model_scoring_history_metrics_values_values_context, model_scoring_history_metrics_values_values_interpretation, model_scoring_history_metrics_values_values_interpretation_context, model_scoring_history_metrics_values_values_values, model_scoring_history_metrics_values_values_values_context, model_scoring_history_metrics_values_values_values_interpretation, model_scoring_history_metrics_values_values_values_interpretation_context, model_scoring_history_metrics_values_values_values_values, model_scoring_history_metrics_values_values_values_values_context, model_scoring_history_metrics_values_values_values_values_interpretation, model_scoring_history_metrics_values_values_values_values_interpretation_context, model_scoring_history_metrics_values_values_values_values_values, model_scoring_history_metrics_values_values_values
Iterate over the job Code: def __next__(self):         """         Iterate over the job          :returns: Iterator over the job         :rtype: Iterator         """         return self
Code: def __init__(self, version, service_sid, channel_sid, ):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      @property     def page_size(self):         """         :returns: How many resources to return in each list page. The default is 50, and the maximum is 1000.         :rtype: unicode         """         return self._properties['page_size']      @property     def next_page_url(self):         """         :returns: The URL of the next page of results         :rtype: unicode         """         return self._properties['next_page_url']      @property     def key(self):         """         :returns: The unique string that identifies the resource         :rtype: unicode         """         return self._properties['key']      @property     def invites(self):         """         :
Build an instance of InviteInstance          :param dict payload:
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __unicode__(self
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, service_sid, channel_sid, ):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_
Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'identity': payload.get('identity'),             'role_sid': payload.get('role_sid'),             'date_created': deserialize.rfc2822_datetime(payload.get('date_created')),             'date_updated': deserialize.rfc2822_datetime(payload.get('date_updated')),             'url': payload.get('url'),         }          # Context
Code: def __init__(self, version, service_sid, sid):         """         Initialize the ModelContext          :param Version version: Version that contains the resource         :param service_sid: The service_sid         :param sid: The sid          :returns: twilio.rest.api.v2010.account.service.model.ModelContext         :rtype: twilio.rest.api.v2010.account.service.model.ModelContext         """         super(ModelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid,'sid': sid, }         self._uri = '/Accounts/{account_sid}/Services/{service_sid}/Models/{sid}.json'.format(**self._solution)          # Dependents         self._fields = None         self._permissions = None      @property     def fields(self):         """         Access the fields          :returns: twilio.rest.api.v2010.account.service.model.field.FieldList         :rtype: twilio.rest.api.v2010.account.service.model.field.FieldList         """         if self._fields is None:             self._fields = FieldList(self._version, service_sid=self._solution['service_sid'], model_sid=self._solution['sid'], )         return self._fields      @property     def permissions(self):         """         Access the permissions          :returns: twilio.rest.api.v2010.account.service.model.permission.PermissionList         :rtype: twilio.rest.api.v2010.account.service.model.permission.PermissionList         """         if self._permissions is None:             self._permissions = PermissionList(self._version, service_sid=self._solution['service_sid'], model_sid=self._solution['sid'], )         return self._permissions      def fetch(self):         """         Fetch a ModelInstance          :returns: Fetched ModelInstance         :rtype: twilio.rest.api.v20
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'identity': payload.get('identity'),             'role_sid': payload.get('role_sid'),             'date_created': deserialize.iso8601_datetime(payload.get('date_created')),             'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')),             'url': payload.get('url'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._
Provide a friendly representation Code: def __init__(self, version, service_sid, channel_sid, ):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def get_instance(self,
Initialize the InvitePage          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def __init__(self, version, service_
Code: def set_params(self, **params):         """         Set the parameters of this estimator.         The method works on simple estimators as well as on nested objects         (such as pipelines). The latter have parameters of the form         ``<component>__<parameter>`` so that it's possible to update each         component of a nested object.          Returns         -------         self         """         if not params:             # Simple optimization to gain speed (inspect is slow)             return self         valid_params = self.get_params(deep=True)
Provide a friendly representation          :returns: Machine friendly representation         :rtype:
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __repr__(self):         """         Provide a friendly representation          :returns: Machine
Code: def __len__(self):         """         PLEASE NOTE that this class contains preview products that are subject to change. Use them with ca
Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def __getitem__(self, key):         """         Convenience method for accessing the first element of the list          :returns: The first element of the list         :rtype: twilio.rest.chat
Code: def _check_targets(y_actual, y_predicted
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation
Build an instance of InviteInstance          :param dict payload:
Initialize the InvitePage          :param Version version: Version that contains the resource         :param dict payload: A JSON response from the Twilio API          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def __init__(self, version, response, service_sid, channel_sid):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :
Code: def glm(interactive=True, echo=True, testing=False):           def demo_body(go):                  go()         # Connect to H2O         h2o.init()          go()         # Upload the prostate dataset that comes included in the h2o python package         prostate = h2o.load_dataset("prostate")          go()         # Print a description of the prostate data         prostate.describe()          go()         # Randomly split the dataset into ~70/30, training/test sets         train, test = prostate.split_frame(ratios
Code: def _wait_for_keypress():          result = None     if os.name == "nt":         # noinspection PyUnresolvedReferences         import msvcrt         result = msvcrt.getch()     else:         import termios         fd = sys.stdin.fileno()          oldterm = termios.tcgetattr(fd)         newattr = termios.tcgetattr(fd)         newattr[3] = newattr[3] & ~termios.ICANON & ~termios.ECHO         termios.tcsetattr(fd, termios.TCSANOW, newattr)          try:             result = sys.stdin.
Code: def __len__(self):         """         :returns: Number of Invites in the response         :rtype: unicode         """         return self._version
Code: def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         return '<Twilio.IpMessaging.
Code: def _launch_server(self, port, baseport, nthreads, ea, mmax, mmin, jvm_custom_args, bind_to_localhost, log_dir, log_level):         if self._verbose:             print("Launching H2O server...")         if self._jar_path is None:             raise H2OValueError("Could not find h2o.jar at %s" % self._jar_path)         if self._ice_root is None:             raise H2OValueError("Could not find ice root at %s" % self._ice_root)         if self._name is None:             raise H2OValueError("Could not find name at %s" % self._name)         if self._extra_classpath is None:             raise H2OValueError("Could not find extra classpath at %s" % self._extra_classpath)         if self._ice_root is None:             raise H2OValueError("Could not find ice root at %s" % self._ice_root)         if self._tempdir is None:             raise H2OValueError("Could not find tempdir at %s" % self._tempdir)         if self._log_dir is None:             raise H2OValueError("Could not find log_dir at %s" % self._log_dir)         if self._log_level is None:             raise H2OValueError("Could not find log_level at %s" % self._log_level)         if self._jvm_custom_args is None:             raise H2OValueError("Could not find jvm_custom_args at %s" % self._jvm_custom_args)         if self._bind_to_localhost is None:             raise H2OValueError("Could not find bind_to_localhost at %s" % self._bind_to_localhost)         if self._verbose:             print("
Return the path to the h2o.jar file from the local directory.          :returns:
Code: def _jar_paths():                   # PUBDEV-3534 hook to use arbitrary h2o.jar         own_jar = os.getenv("H2O_JAR_PATH", "")         if own_jar!= "":             if not os.path.isfile(own_jar):                 raise H2OStartupError("Environment variable H2O_JAR_PATH is set to '%d' but file does not exists, unset environment variable or provide valid path to h2o.jar file." % own_jar)             yield own_jar          # Check if running from an h2o-3 src folder (or any subfolder), in which case use the freshly-built h2o.jar         cwd_chunks = os.path.abspath(".").split(os.path.sep)         for i in range(len(cwd_chunks), 0, -1):             if cwd_chunks[i - 1] == "h2o-3":                 yield os.path.sep.join(cwd_chunks[:i] + ["build", "h2o.jar"])         # Then check the backend/bin folder:         # (the following works assuming this code is located in h2o/backend/server.py file)         backend_dir = os.path.split(os.path.realpath(__file__))[0]         yield os.path.join(backend_dir, "bin", "h2o.jar")          # Then try several old locations where h2o.jar might have been installed         prefix1 = prefix2 = sys.prefix         # On Unix-like systems Python typically gets installed into /Library/... or /System/Library/... If one of         # those paths is sys.prefix, then we also build its counterpart.         if prefix1.startswith(os.path.sep + "Library"):             prefix2 = os.path.join("", "System", prefix1)         elif prefix1.startswith(os.path.sep + "System"):             prefix2 = prefix1[len(os.path.join("", "System")):]         yield os.path.join(prefix1, "h2o_jar", "h2o.jar")         yield os.path.join(os.path.abspath(os.sep), "usr", "local", "h2o_jar", "h2

Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset,                  links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['account_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource
Get the url of the package          :returns: package url         :rtype: string Code: def _get_package_download_url(self):         """         Get the download url of the
Get package name from relative path          :
Get the docstring of an object from a line of text          :param line: line of
Parse a package and return a list of all classes and functions          :param string uri: python location of package - e.g'sphinx.builders'          :returns: (functions, classes)         :rtype: (list, list) Code: def _parse_module_docstring(self, uri):         """         Parse a module docstring and return a list of all classes and functions          :param string uri
Return module sequence discovered from ``self.package_name``            Parameters         ----------         None          Returns         -------         mods : sequence             Sequence of module names within ``self.package_name``          Examples         --------         >>> dw = ApiDocWriter('sphinx')         >>> mods = dw.discover_modules()         >>>'sphinx.util' in mods         True         >>> dw.package_skip_patterns.append('\.util$')         >>>'sphinx.util' in dw.discover_modules()         False         >>>          '''         modules = [self.package_name]         # raw directory parsing         for dirpath, dirnames, filenames in os.walk(self.root_path):             # Check directory names for packages             root_uri = self._path2uri(os.
Code: def write_exceptions_api(
Get an item from the list of resources          :param unicode key: The index of the resource to fetch          :returns
Code: def to_list(self):                  return [[int(self.table.cell_values[0][1]), int(self.table.cell_values[0][2])],                 [
Load ok java messages from file.          :param str ok_java_messages_filename: The filename of the ok java messages file. Code: def load_
Code: def add_new_message():          global g_new_messages_to_exclude    # filename containing text file from user containing new java ignored messages     global g_dict_changed               # True if new ignored java messages are added.      new_message_dict = extract
Code: def update_message_dict(message_dict,action):          global g_ok_java_messages      allKeys = g_ok_java_messages.keys()      for key in message_dict.keys():         if key in allKeys:  # key already exists, just add to it             for message in message_dict[key]:                  if action == 1:                     if message not in g_ok_java_messages[key]:                         g_ok_java_messages[key].append(message)                  if action == 2:                     if
Code: def get_message_from_dict_with_regex_and_count_and_sort_and_count_and_count(message_dict,key,regex):     if key in message_dict:         return sorted([x for x in message_dict[key] if re.search(regex,x)], key=lambda x: int(x.split(' ')[-1]), reverse=
Code: def save_dict():
Code: def _process_message(self, message):         """         Process a message from the server          :param dict message: Message payload from the server          :returns: Message instance         :rtype: twilio.rest.chat.v2.service.channel.message.MessageInstance         """         if message['type'] == 'text':             if message['author'] == self._client.identity:                 return None             if message['author'] in self._client.ignore_list:                 return None             if message['author'] in self._client.ignore_list_text:                 return None             if message['author'] in self._client.ignore_list_regex:                 return None             if message['author'] in self._client.ignore_list_regex_text:                 return None             if message['author'] in self._client.ignore_list_regex_text_filename:                 return None             if message['author'] in self._client.ignore_list_regex_text_filename_text:                 return None             if message['author'] in self._client.ignore_list_regex_text_filename_text_text:                 return None             if message['author'] in self._client.ignore_list_regex_text_filename_text_text_text:                 return None             if message['author'] in self._client.ignore_list_regex_text_filename_text_text_text_text:                 return None             if message['author'] in self._client.ignore_list_regex_text_filename_text_text_text_text_text:                 return None             if message['author'] in self._client.ignore_list_regex_text_filename_text_text_text_text_text_text:                 return None             if message['author'] in self._client.ignore_list_regex_text_filename_text_text_text_text_text_text_text:                 return None             if message['author'] in self._client.ignore_list_regex_text_filename_text_text_text_text_text_text_text_text:                 return None             if message['author'] in self._client.ignore_list_regex_text_filename_text_text_text_text_text_text_text_text_text:                 return None             if message['author'] in self._client.ignore_
Code: def parse_args(argv):          global g_new_messages_to_exclude     global g_old_messages_to_remove     global g_load_java_message_filename     global g_save_java_message_filename     global g_print_java_messages       if len(argv) < 2:   # print out help
Extract a
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset, links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': None,            'service_sid': service_sid,             'channel_sid': channel_sid,             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property
~~~~* <spell> ~~~~* <spell> ====* <spell> ====* <spell> ----* <spell> ----* <spell>  """  import os import re import sys import time import urllib import urllib.parse import urllib.request import uuid import xml.etree.ElementTree as ET  import requests import six  from twilio.base import deserialize from twilio.base import values from twilio.base.instance_resource import InstanceResource from twilio.base.list_resource import ListResource from twilio.base.page import Page from twilio.rest.chat.v2.service.channel.invite.invite_instance import InviteInstance from twilio.rest.chat.v2.service.channel.invite.invite_list import InviteList from twilio.rest.chat.v2.service.channel.invite.invite_page import InvitePage from twilio.rest.chat.v2.service.channel.invite.invite_context import InviteContext from twilio.rest.chat.v2.service.channel.invite.invite_creator import InviteCreator from twilio.rest.chat.v2.service.channel.invite.invite_deleter import InviteDeleter from twilio.rest.chat.v2.service.channel.invite.invite_fetcher import InviteFetcher from twilio.rest.chat.v2.service.channel.invite.invite_reader import InviteReader from twilio.rest.chat.v2.service.channel.invite.invite_updater import InviteUpdater from twilio.rest.chat.v2.service.channel.invite.invite_page import InvitePage   class InviteList(ListResource):     """ PLEASE NOTE that this class contains preview products that are subject     to change. Use them with caution. If you currently do not have developer     preview access, please contact <EMAIL>. """      def __init__(self, version, service_sid, channel_sid):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset, links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': sid,             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def date_created(self):         """         :returns: The ISO 8601 date and time in GMT when the resource was created         :rtype: datetime         """         return self._properties['date_created']      @property     def date_updated(self):         """         :returns: The ISO 8601
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         context =''.join('{}={}'.format(k, v) for k, v in self._solution.items())         return '<Twilio

Code: def addFailedTests(g_summary_dict_intermittents, g_summary_dict_all, ind):     """     Add failed tests to the intermittent dict      :param dict g_summary_dict_intermittents: Intermittent dict     :param dict g_summary_dict_all: All tests dict     :param int ind: Index of the test      """     testName = g_summary_dict_all["TestName"][ind]     testInfo = g_summary_dict_all["TestInfo"][ind]     testCategory = testInfo["TestCategory"]     testCategory = testCategory[0]     testCategory = testCategory.split(" ")     testCategory = testCategory[0]     testCategory = testCategory.split(".")     testCategory = testCategory[0]     testCategory = testCategory.split("-")     testCategory = testCategory[0]     testCategory = testCategory.split("_")     testCategory = testCategory[0]     testCategory = testCategory.split(" ")     testCategory = testCategory[0]     testCategory = testCategory.split(".")     testCategory = testCategory[0]     testCategory = testCategory.split("-")     testCategory = testCategory[0]     testCategory = testCategory.split("_")     testCategory = testCategory[0]     testCategory = testCategory.split(" ")     testCategory = testCategory[0]     testCategory = testCategory.split(".")     testCategory = testCategory[0]     testCategory = testCategory.split("-")     testCategory = testCategory[0]     testCategory = testCategory.split("_")     testCategory = testCategory[0]     testCategory = testCategory.split(" ")     testCategory = testCategory[0]     testCategory = testCategory.split(".")     testCategory = testCategory[0]     testCategory = testCategory.split("-")     testCategory = testCategory[0]     testCategory = testCategory.split("_")     testCategory = testCategory[0]     testCategory = testCategory.split(" ")     testCategory = testCategory[0]     testCategory = testCategory.split(".")     testCategory = testCategory[0]     testCategory = testCategory.split("-")     testCategory = testCategory[0]     testCategory = testCategory.split("_")     testCategory = testCategory[0]
Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def __getitem__(self, key):         """         Get an item from the list of resources          :param unicode key: The index of the resource to fetch          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite
confusion_matrix(self, metrics=None, thresholds=None)                  # make lists out of metrics and thresholds arguments         if metrics is None and thresholds is None:             metrics = ['f1']          if isinstance(metrics, list):             metrics_list = metrics         elif metrics is None:             metrics_list = []         else:             metrics_list = [metrics]          if isinstance(thresholds, list):             thresholds_list = thresholds         elif thresholds is None:             thresholds_list = []         else:             thresholds_list = [thresholds]          # error check the metrics_list and thresholds_list         assert_is_type(thresholds_list, [numeric])         assert_satisfies(thresholds_list, all(0 <= t <= 1 for t in thresholds_list))          if not all(m.lower() in H2OBinomialModelMetrics.max_metrics for m in metrics_list):             raise ValueError("The only allowable metrics are {}", ', '.join(H2OBinomialModelMetrics.max_metrics))          # make one big list that combines the thresholds and metric-thresholds         metrics_thresholds = [self.find_threshold_by_max_metric(m) for m in metrics_list]         for mt in metrics_thresholds:             thresholds_list.append(mt)         first_metrics_thresholds_offset = len(thresholds_list) - len(metrics_thresholds)          thresh2d = self._metric_json['thresholds_and_metric_scores']         actual_thresholds = [float(e[0]) for i, e in enumerate(thresh2d.cell_values)]         cms = []         for i, t in enumerate(thresholds_list):             idx = self.find_idx_by_threshold(t)             row = thresh2d.cell_values[idx]             tns = row[11]             fns = row[12]             fps = row[13]             tps = row[14]             p = tps + fns             n = tns + fps             c0 = n - fps             c1 = p - tps             if t in metrics_thresholds:                 m = metrics_list[i - first_metrics_thresholds_offset]                 table_header = "Confusion Matrix (Act/Pred) for
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset, links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': None,            'service_sid': service_sid,             'channel_sid': channel_sid,             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property
Code: def get_summary_text():     global g_failed_tests_info_dict     summary_text = ''     for key in g_failed_tests_info_dict.keys():         summary_text += g_failed_tests_info
Code: def endpoints():     """     Get all endpoints      :returns: list of dicts     :rtype: list of dicts     """     return [         {             "class_name": "Twilio",             "class_type": "twilio",             "class_id": "TWILIO",             "class_description": "Twilio",             "class_url": "https://www.twilio.com",             "class_icon": "https://www.twilio.com/marketing/bundles/marketing/img/logos/wordmark-color.svg",             "class_enabled": True,             "class_config": {                 "account_sid": "ACXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",                 "auth_token": "y<PASSWORD>",                 "from": "+15558675310",                 "to": "+15558675310",                 "message": "Hello World",                 "method": "POST",                 "url": "https://example.com/twilio/webhook",                 "status_callback": "https://example.com/twilio/status",                 "status_callback_method": "POST",                 "media_url": "https://example.com/twilio/media",                 "media_method": "POST",                 "media_type": "application/pdf",                 "media_filename": "example.pdf",                 "media_expiration": 3600,                 "media_size": 1024,                 "media_content_type": "application/pdf",                 "media_encoding": "base64",                 "media_description": "Example media description",                 "media_keywords": "example, media, keywords",                 "media_title": "Example media title",                 "media_author": "Example media author",                 "media_copyright": "Example media copyright",                 "media_category": "Example media category",                 "media_rating": "Example media rating",                 "media_release_date": "2018-01-01",                 "media_language": "en-US",                 "media_transcript": "Example media transcript",                 "media_caption": "Example media caption",                 "media_frame_height": 100,                 "media_frame_width": 100
Code: def update_site_forward(apps, schema_editor):          Site = apps.get_model("sites", "Site")     Site.objects.update_or_create(         id=settings.SITE_ID,         defaults={             "domain": "{{cookiecutter.domain_name}}",             "name": "{{cook
Convenience method for accessing the first element of the list          :returns: The first element of
Comment medias          :param list[str] medias: medias to comment         :param int amount: amount of medias to comment          :returns: True if success, False otherwise         :rtype: bool Code: def comment_media(self, media_id):     """     Comment a media      :param str media_id: media id to comment      :returns: True if success, False otherwise     :rtype: bool     """     if not self.check_media(media_id):         return False     self.logger.info("Going to comment media_%s:" % media_id)     media_id = self.convert_to_media_id(media_id)     comment = self.get_media_comment(media_id)     if comment:         self.logger.info("Media_%s has already been commented." % media_id)         return True     comment = self.get_media_comment(media_id, filter_closed_acc=True)     if comment:         self.logger.info(             "Media_%s has been commented by closed account." % media_id)         return True     comment = self.get_media_comment(media_id, filter_closed_acc=False)     if comment:         self.logger.info(             "Media_%s has been commented by open account." % media_id)         return True     comment = self.get_media_comment(media_id, filter_closed_acc=None)     if comment:         self.logger.info(             "Media_%s has been commented by both closed and open accounts." % media_
Code: def get_credentials(username=None):          while not check_secret():         pass     while True:         try:             with open(SECRET_FILE, "r") as f:                 lines = [line.strip().split(":", 2) for line in f.readlines()]         except ValueError:             msg = 'Problem with opening `{}`, will remove the file.'             raise Exception(msg.format(SECRET_FILE))         if username is not None:             for login, password in lines:                 if login == username.strip():                     return login, password         print("Which account do you want to use? (Type number)")         for ind, (login, password) in enumerate(lines):             print("%d: %s" % (ind + 1, login))         print("%d: %s" % (0, "add another account."))         print("%d: %s" % (-1, "delete all accounts."))         try:             ind = int(sys.stdin.readline())
Code: def list_reactions(self, limit=None, page_size=None):         """         Lists ReactionInstance records from the API as a list.         Unlike stream(), this operation is eager and will load `limit`
Code: def list_reactions(self, limit=None, page_size=None):         """         Lists ReactionInstance records from the API as a list.         Unlike stream(), this operation is eager and will load `limit` records into
Get user info from api          :param str user_id: user_id          :returns: dict         :rtype: dict Code: def get_user_info_from_api_cache(self, user_id):     """     Get user info from api cache      :param str user_id: user_id      :returns: dict     :rtype: dict     """     user_info = self
读取文件内容          :param str file_path: 文件路径         :param bool quiet: 是否静默模式          :returns: list         :rtype: list Code: def read_list_from_yaml_file_with_prefix(file_path, prefix, quiet=False):     try:         if not check_if_file_exists(file
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'identity': payload.get('identity'),             'role_sid': payload.get('role_sid'),             'date_created': deserialize.iso8601_datetime(payload.get('date_created')),             'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')),             'url': payload.get('url'),             'links': payload.get('links'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': payload.get('sid'),         }      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return
Returns true if both instances are not equal, false otherwise          :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def __init__(self, version, payload, service_sid, channel_sid, sid=None):         """         Initialize the InviteInstance          :returns: tw
Code: def _download_initial(             self, resource_group_name, virtual_wan_name, vpn_sites=None, output_blob_sas_url=None, custom_headers=None, raw=False, **operation_config):                  # Construct URL         url = '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualWans/{virtualWANName}/downloadPcx'         path_format_arguments = {            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name,'str'),             'virtualWANName': self._serialize.url("virtual_wan_name", virtual_wan_name,'str'),            'subscriptionId': self._serialize.url("self.config.subscription_id", self.config.subscription_id,'str')         }         url = self._client.format_url(url, **path_format_arguments)          # Construct parameters         query_parameters = {}         if vpn_sites is not None:             query_parameters['vpnSites'] = self._serialize.query("vpn_sites", vpn_sites, '[str]')         if output_blob_sas_url is not None:             query_parameters['outputBlobSasUrl'] = self._serialize.query("output_blob_sas_url", output_blob_sas_url,'str')          # Construct headers         header_parameters = {}         header_parameters['Content-Type'] = 'application/json; charset=utf-8'         if self.config.generate_client_request_id:             header_parameters['x-ms-client-request-id'] = str(uuid.uuid1())         if custom_headers:             header_parameters.update(custom_headers)         if self.config.accept_language is not None:             header_parameters['accept-language'] = self._serialize.header("self.config.accept_language", self.config.accept_language,'str')          # Construct and send request         request = self._client.post(url, query_parameters)         response = self._client.send(request, header_parameters, **operation_config)          if response.status_code not in [200, 202]:             exp = CloudError(response)             exp.request_id = response.headers.
Build an instance of InviteInstance          :param dict payload:
Code: def _update_command_initial(             self, resource_group_name, node_name, session, pssession, custom_headers=None, raw=False, **operation_config):                  # Construct URL         url = '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HybridCompute/machines/{nodeName}/sessions/{session}/pssessions/{pssession}/update'         path_format_arguments = {            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name,'str'),             'nodeName': self._serialize.url("node_name", node_name,'str'),            'session': self._serialize.url("session", session,'str'),             'pssession': self._serialize.url("pssession", pssession,'str'),            'subscriptionId': self._serialize.url("self.config.subscription_id", self.config.subscription_id,'str')         }         url = self._client.format_url(url, **path_format_arguments)          # Construct parameters         query_parameters = {}         query_parameters['api-version'] = self._serialize.query("self.api_version", self.api_version,'str')          # Construct headers         header_parameters = {}         header_parameters['Content-Type'] = 'application/json; charset=utf-8'         if self.config.generate_client_request_id:             header_parameters['x-ms-client-request-id'] = str(uuid.uuid1())         if custom_headers:             header_parameters.update(custom_headers)         if self.config.accept_language is not None:             header_parameters['accept-language'] = self._serialize.header("self.config.accept_language", self.config.accept_language,'str')          # Construct body         body_content = self._serialize.body(pssession, 'PowerShellCommand')          # Construct and send request         request = self._client.post(url, query_parameters)         response = self._client.send(             request, header_parameters, body_content, stream=False, **operation_config)          if response.status_code not in [200, 202]:             exp = CloudError(response)             exp.request_id = response.headers.get('x
Code: def delete_by_id(             self, application_definition_id, custom_headers=None, raw=False, polling=True, **operation_config):
raw_result = self._create_or_update_by_id_initial(             application_definition_id=application_definition_id,             parameters=parameters,             custom_headers=custom_headers,             raw=True,             **operation_config         )          def get_long_
Provide a friendly representation          :returns: Machine friendly representation         :rtype: unicode Code: def __init__(self, version, service_sid, channel_sid):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, response, solution):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :
Send the request headers to the server.          :param twilio.rest.chat.v2.service.channel.invite.InviteInstance.HTTPResponse connection: The connection to send the request headers to          :param dict headers: The request headers Code: def update(self, data=values.unset, role_sid=values.unset,                last_consumed_message_index=values.unset,                last_consumption_timestamp=values.unset,                date_created=values.unset, date_updated=values.unset,                url=values.unset):         '''         Update the InviteInstance          :param dict data: A JSON string that represents an object that has the                            same structure as an object returned by the API          :param unicode role_sid: The SID of the Role assigned to the invitee          :param unicode last_consumed_message_index: The index of the last Message                                                   that the invitee has read          :param unicode last_consumption_timestamp: The RFC 2822 date and time in                                                   GMT when the invitee last                                                   read a Message          :param datetime date_created: The RFC 2822 date and time in GMT when the                                       resource was created          :param datetime date_updated: The RFC 2822 date and time in GMT when the
Execute script actions on the specified HDInsight cluster.          :param resource_group_name: The name of the resource group.         :type resource_group_name: str         :param cluster_name: The name of the cluster.         :type cluster_name: str         :param persist_on_success: Persist script actions on the specified HDInsight cluster.         :type persist_on_success: bool         :param script_actions: The list of run time script actions.         :type script_actions: list of :class:`ScriptAction          <azure.mgmt.hdinsight.models.ScriptAction>`         :param dict custom_headers: headers that will be added to the request         :param bool raw: returns the direct response alongside the          deserialized response         :param polling: True for ARMPolling, False for no polling, or a          polling object for personal polling strategy         :return: An instance of LROPoller that returns None or          ClientRawResponse<None> if raw==True         :rtype:          ~msrestazure.azure_operation.AzureOperationPoller[None] or          ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[None]]         :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`         """         raw_result = self._execute_script_actions_initial(             resource_group_name=resource_group_name,             cluster_name=cluster_name,             persist_on_success=persist_on_success,             script_actions=script_actions,             custom_headers=custom_headers,             raw=True,             **operation_config         )         if raw:             return raw_result          # Construct and send request         def long_running_send():             return raw_result.response          def get_long_running_status(status_link, headers=None):              request = self._client.get(status_link)             if headers:                 request.headers.update(headers)             header_parameters = {}             header_parameters['x-ms-client-request-id'] = raw_result.response.request.headers['x-ms-client-request-id']             return self._client.send(                 request, header_parameters, stream=False, **operation_config)          def get_long_running_output(response):
Retrieve a single page of InviteInstance records from the API.         Request is executed immediately          :param Response response: The response from the server.          :returns: Page of InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def get_page
Code: def list_deleted_secrets(             self, vault_name, maxresults=None, custom_headers=None, raw=False, polling=True, **operation_config):                  raw_result = self._list_deleted_secrets_initial(             vault_name=vault_name,             maxresults=maxresults,             custom_headers
Get the client secret key sid sid          :returns: The client secret key sid sid         :rtype: unicode Code: def get_client_secret_sid(self):         """         Get the client secret sid          :returns: The client secret sid         :rtype: unicode         """         return self.
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'created_by': payload.get('created_by'),             'created_by_identity': payload.get('created_by_identity'),             'role_sid': payload.get('role_sid'),             'identity': payload.get('identity'),             'date_created': deserialize.iso8601_datetime(payload.get('date_created')),             'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')),             'url': payload.get('url'),         }          #
Code: def get_cli_profile():           try:         from azure.cli.core._profile import Profile         from azure.
Code: def get_cli_profile_user(resource=None):     """     Get the Azure CLI profile user.      :param str resource: The
Code: def __init__(self, client, config, serializer, deserializer):         super(LuisRecognizer, self).__init__(client, config, serializer, de
Code: def check_name_availability_local(             self, location, name, type, custom_headers=None, raw=False, **operation_config):                  check_name_availability = models.CheckNameAvailabilityRequest(name=name, type=type)          # Construct URL         url = self.check_name_availability_local.metadata['url']         path_format_arguments = {            'subscriptionId': self._serialize.url("self.config.subscription_id", self.config.subscription_id,'str'),             'location': self._serialize.url("location", location,'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$')         }         url = self._client.format_url(url, **path_format_arguments)          # Construct parameters         query_parameters = {}         query_parameters['api-version'] = self._serialize.query("self.api_version", self.api_version,'str')          # Construct headers         header_parameters = {}         header_parameters['Accept'] = 'application/json'         header_parameters['Content-Type'] = 'application/json; charset=utf-8'         if self.config.generate_client_request_id:             header_parameters['x-ms-client-request-id'] = str(uuid.uuid1())         if custom_headers:             header_parameters.update(custom_headers)         if self.config.accept_language is not None:             header_parameters['accept-language'] = self._serialize.header("self.config.accept_language", self.config.accept_language,'str')          # Construct body         body_content = self._serialize.body(check_name_availability, 'CheckNameAvailabilityRequest')          # Construct and send request         request = self._client.post(url, query_parameters, header_parameters, body_content)         response = self._client.send(request, stream=False, **operation_config)          if response.status_code not in [200]:             raise models.ErrorResponseException(self._deserialize, response)          deserialized = None          if response.status_code == 200:             deserialized = self._deserialize('CheckNameAvailabilityResponse', response)          if raw:             client_raw_
Read the response body.          :returns: The response body.         :rtype: str Code: def read_chunk(self, size):         """         Read a chunk of the response body.          :param int size: The maximum number of bytes to read.          :returns: The response body.         :rtype: str         """         if self.content_length is None:             raise ValueError('Content-Length header is not set')         if self.content_length == 0:             return ''         if self.content_length == self.content_length_read:             return ''         if size > self.content_length - self.content_length_read:             size = self.content_length - self.content_length_read         if size == 0:             return ''         self.content_length_
Get an item from the list of resources          :param str key: The index of the resource to return          :returns: An instance of the resource         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def __iter__(self):         """         Iterate over list of resources          :returns: List of resources
Sets the request header.          :param str name: The name of the header to set.         :param str value: The value
Gets back all response headers.          :returns: All response headers         :rtype: str Code: def get_all_response_
Sends the request body.          :param request: The request body.         :type request: str          :returns: The response body.         :rtype: str Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  identity=values.unset, role_sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  url=values.unset):         '''         Initialize the InviteContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to create the resource under         :param channel_sid: The SID of the Channel the new resource belongs to         :param sid: The SID of the Invite resource to fetch          :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         '''         super(InviteContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,                          'sid': sid or self._properties['sid'], }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites/{sid}'.format(**self._solution)          # Dependents         self._channel = None         self._member = None          # Context         self._context = None         self._properties = {'identity': identity, 'role_sid': role_sid,                             'date_created': deserialize.iso8601_datetime(date_created),                             'date_updated': deserialize.iso8601_datetime(date_updated),                             'url': url, }          if sid is not None:             self._properties['sid'] = sid      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel
Get response time from the server.          :returns: Response time from the server.         :rtype:
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, response, solution):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.
Sets the request body for the request.          :param str body: The request body to use for the request. Code: def set_request_entity_body(self, body):         '''Sets the request entity body for the request. '''         _body = BSTR(body)         _WinHttpRequest._SetRequestEntityBody(self, _body
Connects to host and sends the request.          :param method: HTTP method to use         :type method: unicode         :param uri: URI to request         :type uri: unicode Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  by=values.unset, role_sid=values.unset, url=values.unset,                  links=values.unset):         """         Initialize the InviteInstance          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to         :param sid: The unique string that identifies the resource         :param date_created: The ISO 8601 date and time in GMT when the resource was created         :param date_updated: The ISO 8601 date and time in GMT when the resource was last updated         :param by: The identity of the User who created the resource         :param role_sid: The SID of the Role assigned to the User         :param url: The absolute URL of the resource         :param links: The absolute URLs of the Channel and User resources          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['account_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'by': by,             'role_sid': role_sid,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {             'account_sid': account_sid,            'service_sid': service_sid,             'channel_sid': channel_sid,             '
Sends the headers of request.          :param name: The name of the header to set.         :param value: The value of the header to set.         :returns: The updated request object.         :rtype: requests.Request Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  identity=values.unset, role_sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  url=values.unset, links=values.unset):         """         Initialize the InviteInstance          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to create the resource under         :param channel_sid: The SID of the Channel the new resource belongs to         :param sid: The unique string that identifies the resource         :param identity: The `identity` value that identifies the new resource's User         :param role_sid: The SID of the Role to assign to the new resource         :param date_created: The RFC 2822 date and time in GMT when the resource was created         :param date_updated: The RFC 2822 date and time in GMT when the resource was last updated         :param url: The absolute URL of the resource         :param links: The absolute URLs of the Channel and User resources related to the new resource          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['account_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'identity': identity,             'role_sid': role_sid,             'date_created': deserialize.rfc2822_datetime(date_created),             'date_updated': deserialize.rfc2822_datetime(date_updated),             'url': url,             'links': links,         }          self._solution = {             'account_sid': account_sid,            'service_sid': service_sid,
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, service_sid, channel_sid, ):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      @property     def has_previous_page(self):         """         :returns: True if there is a previous page of records, else False         :rtype: bool         """         return self._version.has_previous_page(self._uri
Gets the response and generates the _Response object''' Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  by=values.unset, from_=values.unset, body=values.unset,                  url=values.unset):         """         Initialize the InviteInstance          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to         :param sid: The unique string that identifies the resource         :param date_created: The ISO 8601 date and time in GMT when the resource was created         :param date_updated: The ISO 8601 date and time in GMT when the resource was last updated         :param by: The identity of the User who created the resource         :param from_: The identity of the User who accepted the invite         :param body: The body of the invite         :param url: The absolute URL of the resource          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.Invite
Code: def __iter__(self):         """         PLEASE NOTE that this class contains preview products that are subject to change. Use them with caution. If you currently do not have developer preview access, please contact <EMAIL>.          :returns
Code: def _get_serialization_name(element_name):          known = _KNOWN_SERIALIZATION_XFOR
Code: def verify_face_to_person(             self, face_id, person_id, person_group_id=None, large_person_group_id=None, custom_headers=None, raw=False, **operation_config):                  body = models.VerifyFaceToPersonRequest(face_id=face_id, person_group_id=person_group
Code: def delete(             self, job_id, job_delete_options=None, custom_headers=None, raw=False, **operation_config):                  timeout = None         if job_delete_options is not None:             timeout = job_delete_options.timeout         client_request_id = None         if job_delete_options is not None:             client_request_id = job_delete_options.client_request_id         return_client_request_id = None         if job_delete_options is not None:             return_client_request_id = job_delete_options.return_client_request_id         ocp_date = None         if job_delete_options is not None:             ocp_date = job_delete_options.ocp_date          # Construct URL         url = self.delete.metadata['url']         path_format_arguments = {             'batchUrl': self._serialize.url("self.config.batch_url", self.config.batch_url,'str', skip_quote=True),             'jobId': self._serialize.url("job_id", job_id,'str')         }         url = self._client.format_url(url, **path_format_arguments)          # Construct parameters         query_parameters = {}         query_parameters['api-version'] = self._serialize.query("self.api_version", self.api_version,'str')         if timeout is not None:             query_parameters['timeout'] = self._serialize.query("timeout", timeout, 'int')          # Construct headers         header_parameters = {}         header_parameters['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8'         if self.config.generate_client_request_id:             header_parameters['client-request-id'] = str(uuid.uuid1())         if custom_headers:             header_parameters.update(custom_headers)         if self.config.accept_language is not None:             header_parameters['accept-language'] = self._serialize.header("self.config.accept_language", self.config.accept_language,'str')         if client_request_id is not None:             header_parameters['client-request-id'] = self._serialize.header("client_
get properties from entry xml          :param entry: entry xml         :type entry: xml.etree.ElementTree.Element          :param include_id: include id in properties         :type include_id: bool          :param id_prefix_to_skip: prefix to skip when generating id         :type id_prefix_to_skip: str          :param use_title_as_id: use title as id         :type use_title_as_id: bool          :returns: properties         :rtype: dict Code: def get_entry_
Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def get_instance(self, payload):         """         Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.
Code: def _find_namespaces_from_child(parent, child, namespaces):                  for cur_child
Converts xml response to service bus namespace          The xml format for namespace: <entry> <id>uuid:00000000-0000-0000-0000-000000000000;id=0000000</id> <title type="text">myunittests</title> <updated>2012-08-22T16:48:10Z</updated> <content type="application/xml">     <NamespaceDescription         xmlns="http://schemas.microsoft.com/netservices/2010/10/servicebus/connect"         xmlns:i="http://www.w3.org/2001/XMLSchema-instance">     <Name>myunittests</Name>     <Region>West US</Region>     <DefaultKey>0000000000000000000000000000000000000000000=</DefaultKey>     <Status>Active</Status>     <CreatedAt>2012-08-22T16:48:10.217Z</CreatedAt>     <AcsManagementEndpoint>https://myunittests-sb.accesscontrol.windows.net/</AcsManagementEndpoint>     <ServiceBusEndpoint>https://myunittests.servicebus.windows.net/</ServiceBusEndpoint>     <ConnectionString>Endpoint=sb://myunittests.servicebus.windows.net/;SharedSecretIssuer=owner;SharedSecretValue=0000000000000000000000000000000000000000000=</ConnectionString>     <SubscriptionId>00000000000000000000000000000000</SubscriptionId>     <Enabled>true</Enabled>     </NamespaceDescription> </content> </entry> Code: def _parse_bool(value):         """         Parse a boolean value from a string          :param str value: The value to parse          :returns: The parsed boolean value         :
Get the region endpoint of the service bus Code
Converts xml response to service bus namespace availability          The xml format: <?xml version="1.0" encoding="utf-8"?> <entry xmlns="http://www.w3.org/2005/Atom">     <id>uuid:9fc7c652-1856-47ab-8d74-cd31502ea8e6;id=3683292</id>     <title type="text"></title>     <updated>2013-04-16T03:03:37Z</updated>     <content type="application/xml">         <NamespaceAvailability             xmlns="http://schemas.microsoft.com/netservices/2010/10/servicebus/connect"             xmlns:i="http://www.w3.org/2001/XMLSchema-instance">             <Result>false</Result>         </NamespaceAvailability>     </content> </entry> Code: def xml_to_namespace_availability(xmlstr):         '''Converts xml response to service bus namespace availability          The xml format: <?xml version="1.0" encoding="utf-8"?> <entry xmlns="http://www.w3.org/2005/Atom">     <id>uuid:9fc7c652-1856-47ab-8d74-cd31502ea8e6;id=3683292</id>     <title type="text"></title>     <updated>2013-04-16T03:03:37Z</updated>     <content type="application/xml">         <NamespaceAvailability             xmlns="http://schemas.microsoft.com/netservices/2010/10/servicebus/connect"             xmlns:i="http://www.w3.org/2001/XMLSchema-instance">             <Result>false</Result>         </NamespaceAvailability>     </content> </entry>         '''         xmldoc = minidom.parseString(xmlstr)         availability = AvailabilityResponse()          for desc in _MinidomXmlToObject.get_children_from_path(xmldoc, 'entry', 'content',                                             'NamespaceAvailability
Converts xml response to service bus metrics objects          The xml format for MetricProperties <entry>     <id>https://sbgm.windows.net/Metrics(\'listeners.active\')</id>     <title/>     <updated>2014-10-09T11:56:50Z</updated>     <author>         <name/>     </author
Code: def _replace_content_initial(             self, resource_group_name, automation_account_name, runbook_name, runbook_content, custom_headers=None, raw=False, **operation_config):                  # Construct URL         url = '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Automation/automationAccounts/{automationAccountName}/runbooks/{runbookName}/draft/content'         path_format_arguments = {            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name,'str', max_length=90, min_length=1, pattern=r'^[-\w\._]+$'),             'automationAccountName': self._serialize.url("automation_account_name", automation_account_name,'str'),             'runbookName': self._serialize.url("runbook_name", runbook_name,'str'),            'subscriptionId': self._serialize.url("self.config.subscription_id", self.config.subscription_id,'str')         }         url = self._client.format_url(url, **path_format_arguments)          # Construct parameters         query_parameters = {}         query_parameters['api-version'] = self._serialize.query("self.api_version", self.api_version,'str')          # Construct headers         header_parameters = {}         header_parameters['Content-Type'] = 'application/json; charset=utf-8'         if self.config.generate_client_request_id:             header_parameters['x-ms-client-request-id'] = str(uuid.uuid1())         if custom_headers:             header_parameters.update(custom_headers)         if self.config.accept_language is not None:             header_parameters['accept-language'] = self._serialize.header("self.config.accept_language", self.config.accept_language,'str')          # Construct body         body_content = self._serialize.body(runbook_content, 'object')          # Construct and send request         request = self._client.put(url, query_parameters)         response = self._client.send(             request, header_parameters, body_content, **operation_config)          if response.status_code not in [200, 201]:
Code: def list_recommendations(             self, keywords=None, max_domain_recommendations=None, custom_headers=None, raw=False, **operation_config):                  parameters = models.DomainRecommendationSearchParameters(keywords=keywords, max_domain_recommendations=max_domain_recommendations)          def internal_paging(next_link=None, raw=False):              if not next_link:                 # Construct URL                 url = self.list_recommendations.metadata['url']                 path_format_arguments = {                    'subscriptionId': self._serialize.url("self.config.subscription_id", self.config.subscription_id,'str')                 }                 url = self._client.format_url(url, **path_format_arguments)                  # Construct parameters                 query_parameters = {}                 query_parameters['api-version'] = self._serialize.query("self.api_version", self.api_version,'str')              else:                 url = next_link                 query_parameters = {}              # Construct headers             header_parameters = {}             header_parameters['Accept'] = 'application/json'             header_parameters['Content-Type'] = 'application/json; charset=utf-8'             if self.config.generate_client_request_id:                 header_parameters['x-ms-client-request-id'] = str(uuid.uuid1())             if custom_headers:                 header_parameters.update(custom_headers)             if self.config.accept_language is not None:                 header_parameters['accept-language'] = self._serialize.header("self.config.accept_language", self.config.accept_language,'str')              # Construct body             body_content = self._serialize.body(parameters, 'DomainRecommendationSearchParameters')              # Construct and send request             request = self._client.post(url, query_parameters, header_parameters, body_content)             response = self._client.send(request, stream=False, **operation_config)              if response.status_code not in [200]:                 raise models.DefaultErrorResponseException(self._deserialize, response)              return response          # Deserialize response         deserialized = models.NameIdentifierPaged(internal_paging, self._deserialize.dependencies)          if raw:             header_dict = {}             client_raw_response
Code: def __init__(self, client, config, serializer, deserializer):         super(ChannelContext, self).__init__(client)         self._client = client         self._serialize = serializer         self._deserialize = deserializer         self.config = config         self.invites = InviteList(             self._client, self.config, self._serialize, self._deserialize)         self.messages = MessageList(             self._client, self.config, self._serialize, self._deserialize)         self.members = MemberList(             self._client, self.config, self._serialize, self._deserialize)         self.webhooks = WebhookList(             self._client, self.config, self._serialize, self._deserialize)         self.user_profile = None         self.last_consumed_message_index = None         self.last_consumption_timestamp = None         self.typing_indicator = None         self.notification_level = None         self.attributes = None         self.created_by = None         self.created_by_identity = None         self.date_created = None         self.date_updated = None         self.deleted = None         self.links = None         self.url = None         self.links = None         self.url = None         self.links = None         self.url = None         self.links = None         self.url = None         self.links = None         self.url = None         self.links = None         self.url = None         self.links = None         self.url = None         self.links = None         self.url = None         self.links = None         self.url = None         self.links = None         self.url = None         self.links = None         self.url = None         self.links = None         self.url = None         self.links = None         self.url = None         self.links = None         self.url = None         self.links = None         self.url = None         self.links = None         self.url = None         self.links = None         self.url = None         self.links = None         self.url = None         self.links = None         self.url = None         self.links = None         self.url = None         self.links = None         self.url = None         self.links = None         self
Code: def list(self, limit=None, page_size=50):         """         Lists InviteInstance records from the API as a list.         Unlike stream(), this operation is eager and will load `limit` records into         memory before returning.          :param int limit: Upper limit for the number of records to return. list() guarantees             never to return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not
Code: def build_installation_message(sdk_pr):     """     Build the installation message for the PR      :param github.PullRequest sdk_pr: The PR to build the message for      :returns: The installation message     :rtype: str     """     installation_message = "## Installation\n\n"     installation_message += "### Install the package\n\n"     installation_message += "```bash\n"     installation_message += "pip install azure-sdk-for-python\n"     installation_message += "```\n\n"     installation_message += "### Install the package and dependencies\n\n"     installation_message += "```bash\n"     installation_message += "pip install azure-sdk-for-python[all]\n"     installation_message += "```\n\n"     installation_message += "### Install the package and dependencies using pipenv\n\n"     installation_message += "```bash\n"     installation_message += "pipenv install azure-sdk-for-python\n"     installation_message += "```\n\n"     installation_message += "### Install the package and dependencies using poetry\n\n"     installation_message += "```bash\n"     installation_message += "poetry add azure-sdk-for-python\n"     installation_message += "```\n\n"     installation_message += "### Install the package and dependencies using setup.py\n\n"     installation_message += "```bash\n"     installation_message += "python -m pip install -e.\n"     installation_message += "```\n\n"     installation_message += "### Install the package and dependencies using setup.py with pipenv\n\n"     installation_message += "```bash\n"     installation_message += "pipenv install -e.\n"     installation_message += "```\n\n"     installation_message += "### Install the package and dependencies using setup.py with poetry\n\n"     installation_message += "```bash\n"     installation_message += "poetry install -e.\n"     installation_message += "```\n\n"     installation_message += "### Install the package and dependencies using setup.py with poetry\n\
Code: def list_by_service(self, service_sid, limit=None, page_size=None):         """         Lists InviteInstance records from the API as a list.         Unlike stream(), this operation is eager and will load `limit` records into         memory before returning.          :param str service_sid: The SID of the Service to read the resources from         :param int limit: Upper limit for the number of records to return. list() guarantees                           never to return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, list() will attempt to read the limit                               with the most efficient page size, i.e. min(limit, 1000)          :returns: Generator that will yield up to limit results         :rtype: list[twilio.rest.chat.
Code: def _publish_initial(             self, resource_group_name, automation_account_name, runbook_name, custom_headers=None, raw=False, **operation_config):                  # Construct URL         url = '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Automation/automationAccounts/{automationAccountName}/runbooks/{runbookName}/draft/publish'         path_format_arguments = {            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name,'str', max_length=90, min_length=1, pattern=r'^[-\w\._]+$'),             'automationAccountName': self._serialize.url("automation_account_name", automation_account_name,'str'),             'runbookName': self._serialize.url("runbook_name", runbook_name,'str'),            'subscriptionId': self._serialize.url("self.config.subscription_id", self.config.subscription_id,'str')         }         url = self._client.format_url(url, **path_format_arguments)          # Construct parameters         query_parameters = {}         query_parameters['api-version'] = self._serialize.query("self.api_version", self.api_version,'str')          # Construct headers         header_parameters = {}         header_parameters['Content-Type'] = 'application/json; charset=utf-8'         if self.config.generate_client_request_id:             header_parameters['x-ms-client-request-id'] = str(uuid.uuid1())         if custom_headers:             header_parameters.update(custom_headers)         if self.config.accept_language is not None:             header_parameters['accept-language'] = self._serialize.header("self.config.accept_language", self.config.accept_language,'str')          # Construct and send request         request = self._client.post(url, query_parameters)         response = self._client.send(request, header_parameters, **operation_config)          if response.status_code not in [200, 202]:             exp = CloudError(response)             exp.request_id = response.headers.get('x-ms-request-id')             raise exp          deserialized =
This background task receives messages from the server. Code: async def _receive_messages_loop_task(self):         """         This background
Code: def __init__(self, version, service_sid, channel_sid):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel to fetch the resource from          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._invites = None         self._members = None         self._messages = None         self
Code: def get_value(             self, secret_resource_name, secret_value_resource_name, custom_headers=None, raw=False, **operation_config):                  # Construct URL         url = self.get_value.metadata['url']         path_format_arguments = {            'secretResourceName': self._serialize.url("secret_resource_name", secret_resource_name,'str', skip_quote=True),            'secretValueResourceName': self._serialize.url("secret_value_resource_name", secret_value_resource_name,'str
Returns system properties for the specified storage account.          service_name:             Name of the storage service account. Code: def get_storage_account_properties(self, service_name):         '''         Returns system properties for the specified storage account.          service_name
Constructs a UserContext          :param sid: The sid          :returns: twilio.rest.chat.v2.service.user.UserContext         :rtype: twilio.rest.chat.v2.service.user.UserContext Code: def get_user_channel(self, user_sid, channel_sid):         """         Constructs a UserChannelContext          :param user_sid: The user_sid         :param channel_sid
Initialize the ServicePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service to fetch          :returns: twilio.rest.chat.v2.service.ServicePage         :rtype: twilio.rest.chat.v2.service.ServicePage Code: def __getitem__(self, key):         """         Get an item from the ServicePage          :param unicode key: The index of the requested resource          :returns: An instance of the requested resource
Creates a new storage account in Windows Azure.          service_name:             A name for the storage account that is unique within Windows Azure.             Storage account names must be between 3 and 24 characters in length             and use numbers and lower-case letters only.         description:             A description for the storage account. The description may be up             to 1024 characters in length.         label:             A name for the storage account. The name may be up to 100             characters in length. The name can be used to identify the storage             account for your tracking purposes.         affinity_group:             The name of an existing affinity group in the specified             subscription. You can specify either a location or affinity_group,             but not both.         location:             The location where the storage account is created. You can specify             either a location or affinity_group, but not both.         geo_replication_enabled:             Deprecated. Replaced by the account_type parameter.         extended_properties:             Dictionary containing name/value pairs of storage account             properties. You can have a maximum of 50 extended property             name/value pairs. The maximum length of the Name element is 64             characters, only alphanumeric characters and underscores are valid             in the Name, and the name must start with a letter. The value has             a maximum length of 255 characters.         account_type:             Specifies whether the account supports locally-redundant storage,             geo-redundant storage, zone-redundant storage, or read access             geo-redundant storage.             Possible values are:                 Standard_LRS, Standard_ZRS, Standard_GRS, Standard_RAGRS         '''         _validate_not_none('service_name', service_name)         _validate_not_none('description', description)         _validate_not_none('label', label)         if affinity_group is None and location is None:             raise ValueError(                 'location or affinity_group must be specified')         if affinity_group is not None and location is not None:             raise ValueError(                 'Only one of location or affinity_group needs to be specified')         if geo_replication_enabled == False:             account_type = 'Standard_LRS'         return self._perform_post(             self._get_storage_service_path(),             _Xml
Updates the extended properties for a storage account in Windows Azure.          service_name:             Name of the storage service account.
Deletes a UserChannelInvite instance from the service.          :param service_sid: The service_sid         :param channel_sid: The channel_sid         :param sid: The sid          :returns:
Deletes a Storage Service Account.          service_name:             Name of the storage service account. Code: def get_storage_account(self, service_name):         '''         Gets a Storage Service Account.          service_name:             Name of the storage service account.         '''         _validate_not_none('service_name', service_name)         return self._perform_get(
Retrieves system properties for the specified hosted service. These         properties include the service name and service type; the name of the         affinity group to which the service belongs, or its location if it is         not part of an affinity group; and optionally, information on the         service's deployments.          service_sid:             A 34 character string that uniquely identifies this resource.         embed_detail:             When True, the management service returns properties for all             deployments of the service, as well as for the service itself. Code: def get_hosted_service_properties_by_unique_name(self, service_unique_name, embed_detail=False):         '''         Retrieves system properties for the specified hosted service. These         properties include the service name and service type; the name of the         affinity group to which the service belongs, or its location if it is         not part
Gets
Deletes the specified hosted service from Windows Azure.          service_name:             Name of the hosted service.         disk_name:             Name of the data disk. Code: def delete_hosted_service_blob(self, service_name, blob_name):         '''         Deletes the
Uploads a new service package and creates a new deployment on staging         or production.          service_name:             Name of the hosted service.         deployment_slot:             The environment to which the hosted service is deployed. Valid             values are: staging, production         name:             The name for the deployment. The deployment name must be unique             among other deployments for the hosted service.         package_url:             A URL that refers to the location of the service package in the             Blob service. The service package can be located either in a             storage account beneath the same subscription or a Shared Access             Signature (SAS) URI from any storage account.         label:             A name for the hosted service. The name can be up to 100 characters             in length. It is recommended that the label be unique within the             subscription. The name can be used to identify the hosted service             for your tracking purposes.         configuration:             The base-64 encoded service configuration file for the deployment.         start_deployment:             Indicates whether to start the deployment immediately after it is             created. If false, the service model is still deployed to the             virtual machines but the code is not run immediately. Instead, the             service is Suspended until you call Update Deployment Status and             set the status to Running, at which time the service will be             started. A deployed service still incurs charges, even if it is             suspended.         treat_warnings_as_error:             Indicates whether to treat package validation warnings as errors.             If set to true, the Created Deployment operation fails if there             are validation warnings on the service package.         extended_properties:             Dictionary containing name/value pairs of storage account             properties. You can have a maximum of 50 extended property             name/value pairs. The maximum length of the Name element is 64             characters, only alphanumeric characters and underscores are valid             in the Name, and the name must start with a letter. The value has             a maximum length of 255 characters. Code: def delete_deployment(self, service_name, deployment_slot, name):         '''         Deletes a deployment from a service.          service_name:             Name of the hosted service.         deployment_slot:             The environment to which the hosted service is deployed. Valid             values are: staging, production         name:             The name of the deployment to delete.         '''         _validate_not_none('service
Gets the specified deployment media.          service_name:             Name of the hosted service.         deployment_name:             The
Update the ServiceInstance          :param unicode friendly_name: A string to describe the resource         :param unicode attributes: An optional string metadata field you can use to store any data you wish.         :param datetime date_created: The ISO 8601 date and time in GMT when the resource was created         :param datetime date_updated: The
Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def get_instance(self, payload):         """         Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         return InviteInstance(             self._version,             payload,
Initiates a change in deployment status.          service_sid:             A 34 character string that uniquely identifies this resource.         deployment_sid:             A 34 character string that uniquely identifies this resource.         status:             The change to initiate to the deployment status. Possible values             include:                 Running, Suspended Code: def update_deployment_status_using_unique_name(self, service_unique_name, deployment_unique_name, status):         '''         Initiates a change in deployment status.          service_unique_name:             A string to describe the resource. It must be unique within the             Service and it can be up to 64 characters long.         deployment_unique_name:             A string to describe the resource. It can be up to 64 characters             long.         status:             The change to initiate to the deployment status. Possible values             include:                 Running, Suspended         '''         _validate_not_none('service_unique_name', service_unique_name)         _validate_not_none('deployment_unique_name', deployment_unique_name)         _validate
Initiates an upgrade.          service_name:             Name of the hosted service.         deployment_name:             The name of the deployment.         mode:             If set to Manual, WalkUpgradeDomain must be called to apply the             update. If set to Auto, the Windows Azure platform will             automatically apply the update To each upgrade domain for the             service. Possible values are: Auto, Manual         package_url:             A URL that refers to the location of the service package in the             Blob service. The service package can be located either in a             storage account beneath the same subscription or a Shared Access             Signature (SAS) URI from any storage account.         configuration:             The base-64 encoded service configuration file for the deployment.         label:             A name for the hosted service. The name can be up to 100 characters             in length. It is recommended that the label be unique within the             subscription. The name can be used to identify the hosted service             for your tracking purposes.         force:             Specifies whether the rollback should proceed even when it will             cause local data to be lost from some role instances. True if the             rollback should proceed; otherwise false if the rollback should             fail.         role_to_upgrade:             The name of the specific role to upgrade.         extended_properties:             Dictionary containing name/value pairs of storage account             properties. You can have a maximum of 50 extended property             name/value pairs. The maximum length of the Name element is 64             characters, only alphanumeric characters and underscores are valid             in the Name, and the name must start with a letter. The value has             a maximum length of 255 characters. Code: def walk_upgrade_domain(self, service_name, deployment_name,                              upgrade_domain):         '''         Walks the upgrade domain.          service_name:             Name of the hosted service.         deployment_name:             The name of the deployment.         upgrade_domain:             The number of the upgrade domain to walk.         '''         _validate_not_none('service_name', service_name)         _validate_not_none('deployment_name', deployment_name)         _validate_not_none('upgrade_domain', upgrade_domain)         return self._perform_post(             self._get_deployment_path_using_name(                 service_name, deployment_name) + '/?comp
Waits for the deployment to complete.          service_name:             Name of the hosted service.         deployment_name:             The name of the deployment. Code: def wait_for_deployment_to_complete_using_name_async(self, service_name,                                                           deployment_name):         '''         Waits for the deployment to complete.          service_name:             Name of the hosted service
Get the path to a deployment.          :param str service_name: Name of the hosted service.         :param Deployment deployment: The deployment.          :returns: The path to the deployment.         :rtype: str Code: def _get_deployment_by_name(self, service_name, deployment_name):         """         Get the deployment by name.          :param str service_name: Name of the hosted service.         :param str deployment_name: The name of the deployment.          :returns: The deployment.         :rtype: Deployment         """         deployments = self.deployments.list(service_name)         for deployment in deployments:             if deployment.friendly_name == deployment_name:                 return deployment         raise TwilioException(             'Deployment with name {0} not found'.format(deployment_name))
Gets the status of role instances.          service_name:             Name of the hosted service.         deployment_name:             The name of the deployment.         role_instance_names:             List of role instance names. Code: def get_role_instance_status(self, service_name, deployment_name,                                   role_instance_name):         '''         Gets the status of a role instance.          service_name:             Name of the hosted service.         deployment_name:             The name of the deployment.         role_instance_name:             The name of the role instance.         '''         _validate_not_none('service_name', service_name)         _validate_not_none('deployment_name', deployment_name)         _validate_not_none('role_instance_name', role_instance_name)         return self._perform_get(             self._get_deployment_path_using_name(                 service_name, deployment_name) + '/roleinstances/' +             role_instance_name + '?comp=status',             _XmlSerializer.role_instance
Checks to see if the specified hosted service name is available, or if         it has already been taken.          service_name:             Name of the hosted service. Code: def create_hosted_service(self, service_name, friendly_name,                                attributes=values.unset,                                default_channel_creator_role_sid=values.unset,                                default_channel_role_sid=values.unset,                                default_channel_sid=values.unset,                                default_service_role_sid=values.unset,                                default_user_role_sid=values.unset,                                limits=values.unset,                                media=values.unset,                                post_webhook_url=values.unset,                                pre_webhook_url=values.unset,                                read_status_enabled=values.unset,                                reachability_enabled=values.unset,                                typing_indicator_timeout=values.unset,                                webhooks=values.unset):         '''         Create a new hosted service.          service_name:             Name of the hosted service.         friendly_name:             A string to describe the resource.         attributes:             A valid JSON string that contains application-specific data.         default_channel_creator_role_sid:             The SID of the Role to assign to new channel creators.         default_channel_role_sid:             The SID of the Role to assign to new channels.         default_channel_sid:             The SID of the Channel to which new Members are added by default.         default_service_role_sid:             The SID of the Role to assign to new Members.         default_user_role_sid:             The SID of the Role to assign to new Users.         limits:             The limits of the resource.         media:             The media configuration of the resource.         post_webhook_url:             The URL we should call using the `post_webhook_method` after creating             the hosted service.         pre_webhook_url:             The URL we should call using the `pre_webhook_method` before creating             the hosted service.         read_status_enabled:             Whether to enable the Read Status Indicator for the hosted service.         reachability_enabled:             Whether to enable Reachability Indicator for the hosted service.         typing_indicator_timeout:             The length of time in seconds to wait before assuming the user is no             longer typing.         webhooks:             The webhooks
Lists all of the users associated with the account.          :param identity: The identity of the User
Returns the user with the given sid.          service_name:             Name of the service to read the user from.         sid:             A string that uniquely identifies this user. Code: def get_service_user_channel(self, service_name, user_sid, channel_sid):         '''         Returns the channel with the given sid.          service_name:             Name of the service to read the channel from.         user_sid:             A string that uniquely identifies this user.         channel_sid:             A string that uniquely identifies this channel.         '''         _validate_not_none('service_name', service_name)         _validate_not_
Gets a certificate from a hosted service.          service_name:             Name of the hosted service.         certificate_sid:             The SID of the certificate to fetch. Code: def list_service_certificates(self, service_name, limit=None,                                    page_size=None):         '''         Lists certificates from a hosted service.          service_name:             Name of the hosted service.         limit:             Upper limit for the number of records to return. list() guarantees             never to return more than limit.  Default is no limit         page_size:
Deletes a user from the service.          service_name:             Name of the service to delete the user from.         sid:             A 34 character string that uniquely identifies this resource. Code: def delete_service_user_channel(self, service_name, sid, channel_sid):         '''         Deletes a user from the service.          service_name:             Name of the service to delete the user from.         sid:             A 34 character string that uniquely identifies this resource.         channel_sid:             The SID of the Channel the user is a member of.         '''         _validate_not_none
Retrieve a specific page of InviteInstance records from the API.         Request is executed immediately          :param str target_url: API-generated URL for the requested results page          :returns: Page of InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def get_page(self, target_url):         """         Retrieve a specific page of InviteInstance records from the API.         Request is executed immediately          :param str target_url: API-generated URL for the requested results page          :returns: Page of InviteInstance
The
Deletes a User Channel from the Service.          :param sid: The sid         :param channel_sid: The channel_sid          :returns: True if delete succeeds, False otherwise         :rtype: bool Code
Returns a list of all messages in the channel.          channel_sid:             The SID of the Channel resource to fetch. Code: def get_channel_members(self, channel_sid):         '''
Creates a new affinity group for the specified subscription.          name:             A name for the affinity group that is unique to the subscription.         label:             A name for the affinity group. The name can be up to 100 characters             in length.         location:             The data center location where the affinity group will be created.             To list available locations, use the list_location function.
Deletes a user from the specified channel.          :param str user_sid: The SID of the User resource to delete         :param str channel_sid: The SID of the Channel resource to delete          :returns: True if delete succeeds, False otherwise         :rtype: bool Code: def delete_user_channel_invitation(self, user_sid, channel_sid, sid):         """         Deletes a user from the specified channel.          :param str user_sid: The SID of the User resource to delete         :param str channel_sid: The SID of the Channel resource to delete         :param str sid: The SID of the User Channel Invitation resource to delete          :returns: True if delete succeeds, False otherwise         :rtype: bool         """         _validate_not_none('user_sid', user_sid)         _
List a list of all channels for a user.          :param unicode identity: The identity of the User to read         :param int limit: Upper limit for the number of records to return. list() guarantees                           never to return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, list() will attempt to read the limit                               with the most efficient page size, i.e. min(limit, 1000)          :returns: Generator that will yield up to limit results         :rtype: list[
Lists reserved IP addresses for the account
Deletes a User Message from the Service.          :param sid: The SID of the User Message resource to delete          :returns: True if delete succeeds, False
Deletes the InviteInstance          :returns: True if delete succeeds, False otherwise         :rtype: bool Code: def fetch(self):         """         Fetch a InviteInstance          :returns: Fetched InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.
Get the path for reserved
Constructs a UserChannelContext          :param sid: The sid          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def get_user_channel_invite(self, sid):         """         Constructs a UserChannelInviteContext          :param sid: The sid          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         return UserChannelInviteContext(             self._version,             service_
Retrieves the specified virtual machine.          sid:             The SID of the role.         '''
Provisions a virtual machine based on the supplied configuration.          :param str service_name:             Name of the hosted service.         :param str deployment_name:             The name for the deployment. The deployment name must be unique             among other deployments for the hosted service.         :param str deployment_slot:             The environment to which the hosted service is deployed. Valid             values are: staging, production         :param str label:             Specifies an identifier for the deployment. The label can be up to             100 characters long. The label can be used for tracking purposes.         :param str role_name:             The name of the role.         :param system_config:             Contains the metadata required to provision a virtual machine from             a Windows or Linux OS image.  Use an instance of             WindowsConfigurationSet or LinuxConfigurationSet.         :param os_virtual_hard_disk:             Contains the parameters Windows Azure uses to create the operating             system disk for the virtual machine. If you are creating a Virtual             Machine by using a VM Image, this parameter is not used.         :param network_config:             Encapsulates the metadata required to create the virtual network             configuration for a virtual machine. If you do not include a             network configuration set you will not be able to access the VM             through VIPs over the internet. If your virtual machine belongs to             a virtual network you can not specify which subnet address space             it resides under. Use an instance of ConfigurationSet.         :param availability_set_name:             Specifies the name of an availability set to which to add the             virtual machine. This value controls the virtual machine             allocation in the Windows Azure environment. Virtual machines             specified in the same availability set are allocated to different             nodes to maximize availability.         :param data_virtual_hard_disks:             Contains the parameters Windows Azure uses to create a data disk             for a virtual machine.         :param role_size:             The size of the virtual machine to allocate. The default value is             Small. Possible values are: ExtraSmall,Small,Medium,Large,             ExtraLarge,A5,A6,A7,A8,A9,Basic_A0,Basic_A1,Basic_A2,Basic_A3,             Basic_A4,Standard_D1,Standard_D2,Standard_D3,Standard_D4,             Standard_D11,Standard_D12,
Adds a virtual machine to an existing deployment.          service_name:             The name of the service.         deployment_name:             The name of the deployment.         role_name:             The name of the role.         system_config:             Contains the metadata required to provision a virtual machine from             a Windows or Linux OS image.  Use an instance of             WindowsConfigurationSet or LinuxConfigurationSet.         os_virtual_hard_disk:             Contains the parameters Windows Azure uses to create the operating             system disk for the virtual machine. If you are creating a Virtual             Machine by using a VM Image, this parameter is not used.         network_config:             Encapsulates the metadata required to create the virtual network             configuration for a virtual machine. If you do not include a             network configuration set you will not be able to access the VM             through VIPs over the internet. If your virtual machine belongs to             a virtual network you can not specify which subnet address space             it resides under.         availability_set_name:             Specifies the name of an availability set to which to add the             virtual machine. This value controls the virtual machine allocation             in the Windows Azure environment. Virtual machines specified in the             same availability set are allocated to different nodes to maximize             availability.         data_virtual_hard_disks:             Contains the parameters Windows Azure uses to create a data disk             for a virtual machine.         role_size:             The size of the virtual machine to allocate. The default value is             Small. Possible values are: ExtraSmall, Small, Medium, Large,             ExtraLarge. The specified value must be compatible with the disk             selected in the OSVirtualHardDisk values.         role_type:             The type of the role for the virtual machine. The only supported             value is PersistentVMRole.         resource_extension_references:             Optional. Contains a collection of resource extensions that are to             be installed on the Virtual Machine. This element is used if             provision_guest_agent is set to True.         provision_guest_agent:             Optional. Indicates whether the VM Agent is installed on the             Virtual Machine. To run a resource extension in a Virtual Machine,             this service must be installed.         vm_image_name:             Optional. Specifies the name of the VM Image that is to be used to             create the Virtual Machine. If this is specified, the             system_config and network_config parameters are not used.         media_location:
Updates the specified virtual machine.          service_name:             The name of the service.         deployment_name:             The name of the deployment.         role_name:             The name of the role.         os_virtual_hard_disk:             Contains the parameters Windows Azure uses to create the operating             system disk for the virtual machine.         network_config:             Encapsulates the metadata required to create the virtual network             configuration for a virtual machine. If you do not include a             network configuration set you will not be able to access the VM             through VIPs over the internet. If your virtual machine belongs to             a virtual network you can not specify which subnet address space             it resides under.         availability_set_name:             Specifies the name of an availability set to which to add the             virtual machine. This value controls the virtual machine allocation             in the Windows Azure environment. Virtual machines specified in the             same availability set are allocated to different nodes to maximize             availability.         data_virtual_hard_disks:             Contains the parameters Windows Azure uses to create a data disk             for a virtual machine.         role_size:             The size of the virtual machine to allocate. The default value is             Small. Possible values are: ExtraSmall, Small, Medium, Large,             ExtraLarge. The specified value must be compatible with the disk             selected in the OSVirtualHardDisk values.         role_type:             The type of the role for the virtual machine. The only supported             value is PersistentVMRole.         resource_extension_references:             Optional. Contains a collection of resource extensions that are to             be installed on the Virtual Machine. This element is used if             provision_guest_agent is set to True.         provision_guest_agent:             Optional. Indicates whether the VM Agent is installed on the             Virtual Machine. To run a resource extension in a Virtual Machine,             this service must be installed.         '''         _validate_not_none('service_name', service_name)         _validate_not_none('deployment_name', deployment_name)         _validate_not_none('role_name', role_name)         return self._perform_put(             self._get_role_path(service_name, deployment_name, role_name),             _XmlSerializer.update_role_to_xml(                 role_name,                 os_virtual_hard_disk,                 role_type,                 network_
Gets the media content for the specified virtual machine.          service_name:             The name of the service.         deployment_name:             The name of the deployment.         role_name:             The name of the role. Code: def get_role_media_content(self, service_name, deployment_name, role_name):         '''         Gets the media content for
Build an instance of UserInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.user.UserInstance         :rtype: twilio.rest.chat.v2.service.user.UserInstance Code: def get_instance(self, payload):         """         Build an instance of BindingInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.
Stops the specified virtual machine.          service_name:             The name of the service.         deployment_name:             The name of the deployment.         role_name:             The name of the role.         '''         _validate_not_none('service_name', service_name)         _validate_not_none('deployment_name', deployment_name)         _validate_not_none('role_name', role_name)         return self._perform_post(             self._get_role_instance_operations_path(                 service_name, deployment_name, role_name),             _XmlSerializer.stop_role_operation_to_xml(),             as_async=True) Code: def suspend_role(self, service_name, deployment_name, role_name):         '''         Suspends the specified virtual machine.          service_
Updates the specified virtual machines.          service_name:             The name of the service.         deployment_name:             The name of the deployment.         role_names:             The names of the roles, as an enumerable of strings. Code: def
Restarts the specified virtual machine.          service_name:             The name of the service.         deployment_name:             The name of the deployment.         role_name:             The name of the role.         '''         _validate_not_none('service_name', service_name)         _validate_not_none('deployment_name', deployment_name)         _validate_not_none('role_name', role_name)         return self._perform_post(             self._get_role_instance_operations_path(                 service_name, deployment_name, role_name),             _XmlSerializer.restart_role_operation_to_xml(             ),             as_async=True) Code: def restart_role(self, service_name, deployment_name, role_name):         '''         Restarts the specified
Update the ServiceInstance          :param unicode friendly_name: A string to describe the resource         :param unicode attributes: An optional string metadata
Shuts down the specified virtual machines.          service_name:             The name of the service.         deployment_name:             The name of the deployment.         role_names:             The names of the roles, as an enumerable of strings.         post_shutdown_action:             Specifies how the Virtual Machine should be shut down. Values are:                 Stopped                     Shuts down the Virtual Machine but retains the compute                     resources. You will continue to be billed for the resources                     that the stopped machine uses.                 StoppedDeallocated                     Shuts down the Virtual Machine and releases the compute                     resources. You are not billed for the compute resources that                     this Virtual Machine uses. If a static Virtual Network IP                     address is assigned to the Virtual Machine, it is reserved. Code: def update(self, friendly_name=values.unset, attributes=values.unset,                 date_created=values.unset, date_updated=values.unset,                 url=values.unset, links=values.unset):         """         Update the InviteInstance          :param unicode friendly_name: The string that you assigned to describe the resource         :param unicode attributes: The JSON string that stores application-specific data         :param datetime date_created: The ISO 8601 date and time in GMT when the resource was created         :param datetime date_updated: The ISO 8601 date and time in GMT when the resource was last updated         :param unicode url: The absolute URL of the resource         :param unicode links: The absolute URLs of the related resources          :returns: Updated InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         data = values.of({             'FriendlyName': friendly_name,             'Attributes': attributes,             'DateCreated': serialize.iso8601_datetime(date_created),             'DateUpdated': serialize.iso8601_datetime(date_updated),             'Url': url,             'Links': links,         })          payload = self._version.update(             'POST',             self._uri,             data=data,         )          return InviteInstance(             self._version,             payload,             service_sid=self._solution['service_sid'],             channel_sid=self._solution['channel_sid'],             sid=self._solution['sid'],         ) Doc
Adds a DNS server definition to an existing deployment.          service_name:             The name of the service.         deployment_name:             The name of the deployment.         dns_server_name:
Updates the ip address of a DNS server.          service_name:             The name of the service.         deployment_name:             The name of the deployment.         dns_server_name:             Specifies the name of the DNS server.         address:             Specifies the IP address of the DNS server. Code: def update_dns_server(self, service_name, deployment_name, dns_server_name, address):         '''         Updates the ip address of a DNS server.          service_name:             The name of the service.         deployment_name:             The name of the deployment.         dns_server_name:             Specifies the name of the DNS server.         address:             Specifies the IP address of the DNS server.         '''         _validate_not_none('service_name', service_name)         _validate_not_none('deployment_name', deployment_name)         _validate_not_none('dns_server_name', dns_server_name)         _validate_not_none('address', address)         return
Deletes a service.          service_name:             The name of the service.         '''         _validate_not_none('service_name', service_name)         return self._perform_delete(             self._get_service_path(service_name),             as_async=True) Code: def delete
Lists UserInstance records from the API as a list.         Unlike stream(), this operation is eager and will load `limit` records
Get the path to the replication operation using the vm_image_name Code: def _get_replication_path_using_vm_image_id(self, vm_image_id):         '''         Get the path to the replication operation using the vm_image_id         '''
Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.
Get the path to share a VM image using the VM image ID.          :param str vm_image_id: The
Creates a VM Image in the image repository that is associated with the         specified subscription using a specified set of virtual hard disks.          vm_image:             An instance of VMImage class.         vm_image.name: Required. Specifies the name of the image.         vm_image.label: Required. Specifies an identifier for the image.         vm_image.description: Optional. Specifies the description of the image.         vm_image.os_disk_configuration:             Required. Specifies configuration information for the operating              system disk that is associated with the image.         vm_image.os_disk_configuration.host_caching:             Optional. Specifies the caching behavior of the operating system disk.             Possible values are: None, ReadOnly, ReadWrite          vm_image.os_disk_configuration.os_state:             Required. Specifies the state of the operating system in the image.             Possible values are: Generalized, Specialized             A Virtual Machine that is fully configured and running contains a             Specialized operating system. A Virtual Machine on which the             Sysprep command has been run with the generalize option contains a             Generalized operating system.         vm_image.os_disk_configuration.os:             Required. Specifies the operating system type of the image.         vm_image.os_disk_configuration.media_link:             Required. Specifies the location of the blob in Windows Azure             storage. The blob location belongs to a storage account in the             subscription specified by the <subscription-id> value in the             operation call.         vm_image.data_disk_configurations:             Optional. Specifies configuration information for the data disks             that are associated with the image. A VM Image might not have data             disks associated with it.         vm_image.data_disk_configurations[].host_caching:             Optional. Specifies the caching behavior of the data disk.             Possible values are: None, ReadOnly, ReadWrite          vm_image.data_disk_configurations[].lun:             Optional if the lun for the disk is 0. Specifies the Logical Unit             Number (LUN) for the data disk.         vm_image.data_disk_configurations[].media_link:             Required. Specifies the location of the blob in Windows Azure             storage. The blob location belongs to a storage account in the             subscription specified by the <subscription-id> value in the             operation call.         vm_image.data_disk_configurations[].logical_
Gets a list of all the VM Images in the image repository that is         associated with the specified subscription.          location:             The location of the resource.         publisher_name:             A valid image publisher.         offer:             A valid image publisher offer.
Retrieves a list of the VM Images from the image repository that is         associated with the specified subscription.          :param str location: The location of the VM Image.         :param str publisher: The publisher of the VM
Updates a VM Image in the image repository that is associated with the         specified subscription.          vm_image_name:             Name of image to update.         vm_image:             An instance of VMImage class.         vm_image.label: Optional. Specifies an identifier for the image.         vm_image.os_disk_configuration:             Required. Specifies configuration information for the operating              system disk that is associated with the image.         vm_image.os_disk_configuration.host_caching:             Optional. Specifies the caching behavior of the operating system disk.             Possible values are: None, ReadOnly, ReadWrite          vm_image.data_disk_configurations:             Optional. Specifies configuration information for the data disks             that are associated with the image. A VM Image might not have data             disks associated with it.         vm_image.data_disk_configurations[].name:             Required. Specifies the name of the data disk.         vm_image.data_disk_configurations[].host_caching:             Optional. Specifies the caching behavior of the data disk.             Possible values are: None, ReadOnly, ReadWrite          vm_image.data_disk_configurations[].lun:             Optional if the lun for the disk is 0. Specifies the Logical Unit             Number (LUN) for the data disk.         vm_image.description: Optional. Specifies the description of the image.         vm_image.language: Optional. Specifies the language of the image.         vm_image.image_family:             Optional. Specifies a value that can be used to group VM Images.         vm_image.recommended_vm_size:             Optional. Specifies the size to use for the Virtual Machine that             is created from the VM Image.         vm_image.eula:             Optional. Specifies the End User License Agreement that is             associated with the image. The value for this element is a string,             but it is recommended that the value be a URL that points to a EULA.         vm_image.icon_uri:             Optional. Specifies the URI to the icon that is displayed for the             image in the Management Portal.         vm_image.small_icon_uri:             Optional. Specifies the URI to the small icon that is displayed for             the image in the Management Portal.         vm_image.privacy_uri:             Optional. Specifies the URI that points to a document that contains             the privacy policy related to the image.         vm_image
Adds a new role to the service.          friendly_name:             A human readable description of this role.         permissions:             A list of permissions to be assigned to this role.         '''         _validate_not_none('friendly_name', friendly_name)         _validate_not_none('permissions', permissions)         return self._perform_post(self._get_role_path(),                                   _XmlSerializer.role_to_xml(                                       friendly_name, permissions),                                   as_async=True) Code: def add_user(self, attributes,
Updates an OS image that in your image repository.          image_name:             The name of the image to update.         label:             Specifies the friendly name of the image to be updated. You cannot             use this operation to update images provided by the Windows Azure             platform.         media_link:             Specifies the location of the blob in Windows Azure blob store             where the media for the image is located. The blob location must             belong to a storage account in the subscription specified by the             <subscription-id> value in the operation call. Example:             http://example.blob.core.windows.net/disks/mydisk.vhd         name:             Specifies a name for the OS image that Windows Azure uses to             identify the image when creating one or more VM Roles.         os:             The operating system type of the OS image. Possible values are:             Linux, Windows         '''         _validate_not_none('image_name', image_name)         _validate_
Updates metadata elements from a given OS image reference.          image_name:             The name of the image to update.         os_image:             An instance of OSImage class.         os_image.label: Optional. Specifies an identifier for the image.         os_image.description: Optional. Specifies the description of the image.         os_image.language: Optional. Specifies the language of the image.         os_image.image_family:             Optional. Specifies a value that can be used to group VM Images.         os_image.recommended_vm_size:             Optional. Specifies the size to use for the Virtual Machine that             is created from the VM Image.         os_image.eula:             Optional. Specifies the End User License Agreement that is             associated with the image. The value for this element is a string,             but it is recommended that the value be a URL that points to a EULA.         os_image.icon_uri:             Optional. Specifies the URI to the icon that is displayed for the             image in the Management Portal.         os_image.small_icon_uri:             Optional. Specifies the URI to the small icon that is displayed for             the image in the Management Portal.         os_image.privacy_uri:             Optional. Specifies the URI that points to a document that contains             the privacy policy related to the image.         os_image.published_date:             Optional. Specifies the date when the image was added to the image             repository.         os.image.media_link:             Required: Specifies the location of the blob in Windows Azure             blob store where the media for the image is located. The blob             location must belong to a storage account in the subscription             specified by the <subscription-id> value in the operation call.             Example:             http://example.blob.core.windows.net/disks/mydisk.vhd         os_image.name:             Specifies a name for the OS image that Windows Azure uses to             identify the image when creating one or more VM Roles.         os_image.os:             The operating system type of the OS image. Possible values are:             Linux, Windows         '''         _validate_not_none('image_name', image_name)         _validate_not_none('os_image', os_image)         return self._perform_put(self._get_image_path(image_name),             _XmlSerializer
Deletes the specified OS image from your image repository.          image_name:             The name of the image.         delete_vhd:             Deletes the underlying vhd blob in Azure storage. Code: def delete_os_image(self, image_name, delete_vhd=False):         '''         Deletes the specified OS image from your image repository.          image_name:             The name of the image.         delete_vhd:             Deletes the underlying vhd blob in Azure storage.         '''         _validate_not_none('image_name', image_name)         path = self._get_image_path(image_name)         if delete_vhd:             path += '?comp=media'         return self._perform_delete(path, as_async=
Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def get_instance(self, payload):         """         Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat
Adds a data disk to a virtual machine.          service_name:             The name of the service.         deployment_name:             The name of the deployment.         role_name:             The name of the role.         lun:             Specifies the Logical Unit Number (LUN) for the disk. The LUN             specifies the slot in which the data drive appears when mounted             for usage by the virtual machine. Valid LUN values are 0 through 15.         host_caching:             Specifies the platform caching behavior of data disk blob for             read/write efficiency. The default vault is ReadOnly. Possible             values are: None, ReadOnly, ReadWrite         media_link:             Specifies the location of the blob in Windows Azure blob store             where the media for the disk is located. The blob location must             belong to the storage account in the subscription specified by the             <subscription-id> value in the operation call. Example:             http://example.blob.core.windows.net/disks/mydisk.vhd         disk_label:             Specifies the description of the data disk. When you attach a disk,             either by directly referencing a media using the MediaLink element             or specifying the target disk size, you can use the DiskLabel             element to customize the name property of the target data disk.         disk_name:             Specifies the name of the disk. Windows Azure uses the specified             disk to create the data disk for the machine and populates this             field with the disk name.         logical_disk_size_in_gb:             Specifies the size, in GB, of an empty disk to be attached to the             role. The disk can be created as part of disk attach or create VM             role call by specifying the value for this property. Windows Azure             creates the empty disk based on size preference and attaches the             newly created disk to the Role.         source_media_link:             Specifies the location of a blob in account storage which is             mounted as a data disk when the virtual machine is created. Code: def get_instance(self, payload):         """         Build an instance of RoleInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.role.RoleInstance         :rtype: twilio.rest.chat.v2.service.channel.role.RoleInstance         """         return RoleInstance(             self._version,             payload
Updates the specified data disk attached to the specified virtual         machine.          service_name:             The name of the service.         deployment_name:             The name of the deployment.         role_name:             The name of the role.         lun:             Specifies the Logical Unit Number (LUN) for the disk. The LUN             specifies the slot in which the data drive appears when mounted             for usage by the virtual machine. Valid LUN values are 0 through             15.         host_caching:             Specifies the platform caching behavior of data disk blob for             read/write efficiency. The default vault is ReadOnly. Possible             values are: None, ReadOnly, ReadWrite         media_link:             Specifies the location of the blob in Windows Azure blob store             where the media for the disk is located. The blob location must             belong to the storage account in the subscription specified by             the <subscription-id> value in the operation call. Example:             http://example.blob.core.windows.net/disks/mydisk.vhd         updated_lun:             Specifies the Logical Unit Number (LUN) for the disk. The LUN             specifies the slot in which the data drive appears when mounted             for usage by the virtual machine. Valid LUN values are 0 through 15.         disk_label:             Specifies the description of the data disk. When you attach a disk,             either by directly referencing a media using the MediaLink element             or specifying the target disk size, you can use the DiskLabel             element to customize the name property of the target data disk.         disk_name:             Specifies the name of the disk. Windows Azure uses the specified             disk to create the data disk for the machine and populates this             field with the disk name.         logical_disk_size_in_gb:             Specifies the size, in GB, of an empty disk to be attached to the             role. The disk can be created as part of disk attach or create VM             role call by specifying the value for this property. Windows Azure             creates the empty disk based on size preference and attaches the             newly created disk to the Role. Code: def update_role_size(self, service_name, deployment_name, role_name,                          role_size):         '''         Updates the role size of the role in the deployment.          service_name:             The name of the service.         deployment_name:             The name of
Gets the data disks from a virtual machine
Adds a disk to the user image repository. The disk can be an OS disk         or a data disk.          has_operating_system:             Deprecated.         label:             Specifies the description of the disk.         media_link:             Specifies the location of the blob in Windows Azure blob store             where the media for the disk is located. The blob location must             belong to the storage account in the current subscription specified             by the <subscription-id> value in the operation call. Example:             http://example.blob.core.windows.net/disks/mydisk.vhd         name:             Specifies a name for the disk. Windows Azure uses the name to             identify the disk when creating virtual machines from the disk.         os:             The OS type of the disk. Possible values are: Linux, Windows Code: def add_role(self, name, role_size, label, os_virtual_hard_disk, data_virtual_hard_disks):         '''         Adds a role to the user image repository.          name:             Specifies a name for the role. Windows Azure uses the name to             identify the role when creating virtual machines from the role.         role_size:             Specifies the size of the role.         label:             Specifies the description of the role.         os_virtual_hard_disk:             Specifies the location of the blob in Windows Azure blob store             where the operating system disk for the role is located. The blob             location must belong to the storage account in the current             subscription specified by the <subscription-id> value in the             operation call. Example:             http://example.blob.core.windows.net/disks/mydisk.vhd         data_virtual_hard_disks:             Specifies the location of the blob in Windows Azure blob store             where the data disks for the role are located. The blob location             must belong to the storage account in the current subscription             specified by the <subscription-id> value in the operation call.             Example:             http://example.blob.core.windows.net/disks/mydisk.vhd         '''         _validate_not_none('name', name)         _validate_not_none('role_size', role_size)         _validate_not_none('label', label)         _validate_not_none('os_virtual_hard_disk', os_virtual_hard_disk)         _validate_not_none('data_
Updates an existing instance in your image repository.          disk_name:             The name of the disk to update.         label:             Specifies the description of the disk.         media_link:             Deprecated.         name:             Deprecated. Code: def update_os(self, disk_name, label=None, media_link=None, name=None):         '''         Updates an existing operating system in your image repository.          disk_
Gets the specified data or operating system disk from your image         repository.          disk_name:             The name of the disk to get. Code: def get_image(self, image_name
Code: def summarize_for_policy_set(             self, policy_set_name, query_options=None, custom_headers=None, raw=False, **operation_config):                  top = None         if query_options is not None:             top = query_options.top         from_parameter = None         if query_options is not None:             from_parameter = query_options.from_property         to = None         if query_options is not None:             to = query_options.to         filter = None         if query_options is not None:             filter = query_options.filter          # Construct URL         url = self.summarize_for_policy_set.metadata['url']         path_format_arguments = {             'policyStatesSummaryResource': self._serialize.url("self.policy_states_summary_resource", self.policy_states_summary_resource,'str'),             'policySetDefinitionsNamespace': self._serialize.url("self.policy_set_definitions_namespace", self.policy_set_definitions_namespace,'str'),             'policySetDefinitionsName': self._serialize.url("policy_set_name", policy_set_name,'str')         }         url = self._client.format_url(url, **path_format_arguments)          # Construct parameters         query_parameters = {}         query_parameters['api-version'] = self._serialize.query("self.api_version", self.api_version,'str')         if top is not None:             query_parameters['$top'] = self._serialize.query("top", top, 'int', minimum=0)         if from_parameter is not None:             query_parameters['$from'] = self._serialize.query("from_parameter", from_parameter, 'iso-8601')         if to is not None:             query_parameters['$to'] = self._serialize.query("to", to, 'iso-8601')         if filter is not None:             query_parameters['$filter'] = self._serialize.query("filter", filter,'str')          # Construct headers         header_parameters = {}         header_parameters['Accept'] = 'application/json'         if self.config.generate_client_request_id:             header_parameters['x-ms-client-request-
Code: def _build_receiver_link(self):         """         Build the receiver link          :returns: The receiver link         :rtype: proton.Receiver         """         self._receiver = self._session.receiver(self._name)         self._receiver.source.address = self._address         self._receiver.source.durable = self._durable         self._receiver.source.dynamic = self._dynamic         self._receiver.source.filter = self._filter         self._receiver.source.rollover_policy = self._rollover_policy         self._receiver.source.timeout = self._timeout         self._receiver.source.capabilities = self._capabilities         self._receiver.source.capabilities.set(self._capabilities)         self._receiver.source.capabilities.set(self._capabilities)         self._receiver.source.capabilities.set(self._capabilities)         self._receiver.source.capabilities.set(self._capabilities)         self._receiver.source.capabilities.set(self._capabilities)         self._receiver.source.capabilities.set(self._capabilities)         self._receiver.source.capabilities.set(self._
Fetch a single page of InviteInstance records from the API.             Request is executed immediately          :param int max_batch_size: Upper limit for the number of records to return.                                    stream()                           guarantees to never return more than max_batch_size.                           Default is no limit         :param int timeout: How long, in seconds, to wait for the response.                             Default is 15 seconds.          :returns: Page of InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         self._can_run()         wrapped_batch = []         max_batch_size = max_batch_size or self._handler._prefetch  # pylint: disable=protected-access         try:             timeout_ms = 1000 * timeout if timeout else 0             batch = self._handler.receive_message_batch(                 max_batch_size=max_batch_size,                 timeout=timeout_ms)             for received in batch:                 message = self._build_message(received)                 wrapped_batch.append(message)         except Exception as
Send a packet to the server.          :param twilio.rest.chat.v2.service.channel.invite.packet.Packet packet: The packet to send Code: def _start_ping_loop(self):         """         Start the ping loop.         """         self.
Create or update a VM scale set.          :param str resource_group_name: The name of the resource group.         :param str vm_scale_set_name: The name of the VM scale set where the          extension should be create or updated.         :param VirtualMachineScaleSet parameters: Parameters supplied to the          Create Virtual Machine Scale Set operation.         :param dict custom_headers: headers that will be added to the request         :param bool raw: returns the direct response alongside the          deserialized response         :param polling: True for ARMPolling, False for no polling, or a          polling object for personal polling strategy         :return: An instance of LROPoller that returns VirtualMachineScaleSet          or ClientRawResponse<VirtualMachineScaleSet> if raw=true         :rtype:          ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.compute.v2017_03_30.models.VirtualMachineScaleSet]          or          ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.compute.v2017_03_30.models.VirtualMachineScaleSet]]         :raises:          :class:`CloudError<msrestazure.azure_exceptions.CloudError>`         """ Code: def get_instance(self, resource_group_name, vm_scale_set_name, instance_id, custom_headers=None, raw=False, **operation_config):                  # Construct URL         url = '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualmachines/{instanceId}'         path_format_arguments = {            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name,'str'),             'vmScaleSetName': self._serialize.url("vm_scale_set_name", vm_scale_set_name,'str'),             'instanceId': self._serialize.url("instance_id", instance_id,'str'),            'subscriptionId': self._serialize.url("self.config.subscription_id", self.config.subscription_id,'str')         }         url = self._client.format_url(url, **path_format_arguments)          # Construct parameters         query_parameters = {}         query_parameters['api
Build an instance of InviteInstance          :param dict payload:
Code: def screen_text(             self, text_content_type, text_content, language=None, autocorrect=False, pii=False, list_id=None, classify=False, custom_headers=None, raw=False, callback=None, **operation_config):                  # Construct URL         url = self.screen_text.metadata['url']         path_format_arguments = {             'Endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint,'str', skip_quote=True)         }         url = self._client.format_url(url, **path_format_arguments)          # Construct parameters         query_parameters = {}         if language is not None:             query_parameters['language'] = self._serialize.query("language", language,'str')         if autocorrect is not None:             query_parameters['autocorrect'] = self._serialize.query("autocorrect", autocorrect, 'bool')         if pii is not None:             query_parameters['PII'] = self._serialize.query("pii", pii, 'bool')         if list_id is not None:             query_parameters['listId'] = self._serialize.query("list_id", list_id,'str')         if classify is not None:             query_parameters['classify'] = self._serialize.query("classify", classify, 'bool')          # Construct headers         header_parameters = {}         header_parameters['Accept'] = 'application/json'         header_parameters['Content-Type'] = 'text/plain'         if custom_headers:             header_parameters.update(custom_headers)         header_parameters['Content-Type'] = self._serialize.header("text_content_type", text_content_type,'str')          # Construct body         body_content = self._client.stream_upload(text_content, callback)          # Construct and send request         request = self._client.post(url, query_parameters, header_parameters, body_content)         response = self._client.send(request, stream=False, **operation_config)          if response.status_code not in [200]:             raise models.APIErrorException(self._deserialize, response)          deserialized = None          if response.status_code == 200:             deserialized =
Code: def get_key(             self, vault_base_url, key_name, custom_headers=None, raw=False, **operation_config):                  # Construct URL         url = self.get
Code: def list_by_service(             self, service_sid, limit=None, page_size=None, page_token=None,             friendly_name=values.unset, date_created_after=values.unset,             date_created_before=values.unset, date_updated_after=values.unset,             date_updated_before=values.unset, target_role_sid=values.unset,             invited_by=values.unset, identity=values.unset,             attributes=values.unset, x_twilio_webhook_enabled=values.unset,             custom_headers=None, raw=False, **operation_config):                  parameters = models.ChannelListInstanceQueryParams(             limit=limit,             page_size=page_size,             page_token=page_token,             friendly_name=friendly_name,             date_created_after=date_created_after,             date_created_before=date_created_before,             date_updated_after=date_updated_after,             date_updated_before=date_updated_before,             target_role_sid=target_role_sid,             invited_by=invited_by,             identity=identity,             attributes=attributes,         )          # Construct URL         url = self.list_by_service.metadata['url']         path_format_arguments = {            'serviceSid': self._serialize.url("service_sid", service_sid,'str'),         }         url = self._client.format_url(url, **path_format_arguments)          # Construct parameters         query_parameters = {}         query_parameters['api-version'] = self._serialize.query("self.api_version", self.api_version,'str')         if parameters.limit is not None:             query_parameters['Limit'] = self._serialize.query("parameters.limit", parameters.limit, 'int')         if parameters.page_size is not None:             query_parameters['PageSize'] = self._serialize.query("parameters.page_size", parameters.page_size, 'int')         if parameters.page_token is not None:             query_parameters['PageToken'] = self._serialize.query("parameters.page_token", parameters.page_token,'str')         if parameters.friendly_name is not None
Code: def update_key(             self, vault_base_url, key_name, key_version, key_ops=None, key_attributes=None, tags=None, custom_headers=None, raw=False, **operation_config):                  parameters = models.KeyUpdateParameters(key_ops=key_ops, key_attributes=key_attributes, tags=tags)          # Construct URL         url = self.update_key.metadata['url']         path_format_arguments = {             'vaultBaseUrl': self._serialize.url("vault_base_url", vault_base_url,'str', skip_quote=True),             'key-name': self._serialize.url("key_name", key_name,'str'),             'key-version': self._serialize.url("key_version", key_version,'str')         }         url = self._client.format_url(url, **path_format_arguments)          # Construct parameters         query_parameters = {}         query_parameters['api-version'] = self._serialize.query("self.api_version", self.api_version,'str')          # Construct headers         header_parameters = {}         header_parameters['Content-Type'] = 'application/json; charset=utf-8'         if self.config.generate_client_request_id:             header_parameters['x-ms-client-request-id'] = str(uuid.uuid1())         if custom_headers:             header_parameters.update(custom_headers)         if self.config.accept_language is not None:             header_parameters['accept-language'] = self._serialize.header("self.config.accept_language", self.config.accept_language,'str')          # Construct body         body_content = self._serialize.body(parameters, 'KeyUpdateParameters')          # Construct and send request         request = self._client.patch(url, query_parameters)         response = self._client.send(             request, header_parameters, body_content, stream=False, **operation_config)          if response.status_code not in [200]:             raise models.KeyVaultErrorException(self._deserialize, response)          deserialized = None          if response.status_code == 200:             deserialized = self._deserialize('KeyBundle', response)
Code: def set_secret(             self, vault_base_url, secret_name, value, tags=None, content_type=None, secret_attributes=None, custom_headers=None, raw=False, **operation_config):                  parameters = models.SecretSetParameters(value=value, tags=tags, content_type=content_type, secret_attributes=secret_attributes)          # Construct URL         url = self.set_secret.metadata['url']         path_format_arguments = {             'vaultBaseUrl': self._serialize.url("vault_base_url", vault_base_url,'str', skip_quote=True),            'secret-name': self._serialize.url("secret_name", secret_name,'str', pattern=r'^[0-9a-zA-Z-]+$')         }         url = self._client.format_url(url, **path_format_arguments)          # Construct parameters         query_parameters = {}         query_parameters['api-version'] = self._serialize.query("self.api_version", self.api_version,'str')          # Construct headers         header_parameters = {}         header_parameters['Content-Type'] = 'application/json; charset=utf-8'         if self.config.generate_client_request_id:             header_parameters['x-ms-client-request-id'] = str(uuid.uuid1())         if custom_headers:             header_parameters.update(custom_headers)         if self.config.accept_language is not None:             header_parameters['accept-language'] = self._serialize.header("self.config.accept_language", self.config.accept_language,'str')          # Construct body         body_content = self._serialize.body(parameters, 'SecretSetParameters')          # Construct and send request         request = self._client.put(url, query_parameters)         response = self._client.send(             request, header_parameters, body_content, stream=False, **operation_config)          if response.status_code not in [200]:             raise models.KeyVaultErrorException(self._deserialize, response)          deserialized = None          if response.status_code == 200:             deserialized = self._deserialize('SecretBundle', response)          if raw:
Code: def set_certificate_issuer(             self, vault_base_url, issuer_name, provider, credentials=None, organization_details=None, attributes=None, custom_headers=None, raw=False, **operation_config):                  parameter = models.CertificateIssuerSetParameters(provider=provider, credentials=credentials, organization_details=organization_details, attributes=attributes)          # Construct URL         url = self.set_certificate_issuer.metadata['url']         path_format_arguments = {             'vaultBaseUrl': self._serialize.url("vault_base_url", vault_base_url,'str', skip_quote=True),             'issuer-name': self._serialize.url("issuer_name", issuer_name,'str')         }         url = self._client.format_url(url, **path_format_arguments)          # Construct parameters         query_parameters = {}         query_parameters['api-version'] = self._serialize.query("self.api_version", self.api_version,'str')          # Construct headers         header_parameters = {}         header_parameters['Content-Type'] = 'application/json; charset=utf-8'         if self.config.generate_client_request_id:             header_parameters['x-ms-client-request-id'] = str(uuid.uuid1())         if custom_headers:             header_parameters.update(custom_headers)         if self.config.accept_language is not None:             header_parameters['accept-language'] = self._serialize.header("self.config.accept_language", self.config.accept_language,'str')          # Construct body         body_content = self._serialize.body(parameter, 'CertificateIssuerSetParameters')          # Construct and send request         request = self._client.put(url, query_parameters)         response = self._client.send(             request, header_parameters, body_content, stream=False, **operation_config)          if response.status_code not in [200]:             raise models.KeyVaultErrorException(self._deserialize, response)          deserialized = None          if response.status_code == 200:             deserialized = self._deserialize('IssuerBundle', response)          if raw:             client_raw_response = ClientRawResponse(deserialized, response)
Code: def __init__(self, service_namespace, shared_access_key_name, shared_access_key_value, host_base, loop=None, **kwargs):         """         Initialize the ServiceContext          :param str service_namespace: The namespace of the Service to fetch         :param str shared_access_key_name: The name of the Shared Access Policy to use when authenticating         :param str shared_access_key_value: The value of the Shared Access Policy to use when authenticating         :param str host_base: The base host for the Service         :param loop: A loop to use for running the IOLoop in. If none is specified, a new event loop will be created.         :param kwargs: Any additional keyword arguments          :returns: twilio.rest.chat.v2.service.ServiceContext         :rtype: twilio.rest.chat.v2.service.ServiceContext         """         self._version = Version('v2')         self._solution = {            'service_namespace': service_namespace,            'shared_access_key_name': shared_access_key_name,            'shared_access_key_value': shared_access_key_value,             'host_base': host_base,         }         self._uri = '/Services/{service_namespace}/Users/{shared_access_key_name}/{shared_access_key_value}'.format(**self._solution)                  self._channel_list = None         self._channel_page = None         self._user_list = None         self._user_page = None         self._role_list = None         self._role_page = None         self._binding_list = None         self._binding_page = None         self._invite_list = None         self._invite_page = None         self._webhook_list = None         self._webhook_page = None         self._credential_list = None         self._credential_page = None         self._style_list = None         self._style_page = None         self._style_sheet_list = None         self._style_sheet_page = None         self._user_binding_list = None         self._user_binding_page = None         self._user_channel_invitation_list = None         self._user_channel_invitation_page = None         self._user_channel_
Code: def get_user(self, user_id):
Code: def list_subscriptions(self, topic_name):                  try:             subs = self.mgmt_client.list_subscriptions(topic_name)         except requests.exceptions.ConnectionError as e:             raise ServiceBusConnectionError("Namespace: {} not found".format(self.service_namespace), e)         except AzureServiceBusResourceNotFound:             raise ServiceBusResourceNotFound("Specificed topic does not exist.")         sub_clients = []         for sub in subs:             sub_clients.append(SubscriptionClient.from_entity(                 self._get_host(), topic_name, sub,                 shared_access
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         return '<Twilio.Chat
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code
:param twilio.rest.chat.v2.service.channel.channel_channel_sender.ChannelChannelSender session: The session to use for this sender.         :param kwargs: Additional keyword arguments to pass to the sender.          :returns: twilio.rest.chat.v2.service.channel.channel_channel_sender.ChannelChannelSender         :rtype: twilio.rest.chat.v2.service.channel.channel_channel_sender.ChannelChannelSender Code: def get_user(self, identity):         """         Constructs a UserContext          :param identity: The identity of the User resource to fetch          :returns: twilio.rest.chat.v2.service.channel.user.UserContext         :rtype: twilio.rest.chat.v2.service.
Code: def get_messages_by_index(self, index, limit=None,
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, service_sid, channel_sid, ):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def get_instance(self, payload):         """         Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v
Updates the request URI and query string with the query parameters.          request:             The HTTPRequest object to update
Returns the request body as a string.          body:             The body to convert to a string. Code: def _get_response
Get the status of an asynchronous operation.          :param str request_id: The request ID for the request you wish to track.          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance.OperationStatus         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance.OperationStatus Code: def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         context =''.join('{}={}'.format(k, v) for k, v in self._solution.items())         return '<Twilio.IpMessaging.V2.InviteInstance {}>'.format(context)
Retrieve a specific page of InviteInstance records from the API.         Request is executed immediately          :param Page page: Page of InviteInstance         :param dict kwargs: Additional request parameters          :returns: Page of InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def get_page_of_items_by_params(self, params,
Add additional headers for management.          :param request: The request to be updated         :param x_ms_version: The x_ms_version to be used          :
Code: def travis_build_package():           travis_tag = os.environ.get('TRAVIS_TAG')     if not travis_tag:         print("TRAVIS_TAG environment variable is not present")         return "TRAVIS_TAG environment variable is not present"      try:         name, version = travis_tag.split("_")     except ValueError:         print("TRAVIS_TAG is not '<package_name>_<version>' (tag is: {})".format(travis_tag))         return "TRAVIS
Code: def get_certificates(             self, vault_base_url, maxresults=None, include_pending=None, custom_headers=None, raw=False, **operation_config):                  def internal_paging(next_link=None, raw=False):              if not next_link:                 # Construct URL                 url = self.get_certificates.metadata['url']                 path_format_arguments = {                     'vaultBaseUrl': self._serialize.url("vault_base_url", vault_base_url,'str', skip_quote=True)                 }                 url = self._client.format_url(url, **path_format_arguments)                  # Construct parameters                 query_parameters = {}                 if maxresults is not None:                     query_parameters['maxresults'] = self._serialize.query("maxresults", maxresults, 'int', maximum=25, minimum=1)                 if include_pending is not None:                     query_parameters['includePending'] = self._serialize.query("include_pending", include_pending, 'bool')                 query_parameters['api-version'] = self._serialize.query("self.api_version", self.api_version,'str')              else:                 url = next_link                 query_parameters = {}              # Construct headers             header_parameters = {}             header_parameters['Content-Type'] = 'application/json; charset=utf-8'             if self.config.generate_client_request_id:                 header_parameters['x-ms-client-request-id'] = str(uuid.uuid1())             if custom_headers:                 header_parameters.update(custom_headers)             if self.config.accept_language is not None:                 header_parameters['accept-language'] = self._serialize.header("self.config.accept_language", self.config.accept_language,'str')              # Construct and send request             request = self._client.get(url, query_parameters)             response = self._client.send(                 request, header_parameters, stream=False, **operation_config)              if response.status_code not in [200]:                 raise models.KeyVaultErrorException(self._deserialize, response)              return response          # Deserialize response         deserialized = models.CertificateItemPaged(internal_paging, self._deserialize.dependencies)          if raw
Get list of available webhooks.          :returns: List of available webhooks         :rtype: list[twilio.rest.chat.v2.service.channel.invite.WebhookInstance] Code: def list_invites(self, limit=None, page_size=None):         '''         List InviteInstance records from the API as a list.         Unlike stream(), this operation is eager and will load `limit` records into         memory before returning.          :param int limit: Upper limit for the number of records to return. list() guarantees                           never to return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per
Remove a role from the service.          :param
Generate an absolute Twilio REST API path for this resource.          :param sid: The sid          :returns: str         :rtype: str Code: def get_path(self, sid):         """         Generate an absolute Twilio REST API path for this resource.          :param sid: The sid          :returns:
Create a new Notification.          :param unicode identity: The identity of the user to whom the Notification                                  should be sent.         :param unicode notification_level: The level of the Notification.         :param unicode topic: The topic of the Notification.         :param unicode endpoint: The endpoint of the Notification.         :param unicode binding_type: The type of the Notification's endpoint.         :param unicode binding_resource: The resource of the Notification's endpoint.         :param unicode body: The body of the Notification.         :param unicode attributes: The attributes of the Notification.          :returns: The created NotificationInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def create_user(self, identity, attributes=values.unset,                      role_sid=values.unset, friendly_name=values.unset,                      x
Delete a credential from the Service.
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, service_sid, channel_sid):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the new resource belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def create(self, identity, role_sid=values.unset,                type=values.unset, ttl=values.unset,                attributes=values.unset):         """         Create the InviteInstance          :param unicode identity: The `identity` value that identifies the new resource's User         :param unicode role_sid
Retrieves the rules in the service namespace.          name:             Name of the service bus namespace.         subscription_name:             Name of the subscription.          :returns: A list of RuleDescription objects         :rtype: list[~azure.servicebus.common.RuleDescription] Code: def list_queues(self, name):         '''         Retrieves the queues in the service namespace.          name:             Name of the service bus namespace.         '''         response = self._perform_get(             self._get_list_queues_path(name),             None)          return _MinidomXmlToObject.convert_response_to_feeds(             response,             partial(                 _MinidomXmlToObject.convert_xml_to_azure_object,                 azure_type=Queue
Retrieve a list of all Users for a Service Instance          :param service_sid: The service_sid          :returns: A list of User instances         :rtype: list[twilio.rest.chat.v2.service.user.UserInstance] Code: def list_webhooks(self, service_sid):         """         Retrieve a list of all Webhooks for a Service Instance          :param service_sid: The service
Retrieves the topics in the service namespace.          :returns: A list of TopicDescription objects         :rtype: list[~azure.servicebus.
This operation gets rollup data for Service Bus metrics namespace.         Rollup data
This operation gets rollup data for Service Bus metrics topic.         Rollup data includes the time granularity for the telemetry aggregation as well as         the retention settings for each time granularity.          name:             Name of the service bus namespace.         topic_name:             Name of the service bus queue in this namespace.         metric:             name of a supported metric         start_time:             Start time of the time range for which the data is to be fetched.         end_time:             End time of the time range for which the data is to be fetched. Code: def get_metrics_rollups_topic_data_by_instance(self, name, topic_name, metric, start_time, end_time, instance_id):         '''         This operation gets rollup data for Service Bus metrics topic.         Rollup data includes the time granularity for the telemetry aggregation as well as         the retention settings
This operation gets rollup data
This operation gets rollup data for Service Bus metrics topic.         Rollup data includes the time granularity for the telemetry aggregation as well as         the retention settings for
Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'created_by': payload.get('created_by'),             'created_by_identity': payload.get('created_by_identity'),             'role_sid': payload.get('role_sid'),             'date_created': deserialize.iso8601_datetime(payload.get('date_created')),             'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')),             'url': payload.get('url'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': payload.get('sid'),         }      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property     def service_sid(self):         """         :returns: The SID of the Service that the resource is associated with         :rtype: unicode         """         return self._properties['service_sid']      @property     def channel_sid(self):         """         :returns: The SID of the Channel the resource belongs to         :rtype: unicode         """         return self._properties['channel_sid']      @property     def created_by(self):         """         :returns: The identity of the User that created the resource         :rtype: unicode         """         return
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset, links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': sid,             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def date_created(self):         """         :returns: The ISO 8601 date and time in GMT when the resource was created         :rtype: datetime         """         return self._properties['date_created']      @property     def date_updated(self):         """         :returns: The ISO 8601
Create a new Azure SQL Database.          server_name:             The name of the server to create the database in.         database_name:             The name of the database to create.         edition:             The edition of the database to create.         service_objective:             The service objective of the database to create.         collation:             The collation of the database to create.         location:             The region to deploy the new database.          :returns: A CreateDatabaseResponse object         :rtype: twilio.rest.sql_management.v0.create_database_response.CreateDatabaseResponse         ''' Code: def create_
Reset the administrator password for a server.          server_name:             Name of the server to change the password.         admin_password:             The new administrator password for the server. Code: def set_server_admin_password(self, server_name, admin_password):         '''         Reset the administrator password for a server.          server_name:             Name of the server to change the password.         admin_password:             The new administrator password for the server.         '''         _validate_not_none('server_name', server_name)         _validate_not_none('admin
Lists all Users for a Service Instance          :param service_sid: The SID of the Service to read the Users
Gets the event logs for an Azure SQL Database Server.          server_name:             Name of the server to retrieve the event logs from.         start_date:             The starting date and time of the events to retrieve in UTC format,             for example '2011-09-28 16:05:00'.         interval_size_in_minutes:             Size of the event logs to retrieve (in minutes).             Valid values are: 5, 60, or 1440.         event_types:             The event type of the log entries you want to retrieve.             Valid values are:                  - connection_successful                 - connection_failed                 - connection_terminated                 - deadlock                 - throttling                 - throttling
Creates an Azure SQL Database server firewall rule.          server_name:             Name of the server to set the firewall rule on.          name:             The name of the new firewall rule.         start_ip_address:             The lowest IP address in the range of the server-level firewall             setting. IP addresses equal to or greater than this can attempt to             connect to the server. The lowest possible IP address is 0.0.0.0.         end_ip_address:             The highest IP address in the range of the server-level firewall             setting. IP addresses equal to or less than this can attempt to             connect to the server. The highest possible IP address is             255.255.255.255.         '''         _validate_not_none('server_name', server_name)         _validate_not_none('name', name)         _validate_not_none('start_ip_address', start_ip_address)         _validate_not_none('end_ip_address
Update a firewall rule for an Azure SQL Database server.          server_name:             Name of the server to set the firewall rule on.          name:             The name of the firewall rule to update.         start_ip_address:             The lowest IP address in the range of the server-level firewall             setting. IP addresses equal to or greater than this can attempt to             connect to the server. The lowest possible IP address is 0.0.0.0.         end_ip_address:             The highest IP address in the range of the server-level firewall             setting. IP addresses equal to or less than this can attempt to             connect to the server. The highest possible IP address is             255.255.255.255.         '''         _validate_not_none('server_name', server_name)         _validate_not_none('name', name)         _validate_not_none('start_ip_address', start_ip_address)         _validate_not
Deletes a Channel from the Service          :param unicode service_sid: The SID of the Service to delete the resource from         :param unicode sid: The SID of the Channel resource to delete          :returns: True if delete succeeds, False otherwise         :rtype: bool Code: def delete_role(self, service_sid, sid):         """         Deletes a Role from the Service          :param unicode service_sid: The SID of the Service to delete the resource from         :param unicode sid: The SID of the Role resource to delete          :returns: True if delete succeeds, False otherwise         :rtype: bool         """         data = values.of({'Sid': sid, })          payload = self._version.delete(             'DELETE',             self._uri,             data=data,         )          return payload['deleted'] Doc
Lists InviteInstance records from the API as a list.         Unlike stream(), this operation is eager and will load `limit` records into         memory before returning.          :param int limit: Upper limit for the number of records to return. list() guarantees                           never to return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, list() will attempt to read the limit                               with the most efficient page size, i.e. min(limit, 1000)          :returns: Generator that will yield up to limit results         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance] Code: def list_messages(self, order=values.unset, from_=values.unset,                         bounds=values.unset, index=values.unset,                         let=values.unset, order
Gets the usages for an Azure SQL Database server.          server_name:             Name of the server.          :returns: A list of
Gets a database from the Azure SQL Database.          server_name:             Name of the server containing the database.         name:             Name of the database to get. Code: def delete_database(self, server_name, name):         '''         Deletes a database from the Azure SQL Database.          server_name:             Name of the server containing the database.         name:             Name of the
Updates existing database user details.          server_name:             Name of the server to contain the new database.         name:             Required. The name for the new database. See Naming Requirements             in Azure SQL Database General Guidelines and Limitations and             Database Identifiers for more information.         user_name:             Required. The name for the new database user.         password:             Optional.
Deletes a database user role.          server_name:             Name of the server where the database is located.         name:             Name of the database to delete.         user_name:             Name of the database user to delete.         role_name:             Name of the database user role to delete. Code: def delete_database_user_role_assignment(self, server_name, name, user_name, role_name, assignment_name):         '''         Deletes a database user role assignment.          server_name:             Name of the server where the database is located.         name:             Name of the database to delete.         user_name:             Name of the database user to delete.         role_name:             Name of the database user role to delete.         assignment_name:             Name of the database user role assignment to delete.         '''         return self._perform_delete(self._get_database
Lists InviteInstance records from the API as a list.         Unlike stream(), this operation is eager and will load `limit` records into         memory before returning.          :param int limit: Upper limit for the number of records to return. list() guarantees                           never to return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, list() will attempt to read the limit                               with the most efficient page size, i.e. min(limit, 1000)          :returns: Generator that will yield up to limit results         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance] Code: def list_roles(self, limit=None, page_size=None):         """         Lists RoleInstance records from the API as a list.         Unlike stream(), this operation is eager and will load `limit`
Code: def list_invites(             self,             limit=None,             page_size=None,             page_token=None,             channel_sid=values.unset,             identity=values.unset,             role_sid=values.unset,             date_created_after=values.unset,             date_created_before=values.unset,             date_updated_after=values.unset,             date_updated_before=values.unset,             order_by=values.unset,             alpha_sender=values.unset,             beta_sender=values.unset,             include_archived=values.unset,             custom_headers=None,             raw=False,             **operation_config):                  """         Retrieve a list of all Invites belonging to the Channel specified by the         `channel_sid` parameter.                  :param int limit: Upper limit for the number of records to return. list()                           guarantees never to return more than limit.  Default is no                           limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, list() will attempt to read the limit                               with the most efficient page size, i.e. min(limit, 1000)                  :param str page_token: PageToken provided by the API                  :param str channel_sid: The SID of the Channel the resource to fetch belongs to                  :param str identity: The `identity` value that identifies the new resource's                               parent                  :param str role_sid: The SID of the Role assigned to the new resource                  :param datetime date_created_after: The `date_created` value of the resources to                                             return                  :param datetime date_created_before: The `date_created` value of the resources to                                              return                  :param datetime date_updated_after: The `date_updated` value of the resources to                                             return                  :param datetime date_updated_before: The `date_updated` value of the resources to                                              return                  :param str order_by: The order in which to list the resources                  :param bool alpha_sender: The `alpha_sender` value of the resources to return                  :param bool beta_sender: The `beta_sender` value of the resources to return                  :param bool
Receive a packet from the Service Bus.          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: async def _send_loop(self):         """         Send packets to the Service Bus.          :returns: None         :rtype: None         """         while self.running:
Receive messages from the websocket.          :returns: Message instance         :rtype: twilio.rest.chat.v2.service.channel.message.MessageInstance Code: async def _send_packet(self, packet):         """         Send a packet to the websocket.          :param packet: Packet to send         :type packet: twilio.rest.chat.v2.service.channel.invite.packet.Packet          :returns: True if the packet was sent, False otherwise         :rtype: bool         """         if self.ws.open:             try:                 await self.ws.send(packet.to_json())                 return True             except websockets.exceptions.ConnectionClosed:                 self.logger.info('Connection closed')                 self.queue.put(
Code: async def get_session_state(self):                  await self._can_run()         response = await self._mgmt_request_response
Code: async def set_session_state(self, state):                  await self._can_run()         state = state.encode(self.encoding) if isinstance(state, six.text_type) else state         return await self._mgmt_request_response(             REQUEST_RESPONSE_SET_SESSION_STATE_OPERATION,             {'session-id': self.session_id,'session-state':
Code: async def receive_deferred_messages(self, sequence_numbers, mode=ReceiveSettleMode.PeekLock):                  if not sequence_numbers:             raise ValueError("At least
Merge a reservation order into a new reservation.          :param reservation_order_id: The reservation order ID is the identifier          for a reservation order. The reservation order ID is created by the          reservation service when an order is created. The reservation order          specifies the VM size and region for the new reservation.         :type reservation_order_id: str         :param sources: The list of resource IDs that need to be reserved.         :type sources: list[str]         :param dict custom_headers: headers that will be added to the request         :param bool raw: returns the direct response alongside the          deserialized response         :param polling: True for ARMPolling, False for no polling, or a          polling object for personal polling strategy         :return: An instance of LROPoller that returns          list[~azure.mgmt.reservations.models.ReservationResponse] or          ClientRawResponse if raw=true         :rtype:          ~msrestazure.azure_operation.AzureOperationPoller[          list[~azure.mgmt.reservations.models.ReservationResponse]] or          ~msrest.pipeline.ClientRawResponse         :raises:          :class:`ErrorResponseException<azure.mgmt.reservations.models.ErrorResponseException>`         """ Code: def list_by_reservation_order(             self, reservation_order_id, custom_headers=None, raw=False, **operation_config):         """List of reservations that are associated with the reservation order.          :param reservation_order_id: The reservation order ID is the          identifier for a reservation order. The reservation order ID is          created by the reservation service when an order is created.         :type reservation_order_id: str         :param dict custom_headers: headers that will be added to the request         :param bool raw: returns the direct response alongside the          deserialized response         :param operation_config: :ref:`Operation configuration          overrides<msrest:optionsforoperations>`.         :return: An iterator like instance of ReservationResponse         :rtype:          ~azure.mgmt.reservations.models.ReservationResponsePaged[~azure.mgmt.reservations.models.ReservationResponse]         :raises:          :class:`ErrorResponseException<azure.mgmt.reservations.models.ErrorResponseException>`         """         def internal_paging(next_link=None, raw=False):              if not next_link:                 # Construct URL
Retrieve a specific page of InviteInstance records from the API.         Request is executed immediately          :param str target_url: API-generated URL for the requested results page          :returns: Page
Code: def _purge_initial(             self, resource_group_name, workspace_name, table, filters, custom_headers=None, raw=False, **operation_config):                  # Construct URL         url = self.purge.metadata['url']         path_format_arguments = {            'subscriptionId': self._serialize.url("self.config.subscription_id", self.config.subscription_id,'str'),            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name,'str'),             'workspaceName': self._serialize.url("workspace_name", workspace_name,'str'),             'table': self._serialize.url("table", table,'str')         }         url = self._client.format_url(url, **path_format_arguments)          # Construct parameters         query_parameters = {}         query_parameters['api-version'] = self._serialize.query("self.api_version", self.api_version,'str')          # Construct headers         header_parameters = {}         header_parameters['Content-Type'] = 'application/json; charset=utf-8'         if self.config.generate_client_request_id:             header_parameters['x-ms-client-request-id'] = str(uuid.uuid1())         if custom_headers:             header_parameters.update(custom_headers)         if self.config.accept_language is not None:             header_parameters['accept-language'] = self._serialize.header("self.config.accept_language", self.config.accept_language,'str')          # Construct body         body_content = self._serialize.body(filters, 'object')          # Construct and send request         request = self._client.post(url, query_parameters, header_parameters, body_content)         response = self._client.send(request, stream=False, **operation_config)          if response.status_code not in [200, 202]:             raise models.ErrorResponseException(self._deserialize, response)          deserialized = None          if response.status_code == 200:             deserialized = self._deserialize('object', response)          if raw:             client_raw_response = ClientRawResponse(deserialized, response)             return client_raw_response          return deserialized
Constructs a InviteContext          :param sid: A 34 character string that uniquely identifies this resource.          :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext Code: def __unicode__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         return unicode(
Gets a queue.          queue_name:             Name of the queue to get. Code: def get_queues(self):         '''         Gets all queues.         '''         request = HTTPRequest()         request.method = 'GET'         request.host = self._get_host()         request.path = '/' + ''         request.path, request.query = self._httpclient._update_request_uri_query(request)  # pylint: disable=protected-access         request.headers
Get the host for the service bus namespace with SAS token and path.          :param str path: The path to append to the host.          :returns: The host for the service bus namespace with SAS token and path.         :rtype: str Code: def _get_host_with_sas_and_query(self, query):         """         Get the host for the service bus namespace with SAS token and query.          :param str query: The query to append to the host.          :returns: The host for the service bus namespace with SAS token and query.         :rtype: str         """         return self._httpclient.get_host_with_sas_and_query(self._namespace_name, query)
Retrieves a list of queues.          limit:             Upper limit for the number of records to return.             list() guarantees never to return more than limit.             Default is no limit         page_size:             Number of records to fetch per request, when not set will use             the default value of 50 records.             If no page_size is defined but a limit is defined, list() will attempt             to read the limit with the most efficient page size, i.e. min(limit, 1000)          Returns:             Generator that will yield up to limit results         '''         return self.iter_queues(limit=limit, page_size=page_size) Code: def get_service(self, sid):         """         Constructs a ServiceContext          :param sid: The SID that identifies the resource to fetch          :returns: twilio.rest.chat.v2.service.Service
Gets a topic.          topic_name:             Name of the topic to get. Code: def list_topics(self, limit=None, page_size=None):         '''         Lists all topics.          limit:             Upper limit for the number of records to return. list() guarantees             never to return more than limit.  Default is no limit         page_size:             Number of records to fetch per request, when not set will use             the default value of 50 records.  If no page
Retrieve a list of all Users.          :returns: List of UserInstance         :rtype: list[twilio.rest.chat.v2.service.channel.user.UserInstance] Code: def iter_users(self, limit=None, page_size=None):         """         Lists UserInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until the limit         is reached.         The results are returned as a generator, so this operation is memory efficient.          :param int limit: Upper limit for the number of records to return. stream()                           guarantees to never return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, stream() will attempt
Deletes a rule.          topic_name:             Name of the topic.         subscription_name:             Name of the subscription.         rule_name:             Name of the rule. Code: def get_rule(self, topic_name, subscription_name, rule_name):         '''         Gets a rule.          topic_name:             Name of the topic.         subscription_name:             Name of the subscription.         rule_name:             Name of the rule.         '''         _validate_not_none('topic_name', topic_name)         _validate_not_none('subscription_name', subscription_name)         _validate_not_none('rule_name', rule_name)         request = HTTPRequest()         request.method = 'GET'         request.host = self._get_host()         request.path = '/' + _str(topic_name) + '/subscriptions/' + \             _str(
Retrieves the description for the specified rule.          topic_name:             Name of the topic.         subscription_name:             Name of the subscription.         rule_name
Retrieves the subscriptions that exist under the specified topic.          topic_name:             Name of the topic.         '''         _validate_not_none('topic_name', topic_name)         request = HTTPRequest()         request.method = 'GET'         request.host = self._get_host()         request.path = '/' + _str(topic_name) + '/subscriptions/'         request.path, request.query = self._httpclient._update_request_uri
Gets a subscription.          topic_name:             Name of the topic.
Gets an existing subscription.          topic_name:             Name of the topic.         subscription_name:             Name of the subscription.         '''         _validate_not_none('topic_name', topic_name)         _validate_not_none('subscription_name', subscription_name)         request = HTTPRequest()         request.method = 'GET'         request.host = self._get_host()         request.path = '/' + \             _str(topic_name) + '/subscriptions/' + _str(subscription_name) + ''         request.path, request
Retrieves the subscriptions in the specified topic.          topic_name:             Name of the topic.          :returns: A list of SubscriptionInstance objects         :rtype: list[twilio.rest.chat.v2.service.channel.subscription.SubscriptionInstance] Code: def list_messages(self, order='asc', from_=None, to=None, limit=None,                        before=None, after=None, attributes=None,                        include_archived=None, order_by='last_updated_at',                        page_size=None):         """         Lists all Messages in the Channel.          :param str order: The order to sort by. Can be: `asc` or `desc` and the default is `asc`.         :param datetime from_: Only include messages sent on or after this date.         :param datetime to: Only include messages sent on or before this date.         :param int limit: Upper limit for the number of records to return. list() guarantees                           never to return more than limit.  Default is no limit         :param datetime before: Only include messages with `index` < `before`         :param datetime after: Only include messages with `index` > `after`         :param str attributes: Only include messages that have the given attributes.         :param bool include_archived: Whether to include messages from the Archived Channel.         :param str order_by: The attribute by which to order the Messages. Can be: `last_updated_at`, `index`, or `first_created_at`.         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records. If no page_size is defined                               but a limit is defined, list() will attempt to read the limit                               with the most efficient page size, i.e. min(limit, 1000)          :returns: A list of MessageInstance objects         :rtype: list[twilio.rest.chat.v2.service.channel.message.MessageInstance]         """         params = values.of({             'Order': order,             'From': serialize.iso8601_datetime(from_),             'To': serialize.iso8601_datetime(to),             'Limit': limit,             'Before': serialize.iso8601_datetime(before),             'After': serialize.
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __unicode__(self):         """         Provide a friendly representation
Unlock a message for processing by other receivers on a given         subscription. This operation deletes the lock object, causing the         message to be unlocked. A message must have first been locked by a         receiver before this operation is called.          topic_name:             Name of the topic.         subscription_name:             Name of the subscription.         sequence_number:             The sequence number of the message to be unlocked as returned in             BrokerProperties['SequenceNumber'] by the Peek Message operation.         lock_token:             The ID of the lock as returned by the Peek Message operation in             BrokerProperties['LockToken'] Code: def update(self, attributes=values.unset, date_created=values.unset,                 date_updated=values.unset, byoc_trust_chain=values.unset,                 byoc_trust_chain_url=values.unset,                 byoc_trust_chain_expiration=values.unset,                 byoc_trust_chain_expiration_url=values.unset,                 byoc_trust_chain_expiration_date=values.unset,                 byoc_trust_chain_expiration_date_url=values.unset,                 byoc_trust_chain_expiration_reason=values.unset,                 byoc_trust_chain_expiration_reason_url=values.unset,                 byoc_trust_chain_expiration_reason_date=values.unset,                 byoc_trust_chain_expiration_reason_date_url=values.unset,                 byoc_trust_chain_expiration_reason_details=values.unset,                 byoc_trust_chain_expiration_reason_details_url=values.unset,                 byoc_trust_chain_expiration_reason_details_date=values.unset,                 byoc_trust_chain_expiration_reason_details_date_url=values.unset,                 byoc_trust_chain_expiration_reason_details_details=values.unset,                 byoc_trust_chain_expiration_reason_details_details_url=values.unset,                 byoc_trust_chain_expiration_reason_details_details_date=values.unset,                 byoc_trust_chain_expiration_reason_details_details_date_url=values.unset,                 byoc_trust_chain_expiration_reason_details_details_details=values.unset,
Sends a batch of messages into the specified queue. The limit to the number of         messages which may be present in the topic is governed by the message         size the MaxTopicSizeInMegaBytes. If this message will cause the queue         to exceed its quota, a quota exceeded error is returned and the         message will be rejected.          queue_name:             Name of the queue.         messages:             List of message objects containing message body and properties. Code: def send_queue_message_batch(self, queue_name, messages
Unlocks a message for processing by other receivers on a given         queue. This operation deletes the lock object, causing the         message to be unlocked. A message must have first been locked by a         receiver before this operation is called.          queue_name:             Name of the queue.         sequence_number:             The sequence number of the message to be unlocked as returned in             BrokerProperties['SequenceNumber'] by the Peek Message operation.         lock_token:             The ID of the lock as returned by the Peek Message operation in             BrokerProperties['LockToken'] Code: def update(self, role_sid=values.unset, attributes=values.unset,                friendly_name=values.unset, date_created=values.unset,                date_updated=values.unset, created_by=values.unset,                url=values.unset):         """         Update the InviteInstance          :param unicode role_sid: The SID of the Role assigned to this invite         :param unicode attributes: A valid JSON string that contains application-specific data         :param unicode friendly_name: A string to describe the resource         :param datetime date_created: The ISO 8601 date and time in GMT when the resource was created         :param datetime date_updated: The ISO 8601 date and time in GMT when the resource was last updated         :param unicode created_by: The identity of the User that created this invite         :param unicode url: The absolute URL of the resource          :returns: Updated InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         data = values.of({             'RoleSid': role_sid,             'Attributes': attributes,             'FriendlyName': friendly_name,             'DateCreated': serialize.iso8601_datetime(date_created),             'DateUpdated': serialize.iso8601_datetime(date_updated),             'CreatedBy': created_by,             'Url': url,         })          payload = self._version.update(             'POST',             self._uri,             data=data,         )          return InviteInstance(             self._version,             payload,             service_sid=self._solution['service_sid'],             channel_sid=self._solution['channel_sid'],             sid=self._solution['sid'],         ) Doc
Send a message to a queue.          queue_name:             Name of the queue.         message:             Message to send.         visibility_timeout:             Optional. The visibility timeout parameter
Read and delete a message from a subscription.          topic_name:             Name of the topic.         subscription_name:             Name of the subscription.         timeout:             Optional. The timeout parameter is expressed in seconds. Code: def read_delete_subscription_message_with_retry_with_backoff(self,                                                                  topic_name,                                                                  subscription_name,                                                                  timeout=60):         '''         Read and delete a message from a subscription.          topic_name:             Name of the topic.         subscription_name:             Name of the subscription.         timeout:             Optional. The timeout parameter is expressed in seconds.         '''         return self.read_delete_subscription_message_with_retry_with_backoff_with_backoff(             topic_name,
Gets an Event Hub.          hub_name:             Name of event hub.
Updates the Notification Level for a Channel.          notification_level:             Notification Level for a Channel.         notification:             Optional. Notification properties. Instance of Notification class.         notification.log_enabled:             Whether to log notifications.         notification.log_level:             Log level.         notification.webhook_enabled:             Whether to send a webhook event for each notification.         notification.webhook_url:             The URL of the target webhook. Code: def update_role(self, role_sid, role=None):         '''         Updates a Role.          role_sid:             A 34 character string that uniquely identifies this resource.         role:             Optional. Role properties. Instance of Role class.         role.type:             The type of role.         role.permissions:             The permissions
Retrieves an existing notification.          sid:             A 34 character string that uniquely identifies this resource.         '''         _validate_not_none('sid', sid)         request = HTTPRequest
Makes a request and returns a list of results, if any. Code: def _deserialize(self, payload, content_type):         '''         Deserializes a payload.         '''
Add additional headers for Service Bus.          :param request: The request to be signed.          :returns: The request with the authorization header added.         :rtype: requests.Request Code: def _update_service_bus_header(self, request):         ''' Add additional headers for Service Bus. '''          if
return the token expires at as rfc2822.          :returns: The token expires at as rfc2822.         :rtype: unicode         '''         return self._token_expires_at.strftime('%a, %d %b %Y %H:%M:%S GMT') Code: def _get_token_expires_at_as_rfc822(self):         ''' return
Check if token is valid for channel or not.          :param str token: Token to check         :param str channel_sid: Channel SID to check          :returns: True if token is valid for channel, False otherwise         :rtype: bool Code: def _token_is_valid_for_service(self, token, service_sid):  # pylint: disable=no-self-use         ''' Check if token is valid for service or not. '''         time_pos_begin = token.find('ServiceSid=') + len('ServiceSid=')         time_pos_end = token.find('&', time_pos_begin)         token_service_sid = token[time_pos_begin:time_pos_end]          return token_service_sid == service_
Handle an error from the server.          :param packet: Packet to handle         :type packet: Packet Code: def _handle_close(self, packet):         """         Handle a close from the server.          :param packet: Packet to handle         :type packet: Packet         """         self.logger.info('Closed: %s', packet)         self.on_close(packet)
pulls the query string out of the URI and moves it into         the query portion of the request object.  If there are already         query parameters on the request the parameters in the URI will         appear after the existing parameters Code: def _update_request_uri_query(self, request):         '''pulls the query string out of the URI and moves it into         the query portion of the request object.  If there are already         query parameters on the request the parameters in the URI will         appear after the existing parameters'''          if '?' in request.path:             request.path, _, query_string = request.path.partition('?')             if query_string:                 query_params = query_string.split('&')                 for query in query_params:                     if '=' in query:                         name, _, value = query.partition('=')                         request.query.append((name, value))          request.path = url_quote(request.path, '/()$=\',')          # add encoded queries to request
Code: def _reset_service_principal_profile_initial(             self, resource_group_name, resource_name, client_id, secret=None, custom_headers=None, raw=False, **operation_config):                  # Construct URL         url = '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{resourceName}/config/web/publishingcredentials/reset'         path_format_arguments = {            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name,'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+[^\.]$'),            'resourceName': self._serialize.url("resource_name", resource_name,'str'),            'subscriptionId': self._serialize.url("self.config.subscription_id", self.config.subscription_id,'str')         }         url = self._client.format_url(url, **path_format_arguments)          # Construct parameters         query_parameters = {}         query_parameters['api-version'] = self._serialize.query("self.api_version", self.api_version,'str')          # Construct headers         header_parameters = {}         header_parameters['Content-Type'] = 'application/json; charset=utf-8'         if self.config.generate_client_request_id:             header_parameters['x-ms-client-request-id'] = str(uuid.uuid1())         if custom_headers:             header_parameters.update(custom_headers)         if self.config.accept_language is not None:             header_parameters['accept-language'] = self._serialize.header("self.config.accept_language", self.config.accept_language,'str')          # Construct body         body_content = self._serialize.body(client_id,'str')          # Construct and send request         request = self._client.post(url, query_parameters)         response = self._client.send(             request, header_parameters, body_content, stream=False, **operation_config)          if response.status_code not in [200, 202]:             exp = CloudError(response)             exp.request_id = response.headers.get('x-ms-request
Returns true if both instances are not equal          :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def __init__(self, version, payload, service_sid, channel_
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'identity': payload.get('identity'),             'role_sid': payload.get('role_sid'),             'date_created': deserialize.iso8601_datetime(payload.get('date_created')),             'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')),             'url': payload.get('url'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': payload.get('sid'),         }      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'identity': payload.get('identity'),             'role_sid': payload.get('role_sid'),             'date_created': deserialize.iso8601_datetime(payload.get('date_created')),             'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')),             'url': payload.get('url'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': payload.get('sid'),         }      @property     def sid(self):         """         :returns:
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'identity': payload.get('identity'),             'role_sid': payload.get('role_sid'),             'date_created': deserialize.iso8601_datetime(payload.get('date_created')),             'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')),             'url': payload.get('url'),         }          # Context         self._context = None         self._solution
Returns true if both instances are equal          :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def __ne__(self, other):         """         Returns true if both instances are not equal          :param other: twilio.rest.chat.v2.service.channel.
Code: def get_cluster_health(             self, nodes_health_state_filter=0, applications_health_state_filter=0, events_health_state_filter=0, exclude_health_statistics=False, include_system_application_health_statistics=False, timeout=60, custom_headers=None, raw=False, **operation_config):                  api_version = "6.0"          # Construct URL         url = self.get_cluster_health.metadata['url']          # Construct parameters         query_parameters = {}         query_parameters['api-version'] = self._serialize.query("api_version", api_version,'str')         if nodes_health_state_filter is not None:             query_parameters['NodesHealthStateFilter'] = self._serialize.query("nodes_health_state_filter", nodes_health_state_filter, 'int')         if applications_health_state_filter is not None:             query_parameters['ApplicationsHealthStateFilter'] = self._serialize.query("applications_health_state_filter", applications_health_state_filter, 'int')         if events_health_state_filter is not None:             query_parameters['EventsHealthStateFilter'] = self._serialize.query("events_health_state_filter", events_health_state_filter, 'int')         if exclude_health_statistics is not None:             query_parameters['ExcludeHealthStatistics'] = self._serialize.query("exclude_health_statistics", exclude_health_statistics, 'bool')         if include_system_application_health_statistics is not None:             query_parameters['IncludeSystemApplicationHealthStatistics'] = self._serialize.query("include_system_application_health_statistics", include_system_application_health_statistics, 'bool')         if timeout is not None:             query_parameters['timeout'] = self._serialize.query("timeout", timeout, 'long', maximum=4294967295, minimum=1)          # Construct headers         header_parameters = {}         header_parameters['Accept'] = 'application/json'         if custom_headers:             header_parameters.update(custom_headers)          # Construct and send request         request = self._client.get(url, query_parameters, header_parameters)         response = self._client.send
Code: def get_cluster_health_using_policy(             self, nodes_health_state_filter=0, applications_health_state_filter=0, events_health_state_filter=0, exclude_health_statistics=False, include_system_application_health_statistics=False, timeout=60, application_health_policy_map=None, cluster_health_policy=None, custom_headers=None, raw=False, **operation_config):                  cluster_health_policies = None         if application_health_policy_map is not None or cluster_health_policy is not None:             cluster_health_policies = models.ClusterHealthPolicies(application_health_policy_map=application_health_policy_map, cluster_health_policy=cluster_health_policy)          api_version = "6.0"          # Construct URL         url = self.get_cluster_health_using_policy.metadata['url']          # Construct parameters         query_parameters = {}         query_parameters['api-version'] = self._serialize.query("api_version", api_version,'str')         if nodes_health_state_filter is not None:             query_parameters['NodesHealthStateFilter'] = self._serialize.query("nodes_health_state_filter", nodes_health_state_filter, 'int')         if applications_health_state_filter is not None:             query_parameters['ApplicationsHealthStateFilter'] = self._serialize.query("applications_health_state_filter", applications_health_state_filter, 'int')         if events_health_state_filter is not None:             query_parameters['EventsHealthStateFilter'] = self._serialize.query("events_health_state_filter", events_health_state_filter, 'int')         if exclude_health_statistics is not None:             query_parameters['ExcludeHealthStatistics'] = self._serialize.query("exclude_health_statistics", exclude_health_statistics, 'bool')         if include_system_application_health_statistics is not None:             query_parameters['IncludeSystemApplicationHealthStatistics'] = self._serialize.query("include_system_application_health_statistics", include_system_application_health_statistics, 'bool')         if timeout is not None:             query_parameters['timeout'] = self._serialize.query("
Code: def update_message(self, sid, index, attributes=values.unset, custom_headers=None, raw=False,
Code: def get_repair_task_list(             self, task_id_filter=None, state_filter=None, executor_filter=None, custom_headers=None, raw=False, **operation_config):                  api_version = "6.0"          # Construct URL         url = self.get_repair_task_list.metadata['url']          # Construct parameters         query_parameters = {}         query_parameters['api-version'] = self._serialize.query("
Code: def __init__(self, client, config, serializer, deserializer):         super(InvitePaged, self).__init__(client, config)         self._client = client         self._serialize = serializer         self._deserialize = deserializer         self._config = config      @classmethod     def _get_next(cls, next_link=None):         # Construct URL         url = next_link         # Construct parameters         query_parameters = {}          # Construct headers         header_parameters = {}         header_parameters['Content-Type'] = 'application/json; charset=utf-8'         if cls.config.generate_client_request_id:             header_parameters['x-ms-client-request-id'] = str(uuid.uuid1())         if custom_
Build an instance of Invite
:param str resource_group_name: Name of the resource group.         :param str name: Name of the app.         :param int duration_in_seconds: The duration to keep capturing in          seconds.         :param int max_frame_length: The maximum frame length in bytes (Optional).         :param str sas_url: The Blob URL to store capture file.         :param dict custom_headers: headers that will be added to the request         :param bool raw: returns the direct response alongside the          deserialized response         :param polling: True for ARMPolling, False for no polling, or a          polling object for personal polling strategy         :return: An instance of LROPoller that returns list of          NetworkTrace or ClientRawResponse if raw=true         :rtype:          ~msrestazure.azure_operation.AzureOperationPoller[list[~azure.mgmt.web.v2016_03_01.models.NetworkTrace]]          or ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse]         :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`         """ Code: def update_member(self, identity, role_sid, custom_headers=None, raw=False, **operation_config):         """Update the role of a user on a channel.          :param identity: The identity of the resource.         :type identity: str         :param role_sid: The SID of the role to grant to the user.         :type role_sid: str         :param dict custom_headers: headers that will be added to the request         :param bool raw: returns the direct response alongside the          deserialized response         :param operation_config: :ref:`Operation configuration          overrides<msrest:optionsforoperations>`.         :return: None or ClientRawResponse if raw=true         :rtype: None or ~msrest.pipeline.ClientRawResponse         :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`         """         # Construct URL         url = self.update_member.metadata['url']         path_format_arguments = {             'Endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint,'str', skip_quote=True),             'identity': self._serialize.
Code: def list_slot_differences_slot(             self, resource_group_name, name, slot, target_slot, preserve_vnet, custom_headers=None, raw=False, **operation_config):                  slot_swap_entity = models.CsmSlotEntity(target_slot=target_slot, preserve_vnet=preserve_vnet)          def internal_paging(next_link=None, raw=False):              if not next_link:                 # Construct URL                 url = self.list_slot_differences_slot.metadata['url']                 path_format_arguments = {                    'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name,'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+[^\.]$'),                     'name': self._serialize.url("name", name,'str'),                    'slot': self._serialize.url("slot", slot,'str'),                    'subscriptionId': self._serialize.url("self.config.subscription_id", self.config.subscription_id,'str')                 }                 url = self._client.format_url(url, **path_format_arguments)                  # Construct parameters                 query_parameters = {}                 query_parameters['api-version'] = self._serialize.query("self.api_version", self.api_version,'str')              else:                 url = next_link                 query_parameters = {}              # Construct headers             header_parameters = {}             header_parameters['Accept'] = 'application/json'             header_parameters['Content-Type'] = 'application/json; charset=utf-8'             if self.config.generate_client_request_id:                 header_parameters['x-ms-client-request-id'] = str(uuid.uuid1())             if custom_headers:                 header_parameters.update(custom_headers)             if self.config.accept_language is not None:                 header_parameters['accept-language'] = self._serialize.header("self.config.accept_language", self.config.accept_language,'str')              # Construct body             body_content = self._serialize.body(slot_swap_entity, 'CsmSlotEntity')              # Construct and send request             request = self._
Code: def _swap_slot_slot_initial(             self, resource_group_name, name, slot, target_slot, preserve_vnet, custom_headers=None, raw=False, **operation_config):                  # Construct URL         url = '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/slotsswap'         path_format_arguments = {            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name,'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+[^\.]$'),             'name': self._serialize.url("name", name,'str'),            'slot': self._serialize.url("slot", slot,'str'),             'targetSlot': self._serialize.url("target_slot", target_slot,'str'),            'subscriptionId': self._serialize.url("self.config.subscription_id", self.config.subscription_id,'str')         }         url = self._client.format_url(url, **path_format_arguments)          # Construct parameters         query_parameters = {}         query_parameters['api-version'] = self._serialize.query("self.api_version", self.api_version,'str')         if preserve_vnet is not None:             query_parameters['preserveVnet'] = self._serialize.query("preserve_vnet", preserve_vnet, 'bool')          # Construct headers         header_parameters = {}         header_parameters['Content-Type'] = 'application/json; charset=utf-8'         if self.config.generate_client_request_id:             header_parameters['x-ms-client-request-id'] = str(uuid.uuid1())         if custom_headers:             header_parameters.update(custom_headers)         if self.config.accept_language is not None:             header_parameters['accept-language'] = self._serialize.header("self.config.accept_language", self.config.accept_language,'str')          # Construct and send request         request = self._client.post(url, query_parameters)         response = self._client.send(request, header_parameters, **operation_config)          if response.status_code not
Code: def get_by_type(             self, app_id, event_type, timespan=None, filter=None, search=None, orderby=None, select=None, skip=None, top=None, format=None, count=None, apply=None, custom_headers=None, raw=False, **operation_config):                  # Construct URL         url = self.get_by_type.metadata['url']         path_format_arguments = {             'appId': self._serialize.url("app_id", app_id,'str'),             'eventType': self._serialize.url("event_type", event_type,'str')         }         url = self._client.format_url(url, **path_format_arguments)          # Construct parameters         query_parameters = {}         if timespan is not None:             query_parameters['timespan'] = self._serialize.query("timespan", timespan,'str')         if filter is not None:             query_parameters['$filter'] = self._serialize.query("filter", filter,'str')         if search is not None:             query_parameters['$search'] = self._serialize.query("search", search,'str')         if orderby is not None:             query_parameters['$orderby'] = self._serialize.query("orderby", orderby,'str')         if select is not None:             query_parameters['$select'] = self._serialize.query("select", select,'str')         if skip is not None:             query_parameters['$skip'] = self._serialize.query("skip", skip, 'int')         if top is not None:             query_parameters['$top'] = self._serialize.query("top", top, 'int')         if format is not None:             query_parameters['$format'] = self._serialize.query("format", format,'str')         if count is not None:             query_parameters['$count'] = self._serialize.query("count", count, 'bool')         if apply is not None:             query_parameters['$apply'] = self._serialize.query("apply", apply,'str')          # Construct headers         header_parameters = {}         header_parameters['Accept'] = 'application/json'         if custom_headers:             header_parameters.update(custom_
Code: def add_face
Code: def _handle_redirect
:param str resource_group_name: Name of the resource group within the          Azure subscription.         :param str namespace_name: The Namespace name         :param str target_namespace: The Namespace name         :param str post_migration_name: The Post Migration name         :param dict custom_headers: headers that will be added to the request         :param bool raw: returns the direct response alongside the          deserialized response         :param polling: True for ARMPolling, False for no polling, or a          polling object for personal polling strategy         :return: An instance of LROPoller that returns          MigrationConfigProperties or ClientRawResponse if raw=true         :rtype:          ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.eventhub.v2017_04_01.models.MigrationConfigProperties]          or ~msrest.pipeline.ClientRawResponse         :raises:          :class:`ErrorResponseException<azure.mgmt.eventhub.v2017_04_01.models.ErrorResponseException>`         """ Code: def create_and_start_migration(             self, resource_group_name, namespace_name, target_namespace, post_migration_name, custom_headers=None, raw=False, polling=True, **operation_config):                  raw_result = self._create_and_start_migration_initial(             resource_group_name=resource_group_name,             namespace_name=namespace_name,             target_namespace=target_namespace,             post_migration_name=post_migration_name,             custom_headers=custom_headers,             raw=True,             **operation_config         )          def get_long_running_output(response):             deserialized = self._deserialize('MigrationConfigProperties', response)              if raw:                 client_raw_response = ClientRawResponse(deserialized, response)                 return client_raw_response              return deserialized          lro_delay = operation_config.get(             'long_running_operation_timeout',             self.config.long_running_operation_timeout)         if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)         elif polling is False: polling_method = NoPolling()         else: polling_method = polling         return LROPoller(self._client
Lists Invite resources from the Channel          :param str service_sid: The SID of the Service to read the resources from         :param str channel_sid: The SID of the Channel the resource to read         :param int limit: Upper limit for the number of records to return. list() guarantees                           never to return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, list() will attempt to read the limit                               with the most efficient page size, i.e. min(limit, 1000)          :returns: Generator that will yield up to limit results         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance] Code: def stream(             self, service_sid, channel_sid, limit=None, page_size=None):         """         Streams InviteInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until
Code: def _move_resources_initial(             self, source_resource_group_name, resources=None, target_resource_group=None, custom_headers=None, raw=False, **operation_config):                  # Construct URL         url = '/subscriptions/{subscriptionId}/resourceGroups/{sourceResourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/moveResources'         path_format_arguments = {            'sourceResourceGroupName': self._serialize.url("source_resource_group_name", source_resource_group_name,'str'),             'deploymentName': self._serialize.url("self.config.deployment_name", self.config.deployment_name,'str'),            'subscriptionId': self._serialize.url("self.config.subscription_id", self.config.subscription_id,'str')         }         url = self._client.format_url(url, **path_format_arguments)          # Construct parameters         query_parameters = {}         query_parameters['api-version'] = self._serialize.query("self.api_version", self.api_version,'str')          # Construct headers         header_parameters = {}         header_parameters['Content-Type'] = 'application/json; charset=utf-8'         if self.config.generate_client_request_id:             header_parameters['x-ms-client-request-id'] = str(uuid.uuid1())         if custom_headers:             header_parameters.update(custom_headers)         if self.config.accept_language is not None:             header_parameters['accept-language'] = self._serialize.header("self.config.accept_language", self.config.accept_language,'str')          # Construct body         body_content = self._serialize.body(resources, 'MoveResources')          # Construct and send request         request = self._client.post(url, query_parameters)         response = self._client.send(             request, header_parameters, body_content, stream=False, **operation_config)          if response.status_code not in [200, 202]:             exp = CloudError(response)             exp.request_id = response.headers.get('x-ms-request-id')             raise exp          deserialized = None          if response.status_code == 200:
Iterate over list of Invites and return a generator yielding one Invite instance each          :returns: Generator that will yield up to limit results         :rtype: list[twilio.rest.chat.v2.service
Code: def list_query_results_for_management_group(             self, management_group_name, query_options=None, custom_headers=None, raw=False, **operation_config):                  top = None         if query_options is not None:             top = query_options.top         filter = None         if query_options is not None:             filter = query_options.filter          def internal_paging(next_link=None, raw=False):              if not next_link:                 # Construct URL                 url = self.list_query_results_for_management_group.metadata['url']                 path_format_arguments = {                    'managementGroupsNamespace': self._serialize.url("self.management_groups_namespace", self.management_groups_namespace,'str'),                    'managementGroupName': self._serialize.url("management_group_name", management_group_name,'str'),                     'policyTrackedResourcesResource': self._serialize.url("self.policy_tracked_resources_resource", self.policy_tracked_resources_resource,'str')                 }                 url = self._client.format_url(url, **path_format_arguments)                  # Construct parameters                 query_parameters = {}                 query_parameters['api-version'] = self._serialize.query("self.api_version", self.api_version,'str')                 if top is not None:                     query_parameters['$top'] = self._serialize.query("top", top, 'int', minimum=0)                 if filter is not None:                     query_parameters['$filter'] = self._serialize.query("filter", filter,'str')              else:                 url = next_link                 query_parameters = {}              # Construct headers             header_parameters = {}             header_parameters['Accept'] = 'application/json'             if self.config.generate_client_request_id:                 header_parameters['x-ms-client-request-id'] = str(uuid.uuid1())             if custom_headers:                 header_parameters.update(custom_headers)             if self.config.accept_language is not None:                 header_parameters['accept-language'] = self._serialize.header("self.config.accept_language", self.config.accept_language,'str')              # Construct and send request             request = self
Code: def update_queue(self, queue_name, lock_duration=30, max_size_in_megabytes=None,             requires_duplicate_detection=False,             requires_session=False,             default_message_time_to_live=None,             dead_lettering_on_message_expiration=False,             duplicate_detection_history_time_window=None,             max_delivery_count=None, enable_batched_operations=None):                  queue_properties = Queue(             lock_duration="PT{}S".format(int(lock_duration)),             max_size_in_megabytes=max_size_in_megabytes,             requires_duplicate_detection=requires_duplicate_detection,             requires_session=requires_session,             default_message_time_to_live=default_message_time_to_live,             dead_lettering_on_message_expiration=dead_lettering_on_message_expiration,             duplicate_detection_history_time_window=duplicate_detection_history_time_window,             max_delivery_count=max_delivery_count,             enable_batched_operations=enable_batched_operations)         try:             return self.mgmt_client.update_queue(queue_name, queue=queue_properties)         except requests.exceptions.ConnectionError as e:
Code: def delete_queue(self, queue_name, fail_not_exist=False):                  try:             return self.mgmt_client.delete_queue(queue_name, fail_not_exist=fail_not_exist)         except requests.exceptions.ConnectionError as e:             raise ServiceBusConnectionError("Namespace: {} not found".format(self.service_namespace), e)         except azure.common.AzureMissingResourceHttpError as e:             raise ServiceBusResourceNotFound("Specificed queue '{}' does not exist.".format(queue_name), e)
Code
Code: def delete_topic_subscription_rule(self, topic_name, subscription_name, rule_name, fail_not_exist=False):                  try:             return self.mgmt_client.delete_topic_subscription_rule(topic_name, subscription_name, rule_name, fail_not_exist=fail_not_exist)         except requests.exceptions.ConnectionError as e:             raise ServiceBusConnectionError("Namespace: {} not found".format(self.service_namespace), e)         except azure.common.AzureMissingResourceHttpError as e:             raise ServiceBusResourceNotFound("Specificed
Code: def update_subscription(self, topic_name, subscription_name,                              lock_duration=30, requires_session=None,                              default_message_time_to_live=None,                              dead_lettering_on_message_expiration=None,                              dead_lettering_on_filter_evaluation_exceptions=None,                              enable_batched_operations=None, max_delivery_count=None):                  sub_properties = Subscription(             lock_duration="PT{}S".format(int(lock_duration)),             requires_session=requires_session,             default_message_time_to_live=default_message_time_to_live,             dead_lettering_on_message_expiration=dead_lettering_on_message_expiration,             dead_lettering_on_filter_evaluation_exceptions=dead_lettering_on_filter_evaluation_exceptions,             max_delivery_count=max_delivery_count,             enable_batched_operations=enable_batched_operations)         try:             return self.mgmt_client.update_subscription(                 topic_name, subscription_name,                 subscription=sub_properties)         except requests.exceptions.ConnectionError as e:             raise ServiceBusConnectionError("Namespace: {} not found".
Code: def __init__(self, address, name, shared_access_key_name=None, shared_access_key_value=None, **kwargs):         """         Initialize the ServiceContext          :param str address: The address of the Service to fetch         :param str name: The unique string that identifies the resource         :param str shared_access_key_name: The name of the Shared Access Policy         :param str shared_access_key_value: The value of the Shared Access Policy key         :param unicode x_twilio_webhook_enabled: The X-Twilio-Webhook-Enabled HTTP request header          :returns: twilio.rest.chat.v2.service.ServiceContext         :rtype: twilio.rest.chat.v2.service.ServiceContext         """         super(ServiceContext, self).__init__(**kwargs)          # Path Solution         self._solution = {'address': address, 'name': name, }         self._uri = '/Services/{address}/Channels/{name}'.format(**self._solution)          # Dependents         self._channels = None         self._users = None         self._bindings = None         self._roles = None         self._invites = None         self._webhooks = None          # Context         self._context = None         self._solution = {'address': address, 'name': name, }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: ServiceContext for this ServiceInstance         :rtype: twilio.rest.chat.v2.service.ServiceContext         """         if self._context is None:             self._context = ServiceContext(                 self._version,                 address=self._solution['address'],                 name=self._solution['name'],             )         return self._context      @property     def channels(self):         """         Access the channels          :returns: twilio.rest.chat.v2.service.channel.channel.ChannelList         :rtype: twilio.rest.chat.v2.service.channel.channel.ChannelList         """         if self._channels is None:             self._channels = ChannelList(                 self._version,                 service_sid=self._solution['address'],                 channel_sid=self._solution['name'],
Get the runtime information for the user.          :returns: The runtime
Returns true if both instances are not equal, false otherwise          :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def __init__(self, version, payload, service_sid, channel_sid, ):         """         Initialize the InviteInstance          :returns: twilio
Code: def list(             self, resource_group_name, node_name, custom_headers=None, raw=False, **operation_config):                  result = self._list_initial(             resource_group_name=resource_group_name,             node_name=node_name,             custom_headers=custom_headers,             raw=True,             **operation_config         )         if raw:             return result          # Construct and send request         def long_running_send():             return raw_result.response          def get_long_running_status(status_link, headers=None):              request = self._client.get(status_link)             if headers:                 request.headers.update(headers)             header_parameters = {}             header_parameters['x-ms-client-request-id'] = raw_result.response.request.headers['x-ms-client-request-id']             return self._client.send(                 request, header_parameters, stream=False, **operation_config)          def get_long_running_output(response):              deserialized = self._deserialize('SessionResourceList', response)              if raw:                 client_raw_response = ClientRawResponse(deserialized, response)                 return client_raw_response              return deserialized          lro_delay = operation_
raw_result = self._create_subscription_initial(             billing_account_name=billing_account_name,             invoice_section_name=invoice_section_name,             body=body,             custom_headers=custom_headers,             raw=True,             **operation_config         )          def get_long_running_output(response):             header_dict = {                 'Location':'str',                 'Retry-After': 'int',             }             deserialized = self._deserialize('SubscriptionCreationResult', response)              if raw:                 client_raw_response = ClientRawResponse(deserialized, response)                 client_raw_response.add_headers(header_dict)                 return client_raw_response              return deserialized          lro_delay = operation_config.get(             'long_running_operation_timeout',             self.config.long_running_operation_timeout)         if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)         elif polling is False: polling_method = NoPolling()         else: polling_method = polling
Code: def export_request_rate_by_interval(             self, parameters, location, custom_headers=None, raw=False, polling=True, **operation_config):                  raw_result = self._export_request_rate_by_interval_initial(             parameters=parameters,             location=location,             custom_headers=custom_headers,             raw=True,             **operation_config         )          def get_long_running_output(response):             deserialized = self._deserialize('LogAnalyticsOperationResult', response)              if raw:                 client_raw_response = ClientRawResponse(deserialized, response)                 return client_raw_response              return deserialized          lro_delay = operation_config.get(             'long_running_operation_timeout',             self.config.long_running_operation_timeout)         if polling is True: polling_method = ARMPolling(lro_delay, lro_options={'final-state-via': 'azure-async-operation'}, **operation_config)         elif polling is False: polling_method = NoPolling
Code
In case of a chunk exceeding the MaxMessageSize split chunk in half         and resubmit smaller chunk requests          :param BatchErrorException e: BatchErrorException         :param Queue results_queue: Queue         :param list chunk_tasks_to_add: list Code: def _bulk_delete_tasks(self, results_queue, chunk_tasks_to_delete):         try:             delete_collection_response = self._original_delete_collection(                 self._client,                 self._job_id,                 chunk_tasks_to_delete,                 self._task_delete_collection_options,                 self._custom_headers,                 self._raw)         except BatchErrorException as e:             # In case of a chunk exceeding the MaxMessageSize split chunk in half             # and resubmit smaller chunk requests             # TODO: Replace string with constant variable once available in SDK             if e.error.code == "RequestBodyTooLarge":  # pylint: disable=no-member                 # In this case the task is misbehaved and will not be able to be deleted due to:                 #   1) The task exceeding the max message size                 #   2) A single cell of the task exceeds the per-cell limit, or                 #   3) Sum of all cells exceeds max row limit                 if len(chunk_tasks_to_delete) == 1:                     failed_task = chunk_tasks_to_delete.pop()                     self.errors.appendleft(e)                     _LOGGER.error("Failed to delete task with ID %s due to the body"                                   " exceeding the maximum request size", failed_task.id)                 else:                     # Assumption: Tasks are relatively close in size therefore if one batch exceeds size limit                     # we should decrease the initial task collection size to avoid repeating the error                     # Midpoint is lower bounded by 1 due to above base case                     midpoint = int(len(chunk_tasks_to_delete) / 2)                     # Restrict one thread at a time to do this compare and set,                     # therefore forcing max_tasks_per_request to be strictly decreasing                     with self._max_tasks_lock:                         if midpoint < self._max_tasks_per_request:                             self._max_tasks_per_request = midpoint                             _LOGGER.info("Amount of tasks per request reduced from %s to %s
Add a list of tasks to the queue.          :param Queue results_queue: Queue to put results in         :param list tasks_to_add: List of tasks to add          :returns: True if all tasks were added, False otherwise         :rtype: bool Code: def _add_tasks(self, results_queue, tasks_to_add):         """         Add a list of tasks to the queue.          :param Queue results_queue: Queue to put results in         :param list tasks_to_add: List of tasks to add          :returns: True if all tasks were added, False otherwise         :rtype: bool         """         # Add tasks until either we run out or we run into an unexpected error         while tasks_to_add and not self.errors:             max_tasks = self._max_tasks_per_request  # local copy             chunk_tasks_to_add = []             with self._pending_queue_lock:                 while len(chunk_tasks_to_add) < max_tasks and tasks_to_add:                     chunk_tasks_to_add.append(tasks_to_add.pop())              if chunk_tasks_to_add:                 self._add_
Get the package name prefix for the given service and channel.          :param
Code: def update(             self, role_sid=None, last_consumed_message_index=
Code: def _start_environment_initial(             self
Create message from response.          :param response:             response from Service Bus cloud server.         :param service_instance:             the Service Bus client.         :returns: twilio.rest.chat.v2.service.channel.message.Message         :rtype: twilio.rest.chat.v2.service.channel.message.Message Code: def _create_invite(response, service_instance):     ''' Create invite from response.      response:         response from Service Bus cloud server.     service_instance:         the Service Bus client.     '''     respbody = response.body     custom_properties = {}     broker_properties = None     message_type = None     message_location = None      # gets all information from respheaders.     for name, value in response.headers:         if name.lower() == 'brokerproperties':             broker_properties = json.loads(value)         elif name.lower() == 'content-type':             message_type = value         elif name.lower() == 'location':             message_location = value         # Exclude common HTTP headers to avoid noise. List         # is not exhaustive. At worst, custom properties will contains         # an unexpected content generated by the webserver and not the customer.         elif name.lower() not in ['transfer-encoding',                                  'server',                                   'date',                                  'strict-transport-security']:             # Follow the spec:             # https://docs.microsoft.com/rest/api/servicebus/message-headers-and-properties             if '"' in value:                 value = value[1:-1].replace('\\"', '"')                 try:                     custom_properties[name] = datetime.strptime(                         value, '%a, %d %b %Y %H:%M:%S GMT')                 except ValueError:                     custom_properties[name] = value             elif value.lower() == 'true':                 custom_properties[name] = True             elif value.lower() == 'false':                 custom_properties[name] = False             else:  # in theory, only int or float                 try:                     # int('3.1') doesn't work so need to get float('3.14') first                     float_value = float(value)                     if str(int(float_value)) == value:                         custom_properties[name] = int(value)                     else:                         custom_properties[name
Converts entry element to rule object.          The format of xml for rule: <entry xmlns='http://www.w3.org/2005/Atom'> <content type='application/xml'> <RuleDescription     xmlns:i="http://www.w3.org/2001/XMLSchema-instance"     xmlns="http://schemas.microsoft.com/netservices/2010/10/servicebus/connect">     <Filter i:type="SqlFilterExpression">         <SqlExpression>MyProperty='XYZ'</SqlExpression>     </Filter>     <Action i:type="SqlFilterAction">         <SqlExpression>set MyProperty2 = 'ABC'</SqlExpression>     </Action> </RuleDescription> </content> </entry> Code: def _convert_etree_element_to_ruleset(entry_element):     ''' Converts entry element to ruleset object.      The format of xml for ruleset: <entry xmlns='http://www.w3.org/2005/Atom'> <content type='application/xml'> <RuleSetDescription     xmlns:i="http://www.w3.org/2001/XMLSchema-instance"     xmlns="http://schemas.microsoft.com/netservices/2010/10/servicebus/connect">     <Rules>         <Rule>             <Filter i:type="SqlFilterExpression">                 <SqlExpression>MyProperty='XYZ'</SqlExpression>             </Filter>             <Action i:type="SqlFilterAction">                 <SqlExpression>set MyProperty2 = 'ABC'</SqlExpression>             </Action>         </Rule>     </Rules> </RuleSetDescription> </content> </entry>     '''     ruleset = RuleSet()      ruleset_element = entry_element.find('./atom:content/sb:RuleSetDescription', _etree_sb_feed_namespaces)     if ruleset_element is not None:         rules_element = ruleset_element.find('./sb:Rules', _etree_sb_feed_namespaces)         if rules_element is not None:             for rule_element in rules_element.findall('./sb:Rule', _etree_sb_feed_namespaces):                 rule = _convert_etree_element_to_rule(rule_element)
Converts entry element to queue object.          The format of xml response for queue: <QueueDescription     xmlns=\"http://schemas.microsoft.com/netservices/2010/10/servicebus/connect\">     <MaxSizeInBytes>10000</MaxSizeInBytes>     <DefaultMessageTimeToLive>PT5M</DefaultMessageTimeToLive>     <LockDuration>PT2M</LockDuration>     <RequiresGroupedReceives>False</RequiresGroupedReceives>     <SupportsDuplicateDetection>False</SupportsDuplicateDetection>    ... </QueueDescription>          :param entry_element: Entry element of queue         :type entry_element: lxml.etree._Element         :rtype: Queue         :returns: Queue object         :raises: AzureServiceBusResourceNotFound     Code: def _convert_etree_element_to_topic(entry_element):     ''' Converts entry element to topic object.      The format of xml response for topic: <TopicDescription     xmlns=\"http://schemas.microsoft.com/netservices/2010/10/servicebus/connect\">     <DefaultMessageTimeToLive>PT5M</DefaultMessageTimeToLive>     <MaxSizeInMegabytes>10000</MaxSizeInMegabytes>     <RequiresDuplicateDetection>False</RequiresDuplicateDetection>     <DuplicateDetectionHistoryTimeWindow>PT10M</DuplicateDetectionHistoryTimeWindow>     <EnableBatchedOperations>True</EnableBatchedOperations>     <SizeInBytes>0</SizeInBytes>     <FilteringMessagesBeforePublishing>False</FilteringMessagesBeforePublishing>     <IsAnonymousAccessible>False</IsAnonymousAccessible>     <AuthorizationRules>         <SharedAccessAuthorizationRule>             <ClaimType>SharedAccessKey</ClaimType>             <ClaimValue>sb://mynamespace.servicebus.windows.net/mytopic?SharedAccessKey=mykey</ClaimValue>             <Rights>Listen Manage Send</Rights>         </SharedAccessAuthorizationRule>     </AuthorizationRules>     <Status>Active</Status>     <SupportOrdering>True</SupportOrdering>     <AutoDeleteOnIdle>P10675199DT2H48M5.4775807S</AutoDeleteOnIdle>     <EnablePartitioning>False</EnablePartitioning>     <EnableExpress>False</EnableExpress>     <EnableSubscription
Converts entry element to topic          The xml format for topic: <entry xmlns='http://www.w3.org/2005/Atom'>     <content type='application/xml'>     <TopicDescription         xmlns:i="http://www.w3.org/2001/XMLSchema-instance"         xmlns="http://schemas.microsoft.com/netservices/2010/10/servicebus/connect">         <DefaultMessageTimeToLive>P10675199DT2H48M5.4775807S</DefaultMessageTimeToLive>         <MaxSizeInMegabytes>1024</MaxSizeInMegabytes>         <RequiresDuplicateDetection>false</RequiresDuplicateDetection>         <DuplicateDetectionHistoryTimeWindow>P7D</DuplicateDetectionHistoryTimeWindow>         <DeadLetteringOnFilterEvaluationExceptions>true</DeadLetteringOnFilterEvaluationExceptions>     </TopicDescription>     </content> </entry> Code: def _convert_etree_element_to_subscription(entry_element):     '''Converts entry element to subscription      The xml format for subscription: <entry xmlns='http://www.w3.org/2005/Atom'>     <content type='application/xml'>     <SubscriptionDescription         xmlns:i="http://www.w3.org/2001/XMLSchema-instance"         xmlns="http://schemas.microsoft.com/netservices/2010/10/servicebus/connect">         <DefaultMessageTimeToLive>P10675199DT2H48M5.4775807S</DefaultMessageTimeToLive>         <MaxSizeInMegabytes>1024</MaxSizeInMegabytes>         <RequiresDuplicateDetection>false</RequiresDuplicateDetection>         <DuplicateDetectionHistoryTimeWindow>P7D</DuplicateDetectionHistoryTimeWindow>         <DeadLetteringOnFilterEvaluationExceptions>true</DeadLetteringOnFilterEvaluationExceptions>     </SubscriptionDescription>     </content> </entry>     '''     subscription = Subscription()      invalid_subscription = True      subscription_element = entry_element.find('./atom:content/sb:SubscriptionDescription', _etree_sb_feed_namespaces)     if subscription_element is not None:         mappings =
Converts entry element to subscription          The xml format for subscription: <entry xmlns='http://www.w3.org/2005/Atom'>     <content type='application/xml'>     <SubscriptionDescription         xmlns:i="http://www.w3.org/2001/XMLSchema-instance"         xmlns="http://schemas.microsoft.com/netservices/2010/10/servicebus/connect">         <LockDuration>PT5M</LockDuration>         <RequiresSession>false</RequiresSession>         <DefaultMessageTimeToLive>P10675199DT2H48M5.4775807S</DefaultMessageTimeToLive>         <DeadLetteringOnMessageExpiration>false</DeadLetteringOnMessageExpiration>         <DeadLetteringOnFilterEvaluationExceptions>true</DeadLetteringOnFilterEvaluationExceptions>     </SubscriptionDescription>     </content> </entry> Code: def _convert_etree_element_to_topic(entry_element):     '''Converts entry element to topic      The xml format for topic: <entry xmlns='http://www.w3.org/2005/Atom'>     <content type='application/xml'>     <TopicDescription         xmlns:i="http://www.w3.org/2001/XMLSchema-instance"         xmlns="http://schemas.microsoft.com/netservices/2010/10/servicebus/connect">         <DefaultMessageTimeToLive>P10675199DT2H48M5.4775807S</DefaultMessageTimeToLive>         <MaxSizeInMegabytes>1024</MaxSizeInMegabytes>         <RequiresDuplicateDetection>false</RequiresDuplicateDetection>         <DuplicateDetectionHistoryTimeWindow>PT10M</DuplicateDetectionHistoryTimeWindow>         <EnableBatchedOperations>true</EnableBatchedOperations>         <SizeInBytes>0</SizeInBytes>         <FilteringMessagesBeforePublishing>false</FilteringMessagesBeforePublishing>         <IsAnonymousAccessible>false</IsAnonymousAccessible>         <AuthorizationRules />         <Status>Active</Status>         <SupportOrdering>true</SupportOrdering>         <AutoDeleteOnIdle>P10675199DT2H48M5.
Code: def list_by_service(             self, resource_group_name, account_name, custom_headers=None, raw=False, **operation_config):                  result = self._list
Code: def delete(             self, resource_group_name, account_name, certificate_name, custom_headers=None, raw=False, **operation_config):                  raw_result = self._delete_initial(             resource_group_name=resource_group_name,             account_name=
Code: def get_client_from_cli_profile(client_class, **kwargs):          cloud = get_cli_active_cloud()     parameters = {}     if 'credentials' not in kwargs or'subscription_id' not in kwargs:         resource, _ = _client_resource(client_class, cloud)         credentials, subscription_id, tenant_id = get_azure_cli_credentials(resource=resource,                                                                             with_tenant=True)         parameters.update({             'credentials': kwargs.get('credentials', credentials),            'subscription_id': kwargs.get('subscription_id', subscription_id)
Get a client from a service principal.          :param client_class: The client class to instantiate.         :
Code: def get_client_from_json_dict(client_class, config_dict, **kwargs):     """     Get a client from a JSON configuration dictionary.      :param client_class: The client class to instantiate.     :type client_class: :class:`msrestazure.azure_active_directory.AzureActiveDirectory`     :param dict config_dict: The configuration dictionary.     :param kwargs: Additional keyword arguments to pass to the client.     :type kwargs: dict     :rtype: client_class     """     if 'tenant' not in config_dict:         raise ValueError('Missing tenant in configuration')     if'subscription_id' not in config_dict:         raise ValueError('Missing subscription_id in configuration')     if 'client_id' not in config_dict:         raise ValueError('Missing client_id in configuration')     if'secret' not in config_dict:         raise ValueError('Missing secret in configuration')     if 'active_directory_endpoint_url' not in config_dict:         raise ValueError('Missing active_directory_endpoint_url in configuration')     if'resource_management_endpoint_url' not in config_dict:         raise ValueError('Missing resource_management_endpoint_url in configuration')     if 'graph_resource_id' not in config_dict:         raise ValueError('Missing graph_resource_id in configuration')     if 'active_directory_graph_resource_id' not in config_dict:         raise ValueError('Missing active_directory_graph_resource_id in configuration')     if 'tenant_id' not in config_dict:         raise ValueError('Missing tenant_id in configuration')     if 'active_directory_graph_resource_id' not in config_dict:         raise ValueError('Missing active_directory_graph_resource_id in configuration')     if 'active_directory_graph_resource_id' not in config_dict:         raise ValueError('Missing active_directory_graph_resource_id in configuration')     if 'active_directory_graph_resource_id' not in config_dict:         raise ValueError('Missing active_directory_graph_resource_id in configuration')     if 'active_directory_graph_resource_id' not in config_dict:         raise ValueError('Missing active_directory_graph_resource_id in configuration')     if 'active_directory_graph_resource_id'
Initialize the InvitePage          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to         :param Response response: Response from the API         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage
get properties from element tree element          :param element: Element tree element         :type element: xml.etree.ElementTree.Element          :param include_id: Include the id in the properties         :type include_id: bool          :param id_prefix_to_skip: Prefix to skip when generating readable id         :type id_prefix_to_skip: str          :param use_title_as_id: Use the title as the id         :type use_
Code: def list_by_group(             self, resource_group_name, provisioning_service_name, custom_headers=None, raw=False, **operation_
Code: def get_rule(self, topic_name, subscription_name, rule_name):                  try:             rule = self.mgmt_client.get_rule(topic_name, subscription_name, rule_name)         except requests.exceptions.ConnectionError as e:             raise ServiceBusConnectionError("Namespace: {} not found".format(self.service_namespace), e)         except AzureServiceBusResourceNotFound:             raise ServiceBusResourceNotFound("Specificed rule does not exist.")         return RuleClient.from_entity(             self._get_host(), rule,             shared_access_key_name=self.shared_access_key_name,             shared_access_key_value=self.shared_access_key_value,             mgmt_client
Code: def list_rules_by_topic(self, topic_name):                  try:             rules = self.
Code: def get_topic(self, topic_name):                  try:             topic = self.mgmt_client.get_topic(topic_name)         except requests.exceptions.Connection
Code: def list_topics(self):                  try:             topics = self.mgmt_client.list_topics()         except requests.exceptions.ConnectionError as e:             raise ServiceBusConnectionError("Namespace: {} not found".format(self.service_namespace), e)         topic
Receive deferred messages from the channel.          :param list[int] sequence_numbers: The sequence numbers of the deferred messages to receive.         :param ReceiveSettleMode mode: The mode to use for settling the deferred messages.         :param dict kwargs: Additional keyword arguments to pass to the handler.          :returns: DeferredMessageSet         :rtype: twilio.rest.chat.v2.service.channel.message.message_set.DeferredMessageSet Code: def receive_messages(self, limit=None, **kwargs):         """         Receive messages from the channel.          :param int limit: The maximum number of messages to receive.         :param dict kwargs: Additional keyword arguments to pass to the handler.          :returns: MessageSet         :rtype: twilio.rest.chat.v2.service.
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset,                  attributes=values.unset, role_sid=values.unset,                  identity=values.unset, is_pending=values.unset,                  date_expires=values.unset, expiration_period=values.unset,                  date_invited=values.unset, invite_reason=values.unset,                  links=values.unset, **kwargs):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['account_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'attributes': attributes,             'role_sid': role_sid,             'identity': identity,             'is_pending': is_pending,             'date_expires': deserialize.iso8601_datetime(date_expires),             'expiration_period': expiration_period,             'date_invited': deserialize.iso8601_datetime(date_invited),             'invite_reason': invite_reason,             'links': links,         }          # Context         self._context = None         self._solution = {             'account_sid': account_sid,            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are prox
List the domains defined
Get a website.          webspace_name:             The name of the webspace.         website_name:             The name of the website. Code: def get_sites(self,

Update a web site metadata.          webspace_name:             The name of the webspace.         website_name:             The name of the website.         metadata:             The metadata to apply. Code: def update_site_plan(self, webspace_name, website_name, plan):         '''         Update a web site plan.          webspace_name:             The name of the webspace.         website_name:             The name of the website.         plan:             The plan to apply.         '''         xml = _XmlSerializer.update_website_plan_to_xml(plan)         return self._perform_put(             self._get_sites_details_path(webspace_name, website_name),             xml, as_async=
Perform a POST request.          path:             The path to the resource.         data:             The data to send in the request.         as_async:             Whether to perform
Get historical usage metrics.          webspace_name:             The name of the webspace.         website_name:             The name of the website.         metrics:             Optional. List of metrics name. Otherwise, all metrics returned.         start_time:             Optional. An ISO8601 date. Otherwise, current hour is used.         end_time:             Optional. An ISO8601 date. Otherwise, current time is used.         time_grain:             Optional. A rollup name, as P1D. OTherwise, default rollup for the metrics is used.         More information and metrics name at:         http://msdn.microsoft.com/en-us/library/azure/dn166964.aspx         '''                 metrics = ('names='+','.join(metrics)) if metrics else ''         start_time = ('StartTime='+start_time)
Get metric data of metrics available of this web site.          webspace_name:             The name of the webspace.         website_name:             The name of the website.         metric_name:             The name of the metric.         start_time:             The start time of the metric data.         end_time:             The end time of the metric data.         granularity:             The granularity of the metric data.         limit:             The number of results to return.         offset:             The offset of the first result to return.         '''         return self._perform_get(self._get_metric_data_path(webspace_name, website_name, metric_name, start_time, end_time, granularity, limit, offset),                                  MetricData) Code: def get_metric_data_streams(self, webspace_name, website_name, metric_name, start_time, end_time,                                  granularity, limit=None, offset=None):         '''         Get metric data streams of metrics available of this web site.          webspace
Get a site's publish profile as a string          webspace_name:             The name of the webspace.         website_name:             The name of the website.         sid:             The sid of the site. Code: def get_publish_profile_xml_with_webspace_name_and_website_name_and_website_name(self, webspace_name, website_name, website_name
Constructs a WebhookContext          :param sid: The SID that identifies the resource to fetch Code: def list_webhooks(self, limit=None, page_size=None):         """         Lists WebhookInstance records from the API as a list.         Unlike stream(), this operation is eager and will load `limit` records into         memory before returning.          :param int limit: Upper limit for the number of records to return. list() guarantees                           never to return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, list() will attempt to read the limit                               with the most efficient page size, i.e. min(
:param str resource_group_name: The name of the resource group that          contains the IoT hub.         :param str registry_name: The name of the IoT hub.         :param str quarantine_policy: The new quarantine policy.         :param str trust_policy: The new trust policy.         :param dict custom_headers: headers that will be added to the request         :param bool raw: returns the direct response alongside the          deserialized response         :param polling: True for ARMPolling, False for no polling, or a          polling object for personal polling strategy         :return: An instance of LROPoller that returns RegistryPolicies or          ClientRawResponse<RegistryPolicies> if raw=true         :rtype:          ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.iothub.v2018_04_01.models.RegistryPolicies]          or          ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.iothub.v2018_04_01.models.RegistryPolicies]]         :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`         """ Code: def update_policies(             self, resource_group_name, registry_name, quarantine_policy=None, trust_policy=None, custom_headers=None, raw=False, polling=True, **operation_config):                  raw_result = self._update_policies_initial(             resource_group_name=resource_group_name,             registry_name=registry_name,             quarantine_policy=quarantine_policy,             trust_policy=trust_policy,             custom_headers=custom_headers,             raw=True,             **operation_config         )          def get_long_running_output(response):             deserialized = self._deserialize('RegistryPolicies', response)              if raw:                 client_raw_response = ClientRawResponse(deserialized, response)                 return client_raw_response              return deserialized          lro_delay = operation_config.get(             'long_running_operation_timeout',             self.config.long_running_operation_timeout)         if polling is True: polling_method = ARMPolling
The Create Cloud Service Job Collection request creates a new job         collection. When job collections are created, they are hosted within a         cloud service. A cloud service groups job collections together in a         given region. Once a cloud service has been created, job collections         can then be created and contained within it.
The Check Name Availability operation checks if a new job collection with         the given name may be created, or if it is unavailable. The result of the         operation is a Boolean true or false.          cloud_service_id:             The cloud service id         job_
The Get Job Collection Statistics operation gets the statistics of a job collection          cloud_service_id:             The cloud service id         job_collection_id:             Name of the hosted service.          :returns: twilio.rest.chat.v2.service.job_collection.JobCollectionStatisticsInstance         :rtype: twilio.rest.chat.v2.service.job_collection.JobCollectionStatisticsInstance Code: def get_job_statistics(self, cloud_service_id, job_collection_id, job_sid):         '''         The Get Job Statistics operation gets the statistics of a job          cloud_service_id:             The cloud service id         job_collection_id:             Name of the hosted service.         job_sid:             The SID of the Job resource to fetch.         '''         _validate_not_none('cloud_service_id', cloud_service_id)         _validate_not_none('job_collection_id', job_collection_id)         _validate_not_none('job_sid', job_sid)          path = self._get_job_statistics_path(             cloud_service_id, job_collection_id, job_sid)          return self._perform_get(path, Resource) Docstring
Code: def _complete_restore_initial(             self, location_name, operation_id, last_backup_name, custom_headers=None, raw=False, **operation_config):                  # Construct URL         url = '/v2/Services/{serviceSid}/Channels/{channelSid}/Invites/{sid}/CompleteRestore'         path_format_arguments = {            'serviceSid': self._serialize.url("self._config.service_sid", self._config.service_sid,'str'),             'channelSid': self._serialize.url("self.channel_sid", self.channel_sid,'str'),            'sid': self._serialize.url("self.sid", self.sid,'str')         }         url = self._client.format_url(url, **path_format_arguments)          # Construct parameters         query_parameters = {}         query_parameters['LocationName'] = self._serialize.query("location_name", location_name,'str')         query_parameters['OperationId'] = self._serialize.query("operation_id", operation_id,'str')         query_parameters['LastBackupName'] = self._serialize.query("last_backup_name", last_backup_name,'str')          # Construct headers         header_parameters = {}         header_parameters['Content-Type'] = 'application/x-www-form-urlencoded'         if self.config.generate_client_request_id:             header_parameters['x-twilio-request-id'] = str(uuid.uuid1())         if custom_headers:             header_parameters.update(custom_headers)         if self.config.accept_language is not None:             header_parameters['accept-language'] = self._serialize.header("self.config.accept_language", self.config.accept_language,'str')          # Construct and send request         request = self._client.post(url, query_parameters)         response = self._client.send(request, header_parameters, stream=False, **operation_config)          if response.status_code not in [200, 202]:             raise models.RestException(self._deserialize, response)          deserialized = None          if response.status_code == 200:             deserialized = self._deserialize('CompleteRestoreResponse', response)
Create a new InviteInstance          :param unicode identity: The unique string that identifies the resource         :param unicode role_sid: The SID of the Role assigned to the new invite         :param unicode ttl: The time-to-live of the invite, in seconds         :param unicode type: The type of push notification to send to the new             invite         :param unicode unique_name: An application-defined string that uniquely             identifies the resource          :returns: Newly
Code: async def send_pending_messages(self):                  if not self.running:             await self.open()         try:             pending = self._handler._pending_messages[:]  # pylint: disable=protected-access             await self._handler.wait_async()             results = []             for
Code: async def _handle_exception(self, e):         """         Handle an exception that occurred during the connection.          :param Exception e: The exception that occurred          :returns: None         :rtype: None         """         self.logger.error('Connection error: %s', e)         self.logger.debug('Connection error traceback: %s', traceback.format_exc())         self.logger.debug('Connection error stack: %s', traceback.extract_stack())         self.logger.debug('Connection error type: %s', type(e))         self.logger.debug('Connection error message: %s', e.message)         self.logger.debug('Connection error code: %s', e.code)         self.logger.debug('Connection error status: %s', e.status)         self.logger.debug('Connection error reason: %s', e.reason)         self.logger.debug('Connection error headers: %s', e.headers)         self.logger.debug('Connection error body: %s', e.body)         self.logger.debug('Connection error request: %s', e.request)         self.logger.debug('Connection error response: %s', e.response)         self.logger.debug('Connection error request_id: %s', e.request_id)         self.logger.debug('Connection error request_time: %s', e.request_time)         self.logger.debug('Connection error request_url: %s', e.request_url)         self.logger.debug('Connection error request_method: %s', e.request_method)         self.logger.debug('Connection error request_headers: %s', e.request_headers)         self.logger.debug('Connection error request_body: %s', e.request_body)         self.logger.debug('Connection error response_status: %s', e.response_status)         self.logger.debug('Connection error response_headers: %s', e.response_headers)         self.logger.debug('Connection error response_body: %s', e.response_body)         self.logger.debug('Connection error response_code: %s', e.response_code)         self.logger.debug('Connection error response_reason: %s', e.response_reason)         self.logger.
Writes a certificate file to the specified location.  This can then be used          to instantiate ServiceManagementService.  Returns the subscription ID.          publish_settings_path:              Path to subscription file downloaded from              http://go.microsoft.com/fwlink/?LinkID=301775         path_to_write_certificate:             Path to write the certificate file.         subscription_id:             (optional)  Provide a subscription id here if you wish to use a              specific subscription under the publish settings file. Code: def get_certificate_from_publish_settings_file(publish_settings_file_path, path_to_write_certificate, subscription_id=None):     '''     Writes a certificate file to the specified location.  This can then be used      to instantiate ServiceManagementService.  Returns the subscription ID.      publish_settings_file_path:          Path to subscription file downloaded from          http://go.microsoft.com/fwlink/?LinkID=301775     path_to_write_certificate:         Path to write the certificate file.     subscription_id:         (optional)  Provide a subscription id here if you wish to use a          specific subscription under the publish settings file.     '''     import base64      try:         from xml.etree import cElementTree as ET     except ImportError:         from xml.etree import ElementTree as ET      try:         import OpenSSL.crypto as crypto     except:         raise Exception("pyopenssl is required to use get_certificate_from_publish_settings_file")      _validate_not_none('publish_settings_file_path', publish_settings_file_path)     _validate_not_none('path_to_write_certificate', path_to_write_certificate)      # parse the publishsettings file and find the ManagementCertificate Entry     tree = ET.parse(publish_settings_file_path)     subscriptions = tree.getroot().findall("./PublishProfile/Subscription")          # Default to the first subscription in the file if they don't specify     # or get the matching subscription or return none.     if subscription_id:         subscription = next((s for s in subscriptions if s.get('Id').lower() == subscription_id.lower()), None)     else:         subscription = subscriptions[0]      # validate that subscription was found     if subscription is None:         raise ValueError("The provided subscription
Initialize the Plugin          :param str service_sid: The SID of the Service to fetch the resource from         :param str channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext Code: def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         context =''.join('{}={}'.format(
Iterate over list of Invites          :returns: List of Invites         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance] Code: def __len__(self):         """         :returns: Number of Invites in the response         :rtype: unicode         """         return self._version.read_limits['
Code
Get an item from the list of resources          :param unicode key: The index of the resource to fetch          :returns
Code: def __eq__(self, other):         """         :returns: True if other == this,
Code: def __getitem__(self, key
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset,                  links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': None,            'service_sid': service_sid,             'channel_sid': channel_sid,             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __unicode__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :
Code: def __init__(self, *args, **kwargs):         """         Initialize the SegmentList          :returns: twilio.rest.video.v1.room.room_participant.room_participant_published_track.SegmentList         :rtype: twilio.rest.video.v1.room.room_participant.room_participant_published_track.SegmentList         """         super(SegmentList, self).__init__(version=kwargs.get('version'))          # Path Solution         self._solution = {'room_sid': kwargs.get('room_sid'), 'participant_sid': kwargs.get('participant_sid'),                           'track_sid': kwargs.get('track_sid'), }         self._uri = '/Rooms/{room_sid}/Participants/{participant_sid}/PublishedTracks/{track_sid}/Segments'.format(**self._solution)      def stream(self, limit=None, page_size=None):         """         Streams SegmentInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until the limit         is reached.         The results are returned as a generator, so this operation is memory efficient.          :param int limit: Upper limit for the number of records to return. stream()                           guarantees to never return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, stream() will attempt to read the                               limit with the most efficient page size, i.e. min(limit, 1000)          :returns: Generator that will yield up to limit results         :rtype: list[twilio.rest.video.v1.room.room_participant.room_participant_published_track.SegmentInstance]         """         limits = self._version.read_limits(limit, page_size)          page = self.page(page_size=limits['page_size'], )          return self._version.stream(page, limits['limit'], limits['page_limit'])      def list(self, limit=None, page_size=None):         """         Lists SegmentInstance records from the API as a list.         Unlike stream(), this operation is eager and will load `limit` records into         memory before returning
Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'identity': payload.get('identity'),             'role_sid': payload.get('role_sid'),             'date_created': deserialize.iso8601_datetime(payload.get('date_created')),             'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')),             'url': payload.get('url'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': payload.get('sid'),         }      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property     def service_sid(self):         """         :returns: The SID of the Service that the resource is
Code: def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         return '<Twilio.IpMessaging.V2.InviteList>' Doc
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset,                  links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': sid,             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def date_created(self):         """         :returns: The ISO 8601 date and time in GMT when the resource was created         :rtype: datetime         """         return self._properties['date_created']      @property     def date_updated(self):         """         :returns: The ISO 860
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset,                  links=values.unset):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to         :param sid: The unique string that identifies the resource          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites{sid}'.format(**self._solution)          # Path Parameters         self._solution['service_sid'] = service_sid         self._solution['channel_sid'] = channel_sid         self._solution['sid'] = sid          # Components         self._invites = None         self._links = None      @property     def invites(self):         """         :returns: A list of instances of InviteInstance         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]         """         if self._invites is None:             self._invites = list()         if self._invites:             return self._invites          self._invites = list()         for payload in self._version.page(method='GET', uri=self._uri, params=self._solution,):             self._invites.append(InviteInstance(                 self._version,                 payload,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             ))          return self._invites      @property     def links(self):         """         :returns: The links         :rtype: unicode         """         if self._links is None:             self._links = self._
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, service_sid, channel_sid):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """
Code: def _extract_nonce(cls, http_result):                   # Extract the redirect URL from the last call         last_redirect_url
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, role_sid=values.unset,                  identity=values.unset, url=values.unset, links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['account_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'role_sid': role_sid,             'identity': identity,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {             'account_sid': account_sid,            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.
Get an item from the list of resources in the response.          :returns: An instance of the resource at the given index, or None if                   that index does not exist.         :rtype: twilio
Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'created_by': payload.get('created_by'),             'created_by_identity': payload.get('created_by_identity'),             'role_sid': payload.get('role_sid'),             'date_created': deserialize.rfc2822_datetime(payload.get('date_created')),             'date_updated': deserialize.rfc2822_datetime(payload.get('date_updated')),             'url': payload.get('url'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': payload.get('sid'),         }      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property     def service_sid(self):         """         :returns: The SID of the Service that the resource is associated with         :rtype: unicode         """         return self._properties['service_sid']      @property     def channel_sid(self):         """         :returns: The SID of the Channel the resource belongs to         :rtype: unicode         """         return self._properties['channel_sid']      @property     def created_by(self):         """         :returns: The identity of the User that created the resource         :rtype: unicode         """         return
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset, **kwargs):         """         Initialize the InviteContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to         :param sid: The SID of the Invite resource to fetch          :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         super(InviteContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites/{sid}'.format(**self._solution)          # Dependents         self._channel = None      @property     def sid(self):         """         :returns: The SID of the Invite resource         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property     def service_sid(self):         """         :returns: The SID of the Service that the resource is associated with         :rtype: unicode         """         return self._properties['service_sid']      @property     def channel_sid(self):         """         :returns: The SID of the Channel the resource to fetch belongs to         :rtype: unicode         """         return self._properties['channel_sid']      @property     def role_sid(self):         """         :returns: The SID of the Role assigned to the user when they join the Channel         :rtype: unicode         """         return self._properties['role_sid']      @property     def identity(self):         """         :returns: The identity of the User when they join the Channel         :rtype: unicode         """         return self._properties['identity']      @property     def date_created(self):         """         :returns: The RFC 2822 date and time in
Code: def __len__(self):         """         :returns: Number of invites in the response         :rtype: unicode
Spawn a process and wait for it to complete.          :param list parameters: List of parameters to pass to the command.         :param list arguments: List of arguments to pass to the command.         :param file stderr: File-like object to write stderr to.         :param int timeout: Timeout in seconds.         :param str short_option_prefix: Prefix for short options.         :param str long_option_prefix: Prefix for long options.          :returns: subprocess.Popen         :rtype: subprocess.Popen Code: def spawn_and_wait_for_output(self, output, parameters=None, arguments=None, stderr=None, timeout=None, short_option_prefix="-", long_option_prefix="--"):         """         Spawn a process and wait for it to complete.          :param str output: The output to wait for.         :param list parameters: List of parameters to pass to the command.         :param list arguments: List of
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, response, solution):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The service_sid          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__
Get the channel unique name from the channel_sid or channel_unique_name          :param str channel_sid: The channel_sid         :param str channel_unique_name: The channel_unique_name          :returns: The channel unique name         :rtype: str Code: def _get_channel_type(self, channel_type):         """         Get the channel type from the channel_type or channel_unique_name          :param str channel_type: The channel_type         :param str channel_unique_name: The channel_unique_name          :returns: The channel type         :rtype: str         """
Get an item from the list of resources          :param unicode key: The index of the resource to fetch          :returns:
Code: def __iter__(self):         """         Iterate over list of invites
Code: def __iter__(self):         """         Iterate over pages of results          :returns: Page of InviteInstance         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]         """         return list(self)
Iterate over list of resources, yielding each one as a dict.          :returns: Generator that will yield up to limit results         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance] Code: def __len__(self):         """         :returns: Number of resources in the response         :rtype: unicode         """         return self._version.read(             method='GET',             uri=self._uri,         )
Code: def parse_headers(
Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def __getitem__(self, key):         """         Get an item from the list of resources          :param unicode key: The index of the resource to fetch          :returns: twilio.rest.chat.v2
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, payload, service_sid, channel_sid, sid=None):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'created_by': payload.get('created_by'),             'created_by_identity': payload.get('created_by_identity'),             'role_sid': payload.get('role_sid'),             'identity': payload.get('identity'),             'date_created': deserialize.iso8601_datetime(payload.get('date_created')),             'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')),             'url': payload.get('url'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def sid
Code: def __lt__(self, other):         return (             self.name < other.name or             (self.name == other.name and self.level < other.level) or             (self.name == other.name and self.level == other.level and self.
Attempt to login to the LiveEdu account          :raises: LiveEduLoginError if login fails         """         if self.session.is_logged_in:             return          self.logger.debug("Attempting login as {0}", self.username)          res = self.session.http.get(self.login_url)         csrf_match = self.csrf_re.search(res.text)         token = csrf_match and csrf_match.group(1)         self.logger.debug("Attempting login as {0} (token={1})", self.username, token)          res = self.session.http.post(self.login_url,                             data=dict(login=self.username, password=self.password, csrfmiddlewaretoken=token),                             allow_redirects=False,                             raise_for_status=False,                             headers={"Referer": self.login_url})          if res.status_code!= 302:             self.logger.error("Failed to login to LiveEdu account: {0}", self.username)             raise LiveEduLogin
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __
Code: def __call__(self, sid):         """         Constructs a InviteContext          :param sid: The sid          :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         return InviteContext(             self._version,             service_sid=
Iterate over the tags in the file.          :param file fd: File object to read from.         :param int buf: Size of buffer to read from file.         :param bool skip_header: Skip the header.          :returns: Iterator over the tags in the file.         :rtype: iterator Code: def iter_chunks(self, fd=None, buf=None, skip_header=None):                  timestamps = dict(self.timestamps_add)         tag_iterator = self.iter_tags(fd=fd, buf=buf, skip_header=skip_header)          if not self.flv_header_written:             analyzed_tags = self.analyze_tags(tag_iterator)         else:             analyzed_tags = []          for tag in chain(analyzed_tags, tag_iterator):             if not self.flv_header_written:                 flv_header = Header(has_video=self.has_video,                                     has_audio=self.has_audio)                 yield flv_header.serialize()                 self.flv_header_written = True              if self.verify_tag(tag):                 self.adjust_tag_gap(tag)                 self.adjust_tag_timestamp(tag)                  if self.duration:                     norm_timestamp = tag.timestamp / 1000                     if norm_timestamp > self.duration:                         break                 yield tag.serialize()                 timestamps[tag.type] = tag.timestamp          if not self.flatten_timestamps:             self.timestamps_add = timestamps          self.tags
Get an item from the list of resources          :param unicode key: The index of the resource to fetch          :returns
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset,                  links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['service_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property     def service_sid(self):         """         :returns: The SID of the Service that the resource is associated with         :rtype: unicode         """         return self._properties['service_sid']      @property     def channel_sid(self):         """         :returns: The SID of the Channel the resource belongs to         :rtype: unicode         """         return self._properties['channel_sid']      @property     def date_created(self):         """         :returns: The RFC 2822 date and time in GMT when the resource was created         :
Create a player thread.          :param out: Output instance         :type out: :class:`StreamlinkOutput`          :returns: Player thread         :rtype: :class:`threading.Thread` Code: def create_player_thread_and_http_server(out, http):     """     Create a player thread and HTTP server thread.      :param out: Output
Code: def create_http_server(host=None, port
Code: def iter_http_requests(server,
Code: def output_stream_rtmp(plugin, initial_streams, external=False, port=0):          global output      if not external:         if not args.player:             console.exit("The default player (VLC) does not seem to be "                          "installed. You must specify the path to a player "                          "executable with --player.")          title = create_title(plugin)         server = create_rtmp_server()         player = output = PlayerOutput(args.player, args=args.player_args,                                        filename=server.url,                                        quiet=not args.verbose_player,                                        title=title)          try:             log.info("Starting player: {0}", args.player)             if player:                 player.open()         except OSError as err:             console.exit("Failed to start player: {0} ({1})",                          args.player, err)     else:         server = create_rtmp_server(host=None, port=port)         player = None          log.info("Starting server, access with one of:")         for url in server.urls:             log.info(" " + url)      for req in iter_rtmp_requests(server, player):         user_agent = req.headers.get("User-Agent") or "unknown player"         log.info("Got RTMP request from {0}".format(user_agent))          stream_fd = prebuffer = None         while not stream_fd and (not player or player.running):             try:                 streams = initial_streams or fetch_streams(plugin)                 initial_streams = None                  for stream_name in (resolve_stream_name(streams, s) for s in args.stream):                     if stream_name in streams:                         stream = streams[stream_name]                         break                 else:                     log.info("Stream not available, will re-fetch "                              "streams in 10 sec")                     sleep(10)                     continue             except PluginError as err:                 log.error(u"Unable to fetch new streams: {0}", err)                 continue              try:                 log.info("Opening stream: {0} ({1})", stream_name,                          type(stream).shortname())                 stream_fd, prebuffer = open_stream(stream)             except StreamError as err:                 log.error("{0}",
Code: def output_stream_passthrough(plugin, stream):          global output      title = create_title(plugin)     filename = '"{0}"'.format(stream_to_url(stream))     output = PlayerOutput(args.player, args=args.player_args
Attempts to open the stream          :param stream: The stream to open          :returns: A tuple of (stream_fd, prebuffer)         :rtype: tuple Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'identity': payload.get('identity'),             'role_sid': payload.get('role_sid'),             'date_created': deserialize.rfc2822_datetime(payload.get('date_created')),             'date_updated': deserialize.rfc2822_datetime(payload.get('date_updated')),             'url': payload.get('url'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': payload.get('sid'),         }      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property     def service_sid(self):         """         :returns: The SID of the Service that the resource is associated with         :rtype: unicode         """         return self._properties['service_sid']      @property     def channel_sid(self):         """         :returns: The SID of the Channel the resource belongs to         :rtype: unicode         """         return self._properties['channel_sid']      @property     def identity(self):         """         :returns: The identity of the User that created
Read from the stream and write to the output.          :param int stream_fd: File descriptor of the stream         :param output: Output object         :type output: :class:`Output`         :param bytes prebuffer: Prebuffer to read from the stream Code: def read_stream_async(stream_fd, output, prebuffer):     """     Read from the stream and write to the output.      :param int stream_fd: File descriptor of the stream     :param output:
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, response, solution):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service that the resource is associated with          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init__(version, response)          # Path Solution         self._solution = solution
Code: def handle_stream(plugin, streams, stream_name):           stream_name = resolve_stream_name(streams, stream_name)
Code: def fetch_
Get streams from the plugin          :param interval: Interval to wait between retries         :type interval: int          :param count: Number of retries         :type count: int          :returns: list of streams         :rtype: list Code: def get_streams_with_retry_and_timeout(
Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest
Build an instance of InviteInstance          :param dict payload:
Code: def handle_stream(plugin, streams, stream_name):     if args.json:         console.msg_json(streams[stream_name])     else:         console.msg("Starting stream {0} of {1}", stream_name, plugin.module)         if args.live:             console.msg("Press Ctrl+C to stop")         try:             plugin.set_option("live", args.live)             plugin.set_option("reconnect", args.reconnect)             plugin.set_option("reconnect_streamed", args.reconnect_streamed)             plugin.set_option("reconnect_delay", args.reconnect_delay)             plugin.set_option("reconnect_attempts", args.reconnect_attempts)             plugin.set_option("reconnect_max_delay", args.reconnect_max_delay)             plugin.set_option("reconnect_min_delay", args.reconnect_min_delay)             plugin.set_option("http_headers", args.http_headers)             plugin.set_option("http_cookies", args.http_cookies)             plugin.set_option("http_user_agent", args.http_user_agent)             plugin.set_option("http_referer", args.http_referer)             plugin.set_option("http_proxy", args.http_proxy)             plugin.set_option("http_proxy_user", args.http_proxy_user)             plugin.set_option("http_proxy_pass", args.http_proxy_pass)             plugin.set_option("http_no_proxy", args.http_no_proxy)             plugin.set_option("http_no_proxy_on", args.http_no_proxy_on)             plugin.set_option("http_no_proxy_off", args.http_no_proxy_off)             plugin.set_option("http_timeout", args.http_timeout)             plugin.set_option("http_retries", args.http_retries)             plugin.set_option("http_retry_wait", args.http_retry_wait)             plugin.set_option("http_ssl_verify", args.http_ssl_verify)             plugin.set_option("http_ssl_cert", args.http_ssl_cert)             plugin.set_option("http_
Get the channel members from the channel sid          :param str channel_sid: The channel sid          :returns: The channel members         :rtype: list Code: def _get_channel_messages(self, channel_sid):
Code: def authenticate_twitch_oauth():           client_id = TWITCH_CLIENT_ID     redirect_uri = "https://streamlink.github.io/twitch_oauth.html"     url = ("https://api.twitch.tv/kraken/oauth2/authorize"            "?response_type=token"            "&client_id={0}"            "&redirect_uri={1}"            "&scope=user_read+user_subscriptions
Get an item from the list of resources          :param unicode key: The index of the resource to fetch
Get the user sid from the user name          :param str user_name: User name          :returns: User sid         :rtype: str Code: def _get_channel_sid(self, channel_name):         """         Get the channel sid from the channel name          :param str
Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'role_sid': payload.get('role_sid'),             'identity': payload.get('identity'),             'date_created': deserialize.rfc2822_datetime(payload.get('date_created')),             'date_updated': deserialize.rfc2822_datetime(payload.get('date_updated')),             'url': payload.get('url'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': payload.get('sid'),         }      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property     def service_sid(self):         """         :returns: The SID of the Service that the resource is associated with         :rtype: unicode         """         return self._properties['service_sid']      @property     def channel_sid(self):         """         :returns: The SID of the Channel the resource belongs to         :rtype: unicode         """         return self._properties['channel_sid']      @property     def role_sid(self):         """         :returns: The SID of the Role assigned to the user when they join the Channel         :rtype: unicode         """         return self._properties['role_sid']      @property     def identity(self):
Get stream URL from stream info list          :param list stream_info_list: Stream info list          :returns: str         :rtype: str Code: def _get_
Get the service sid from the service_sid or service_unique_name          :param str service_sid: The service_sid         :param str service_unique_name: The service_unique_name          :
Code: def setup_options():          if args.hls_live_edge:         streamlink.set_option("hls-live-edge", args.hls_live_edge)      if args.hls_segment_attempts:         streamlink.set_option("hls-segment-attempts", args.hls_segment_attempts)      if args.hls_playlist_reload_attempts:         streamlink.set_option("hls-playlist-reload-attempts", args.hls_playlist_reload_attempts)      if args.hls_segment_threads:         streamlink.set_option("hls-segment-threads", args.hls_segment_threads)      if args.hls_segment_timeout:         streamlink.set_option("hls-segment-timeout", args.hls_segment_timeout)      if args.hls_segment_ignore_names:         streamlink.set_option("hls-segment-ignore-names", args.hls_segment_ignore_names)      if args.hls_segment_key_uri:         streamlink.set_option("hls-segment-key-uri", args.hls_segment_key_uri)      if args.hls_timeout:         streamlink.set_option("hls-timeout", args.hls_timeout)      if args.hls_audio_select:         streamlink.set_option("hls-audio-select", args.hls_audio_select)      if args.hls_start_offset:         streamlink.set_option("hls-start-offset", args.hls_start_offset)      if args.hls_duration:         streamlink.set_option("hls-duration", args.hls_duration)      if args.hls_live_restart:         streamlink.set_option("hls-live-restart", args.hls_live_restart)      if args.hds_live_edge:         streamlink.set_option("hds-live-edge", args.hds_live_edge)      if args.hds_segment_attempts:         streamlink.set_option("hds-segment-attempts", args.hds_segment_attempts)      if args.hds_segment_threads:         streamlink.set_option("hds-segment-threads", args.hds_segment_threads)      if args.hds_segment_
Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def page(self, page_token=values.unset, page_number=values.unset,              page_size=values.unset):         """         Retrieve a single page of InviteInstance records from the API.         Request is executed immediately          :param str page_token: PageToken provided by the API         :param int page_number: Page Number, this value is simply for client state         :param int page_size: Number of records to return, defaults to 50          :returns: Page of InviteInstance         :rtype
Code: def _get_stream_id(self, text):                  m = self._image_re.search(text)         if m:             return m.group("stream_id")
Code: def _get_iframe(self, text):                  m = self._iframe_re.
Code: def __setattr__(self, name, value):         if name in self.options:             self.options[
Retrieve a single page of InviteInstance records from the API.         Request is executed immediately          :param str target_url: API-generated URL for the requested results page          :param dict params: Parameters for the request          :returns: Page of InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def get_page(self, target_url, params=values.of()):         """         Retrieve a single page of InviteInstance records from the API.         Request is executed immediately          :param str target_url
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, service_sid, channel_sid, ):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param service_sid: The service_sid          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      @property     def page_size(self):         """         :returns: How many resources to return in each list page. The default is 50, and the maximum is 1000.         :rtype: unicode         """         return self._properties['page_size']      @property     def next_page_url(self):         """         :returns: The URL of the next page in the list         :rtype: unicode         """         return self._properties['next_page_url']      @property     def key(self):         """         :returns: The key         :rtype: unicode         """         return self._properties['key
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, payload, service_sid, channel_sid, sid=None):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'created_by': payload.
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset, links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': sid,             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def date_created(self):         """         :returns: The ISO 8601 date and time in GMT when the resource was created         :rtype: datetime         """         return self._properties['date_created']      @property     def date_updated(self):         """         :returns: The ISO 8601
Code: def load_plugin(self, module_name, file, pathname, desc):         """         Load a plugin from a file.          :param str module_name: Name of the plugin module         :param file file: File object of the plugin module         :param str pathname: Pathname of the plugin module         :param desc: Description of the plugin module          :raises: :class:`streamlink.exceptions.
Code: def __init__(self, version, payload, service_sid, channel_sid,                  sid=None):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'created_by': payload.get('created_by'),             'created_by_identity': payload.get('created_by_identity'),             'role_sid': payload.get('role_sid'),             'date_created': deserialize.rfc2822_datetime(payload.get('date_created')),             'date_updated': deserialize.rfc2822_datetime(payload.get('date_updated')),             'url': payload.get('url'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property     def service_sid(self):         """         :returns: The SID of the Service that the resource is associated with         :rtype: unicode         """         return self._properties['service_sid']      @property     def channel_sid(self):         """         :returns: The SID of the Channel the resource belongs to         :rtype: unicode         """         return self._properties['channel_sid']      @property     def created_by(self):         """         :returns: The identity of the User that created the resource         :
Get an item from the list of resources          :param unicode key: The index of the resource to fetch          :returns: twilio.rest.chat.v2.service.channel.invite.
Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param dict payload: A JSON response from the Twilio API          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init__(version, response=payload, solution=service_sid)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._context      @property     def invites(self):         """         :returns: A list of instances of InviteInstance         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]         """         return self._proxy.invites      @property     def page_size(self):         """         :returns: How many resources to return in each list page. The default is 50, and the maximum is 1000.         :rtype: unicode         """         return self._properties['page_size']      @property     def start(self):         """         :returns: The index of the first resource to return in the response         :rtype: unicode         """         return self._properties['start']      @property     def end(self):         """         :returns: The index of the last resource in the response         :rtype: unicode         """         return self._properties['end']      @property     def uri(self):         """         :returns: The URI of the resource, relative to `https://chat.twilio
Get an item from the list of resources          :param unicode key: The index of the resource to fetch          :returns: twilio.rest.chat.v2.service.channel.invite
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, payload, service_sid, channel_sid, sid=None):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid, }         self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),             'channel_sid': payload.get('channel_sid'),            'service_sid': payload.get('service_sid'),             'identity': payload.get('identity'),             'role_sid': payload.get('role_sid'),             'date_created': deserialize.iso8601_datetime(payload.get('date_created')),             'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')),             'url': payload.get('url'),         }          self._
Create a new InviteInstance instance from a JSON response.          :param dict payload: JSON response from the API          :returns: twilio.rest.chat.
Get an item from the list of resources          :param unicode key: The index of the resource to fetch          :returns: twilio.rest.chat.v2.service
Get an item from the list of resources          :param unicode key: The index of the resource to fetch          :returns:
:returns: Number of resources in the response         :rtype: unicode Code: def __repr
Get an item from the list of resources          :param unicode key: The index of the resource to fetch          :returns: twilio.rest.chat.v2
Get the player URL from the response          :returns: The player URL         :rtype: unicode Code: def _get_player_url(self):         """         Get the player URL from the response          :returns: The player URL         :
Initialize the InvitePage          :param Version version: Version that contains the resource         :param dict payload: A JSON response from the Twilio API          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def __repr__(self):         """         Provide a friendly representation          :returns:
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __getitem__(self, key):         """         Get an item from the list of resources in the response.          :returns: An instance of the resource at the given index, or None if                   that index does not exist.         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         return self.get(key) Doc
Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def dologin(self, email, password, emailauth="", emailsteamid="", captchagid="-1", captcha_text="", twofactorcode=""):                  epassword, rsatimestamp = self.encrypt_password(email, password)          login_data = {             'username': email,             "password": epassword,             "emailauth": emailauth,             "loginfriendlyname": "Streamlink",             "captchagid": captchagid,             "captcha_text": captcha_text,             "emailsteamid": emailsteamid,             "rsatimestamp": rsatimestamp,             "remember_login": True,             "donotcache": self.donotcache,             "twofactorcode": twofactorcode         }          res = self.session.http.post(self._dologin_url, data=login_data)          resp = self.session.http.json(res, schema=self._dologin_schema)          if not resp[u"success"]:             if resp.get(u"captcha_needed"):                 # special case for captcha                 captchagid = resp[u"captcha_gid"]                 log.error("Captcha result required, open this URL to see the captcha: {}".format(                     self._captcha_url.format(captchagid)))                 try:                     captcha_text = self.input_ask("Captcha text")                 except FatalPluginError:                     captcha_text = None
Extract video_height from html          :param str html:
Get the video URL from the stream_info          :param list stream_info: List of stream_info          :returns: str         :rtype: str Code: def get_video_url_from_stream
get channel url from channel sid          :param str channel_sid: Channel sid          :returns: Channel url         :rtype: str Code: def _get_channel_members(self, channel_sid):         '''get channel members from channel sid'''         self.logger.debug('get channel members...')          res = self.session.http.get
Code: def __init__(self, version, service_sid, channel_sid):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the invite belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def stream(self, limit=None, page_size=None):         """         Streams InviteInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until the limit         is reached.         The results are returned as a generator, so this operation is memory efficient.          :param int limit: Upper limit for the number of records to return. stream()                           guarantees to never return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, stream() will attempt to read the                               limit with the most efficient page size, i.e. min(limit, 1000)          :returns: Generator that will yield up to limit results         :rtype: list[
Receive a packet from the server.          :returns: Packet received         :rtype: twilio.rest.chat.v2.service.channel.invite.packet.Packet Code: def _handle_packet(self, packet):         """         Handle a packet from the server.          :param packet: Packet received         :type packet: twilio.rest.chat.v2.service.channel.invite.packet.Packet         """         self.logger.debug('Handling packet: %s', packet)         if packet.type == packet.PONG:             self.pong_received = True         elif packet.type == packet.ERROR:             raise CrunchyrollAPIError(packet.message, packet.code)         elif packet.type == packet.MESSAGE:             self.queue.put(packet)         elif packet.type == packet.INVITE:             self.queue.put(self.get_instance(packet.payload))         elif packet.type == packet.CHANNEL_UPDATE:             self.channel = self.get_instance(packet.payload)         elif packet.type == packet.CHANNEL_DELETED:             self.channel = None         elif packet.type == packet.CHANNEL_MEMBER_UPDATE:             self.channel.members.update(packet.payload)         elif packet.type == packet.CHANNEL_MEMBER_DELETED:             self.
Receive a packet from the server          :returns: The packet received         :rtype: packet.
Constructs a InviteContext          :param role_sid: The role_sid
Code: def _create_api(self):                  if self.options.get("purge_credentials"):             self.cache.set("session_id", None, 0)             self.cache.set("auth", None, 0)             self.cache.set("session_id", None, 0)          # use the crunchyroll locale as an override, for backwards compatibility         locale = self.get_option("locale") or self.session.localization.language_code         api = CrunchyrollAPI(self.cache,                              self.
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, response, solution):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service that the resource is associated with          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init__(version, response)                  # Path Solution         self._solution =
Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def page_of(self):         """         Retrieve a single page of InviteInstance records from the API.         Request is executed immediately          :returns: Page of InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         response = self.version
Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def __getitem__(self, key):         """         Get an item from the list of resources          :param unicode key: The index of the resource to fetch          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         return self.get(key
Code: def readString
Convenience method to access members of the created :class:`InviteInstance`          :param str key: name of member to access         :
Returns true if both instances are not equal, false otherwise          :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def __init__(self, version, payload, service_sid, channel_sid, sid=None):         """         Initialize the InviteInstance          :returns: tw
Set the prefix length to use for encoding and decoding.          :param int prefixLength: The prefix length to use for encoding and decoding.          :returns: The updated Prefix
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __repr__(self):         """
Code: def __init__(self, version, service_sid, channel_sid):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def stream(self, limit=None, page_size=None):         """         Streams InviteInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until the limit         is reached.         The results are returned as a generator, so this operation is memory efficient.          :param int limit: Upper limit for the number of records to return. stream()                           guarantees to never return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, stream() will attempt to read the                               limit with the most efficient page size, i.e. min(limit, 1000)          :returns: Generator that will yield up to limit results         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]         """         limits = self._version.read_limits(limit, page_size)          page = self.page(page_size=limits['page_size'], )          return self._version.stream(page, limits['limit'], limits['page_limit'])      def list(self, limit=None, page_size=None):         """         Lists InviteInstance records from the API as a list.         Unlike stream(), this operation is eager and will load `limit` records into         memory before returning.          :param int
Read a list of tuples from the stream.          :param stream: The stream to read from.         :type stream: io.BytesIO          :returns: The list of tuples read from the stream.         :rtype: list Code: def readDict(self, stream):         """         Read a dictionary from the stream.          :param stream: The stream to read from.         :type stream: io.BytesIO          :returns: The dictionary read from the stream.         :rtype: dict         """         length, symbol = self.decodePeek(stream.peek(self.maxLength))
Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param dict payload: A JSON response from the Twilio API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Marshaled Properties         self._properties = {             'invites': payload.get('invites'),            'meta': payload.get('meta'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._context      @property     def invites(self):         """         :returns: The list of Invites         :rtype: unicode         """         return self._properties['invites']      @property     def meta(self):         """         :returns: The response metadata         :rtype: dict         """         return self._properties['meta']      def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         return '<Twilio.IpMessaging.V2.InviteList>'   class InvitePage(Page):     """ PLEASE NOTE that this class contains preview products that are subject     to change. Use them with caution. If you currently do not have developer     preview access, please contact <EMAIL>. """      def __init__(self, version, response, solution):         """         Initialize the InvitePage          :param Version version: Version that contains the resource
Code: def __getitem__(self, key):         """         Get an item or
Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param dict payload: A JSON response from the Twilio API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Marshaled Properties         self._properties = {             'invites': payload.get('invites'),            'meta': payload.get('meta'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,         }      @property     def invites(self):         """         :returns: The list of Invites         :rtype: unicode         """         return self._properties['invites']      @property     def meta(self):         """         :returns: The response metadata         :rtype: dict         """         return self._properties['meta']      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._context      def __call__(self, sid):         """         Constructs a InviteContext          :param sid: The unique string that identifies the resource          :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         return InviteContext(             self._version,             service_sid=self._solution['service_sid'],             channel_sid=self._solution['channel_sid'],             sid=sid,         )      def __repr__(self
1. If index is 0, return 1, 0. 2. If index is less than or equal to RLEMAX, return (1<<index)+extra, 0. 3. Otherwise, return 1, index-RLEMAX. Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param dict payload: A JSON response from the Twilio API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Marshaled Properties         self._properties = {             'invites': payload.get('invites'),            'meta': payload.get('meta'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,         }      @property     def invites(self):         """         :returns: The list of Invites         :rtype: unicode         """         return self._properties['invites']      @property     def meta(self):         """         :returns: The response metadata         :rtype: dict         """         return self._properties['meta']      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._context      @property     def channel_sid(self):         """         :returns: The SID of the Channel the resource is associated with         :rtype: unicode         """         return self._properties['channel_sid']      @property     def service_sid(self):         """         :returns: The SID of the Service that the resource
Get an item from the list of resources          :param unicode key: The index of the resource to fetch          :returns: twilio.rest.chat.v2.service.channel.
Code: def __str__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         return
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._invites = None         self._members = None         self._messages = None         self._webhooks = None      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = InviteList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._invites      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, service_sid, channel_sid, ):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      @property     def page_size(self):         """         :returns: How many resources to return in each list page. The default is 50, and the maximum is 1000.         :rtype: unicode         """         return self._properties['page_size']      @property     def next_page_url(self):         """         :returns: The URL of the next page in the list         :rtype: unicode         """         return self._properties['next_page_url']      @property
Code: def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         context =''.join('{}={}'.format(k, v) for k, v in
Read a prefix code.          :param int blockType: Block type          :returns: Prefix code         :rtype: list Code: def readPrefixArray(self, blockType, numberOfTrees):         """         Read a prefix code list.          :param int blockType: Block type         :param int numberOfTrees: Number of trees         """         self.prefixCodes[blockType] = []         for tree in range(numberOfTrees):             self.prefixCodes[
Code: def _read_message(self, message_type):         """         Read a message from the stream.          :param int message_type: The message type to read.          :returns: A Message instance.         :rtype: twilio.rest.chat.v2.service.channel.message.MessageInstance         """         if message_type == Message.MESSAGE_TYPE_TEXT:             return self._read_text_message()         elif message_type == Message.MESSAGE_TYPE_MEDIA:             return self._read_media_message()         elif message_type == Message.MESSAGE_TYPE_COMMAND:             return self._read_command_message()         elif message_type == Message.MESSAGE_TYPE_NOTIFICATION:             return self._read_notification_message()         elif message_type == Message.MESSAGE_TYPE_PUSH:             return self._read_push_message()         elif message_type == Message.MESSAGE_TYPE_APNS:             return self._read_apns_message()         elif message_type == Message.MESSAGE_TYPE_GCM:             return self._read_gcm_message()         elif message_type == Message.MESSAGE_TYPE_APNS_FEEDBACK:             return self._read_apns_feedback_message()         elif message_type == Message.MESSAGE_TYPE_GCM_FEEDBACK:             return self._read_gcm_feedback_message()         elif message_type == Message.MESSAGE_TYPE_APNS_ERROR:             return self._read_apns_error_message()         elif message_type == Message.MESSAGE_TYPE_GCM_ERROR:             return self._read_gcm_error_message()         elif message_type == Message.MESSAGE_TYPE_APNS_FEEDBACK_ERROR:             return self._read_apns_feedback_error_message()         elif message_type == Message.MESSAGE_TYPE_GCM_FEEDBACK_ERROR:             return self._read_gcm_feedback_error_message()         elif message_type == Message.MESSAGE_TYPE_APNS_FEEDBACK_RETRY:             return self._read_apns_feedback_retry_message()         elif message_type == Message.MESSAGE_TYPE_GCM_FEEDBACK_RETRY:             return self._read_gcm_feedback_retry_message()         elif message_type == Message.MESSAGE_TYPE_APNS_ERROR_
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, response, solution):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.
Read a list of blocks of data of the given type.          :param str kind: The type of block to read.          :returns: The list of blocks of data.         :rtype: list[bytes] Code: def _read_block_type_list_list(self, kind):         """         Read a list of lists of blocks of data of the given type.          :param str kind: The type of block to read.          :returns: The list of lists of blocks of data.         :rtype: list[list[bytes]]         """         NBLTYPES = self.numberOfBlockTypes
Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InviteList          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Marshaled Properties         self._properties = {             'invites': payload.get('invites'),            'meta': payload.get('meta'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,         }      @property     def invites(self):         """         :returns: The list of Invites         :rtype: unicode         """         return self._properties['invites']      @property     def meta(self):         """         :returns: The response metadata         :rtype: dict         """         return self._properties['meta']      def __repr
Read a prefix code from the stream.          :param alphabet: Alphabet to use for reading the code         :type alphabet: Alphabet Code: def readPrefixCode(self, alphabet):         """         Read a prefix code from
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __str__(self):         """         Provide a friendly representation          :returns: Machine friendly
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __str__(self):         """         Provide a friendly representation          :returns: Machine friendly
Code: def arrow_array_from_numpy_array(array):     if array.dtype.kind == 'M':         return pyarrow.array(array.astype('datetime64[ns]'))     elif array.dtype.kind == 'O':         return pyarrow.array(array.astype('string'))     else:         return pyarrow.array(array)
Adds method f to the Dataset class          :param f: The method to add to the Dataset class          :returns: The method f         :rtype: function Code: def __init__(self, version, service_sid, channel_sid):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def create(self, identity, role_sid=values.unset,                type=values.unset, url=values.unset, ttl=values.unset):         """         Create a new InviteInstance          :param unicode identity: The `identity` value that identifies the new resource's User         :param unicode role_sid: The SID of the Role to assign to the new resource         :param unicode type: The type of push notification to send to the new resource's User         :param unicode url: The absolute URL of the new resource         :param unicode ttl: The amount of time, in seconds, that the new resource is valid          :returns: Newly created InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         data = values.of({             'Identity': identity,             'RoleSid': role_sid,             'Type': type,             'Url': url,             'Ttl': ttl,         })          payload = self._version.create(             'POST',             self._uri,             data=data,         )          return InviteInstance(             self._version,             payload,             service_sid=self._solution['service_sid'],             channel_sid=self._solution['channel_sid'],         )      def stream(self, limit=None, page_size=None):
Code: def add_virtual_columns_cartesian_velocities_to_pmvr(self, x="x", y="y", z="z", vx="vx", vy="vy", vz="vz", vr="vr", pm_long="pm_long", pm_lat="pm_lat", distance=None):          if distance is None:         distance = "sqrt({x}**2+{y}**2+{z}**2)".format(**locals())     k = 4.74057     self.add_variable("k", k, overwrite=False)     self.add_virtual_column(vr, "({x}*{vx}+{y}*{vy}+{z}*{vz})/{distance}".format(**locals()))     self.add_virtual_column(pm_long, "-({vx}*{y}-{x}*{vy})/sqrt({x}**2+{y}**2)/{distance}/k".format(**
Code: def add_virtual_columns_proper_motion2vperpendicular(self, distance="distance", pm_long="pm_l", pm_lat="pm_b",                                                      vl="vl", vb="vb",                                                      propagate_uncertainties=False,                                                      radians=False):          k = 4.74057     self.add_variable("k", k, overwrite=False)     self.add_virtual_column(vl, "k*{pm_long}*{distance}".format(**locals()))     self.add_virtual_column(vb, "k* {pm_lat}*{distance}".format(**locals()))     if propagate_uncertainties:         self.propagate_uncertainties([self[vl
Code: def __iter__(self):         """         :returns: Iterator for list of invites         :rtype: list[twilio.rest.chat
Get the value at the given index          :param int index: Index of the value to get          :returns: Value at the given index         :rtype: object Code: def _get_value_at(self, index):         """         Get the value at
Code: def __init__(self, ds, expression, name=None):         super(Map, self).__init__(ds, expression, name
Code: def __init__(self, *args, **kwargs):         super(VaexApp, self).__init__(*args, **kwargs)         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')         self.logger.info('Initializing VaexApp')
Code: def open_many(filenames):          dfs = []     for filename in filenames:         filename = filename.strip()         if filename and filename[0]!=
Create a new Channel from an Astropy Table.          :param table: Astropy Table         :type table: astropy.table.Table          :returns: twilio.rest.chat.v2.service.channel.ChannelInstance         :rtype: twilio.rest.chat.v2.service.channel.ChannelInstance Code: def from_json(raw):     """     Create a new Channel from a JSON string.      :param raw: JSON string     :type raw: str      :returns: twilio.rest.chat.v2.service.channel.ChannelInstance     :rtype: twilio.rest.chat.v2
Code: def from_astropy_table(table):          import vaex.file.other     return vaex.file.
Code: def from_arrays(**arrays):          import numpy as np     import
Initialize the InvitePage          :param list[unicode] identity: The identity of the User that created the Invite         :param unicode role_sid: The SID of the Role assigned to the User that created the Invite         :param unicode last_consumed_message_index: The index of the last Message that the User in this Channel has read         :param unicode last_consumption_timestamp: The RFC 2822 date and time in GMT
Code: def from_pandas(df, name="pandas", copy_index=True, index_name="index"):          import six     vaex_df = vaex.dataframe.DataFrameArrays(name)      def add(name, column):         values = column.values         try:             vaex_df.add_column(name, values)         except Exception as e:             print("could not convert column %s, error:
Code: def from_excel(filename_or_buffer, sheet_name=0, header=0, index_col=None, parse_dates=False, squeeze=False, na_values=None, keep_default_na=True, verbose=False, skip_footer=0, converters=None, true_values=None, false_values=None, skiprows=None, nrows=None, na_filter=True, parse_cols=None, date_parser=None, thousands=None, comment=None, skipinitialspace=False, encoding=None, engine=None, converter_errors='strict', skipfooter=0, sheet_name=None, mangle_dupe_cols=True, **kwds):     """     Read Excel file into DataFrame.      Parameters     ----------     filename_or_buffer : file path or file-like object         File path or object to read.     sheet_name : int, str, list, tuple, or dict, default 0         Name or index of sheet(s) to read, if a dict is passed, the keys         indicate the sheet names and the values the corresponding indexes.     header : int, list of ints, default 0         Row(s) to use as the column names, also accepts a list of         row indices (zero-indexed). If this is None, and there is only         one non-whitespace row in the file, then column names will be         ``'X', 'X.1', 'X.2',...``     index_col : int, list of ints, str, or False, default 0         Column(s) to use as the row labels of the DataFrame. If a         sequence is given, a MultiIndex is used. If False, no index is         used. If None, and `header` and `index_col` are both non-None,         then the values in `header` are used for both.     parse_dates : boolean, list, or dict, default False         - If boolean, determines if columns can be parsed to dates.         - If list or dict, determines which columns can be parsed to           dates, using the keys as a subset of the column names, and the           values as the names of the columns.     squeeze : boolean, default False         If the parsed data only contains one column then return a Series.     na_values : scalar,
Get an item from the list of resources          :param unicode key: The index of the resource to fetch          :returns
Code: def zeldov
Concatenate a list of DataFrames.          :rtype: DataFrame Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['account_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,         }          self._solution = {             'account_sid': account_sid,            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property     def service_sid(self):         """         :returns: The SID of the Service that the resource is associated with         :rtype: unicode         """         return self._properties['service_sid']      @property     def channel_sid(self):         """         :returns: The SID of the Channel the resource belongs to         :rtype: unicode         """         return self._properties['channel_sid']      @property     def date_created(self):         """         :returns: The RFC 2822 date and time in GMT when the resource was created         :rtype: datetime         """
Code: def __init__(self, service_sid, channel_sid, version):         """         Initialize the InviteList          :param unicode service_sid: The SID of the Service to fetch the resources from         :param unicode channel_sid: The SID of the Channel the resource to fetch belongs to         :param Version version: Version that contains the resource          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def stream(self, limit=None, page_size=None):         """         Streams InviteInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until the limit         is reached.         The results are returned as a generator, so this operation is memory efficient.          :param int limit: Upper limit for the number of records to return. stream()                           guarantees to never return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, stream() will attempt to read the                               limit with the most efficient page size, i.e. min(limit, 1000)          :returns: Generator that will yield up to limit results         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]         """         limits = self._version.read_limits(limit, page_size)          page = self.page(page_size=limits['page_size'], )          return self._version.stream(page, limits['limit'], limits['page_limit'])      def list(self, limit=None, page_size=None):         """         Lists InviteInstance records from the API as a list.         Unlike stream(), this operation is eager and will load `limit` records into         memory before returning.          :
Open a dataset from a URL.          :param str url: URL to the dataset file.         :rtype: vaex.dataset.Dataset Code: def open_dataset_from_url(self, url):         """Open a dataset from a URL.          :param str url: URL to the dataset file.         :rtype: vaex.dataset.Dataset         """         dataset = vaex.open(url, thread_mover=self.call_in_main_thread)         self.add_recently
Code: def __init__(self, version, payload, service_sid, channel_sid, ):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version                  self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,         }                  self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'identity': payload.get('identity'),             'role_sid': payload.get('role_sid'),             'date_created': deserialize.iso8601_datetime(payload.get('date_created')),             'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')),             '
Build an instance of MessageInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.message.MessageInstance         :rtype: twilio.rest.chat.v2.service
Get the column values for this selection          :param pandas.DataFrame ds: Dataset to get column values for          :returns: dict of column names to values         :rtype: dict Code: def _get_column_values_for_index(self, ds, index):         '''Get the column values for this selection at the given index'''         column_values = {}         for expression in self.expressions:             expression = ds._
Send a packet to the server.          :param packet: The packet to send         :type packet: :class:`vaex.execution.packet.Packet` Code: def _receive_packet(self, packet):         """         Receive a packet from the server.          :param packet: The packet to receive         :type packet: :class:`vaex.execution.packet.Packet`         """         if packet.type == packet.PONG:             self.pong_received = True         elif packet.type == packet.ERROR:             self.logger.error(packet.message)             self.queue.put(None)         elif packet.type == packet.RESULT:             self.queue.put(packet.result)         elif packet.type == packet.PROGRESS:             self.
Code: def _on_message_received(self, message):         """         Handle a message received from the server.          :param Message message: The message received from the server         """         self.logger.debug('Received message: %s', message)         if message.type =='message':             self.emit(QtCore.SIGNAL('messageReceived(PyQt_PyObject)'), message)         elif message.type == 'invite':             self.emit(QtCore.SIGNAL('inviteReceived(PyQt_PyObject)'), message)         elif message.type == 'command':             self.emit(QtCore.SIGNAL('commandReceived(PyQt_PyObject)'), message)         elif message.type == 'typing':             self.emit(QtCore.SIGNAL('typingIndicatorReceived(PyQt_PyObject)'), message)         elif message.type == 'user_typing':             self.emit(QtCore.SIGNAL('userTypingIndicatorReceived(PyQt_PyObject)'), message)         elif message.type == 'deleted':             self.emit(QtCore.SIGNAL('messageDeleted(PyQt_PyObject)'), message)         elif message.type =='read':             self.emit(QtCore.SIGNAL('messageRead(PyQt_PyObject)'), message)         elif message.type == 'channel_update':             self.emit(QtCore.SIGNAL('channelUpdated(PyQt_PyObject)'), message)         elif message.type =='service_update':             self.emit(QtCore.SIGNAL('serviceUpdated(PyQt_PyObject)'), message)         elif message.type =='member_update':             self.emit(QtCore.SIGNAL('memberUpdated(PyQt_PyObject)'), message)         elif message.type =='member_removed':             self.emit(QtCore.SIGNAL('memberRemoved(PyQt_PyObject)'), message)         elif message.type =='member_joined':             self.emit(QtCore.SIGNAL('memberJoined(PyQt_PyObject)'), message)         elif message.type == 'channel_deleted':             self.emit(QtCore.SIGNAL('channelDeleted(PyQt_PyObject)'), message)         elif message.type =='service_deleted':             self.emit(QtCore.SIGNAL('serviceDeleted(PyQt_PyObject)'), message)         elif message.type == 'role_updated':             self.emit(QtCore.SIGNAL('roleUpdated(PyQt_PyObject)'), message)
Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def getinfo(filename, seek=None): 	 	DESC = '=I4sII'                                # struct formatting string 	HEAD = '=I6I6dddii6iiiddddii6ii60xI'        # struct formatting string 	keys = ('Npart', 'Massarr', 'Time', 'Redshift', 'FlagSfr', 'FlagFeedback', 'Nall', 'FlagCooling', 'NumFiles', 'BoxSize', 'Omega0', 'OmegaLambda', 'HubbleParam', 'FlagAge', 'FlagMetals', 'NallHW', 'flag_entr_ics', 'filename') 	f = open(filename, 'rb') 	 	 	firstbytes = struct.unpack('I',f.read(4)) 	if firstbytes[0] == 8: 		gtype = 2 	else: 		gtype = 1 	if gtype == 2: 		f.seek(16) 	else: 	 	f.seek(0) 	if seek is not None: 		f.seek(seek) 	raw = struct.unpack(HEAD,f.read(264))[1:-1] 	values = (raw[:6], raw[6:12]) + raw[12:16] + (raw[16:22],) + raw[22:30] + (raw[30:36], raw[36
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, service_sid):         """         Initialize the ServiceContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Sync Service to fetch          :returns: twilio.rest.sync.v1.service.ServiceContext         :rtype: twilio.rest.sync.v1.service.ServiceContext         """         super(ServiceContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, }         self._uri = '/Services/{service_sid}'.format(**self._solution)          # Dependents         self._documents = None         self._sync_lists = None         self._sync_maps = None         self._sync_streams = None      @property     def documents(self):         """         Access the documents          :returns: twilio.rest.sync.v1.service.document.DocumentList         :rtype: twilio.rest.sync.v1.service.document.DocumentList         """         if self._documents is None:             self._documents = DocumentList(                 self._version,                 service_sid=self._solution['service_sid'],             )         return self._documents      @property     def sync_lists(self):         """         Access the sync_lists          :returns: twilio.rest.sync.v1.service.sync_list.SyncListList         :rtype: twilio.rest.sync.v1.service.sync_list.SyncListList         """         if self._sync_lists is None:             self._sync_lists = SyncListList(                 self._version,                 service_sid=
Update the plot layout          :param dict data: Data to update the plot with Code: def _replot_layout(self, data):
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __unicode__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         return unicode(self
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __call__(self, key):         """         Convenience method to access child resources          :returns: If key is None, returns the list instance.  If key is provided,             returns the element
Returns the dtype of a block, or None if it is not a masked array Code: def _get_block_size(self, block): 	'''Returns the size of a block, or None

Code: def _first_calculation(self, expression, order_expression, binby, limits, shape, selection, edges, progressbar):         if selection is None:             selection = np.ones(len(self), dtype=np.bool)         if edges:             raise ValueError("edges not implemented for first")         if binby is None:             binby = []         if len(binby) == 0:             if order_expression is None:                 order_expression = expression             if order_expression is None:                 raise ValueError("expression or order_expression must be given")             if isinstance(order_expression, basestring):                 order_expression = [order_expression]             if len(order_expression)!= 1:                 raise ValueError("only one order_expression allowed")             order_expression = order_expression[0]             if order_expression not in self.get_column_names(virtual=True):                 raise ValueError("order_expression must be a valid column name")             if expression is None:                 expression = order_expression             if expression not in self.get_column_names(virtual=True):                 raise ValueError("expression must be a valid column name")             if expression == order_expression:                 raise ValueError("expression and order_expression must be different")             if not self.is_virtual_column(order_expression):                 raise ValueError("order_expression must be a virtual column")             if not self.is_virtual_column(expression):                 raise ValueError("expression must be a virtual column")             if self.is_filtered():                 selection = self.evaluate_selection_mask(selection, expression)             if self.filtered:                 selection = self.evaluate_selection_mask(selection, order_expression)             if self.filtered:                 selection = self.evaluate_selection_mask(selection, expression)             if self.filtered:                 selection = self.evaluate_selection_mask(selection, order_expression)             if self.filtered:                 selection = self.evaluate_selection_mask(selection, expression)             if self.filtered:                 selection = self.evaluate_selection_mask(selection, order_expression)             if self.filtered:                 selection = self.evaluate_selection_mask(selection, expression)             if self.filtered:                 selection = self.evaluate_selection_mask(selection, order_expression)             if self.filtered:
Code: def min(self, expression, binby=[], limits=None, shape=default_shape, selection=False, delay=False, progress=None, edges=False):                  return self._compute_agg('min', expression, binby, limits, shape, selection, delay, edges, progress)         logger.debug("min of %r, with binby=%r, limits=%r, shape=%r, selection=%r, delay=%r", expression, binby, limits, shape, selection, delay)         expression = _ensure_
Code: def _sum_calculation(self, expression, binby=[], limits=None, shape=default_shape, selection=False, progressbar=None):         if selection:             raise ValueError("cannot sum with a selection")         if not binby:             binby = []         if not limits:             limits = [None] * len(binby)         if not shape:             shape = default_shape         if not progressbar:             progressbar = vaex.utils.progressbars(False)         if not self.filtered:             filtered = False         else:             filtered = True         if not self.filtered:             filtered = False         else:             filtered = True         if not self.filtered:             filtered = False         else:             filtered = True         if not self.filtered:             filtered = False         else:             filtered = True         if not self.filtered:             filtered = False         else:             filtered = True         if not self.filtered:             filtered = False         else:             filtered = True         if not self.filtered:             filtered = False         else:             filtered = True         if not self.filtered:             filtered = False         else:             filtered = True         if not self.filtered:             filtered = False         else:             filtered = True         if not self.filtered:             filtered = False         else:             filtered = True         if not self.filtered:             filtered = False         else:             filtered = True         if not self.filtered:             filtered = False         else:             filtered = True         if not self.filtered:             filtered = False         else:             filtered = True         if not self.filtered:             filtered = False         else:             filtered = True         if not self.filtered:             filtered = False         else:             filtered = True         if not self.filtered:             filtered = False         else:             filtered = True         if not self.filtered:             filtered = False         else:             filtered = True         if not self.filtered:             filtered = False         else:             filtered = True         if not self.filtered:             filtered = False         else:             filtered = True         if not self.filtered:             filtered = False         else:             filtered = True         if not self.filtered:             filtered = False         else:             filtered = True         if not self.filtered:             filtered = False         else:             filtered = True         if not self.filtered:
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset, date_created=values.unset, date_updated=values.unset, by=values.unset, from_=values.unset, to=values.unset, url=values.unset, links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['account_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'by': by,             'from': from_,             'to': to,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {             'account_sid': account_sid,            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']
Code: def _expand_shape(shape, ndim):         if shape is None:             return (1,) * ndim         if _issequence(shape
Code: def minmax(self, expression, binby=[], limits=None, shape=default_shape, selection=False, delay=False, progress=None):                  # vmin  = self._compute_agg('min', expression, binby, limits, shape
Code: def std(self, expression, binby=[], limits=None, shape=default_shape, selection=False, delay=False, progress=None, edges=False):                  return self._compute_agg('std', expression, binby, limits, shape, selection, delay, edges, progress)         @delayed         def finish(result):             return result[..., 0]         return self._delay(delay, finish(self.std(expression, binby=binby, limits=limits, shape=shape, selection=selection, delay=delay
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset, date_created=values.unset, date_updated=values.unset, created_by=values.unset, url=values.unset, links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': None,            'service_sid': service_sid,             'channel_sid': channel_sid,             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property     def service
Code: def plot_widget(self, x, y, z=None, grid=None, shape=256, limits=None, what="count(*)", figsize=None,                     f="identity", figure_key=None, fig=None, axes=None, xlabel=None, ylabel=None, title=None,                     show=True, selection=[None, True], colormap="afmhot", grid_limits=None, normalize="normalize",                     grid_before=None,                     what_kwargs={}, type="default",                     scales=None,
Code: def healpix_sum(self, expression=None, healpix_expression=None, healpix_max_level=12, healpix_level=8, binby=None, limits=None, shape=default_shape, delay=False, progress=None, selection=None):                  # if binby is None:         import healpy as hp         if healpix_expression is None:             if self.ucds.get("source_id", None) =='meta.id;meta.main':  # we now assume we have gaia data                 healpix_expression = "source_id/
Code: def healpix_plot(self, healpix_expression="source_id/34359738368", healpix_max_level=12, healpix_level=8, what="count(*)", selection=None,                      grid=None,                      healpix_input="equatorial", healpix_output="galactic", f=None,                      colormap="afmhot", grid_limits=None, image_size=800, nest=True,                      figsize=None, interactive=False, title="", smooth=None, show=False, colorbar=True,                      rotation=(0, 0, 0), **kwargs):                  # plot_level = healpix_level #healpix_max_level-reduce_level         import healpy as hp         import pylab as plt         if grid is None:             reduce_level = healpix_max_level - healpix_level             NSIDE = 2**healpix_level             nmax = hp.nside2npix(NSIDE)             # print nmax, np.sqrt(nmax)             scaling = 4**reduce_level             # print nmax             epsilon = 1. / scaling / 2             grid = self._stat(what=what, binby="%s/%s" % (healpix_expression, scaling), limits=[-epsilon, nmax - epsilon], shape=nmax, selection=selection)         if grid_limits:             grid_min, grid_max = grid_limits         else:             grid_min = grid_max = None         f_org = f         f = _parse_f(f)         if smooth:             if nest:                 grid = hp.reorder(grid, inp="NEST", out="RING")                 nest = False             # grid[np.isnan(grid)] = np.nanmean(grid)             grid = hp.smoothing(grid, sigma=np.radians(smooth))         fgrid = f(grid)         coord_map = dict(equatorial='C', galactic='G', ecliptic="E")         fig = plt.gcf()         if figsize is not None:             fig.set_size_inches(*figsize)         what_label = what         if f_org:             what_
3D plot of a DataFrame.          :param str x: Column name for x-axis         :param str y: Column name for y-axis         :param str z: Column name for z-axis         :param str vx: Column name for x-axis velocity         :param str vy: Column name for y-axis velocity         :param str vz: Column name for z-axis velocity         :param str vwhat: Column name for velocity vector length         :param list limits: List of 6 values, defining the limits of the plot.                             The order is [xmin, xmax, ymin, ymax, zmin, zmax]         :param list grid: List of 6 values, defining the grid of the plot.                           The order is [nx, ny, nz, xmin, xmax, ymin, ymax, zmin, zmax]         :param str what: Column name for the density of the plot.                          If not given, defaults to count(*)         :param int shape: Number of points per dimension of the grid         :param list selection: List of boolean expressions to apply to the                                DataFrame before plotting.         :param function f: Function to apply to the DataFrame before plotting.         :param list vcount_limits: List of 2 values, defining the limits of the                                    velocity vector length.         :param int smooth_pre: Number of points to smooth the data before                                plotting.         :param int smooth_post: Number of points to smooth the data after                                 plotting.         :param list grid_limits: List of 6 values, defining the limits of the                                  grid. The order is [xmin, xmax, ymin, ymax, zmin, zmax]         :param str normalize: Normalization of the density.                               Possible values are: 'normalize', 'none'         :param str colormap: Colormap to use for the density.                              Possible values are: 'afmhot', 'autumn', 'binary', 'bone', 'cool', 'copper', 'flag', 'gist_earth', 'gist_gray', 'gist_heat', 'gist_ncar', 'gist_rainbow', 'gist_stern', 'gist_yarg', 'gnuplot', 'gnuplot2', 'gray', 'hot', 'hsv', 'jet', 'pink', 'prism','spring','summer', 'winter'         :param str figure_key: Key to use for
Evaluate an expression on the data.          :param str expression: The expression to evaluate.         :param int start: The index of the first row to evaluate.         :param int end: The index of the last row to evaluate.         :param bool filtered: Whether to filter the data before evaluating.          :returns: The result of the evaluation.         :rtype: object Code: def _evaluate(self, expression, start, end):         """         Evaluate an expression on the data.          :param str expression: The expression to evaluate.         :param int start: The index of the first row to evaluate.         :param int end: The index of the last row to evaluate.          :returns: The result of the evaluation.         :rtype: object         """         if not isinstance(expression, six.string_types):             raise TypeError('expression must be a string')         if not isinstance(start, int):             raise TypeError
Code: def get_server_url_for_path(self, path):         if self.is_local():             return self.path         else:             server = self.server             return "http://%s:%s%s" % (server.hostname, server.port, server.base_path + path)
Code: def state_set(self, state):         """Set the state of the dataset from a dict.          :param dict state: The state dict to set the dataset to.         """         self.logger.debug("restoring state: %r", state)         self.column_names = state.get('column_names', [])         self.virtual_columns = state.get('virtual_columns', {})         self.variables = state.get('variables', {})         self.functions = state.get('functions', {})         self.selections = state.get('selections', {})         self.ucds = state.get('ucds', {})         self.units = state.get('units', {})         self.descriptions = state.get('descriptions', {})         self.description = state.get('description', '')         self.column_units = state.get('column_units', {})         self.column_descriptions = state.get('column_descriptions', {})         self.column_ucds = state.get('column_ucds', {})         self.column_aliases = state.get('column_aliases', {})         self.column_virtual_types = state.get('column_virtual_types', {})         self.column_virtual_functions = state.get('column_virtual_functions', {})         self.column_virtual_expressions = state.get('column_virtual_expressions', {})         self.column_virtual_imports = state.get('column_virtual_imports', {})         self.column_virtual_modules = state.get('column_virtual_modules', {})         self.column_virtual_module_names = state.get('column_virtual_module_names', {})         self.column_virtual_module_versions = state.get('column_virtual_module_versions', {})         self.column_virtual_module_dependencies = state.get('column_virtual_module_dependencies', {})         self.column_virtual_module_dependencies_versions = state.get('column_virtual_module_dependencies_versions', {})         self.column_virtual_module_dependencies_versions_hashes = state.get('column_virtual_module_dependencies_versions_hashes', {})         self.column_virtual_module_dependencies_versions_hashes_signatures = state.get('column_virtual_module_dependencies_versions_hashes_signatures', {})         self.
Code: def _rename(self, old, new):         """Rename a column"""         if old == new:             return         if old in self.column_names:             index = self.column_names.index(old)             self.column_names[index] = new         if old in self.virtual_columns:             self.virtual_columns[new] = self.virtual_columns.pop(old)         if old in self.expressions:             self.expressions[new] = self.expressions.pop(old)         if old in self.virtual_masked_columns:             self.virtual_masked_columns[new] = self.virtual_masked_columns.pop(old)         if old in self.virtual_columns_dropped:             self.virtual_columns_dropped[new] = self.virtual_columns_dropped.pop(old)         if old in self.virtual_columns_selected:             self.virtual_columns_selected[new] = self.virtual_columns_selected.pop(old)         if old in self.virtual_columns_filtered:             self.virtual_columns_filtered[new] = self.virtual_columns_filtered.pop(old)         if old in self.virtual_columns_string:             self.virtual_columns_string[new] = self.virtual_columns_string.pop(old)         if old in self.virtual_columns_arithmetic:             self.virtual_columns_arithmetic[new] = self.virtual_columns_arithmetic.pop(old)         if old in self.virtual_columns_math:             self.virtual_columns_math[new] = self.virtual_columns_math.pop(old)         if old in self.virtual_columns_boolean:             self.virtual_columns_boolean[new] = self.virtual_columns_boolean.pop(old)         if old in self.virtual_columns_datetime:             self.virtual_columns_datetime[new] = self.virtual_columns_datetime.pop(old)         if old in self.virtual_columns_string_list:             self.virtual_columns_string_list[new] = self.virtual_columns_string_list.pop(old)         if old in self.virtual_columns_string_categorical:             self.virtual_columns_string_categorical[
Build an instance of InviteInstance          :param dict payload: Payload response from the API          :returns: twilio.rest.chat.v2.
Code: def write_meta(self):         """Write the meta information to disk"""         path = os.path.join(self.get_private_dir(create=True), "meta.yaml")         meta_info = dict(             name=self.name,             description=self.description,             units=self.units,             ucds=self.ucds,             variables=self.variables,             virtual_columns=self.virtual_columns,             column_names=self.column_names,             column_units=self.column_units,             column_ucds=self.column_ucds,             column_descriptions=self.column_descriptions,             column_types=self.column_types,             column_virtual_types=self.column_virtual_types,             column_virtual_functions=self.column_virtual_functions,             column_virtual_units=self.column_virtual_units,             column_virtual_ucds=self.column_virtual_ucds,             column_virtual_descriptions=self.column_virtual_descriptions,             column_virtual_meta=self.column_virtual_meta,             column_virtual_meta_functions=self.column_virtual_meta_functions,             column_virtual_meta_units=self.column_virtual_meta_units,             column_virtual_meta_ucds=self.column_virtual_meta_ucds,             column_virtual_meta_descriptions=self.column_virtual_meta_descriptions,             column_virtual_meta_meta=self.column_virtual_meta_meta,             column_virtual_meta_meta_functions=self.column_virtual_meta_meta_functions,             column_virtual_meta_meta_units=self.column_virtual_meta_meta_units,             column_virtual_meta_meta_ucds=self.column_virtual_meta_meta_ucds,             column_virtual_meta_meta_descriptions=self.column_virtual_meta_meta_descriptions,             column_virtual_meta_meta_meta=self.column_virtual_meta_meta_meta,             column_virtual_meta_meta_meta_functions=self.column_virtual_meta_meta_meta_functions,             column_virtual_meta_meta_meta_units=self.column_virtual_meta_meta
Code: def _read_meta(self):         # raise NotImplementedError         path = os.path.join(self.get_private_dir(create=True), "meta.yaml")         if os.path.exists(path):             meta_info = vaex.utils.read_json_or_yaml(path)             self.description = meta_info.get("description", "")             self.ucds = meta_info.get("ucds", {})             self.units = meta_info.
Code: def __init__(self, *args, **kwargs):
Convenience method for `get(key)`          :param key: The unique string that identifies the resource          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         context =''.join('{}={}'.format(k, v) for k, v in self._solution.items())         return '<Twilio.Ip
Convenience method providing a common interface for accessing this domain's         Invites resources.  The following are valid ways to call this resources:         .. code-block:: python              from twilio.rest.chat.v2.service.channel import InviteList             from twilio.rest.chat.v2.service.channel import InvitePage             from twilio.rest.chat.v2.service.channel import InviteContext              list_resource = InviteList(version, service_sid, channel_sid)             page_resource = InvitePage(version, service_sid, channel_
Code: def __getattribute__(self, item):         """         Provides a friendly representation          :returns: Operational friendly representation         :rtype: str         """         context = None         if hasattr(self, '_proxy'):             context = self._proxy         else:             context = self._context         if
Code: def to_items(self, column_names=None, selection=None, strings=True, virtual=False):         """         Return a list of tuples representing the object's attributes.          :param list column_names: The list of attributes to return.         :param list selection: The list of attributes to return.         :param bool strings: Whether to return strings or unicode.         :param bool virtual: Whether to return virtual attributes.          :returns: A list of tuples representing the object's attributes.         :rtype: list[tuple]         """         if column_names is None:             column_names = self.columns         if selection is None:             selection = self.attributes         if not isinstance(column_names, list):             column_names = [column_names]         if not isinstance(selection, list):             selection = [selection]         if not column_names:             column_names = selection         if not selection:             selection = column_names         if not isinstance(strings, bool):             raise ValueError('strings must be a boolean')         if not isinstance(virtual, bool):             raise ValueError('virtual must be a boolean')         items = []         for name in column_names:             if name in selection:                 if name in self.attributes:                     if strings:                         items.append((name, self.attributes[name]))                     else:                         items.append((name, self.attributes[name].to_unicode()))                 elif name in self.virtual_attributes:                     if strings:                         items.append((name, self.virtual_attributes[name]))                     else:                         items.append((name, self.virtual_attributes[name].to_unicode()))                 elif name in self.virtual_attributes_values:                     if strings:                         items.append((name, self.virtual_attributes_values[name]))                     else:                         items.append((name, self.virtual_attributes_values[name].to_unicode()))                 elif name in self.virtual_attributes_values_values:                     if strings:                         items.append((name, self.virtual_attributes_values_values[name]))                     else:                         items.append((name, self.virtual_attributes_values_values[name].to_unicode()))                 elif name in self.virtual_attributes_values_values_values:                     if strings:                         items.append((name, self.virtual_attributes_
Convert the DataFrame to a list of (name, array) tuples.          :param list column_names: Names of the columns to include in the result.             If None, all columns are included.         :param list selection: A list of booleans indicating which rows to include.             If None, all rows are included.         :param bool strings: If True, convert strings to numpy.string_ arrays.             If False, convert strings to numpy.bytes_ arrays.
Code: def __repr__(self):         """         Provide
Convert the vaex DataFrame to a pandas DataFrame.          :param list column_names: Names of the columns to include in the DataFrame.         :param list selection: List of boolean expressions to apply to the DataFrame.         :param bool strings: Whether to convert string columns to strings.         :param bool virtual: Whether to include virtual columns in the DataFrame.          :returns: pandas.DataFrame         :rtype: pandas.DataFrame Code: def to_dict(self, column_names=None, selection=None, strings=True, virtual=False):         """         Convert the vaex DataFrame to a dictionary.          :param list column_names: Names of the columns to include in the dictionary.         :param list selection: List of boolean expressions to apply to the dictionary.         :param bool strings: Whether to convert string columns to strings.         :param bool virtual: Whether to include virtual columns in the dictionary.          :returns: dict         :rtype: dict         """         import vaex         df = vaex.from_arrays(**self.to_dict())         if column_names is not None:             df = df[column_names]         if selection is not None:             df = df.evaluate(selection)         if strings:             df = df.astype(str)         if virtual:             df = df.copy()             df.drop(
Code: def to_pandas(self, column_names=None, selection=None, strings=True, virtual=False, index=None):         """         Return a pandas.DataFrame for this table.          Parameters         ----------         column_names : list of str, optional             A list of column names to include in the output.  If not provided,             all columns will be included.         selection : 2-tuple, optional             A 2-
Get the column values for the given index.          :param str name: The name of the column         :param index: The index         :returns: The column values         :rtype: list Code: def _get_column_values_for_index_slice(self, name, index_slice):
Get the row as a dictionary where the row_id is equal to row_id.          :param row_id: The row_id to use.          :
Code
Code: def add_virtual_columns_cartesian_velocities_to_spherical(self, x="x", y="y", z="z", vx="vx", vy="vy", vz="vz", vr="vr", vlong="vlong", vlat="vlat", distance=None):                  # see http://www.astrosurf.com/jephem/library/li110spherCart_en.htm         if distance is None:             distance = "sqrt({x}**2+{y}**2+{z}**2)".format(**locals())         self.add_virtual_column(vr, "({x}*{vx}+{y}*{vy}+{z}*{vz})/{distance}".format(**locals()))         self.add_virtual_column(vlong, "-({vx}*{y}-{x}*{vy})/sqrt({x}**2+{y}**2)".format(**locals()))         self.add_virtual_column(vlat, "-({z}*({x}*{vx}
Code: def add_virtual_columns_cartesian_velocities_to_polar(self, x="x", y="y", vx="vx", radius_polar=None, vy="vy", vr_out="vr_
Code: def add_virtual_columns_polar_velocities_to_cartesian(self, x='x', y='y', azimuth=None, vr='vr_polar', vazimuth='vphi_polar', vx_out='vx', vy_out='vy', propagate_uncertainties=False):                  x = self._expr(x)         y = self._expr(y)         vr = self._expr(vr)         vazimuth = self._expr(vazimuth)         if azimuth is not None:             azimuth = self._expr(azimuth)             azimuth = np.deg2rad(azimuth)         else:             azimuth = np.arctan2(y, x)         azimuth = self._expr(azimuth)         self[vx_out] = vr * np.cos(azimuth) - vazimuth * np.sin(azimuth)         self[vy_out] = vr * np.sin(azimuth) + vazimuth * np.cos(azimuth)         if propagate_uncertainties:             self.propagate_uncert
:param x: x coordinate         :type x: str or :class:`pymc3.distributions.continuous.Continuous`         :param y: y coordinate         :type y: str or :class:`pymc3.distributions.continuous.Continuous`         :param xnew: x coordinate after rotation         :type x
Code: def add_virtual_columns_spherical_to_cartesian(self, alpha, delta, distance, xname="x", yname="y", zname="z",                                                    propagate_uncertainties=False,                                                    center=[0, 0, 0], center_name="solar_position", radians=False):                  alpha = self._expr(alpha)         delta = self._expr(delta)         distance = self._expr(distance)         if not radians:             alpha = alpha * self._expr('pi')/180             delta = delta * self._expr('pi')/180          # TODO: use sth like.optimize by default to get rid of the +0
Code: def add_virtual_columns_cartesian_to_cylindrical(self, x="x", y="y", z="z", radius="r", height="h", radians=False, center=None, center_name="solar_position"):                  transform = "" if radians else "*180./pi"          if center is not None:             self.add_variable(center_name, center)         if center is not None and center[0]!= 0:             x = "({x} - {center_name}[0])".format(**locals())         if center is not None and center[1]!= 0:             y = "({y} - {center_name}[1])".format(**locals())         if center is not None and center[2]!= 0:             z = "({z} - {center_name}[2])".format(**locals())         self.add_virtual_column(radius, "sqrt({x}**2
:param str old_name:          :param str new_name:          :param str expression:           :returns: (new_expression, new_column_names)         :rtype: (str, list) Code: def _rename_expression(self, old_name, new_name, expression):         """         Rename a column, and update the expression          :param str old_name:          :param str new_
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset,                  identity=values.unset, role_sid=values.unset,                  last_consumed_message_index=values.unset,                  last_consumed_timestamp=values.unset,                  last_read_message_index=values.unset,                  last_read_timestamp=values.unset,                  attributes=values.unset, date_expires=values.unset,                  links=values.unset, **kwargs):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['account_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'identity': identity,             'role_sid': role_sid,             'last_consumed_message_index': last_consumed_message_index,             'last_consumed_timestamp': deserialize.iso8601_datetime(last_consumed_timestamp),             'last_read_message_index': last_read_message_index,             'last_read_timestamp': deserialize.iso8601_datetime(last_read_timestamp),             'attributes': attributes,             'date_expires': deserialize.iso8601_datetime(date_expires),             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @
Return
Returns true if both instances are not equal, false otherwise          :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def __init__(self, version, payload, service_sid, channel_sid, sid=None):         """         Initialize the InviteInstance          :returns:
Code: def __iter__(self):         """         Iterate over pages of Invites          :returns: Page of InviteInstance         :rtype
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, service_sid, channel_sid):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def stream(self, limit=None, page_size=None):         """         Streams InviteInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until the limit         is reached.         The results are returned as a generator, so this operation is memory efficient.          :param int limit: Upper limit for the number of records to return. stream()                           guarantees to never return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, stream() will attempt to read the                               limit with the most efficient page size, i.e. min(limit, 1
Code: def
Code: def __str__(self):
Code: def __init__(self, version, service_sid, channel_sid, **kwargs):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the new resource belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)          # Components         self._invites = None      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList.InvitePage         """         if self._invites is None:             self._invites = InvitePage(self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], )         return self._invites      def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         return '<Twilio.IpMessaging.V2.InviteList>'   class InvitePage(Page):     """ PLEASE NOTE that this class contains preview products that are subject     to change. Use them with caution. If you currently do not have developer     preview access, please contact <EMAIL>. """      def __init__(self, version, service_sid, channel_sid, response, solution):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the new resource belongs to         :param Response response: Response from the API         :param service_sid: The SID of the Service to fetch
Code: def get_column_names(self, virtual=True, strings=True, hidden=False, regex=None):                  def column_filter(name):             '''Return True if column with specified name should be
Return the codes of the index.          :returns: The codes of the index.         :rtype: list Code: def _get_index_nlevels(self):
Export the DataFrame to a JSON file.          :param path: Path to the file to write to.         :type path: str         :param kwargs: Keyword arguments passed to :func:`pandas.DataFrame.to_json`.         :type kwargs: dict Code: def to_parquet(self, path, **kwargs):         """         Export the DataFrame to a Par
Return a DataFrame containing only the filtered rows.          {note_copy}          The resulting DataFrame may be more efficient to work with when the original DataFrame is         heavily filtered (contains just a small number of rows).          If no filtering is applied, it returns a trimmed view.         For the returned df, len(df) == df.length_original() == df.length_unfiltered()          :rtype: DataFrame Code: def __init__(self, *args, **kwargs):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def stream(self, limit=None, page_size=None):         """         Streams InviteInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until the limit         is reached.         The results are returned as a generator, so this operation is memory efficient.          :param int limit: Upper limit for the number of records to return. stream()                           guarantees to never return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, stream() will attempt to read the                               limit with the most efficient page size, i.e. min(limit, 1000)          :returns: Generator that will yield up to limit results         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]         """         limits = self._version.read_limits(limit, page_size)          page = self.page(page_size=limits['
Returns a DataFrame with a random set of rows          {note_copy}          Provide either n or frac.          Example:          >>> import vaex, numpy as np         >>> df = vaex.from_arrays(s=np.array(['a', 'b', 'c', 'd']), x=np.arange(1,5))         >>> df           #  s      x           0  a      1           1  b      2           2  c      3           3  d      4         >>> df.sample(n=2, random_state=42) # 2 random rows, fixed seed           #  s      x           0  b      2           1  d      4         >>> df.sample(frac=1, random_state=42) #'shuffling'           #  s      x           0  c      3           1  a      1           2  d      4           3  b      2         >>> df.sample(frac=1, replace=True, random_state=42) # useful for bootstrap (may contain repeated samples)           #  s      x           0  d      4           1  a      1           2  a      1           3  d      4          :param int n: number of samples to take (default 1 if frac is None)         :param float frac: fractional number of takes to take         :param bool replace: If true, a row may be drawn multiple times         :param str or expression weights: (unnormalized) probability that a row can be drawn         :param int or RandomState: seed or RandomState for reproducability, when None a random seed it chosen         :return: {return_shallow_copy}         :rtype: DataFrame         '''         self = self.extract()         if type(random_state) == int or random_state is None:             random_state = np.random.RandomState(seed=random_state)         if n is None and frac is None:             n = 1         elif frac is not None:             n = int(round(frac * len(self)))         weights_values = None         if weights is not None:             weights_values = self.evaluate(weights)             weights_values = weights_values / self.sum(weights)         indices = random_state.choice(len(self), n, replace=replace, p=weights_values
Returns a list containing random portions of the DataFrame.          {note_copy}          Example:          >>> import vaex, import numpy as np         >>> np.random.seed(111)         >>> df = vaex.from_arrays(x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9])         >>> for dfs in df.split_random(frac=0.3, random_state=42):        ...     print(dfs.x.values)        ...         [8 1 5]         [0 7 2 9 4 3 6]         >>> for split in df.split_random(frac=[0.2, 0.3, 0.5], random_state=42):        ...     print(dfs.x.values)         [8 1]         [5 0 7]         [2 9 4 3 6]          :param int/list frac: If int will split the DataFrame in two portions, the first of which will have size as specified by this parameter. If list, the generator will generate as many portions as elements in the list, where each element defines the relative fraction of that portion.         :param int random_state: (default, None) Random number seed for reproducibility.         :return: A list of DataFrames.         :rtype: list Code: def split_random_by(self, by, frac, random_state=None):         '''Returns a list containing random portions of the DataFrame.          {note_copy}          Example:          >>> import vaex, import numpy as np         >>> np.random.seed(111)         >>> df = vaex.from_arrays(x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9])         >>> for dfs in df.split_random_by(by='x', frac=0.3, random_state=42):        ...     print(dfs.x.values)        ...         [8 1 5]         [0 7 2 9 4 3 6]         >>> for split in df.split_random_by(by='x', frac=[0.2, 0.3,
Returns a list containing ordered subsets of the DataFrame.          {note_copy}          Example:          >>> import vaex         >>> df = vaex.from_arrays(x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9])         >>> for dfs in df.split(frac=0.3):        ...     print(dfs.x.values)        ...         [0 1 3]         [3 4 5 6 7 8 9]         >>> for split in df.split(frac=[0.2, 0.3, 0.5]):        ...     print(dfs.x.values)         [0 1]         [2 3 4]         [5 6 7 8 9]          :param int/list frac: If int will split the DataFrame in two portions, the first of which will have size as specified by this parameter. If list, the generator will generate as many portions as elements in the list, where each element defines the relative fraction of that portion.         :return: A list of DataFrames.         :rtype: list Code: def split_by(self, column, frac):         """Returns a list containing ordered subsets of the DataFrame.          {note_copy}          Example:          >>> import vaex         >>> df = vaex.from_arrays(x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9])         >>> for dfs in df.split_by(column='x', frac=0.3):        ...     print(dfs.x.values)        ...         [0 1 3]         [3 4 5 6 7 8 9]         >>> for split in df.split_by(column='x', frac=[0.2, 0.3, 0.5]):        ...     print(dfs.x.values)         [0 1]         [2 3 4]         [5 6 7 8 9]          :param str column: The column to split on.         :param int/list frac: If int will split the DataFrame in two portions, the first of which will have size as specified by this parameter. If list, the
Return a sorted DataFrame, sorted by the expression 'by'          {note_copy}          {note_filter}          Example:          >>> import vaex, numpy as np         >>> df = vaex.from_arrays(s=np.array(['a', 'b', 'c', 'd']), x=np.arange(1,5))         >>> df['y'] = (df.x-1.8)**2         >>> df           #  s      x     y           0  a      1  0.64           1  b      2  0.04           2  c      3  1.44           3  d      4  4.84         >>> df.sort('y', ascending=False)  # Note: passing '(x-1.8)**2' gives the same result           #  s      x     y           0  d      4  4.84           1  c      3  1.44           2  a      1  0.64           3  b      2  0.04          :param str or expression by: expression to sort by         :param bool ascending: ascending (default, True) or descending (False)         :param str kind: kind of algorithm to use (passed to numpy.argsort) Code: def sort_values(self, by, ascending=True, kind='quicksort'):         '''Return a sorted DataFrame, sorted by the expression 'by'          {note_copy}          {note_filter}          Example:          >>> import vaex, numpy as np         >>> df = vaex.from_arrays(s=np.array(['a', 'b', 'c', 'd']), x=np.arange(1,5))         >>> df['y'] = (df.x-1.8)**2         >>> df           #  s      x     y           0  a      1  0.64           1  b      2  0.04           2  c      3  1.44           3  d      4  4.84         >>> df.sort_values('y', ascending=False)  # Note: passing '(x-1.8)**2' gives the same result           #  s      x     y           0  d      4  4.84           1  c      3  1.44           2  a
Return the mean of column_or_expression, possible over an expression selection.          :param column_or_expression: {expression}         :param out: {out}         :param selection: {selection}         :param kwargs: {kwargs}         :return: {return_stat_scalar}
Get the current selection for the given name.          :param str name: The name of the selection history to get.          :returns: list         :rtype: list Code: def selection_set(self, selection, name="default"):
Code: def selection_paste(self, name="default"):         selection = self.clipboard.get()
Code: def selection_undo_except(self, name):                  self.selection_history_indices[name] -= 1         self.selection_histories[name].append(self.selection_histories[name][self.selection_history_indices[name]])
:param boolean_expression: A boolean expression to evaluate for each item in the history.         :param mode: The mode to use when the expression evaluates to True.         :param name: The name of the selection.         :param executor: The executor to use when evaluating the expression.         :returns: The selection object.         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList.Selection Code: def __init__(self, version, service_sid, channel_sid):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the resource to fetch belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def stream(self, limit=None, page_size=None):         """         Streams InviteInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as possible until the limit         is reached.         The results are returned as a generator, so this operation is memory efficient.          :param int limit: Upper limit for the number of records to return. stream()                           guarantees to never return more than limit.  Default is no limit         :param int page_size: Number of records to fetch per request, when not set will use                               the default value of 50 records.  If no page_size is defined                               but a limit is defined, stream() will attempt to read the                               limit with the most efficient page size, i.e. min(limit, 1000)          :returns: Generator that will yield up to limit results         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]         """         limits = self._version.read_limits(limit, page_size)          page =
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset, date_created=values.unset, date_updated=values.unset, by=values.unset, from_=values.unset, to=values.unset, url=values.unset, links=values.unset, ):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to         :param sid: The unique string that identifies the resource          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites{sid}'.format(**self._solution)          # Dependents         self._invites = None      @property     def invites(self):         """         :returns: The list of Invites         :rtype: unicode         """         if self._invites is None:             self._invites = list()         if self._invites is not None:             return self._invites          self._invites = list()         for child in self._version.page(self, 'invites', self._solution):             self._invites.append(child)          return self._invites      def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         return '<Twilio.IpMessaging.V2.InvitePage>'   class InviteContext(InstanceContext):     """ PLEASE NOTE that this class contains preview products that are subject     to change. Use them with caution. If you currently do not have developer     preview access, please contact <EMAIL>. """      def __init__(self, version, service_sid, channel_sid, sid):         """         Initialize the InviteContext          :param Version version: Version that contains the resource         :param service_sid:

Select a box in the image.          :param list[int] points: The points of the box.         :param list[int] limits: The limits of the box.         :param str mode: The mode to use when selecting the box. Can be: replace, add, or subtract.         :param str name: The name of the box.          :returns: twilio.rest.video.v1.room.room_participant.room_participant_track.room_participant_track_captions.room_participant_track_captions_captions_item.RoomParticipantTrackCaptionsCaptionsItem         :rtype: twilio.rest.video.v1.room.room_
Code: def select_box(self, spaces, limits, mode="replace", name="default"):                  sorted_limits = [(min(l), max(l)) for l in limits
Code: def select_circle(self, x, y, xc, yc, r, mode="replace", name="default", inclusive=True):                   # expr = "({x}-{xc})**2 + ({y}-{yc})**2 <={r}**2".format(**locals())
Code: def select_ellipse(self, x, y, xc, yc, width, height, angle=0, mode="replace", name="default", radians=False, inclusive=True):                   # Computing the properties of the ellipse prior to selection         if radians:             pass         else:             alpha = np.deg2rad(angle)         xr = width / 2         yr = height / 2         r = max(xr, yr)         a = xr / r         b = yr / r          expr = "(({x}-{xc})*cos({alpha})+
polygon selection          :param expression_x:          :param expression_y:          :param xsequence:          :param ysequence:          :param mode:          :param name:          :param executor:          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def select_circle(self, expression_x, expression_y, xsequence, ysequence, mode="replace", name="default", executor=None):                   def create(current):             return selections.SelectionCircle(expression_x, expression_y, xsequence, ysequence, current, mode)         self._selection(create, name, executor=executor
Retrieve a single page of InviteInstance records from the API.         Request is executed immediately          :param int page_size: Number of records to return, defaults to 50         :param str name: A string to describe the selection.         :param executor: The executor to use for this selection.          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, payload
Called when the selection has changed, and the selection has been         applied
Constructs a InviteContext          :param sid: The unique string that identifies the resource          :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext Code: def __unicode__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         return unicode(self.__repr
Get a unicode representation of the result set.          :returns: The result set unicode representation.         :rtype: unicode Code: def __nonzero__(self):         """         Get a boolean value
Code: def __init__(self, version, service_sid, channel_sid):
Retrieve a user's identity          :param identity: The identity         :type identity: unicode          :returns: The identity         :rtype: unicode Code: def _get_page(self, target_url):         """         Retrieve a page of results          :param target_url: The target URL         :type target_url: unicode          :returns: The page of results         :rtype: twilio.rest.chat.v2.service.channel.invite.
Code: def __init__(self, *args, **kwargs):         super(Channel, self).__init__(*args, **kwargs)         self._properties['members'] = None         self._properties['invites'] = None         self._properties['last_consumed_message_index'] = None         self._properties['last_consumption_timestamp'] = None         self._properties['typing_indicator_timeout'] = None         self._properties['reachability_enabled'] = None         self._properties['notifications_enabled'] = None         self._properties['messages_count'] = None         self._properties['messages_last_consumed_timestamp'] = None         self._properties['created_by'] = None         self._properties['created_by_identity'] = None         self._properties['created_by_role_sid'] = None         self._properties['created_by_identity_channel_role_sid'] = None         self._properties['created_by_identity_channel_role_sid'] = None         self._properties['created_by_identity_channel_role_sid'] = None         self._properties['created_by_identity_channel_role_sid'] = None         self._properties['created_by_identity_channel_role_sid'] = None         self._properties['created_by_identity_channel_role_sid'] = None         self._properties['created_by_identity_channel_role_sid'] = None         self._properties['created_by_identity_channel_role_sid'] = None         self._properties['created_by_identity_channel_role_sid'] = None         self._properties['created_by_identity_channel_role_sid'] = None         self._properties['created_by_identity_channel_role_sid'] = None         self._properties['created_by_identity_channel_role_sid'] = None         self._properties['created_by_identity_channel_role_sid'] = None         self._properties['created_by_identity_channel_role_sid'] = None         self._properties['created_by_identity_channel_role_sid'] = None         self._properties['created_by_identity_channel_role_sid'] = None         self._properties['created_by_identity_channel_role_sid'] = None         self._properties['created_by_identity_
Initialize the InvitePage          :param Version
Constructs a InviteContext          :param sid: The sid          :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext Code: def __iter__(self):         """         :returns: Iterator for list of invites         :rtype: list[twilio.rest.chat.v2.service.channel.invite.

Get an item from the list of resources          :param unicode key: The index of the resource to fetch          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def __call__(self, sid):         """         Constructs a InviteContext          :param sid: The sid          :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """
Code: def export_hdf5(self, path
Code: def __init__(self, data=None, index=None, columns=None, dtype=None, copy=False,                  fastpath=False, allow_duplicates=False, verify_integrity=False):         """         Create a new DataFrame from a dictionary, list of tuples, or array.          Parameters         ----------         data : dict, list of tuples, ndarray, dict of arrays, or DataFrame             Dict can contain Series, arrays, constants, or list-like objects         index : Index or array-like             Index to use for resulting frame. Will default to np.arange(n)             if no indexing information part of input data and no index provided         columns : Index or array-like             Column labels to use for resulting frame. Will default to             RangeIndex(n) if no column labels are provided         dtype : dtype, default None             Data type to force, otherwise infer         copy : boolean, default False             Copy data from inputs. Only affects DataFrame / 2d ndarray input         fastpath : boolean, default False             Only use arrays / scalar values as input, do not attempt to             put anything in object dtype. Only affects DataFrame / 2d ndarray             input         allow_duplicates : boolean, default False             Allow columns to be duplicated. If False, will raise an exception             if a column label is duplicated.         verify_integrity : boolean, default False             Check the new object for duplicates. Otherwise defer the check             until necessary. Setting to False will improve the performance of             this method          Notes         -----         To learn more about the canonical representation of DataFrames         in pandas, please see :ref:`the User Guide <basics.dataframe>`.          See Also         --------         DataFrame : DataFrame object creation using constructor         DataFrame.from_dict : DataFrame from dict of array-like or dicts         DataFrame.from_items : DataFrame from sequence of (key, value) pairs         DataFrame.from_records : DataFrame from ndarray (structured or homogeneous)         DataFrame.from_csv : DataFrame from CSV file         DataFrame.from_json : DataFrame from JSON file          Examples         --------         Constructing DataFrame from a dictionary          >>> data = {'col1': [1, 2, 3],        ...         'col2': [4, 5, 6]}         >>> df = pd.DataFrame(data)         >>> df            col1  col2         0     1     4         1     2     5         2     3     6
Adds method f to the DataFrame class          :param f: The method to add to the DataFrame class          :returns: The method added to the DataFrame class         :rtype: function Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  identity=values.unset, role_sid=values.unset,                  last_consumed_message_index=values.unset,                  last_consumption_timestamp=values.unset, date_created=values.unset,                  date_updated=values.unset, url=values.unset):         """         Initialize the UserInstance          :returns: twilio.rest.chat.v2.service.channel.user.UserInstance         :rtype: twilio.rest.chat.v2.service.channel.user.UserInstance         """         super(UserInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['account_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'identity': identity,             'role_sid': role_sid,             'last_consumed_message_index': last_consumed_message_index,             'last_consumption_timestamp': last_consumption_timestamp,             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'url': url,         }          self._solution = {             'account_sid': account_sid,            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property     def service_sid(self):         """         :returns: The SID of the Service that the resource is associated with         :
Code: def __init__(self, ds, name, expression, **kwargs):         super(LazyFunction, self).__init__(ds, name, expression, **kwargs)         self.expression = expression         self.ds = ds         self.name = name         self.kwargs = kwargs         self.function = getattr(self.ds.func, self.name)         self.function_args = self.function.func_code.co_varnames[:self.function.func_code.co_argcount]         self.function_defaults = self.function.func_defaults         self.function_annotations = self.function.func_annotations         self.function_kwonlyargs = self.function.func_code.co_kwonlyargcount         self.function_kwonlydefaults = self.function.func_kwonlydefaults         self.function_varkw = self.function.func_code.co_flags & 0x4000 > 0         self.function_varargs = self.function.func_code.co_flags & 0x8000 > 0         self.function_annotations = self.function.func_annotations         self.function_closure = self.function.func_closure         self.function_code = self.function.func_code         self.function_doc = self.function.__doc__         self.function_name = self.function.__name__         self.function_module = self.function.__module__         self.function_defaults = self.function.func_defaults         self.function_globals = self.function.func_globals         self.function_kwdefaults = self.function.func_kwdefaults         self.function_annotations = self.function.func_annotations         self.function_closure = self.function.func_closure         self.function_code = self.function.func_code         self.function_doc = self.function.__doc__         self.function_name = self.function.__name__         self.function_module = self.function.__module__         self.function_defaults = self.function.func_defaults         self.function_globals = self.function.func_globals         self.function_kwdefaults = self.function.func_kwdefaults         self.function_annotations = self.function.func_annotations         self.function_closure = self
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __eq__(self, other):         """         Returns true if both instances are equal          :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def __ne__(self, other):         """         Returns true if both instances are not equal          :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def __init__(self, version, payload, service_sid, channel_sid, ):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def __init__(self, version, payload, service_sid, channel_sid, ):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance Code: def __init__(self, version, payload
Code: def dt_days_in_month
Code: def dt_dayofyear(x):          import pandas as pd     return pd.Series(x).dt.dayofyear.
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset):         """         Initialize the InviteInstance          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to         :param sid: The unique string that identifies the resource         :param date_created: The ISO 8601 date and time in GMT when the resource was created         :param date_updated: The ISO 8601 date and time in GMT when the resource was last updated         :param created_by: The identity of the User that created the resource         :param url: The absolute URL of the resource          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': self._solution['account_sid'],            'service_sid': self._solution['service_sid'],             'channel_sid': self._solution['channel_sid'],             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context
Code: def dt_is_month_end(x):
Code: def dt_month(x):          import pandas as pd     return
Code: def dt_month_name(x):          import pandas as pd     return pd.Series(_pandas_dt_fix(x)).dt
Code
Code: def dt_day_name(x):          import pandas as pd     return pd.Series(_pandas_dt_fix(x)).dt
Code: def dt_is_quarter_end(x):          import
Code: def dt_
Code
Code: def dt_
Code: def __init__(self, version, payload, service_sid, channel_sid, ):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param dict payload: A JSON response from the Twilio API          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init__(version, response=payload, service_sid=service_sid, channel_sid=channel_sid, )          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._context      @property     def invites(self):         """         :returns: A list of instances of InviteInstance         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]         """         return self._proxy.invites      @property     def page_size(self):         """         :returns: How many resources to return in each list page. The default is 50, and the maximum is 1000.         :rtype: unicode         """         return self._properties['page_size']      @property     def next_page_url(self):         """         :returns: The URL of the next page of results         :rtype: unicode         """         return self._properties['next_page_url']      @property     def key(self):         """         :returns: The unique string that identifies the resource         :rtype: unicode         """         return self._properties['key']      def __repr__(self):         """         Provide a friendly representation
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset,                  identity=values.unset, role_sid=values.unset,                  last_consumed_message_index=values.unset,                  last_consumed_timestamp=values.unset,                  last_read_message_index=values.unset,                  last_read_timestamp=values.unset,                  last_seen_timestamp=values.unset, attributes=values.unset,                  unread_messages_count=values.unset, links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'identity': identity,             'role_sid': role_sid,             'last_consumed_message_index': last_consumed_message_index,             'last_consumed_timestamp': deserialize.iso8601_datetime(last_consumed_timestamp),             'last_read_message_index': last_read_message_index,             'last_read_timestamp': deserialize.iso8601_datetime(last_read_timestamp),             'last_seen_timestamp': deserialize.iso8601_datetime(last_seen_timestamp),             'attributes': attributes,             'unread_messages_count': unread_messages_count,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __repr__(self):         """         Provide a friendly representation
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __repr__(self):         """         Provide a friendly representation
Code: def str_rindex(x, sub, start=0, end=None):          return _to_
Code: def __init__(self, service_sid, channel_sid, version):         """         Initialize the InviteList          :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the new resource belongs to         :param version: Version that contains the resource          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def create(self, identity, role_sid=values.unset,                type=values.unset, url=values.unset, ttl=values.unset):         """         Create a new InviteInstance          :param unicode identity: The `identity` value that identifies the new resource's User         :param unicode role_sid: The SID of the Role to assign to the new resource         :param unicode type: The type of push notification to use. Can be: `gcm` or `apn` and the default is `gcm`         :param unicode url: The URL we should call using the `notification_protocol` to send a notification when the Invite has been accepted         :param unicode ttl: The amount of time, in seconds, that a Push Notification should be retained for. Can be an integer between 0 and 1440 (24 hours).          :returns: Newly created InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         data = values.of({             'Identity': identity,             'RoleSid': role_sid,             'Type': type,             'Url': url,             'Ttl': ttl,         })          payload = self._version.create(             'POST',             self._uri,             data=data,         )          return InviteInstance(             self._version,             payload,             service_sid=self._solution['service_sid'],             channel_sid=self._solution['channel_sid'],         )
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __repr__(self):         """         Provide a friendly representation
Get an item from the list of resources          :
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __getitem__(self, key):         """         Get an item from the list of resources in the response.          :returns: An instance of the resource at the given index         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         return self
Code: def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         return '<Twilio.IpMessaging.V2.InvitePage
Code: def __init__(self, service_sid, channel_sid, version):         """         Initialize the InviteList          :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the new resource belongs to         :param version: Version that contains the resource          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution)      def create(self, identity, role_sid=values.unset,                type=values.unset, url=values.unset, ttl=values.unset):         """         Create a new InviteInstance          :param unicode identity: The `identity` value that identifies the new resource's User         :param unicode role_sid: The SID of the Role to assign to the new resource         :param unicode type: The type of push notification to send when the new resource is added to the Channel         :param unicode url: The absolute URL of the new resource         :param unicode ttl: The amount of time, in seconds, that a Push Notification should be retained for the new resource          :returns: Newly created InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         data = values.of({             'Identity': identity,             'RoleSid': role_sid,             'Type': type,             'Url': url,             'Ttl': ttl,         })          payload = self._version.create(             'POST',             self._uri,             data=data,         )          return InviteInstance(             self._version,             payload,             service_sid=self._solution['service_sid'],             channel_sid=self._solution['channel_sid'],         )      def stream(self, limit=None, page_size=None):         """         Streams InviteInstance records from the API as a generator stream.         This operation lazily loads records as efficiently as
Code: def __unicode__(self):         """         Provide a friendly representation          :returns: Machine
Iterate over list of Invites          :returns: List of Invites         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance] Code: def __len__(self):         """         :returns: Number of Invites in the response         :rtype: unicode         """         return self._version.read_limits['
Code: def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         return '<Twilio.IpMessaging.V2.InvitePage
Code: def __init__(self, version, payload, service_sid, channel_sid, ):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param dict payload: A JSON response from the Twilio API          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init__(version, response=payload, service_sid=service_sid, channel_sid=channel_sid, )          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._context      @property     def invites(self):         """         :returns: A list of instances of InviteInstance         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]         """         return self._proxy.invites      @property     def page_size(self):         """         :returns: How many resources to return in each list page. The default is 50, and the maximum is 1000.         :rtype: unicode         """         return self._properties['page_size']      @property     def next_page_url(self):         """         :returns: The URL of the next page of results         :rtype: unicode         """         return self._properties['next_page_url']      @property     def key(self):         """         :returns: The unique string that identifies the resource         :rtype: unicode         """         return self._properties['key']      def __repr__(self):         """         Provide a friendly representation
Get an item from the list
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __getitem__(self, key):         """         Get an item from the list of resources in the response.          :returns: An instance of the resource at the given index         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         return self
Code: def __init__(self, version, payload, service_sid, channel_sid, ):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param dict payload: A JSON response from the Twilio API          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage         """         super(InvitePage, self).__init__(version, response=payload, service_sid=service_sid, channel_sid=channel_sid, )          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._context      @property     def invites(self):         """         :returns: A list of instances of InviteInstance         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]         """         return self._proxy.invites      @property     def page_size(self):         """         :returns: How many resources to return in each list page. The default is 50, and the maximum is 1000.         :rtype: unicode         """         return self._properties['page_size']      @property     def next_page_url(self):         """         :returns: The URL of the next page of results         :rtype: unicode         """         return self._properties['next_page_url']      @property     def key(self):         """         :returns: The unique string that identifies the resource         :rtype: unicode         """         return self._properties['key']      def __repr__(self):         """         Provide a friendly representation
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __iter__(self):         """         Iterate over pages of results          :returns: Page of InviteInstance         :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]         """         return list(self.
Code: def get_autotype(arr):          try:         narr = arr.astype('float')         if (narr < sys.maxsize).all() and
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, payload, service_sid, channel_sid):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': payload.get('sid'),             'account_sid': payload.get('account_sid'),            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'created_by': payload.get('created_by'),             'created_by_identity': payload.get('created_by_identity'),             'role_sid': payload.get('role_sid'),             'identity': payload.get('identity'),             'date_created': deserialize.iso8601_datetime(payload.get('date_created')),             'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')),             'url': payload.get('url'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': payload.get('sid'),         }      @property     def sid(self):         """
Get an item from the list of resources          :param unicode key: The index of the resource to fetch          :returns: twilio.rest.chat.v2.service.channel.
Raise an exception if the given value is
Raise an exception if the given value is not a list.          :param value: The value to check.         :param str name: The name of the value.         :raises TypeError: If the value is not a list. Code: def _require_dict
Code: def iter_properties(fh, comments=False):      for line in _property_lines(fh):     key, value = _split_key_value(line)     if key is not COMMENT:       key = _
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __getitem__(self, key):         """         Get an item from the list of resources          :param unicode key: The index of the resource to fetch          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         return self.
Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to          :returns: twilio.rest.chat.
Provide a friendly representation          :returns: Machine friendly representation
Set the hop length, in samples, of the STFT.          Parameters         ----------         hop_length : int > 0 [scalar]             The number of samples between subsequent frames.             If unspecified, defaults to `win_length / 4`.          Examples         --------         Use a shorter frame shift for better frequency resolution          >>> y, sr = librosa.load(librosa.util.example_audio_file())         >>> D = librosa.stft(y)         >>> librosa.set_hop_length(64)         >>> D = librosa.stft(y)          Reset to default hop length          >>> librosa.set_hop_length()          '''          global __HOP_LENGTH         if hop_length is None:             hop_
Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service to fetch the resource from          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def __repr__(self):         """         Provide a friendly representation          :returns:
Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service to fetch the resource from          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def __repr__(self):         """         Provide a friendly representation          :returns: Machine friendly representation         :rtype: str         """         return '<Twilio.IpMessaging.V2.InvitePage>'
Get an item from the list of resources in the response.          :returns: An instance of the resource at the given index, or None if
Code: def __init__(self, version, service_sid, channel_sid, sid=values.unset,                  date_created=values.unset, date_updated=values.unset,                  created_by=values.unset, url=values.unset,                  links=values.unset):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         self._version = version          # Marshaled Properties         self._properties = {            'sid': sid,             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'created_by': created_by,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid or self._properties['sid'],         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],                 sid=self._solution['sid'],             )         return self._context      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def date_created(self):         """         :returns: The RFC 2822 date and time in GMT when the resource was created.         :rtype: datetime         """         return self._properties['date_created']      @property     def date_updated(self):         """         :returns: The RFC 28
Convert time to samples          :param list times: List of times in seconds         :param int sr: Sampling rate in Hz         :returns: List of samples         :rtype: list Code: def time_to_samples(times, sr=22050):     """     Convert time to samples      :param list times: List of times
Convert one or more MIDI numbers to note strings.          MIDI numbers will be rounded to the nearest integer.          Notes will be of the format 'C0', 'C#0', 'D0',...          Examples         --------         >>> librosa.midi_to_note(0)         'C-1'         >>> librosa.midi_to_note(37)         'C#2'         >>> librosa.midi_to_note(-2)         'A#-2'         >>> librosa.midi_to_note(104.7)         'A7'         >>> librosa.midi_to_note(104.7, cents=True)         'A7-30'         >>> librosa.midi_to_note(list(range(12, 24)))         ['C0', 'C#0', 'D0', 'D#0', 'E0', 'F0', 'F#0', 'G0', 'G#0', 'A0', 'A#0', 'B0']          Parameters         ----------         midi : int or iterable of int             Midi numbers to convert.          octave: bool             If True, include the octave number          cents: bool             If true, cent markers will be appended for fractional notes.             Eg, `midi_to_note(69.3, cents=True)` == `A4+03`          Returns         -------         notes : str or iterable of str             Strings describing each midi note.          Raises         ------         ParameterError             if `cents` is True and `octave` is False          See Also         --------         midi_to_hz         note_to_midi         hz_to_note         '''      if cents and not octave:         raise ParameterError('Cannot encode cents without octave information.')      if not np.isscalar(midi):         return [midi_to_note(x, octave=octave, cents=cents) for x in midi]      note_map = ['C', 'C#', 'D', 'D#',                 'E', 'F', 'F#', 'G',                 'G#', 'A', 'A#', 'B']      note_num = int(np.round(midi))     note_cents = int(100
Code: def hz_to_mel(frequencies, htk=False):           frequencies = np.asanyarray(frequencies)      if htk:         return 2595.0 * np.log10(1.0 + frequencies / 700.0)      # Fill in the linear part     f_min = 0.0     f_sp = 200.0 / 3      mels = (frequencies - f_min) / f_sp      # Fill in the log-scale part      min_log_hz = 1000.0                         # beginning of log region (Hz)     min_log_mel = (min_log_hz - f_min) / f_sp   # same (Mels)     logstep = np.log(6.4) / 27.0                # step
Initialize the InvitePage          :param Version version: Version that contains the resource         :param dict payload: A JSON response from the Twilio API.          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage Code: def __init__(self, version, service_sid, channel_sid, ):         """         Initialize the InviteList          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_
Alternative implementation of `np.fft.fftfreq`          Parameters         ----------         sr : number >
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, response, solution):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API
Code: def mel_frequencies(n_mels=128, fmin=0.0, fmax=11025.0, htk=False):           # 'Center freqs' of mel bands - uniformly spaced between limits     min_mel = hz_to_mel(fmin, htk=htk)     max_mel
Compute the A-weighting of a set of frequencies.          Parameters         ----------         frequencies : scalar or np.ndarray [shape=(n,)]             One or more frequencies (in Hz)          min_db : float [scalar] or None             Clip
Provide a friendly representation          :returns: Machine friendly representation         :rtype: str Code: def __init__(self, version, response, service_sid, channel_sid):         """         Initialize the InvitePage          :param Version version: Version that contains the resource         :param Response response: Response from the API         :param service_sid: The SID of the Service that the resource is associated with         :param channel_sid: The SID of the Channel the resource belongs to          :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage         :rtype: twilio.
Code: def __init__(self, *args, **kwargs):         """         Initialize the ChannelContext          :param Version version: Version that contains the resource         :param service_sid: The SID of the Service to fetch the resource from         :param channel_sid: The SID of the Channel the new resource belongs to          :returns: twilio.rest.chat.v2.service.channel.ChannelContext         :rtype: twilio.rest.chat.v2.service.channel.ChannelContext         """         super(ChannelContext, self).__init__(version)          # Path Solution         self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, }         self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution)          # Dependents         self._members = None         self._messages = None         self._invites = None         self._webhooks = None      @property     def members(self):         """         Access the members          :returns: twilio.rest.chat.v2.service.channel.member.MemberList         :rtype: twilio.rest.chat.v2.service.channel.member.MemberList         """         if self._members is None:             self._members = MemberList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._members      @property     def messages(self):         """         Access the messages          :returns: twilio.rest.chat.v2.service.channel.message.MessageList         :rtype: twilio.rest.chat.v2.service.channel.message.MessageList         """         if self._messages is None:             self._messages = MessageList(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._messages      @property     def invites(self):         """         Access the invites          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         if self._invites is None:             self._invites = Inv
Compute the hybrid constant-Q transform of an audio signal.      Here, the hybrid CQT uses the pseudo CQT for higher frequencies where     the hop_length is longer than half the filter length and the full CQT     for lower frequencies.      Parameters     ----------     y : np.ndarray [shape=(n,)]         audio time series      sr : number > 0 [scalar]         sampling rate of `y`      hop_length : int > 0 [scalar]         number of samples between successive CQT columns.      fmin : float > 0 [scalar]         Minimum frequency. Defaults to C1 ~= 32.70 Hz      n_bins : int > 0 [scalar]         Number of frequency bins, starting at `fmin`      bins_per_octave : int > 0 [scalar]         Number of bins per octave      tuning : None or float in `[-0.5, 0.5)`         Tuning offset in fractions of a bin (cents).          If `None`, tuning will be automatically estimated from the signal.      filter_scale : float > 0         Filter filter_scale factor. Larger values use longer windows.      sparsity : float in [0, 1)         Sparsify the CQT basis by discarding up to `sparsity`         fraction of the energy in each basis.          Set `sparsity=0` to disable sparsification.      window : str, tuple, number, or function         Window specification for the basis filters.         See `filters.get_window` for details.      pad_mode : string         Padding mode for centered frame analysis.          See also: `librosa.core.stft` and `np.pad`.      res_type : string         Resampling mode.  See `librosa.core.cqt` for details.      Returns     -------     CQT : np.ndarray [shape=(n_bins, t), dtype=np.float]         Constant-Q energy for each frequency at each time.      Raises     ------     ParameterError         If `hop_length` is not an integer multiple of         `2**(n_bins / bins_per_octave)`          Or if `y` is too short to support the frequency range of the CQT.      See Also     --------     cqt     pseudo_cqt      Notes     -----     This function caches at level
Compute the pseudo constant-Q transform of an audio signal.          This uses a single fft size that is the smallest power of 2 that is         greater than or equal to the max of:              1. The longest CQT filter             2. 2x the hop_length          Parameters         ----------         y : np.ndarray [shape=(n,)]             audio time series          sr : number > 0 [scalar]             sampling rate of `y`          hop_length : int > 0 [scalar]             number of samples between successive CQT columns.          fmin : float > 0 [scalar]             Minimum frequency. Defaults to C1 ~= 32.70 Hz          n_bins : int > 0 [scalar]             Number of frequency bins, starting at `fmin`          bins_per_octave : int > 0 [scalar]             Number of bins per octave          tuning : None or float in `[-0.5, 0.5)`             Tuning offset in fractions of a bin (cents).              If `None`, tuning will be automatically estimated from the signal.          filter_scale : float > 0             Filter filter_scale factor. Larger values use longer windows.          sparsity : float in [0, 1)             Sparsify the CQT basis by discarding up to `sparsity`             fraction of the energy in each basis.              Set `sparsity=0` to disable sparsification.          window : str, tuple, number, or function             Window specification for the basis filters.             See `filters.get_window` for details.          pad_mode : string             Padding mode for centered frame analysis.              See also: `librosa.core.stft` and `np.pad`.          Returns         -------         CQT : np.ndarray [shape=(n_bins, t), dtype=np.float]             Pseudo Constant-Q energy for each frequency at each time.          Raises         ------         ParameterError             If `hop_length` is not an integer multiple of             `2**(n_bins / bins_per_octave)`              Or if `y` is too short to support the frequency range of the CQT.          Notes         -----         This function caches at level 20.          '''      if fmin is None:         # C1 by default         fmin = note_to_hz('C1
Given a constant-Q transform representation `C` of an audio signal `y`,         this function produces an approximation `y_hat`.          Parameters         ----------         C : np.ndarray, [shape=(n_bins, n_frames)]             Constant-Q representation as produced by `core.cqt`          hop_length : int > 0 [scalar]             number of samples between successive frames          fmin : float > 0 [scalar]             Minimum frequency. Defaults to C1 ~= 32.70 Hz          tuning : float in `[-0.5, 0.5)` [scalar]             Tuning offset in fractions of a bin (cents).          filter_scale : float > 0 [scalar]             Filter scale factor. Small values (<1) use shorter windows             for improved time resolution.          norm : {inf, -inf, 0, float > 0}             Type of norm to use for basis function normalization.             See `librosa.util.normalize`.          sparsity : float in [0, 1)             Sparsify the CQT basis by discarding up to
Generate the frequency domain constant-Q filter basis.          :param int sr: Sample rate of the incoming signal.          :param float fmin: Minimum frequency. Defaults to C1 ~= 32.70 Hz.          :param int n_bins: Number of frequency bins, starting at ``fmin``.          :param int bins_per_octave: Number of bins per octave. Defaults to 12.          :param float tuning: Tuning deviation from A440 (in fractions of a bin).          :param float filter_scale: Filter scale factor. Larger values             (e.g., 1.0) use longer windows.          :param str norm: Normalization mode. One of ``'ortho'`` (ortho-normal),             ``'slaney'`` (slaney-rule), or ``None`` (no normalization).          :param float sparsity: Sparsify the filterbank by discarding             up to ``sparsity`` fraction of the energy in each basis             function.          :param int hop_length: The number of samples between subsequent             columns of ``D``. If not supplied, defaults to ``win_length // 4``.          :param str window: Window function for the basis filters.             See `scipy.signal.get_window` for a list of windows and required             parameters. If omitted, defaults to ``'hann'``.          :returns: Constant-Q basis, FFT length, and filter lengths         :rtype: tuple          :raises ParameterError: If any of the parameters are invalid.     Code: def __init__(self, sr=22050, fmin=C1, n_bins=84, bins_per_octave=12,                      tuning=0.0, filter_scale=1, norm=None, sparsity=0.01,                      hop_length=None, window='hann'):         """Construct a Constant-Q basis.          :param int sr: Sample rate of the incoming signal.          :param float fmin: Minimum frequency. Defaults to C1 ~= 32.70 Hz.          :param int n_bins: Number of frequency bins, starting at ``fmin``.          :param int bins_per_octave: Number of bins per octave. Defaults to 12.          :param float tuning: Tuning deviation from A44
Helper function to trim and stack a collection of CQT responses          :param list cqt_resp: List of CQT responses          :param int n_bins: Number of bins to keep          :returns: np.ndarray         :rtype: np.ndarray Code: def __init__(self, service_sid, channel_sid, version, payload):         """         Initialize the InviteList          :param unicode service_sid: The SID of the Service to fetch the resources from         :param unicode channel_sid: The SID of the Channel the resource is associated with         :param Version version: Version that contains the resource         :param dict payload: The JSON response payload          :returns: twilio.rest.chat.v2.service.channel.invite.InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList         """         super(InviteList, self).__init__(version)          # Marshaled Properties         self._properties = {            'service_sid': payload.get('service_sid'),             'channel_sid': payload.get('channel_sid'),             'account_sid': payload.get('account_sid'),             'date_created': deserialize.iso8601_datetime(payload.get('date_created')),             'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')),             'url': payload.get('url'),         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,         }      @property     def _proxy(self):         """         Generate an instance context for the instance, the context is capable of         performing various actions.  All instance actions are proxied to the context          :returns: InviteContext for this InviteList         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext         """         if self._context is None:             self._context = InviteContext(                 self._version,                 service_sid=self._solution['service_sid'],                 channel_sid=self._solution['channel_sid'],             )         return self._context      @property     def service_sid(self):         """         :returns: The SID of the Service that the resource is associated with         :rtype:
Compute the filter response with a target STFT hop.          :param y: the input signal         :type y: np.ndarray         :param n_fft: the FFT window size         :type n_fft: int         :param hop_length: the hop length         :type hop_length: int         :param fft_basis: the FFT basis         :type fft_basis: np.ndarray         :param mode: the padding mode         :type mode: str         :returns: the filter response         :rtype: np.ndarray Code: def __init__(self, service_sid, channel_sid, sid, version,                  date_created, date_updated, by, role_sid,                  url, links, **kwargs):         """         Initialize the InviteInstance          :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance         :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance         """         super(InviteInstance, self).__init__(version)          # Marshaled Properties         self._properties = {            'sid': sid,             'account_sid': kwargs.get('account_sid'),            'service_sid': service_sid,             'channel_sid': channel_sid,             'date_created': deserialize.iso8601_datetime(date_created),             'date_updated': deserialize.iso8601_datetime(date_updated),             'by': by,             'role_sid': role_sid,             'url': url,             'links': links,         }          # Context         self._context = None         self._solution = {            'service_sid': service_sid,             'channel_sid': channel_sid,            'sid': sid,         }      @property     def sid(self):         """         :returns: A 34 character string that uniquely identifies this resource.         :rtype: unicode         """         return self._properties['sid']      @property     def account_sid(self):         """         :returns: The SID of the Account that created the resource         :rtype: unicode         """         return self._properties['account_sid']      @property     def service_sid(self):         """         :returns: The SID of the Service that the resource is associated with         :rtype: unicode         """         return self._properties
Compute the number of 2 factors in n          :param int n: Number          :returns: int         :rtype: int Code: def __num_two_factors(n):     '''Compute the number of 2 factors in n'''
