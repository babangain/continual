{"text": "{\"input\": \"Summarize the following code: func RegisterAuthHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {\\n\\treturn RegisterAuthHandlerClient(ctx, mux, etcdserverpb.NewAuthClient(conn))\\n}\", \"output\": \"// RegisterAuthHandler registers the http handlers for service Auth to \\\"mux\\\".\\n// The handlers forward requests to the grpc endpoint over \\\"conn\\\".\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function getAdministratorRole()\\n    {\\n        $role = Voyager::model('Role')->firstOrNew([\\n            'name' => 'admin',\\n        ]);\\n\\n        if (!$role->exists) {\\n            $role->fill([\\n                'display_name' => 'Administrator',\\n            ])->save();\\n        }\\n\\n        return $role;\\n    }\", \"output\": \"Get the administrator role, create it if it does not exists.\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function getUser($create = false)\\n    {\\n        $email = $this->argument('email');\\n\\n        $model = config('voyager.user.namespace') ?: config('auth.providers.users.model');\\n\\n        // If we need to create a new user go ahead and create it\\n        if ($create) {\\n            $name = $this->ask('Enter the admin name');\\n            $password = $this->secret('Enter admin password');\\n            $confirmPassword = $this->secret('Confirm Password');\\n\\n            // Ask for email if there wasnt set one\\n            if (!$email) {\\n                $email = $this->ask('Enter the admin email');\\n            }\\n\\n            // Passwords don't match\\n            if ($password != $confirmPassword) {\\n                $this->info(\\\"Passwords don't match\\\");\\n\\n                return;\\n            }\\n\\n            $this->info('Creating admin account');\\n\\n            return $model::create([\\n                'name'     => $name,\\n                'email'    => $email,\\n                'password' => Hash::make($password),\\n            ]);\\n        }\\n\\n        return $model::where('email', $email)->firstOrFail();\\n    }\", \"output\": \"Get or create user.\\n\\n@param bool $create\\n\\n@return \\\\App\\\\User\"}"}
{"text": "{\"input\": \"Summarize the following code: public function handle(BreadDeleted $bread)\\n    {\\n        if (config('voyager.bread.add_menu_item')) {\\n            $menuItem = Voyager::model('MenuItem')->where('route', 'voyager.'.$bread->dataType->slug.'.index');\\n\\n            if ($menuItem->exists()) {\\n                $menuItem->delete();\\n            }\\n        }\\n    }\", \"output\": \"Delete a MenuItem for a given BREAD.\\n\\n@param BreadDeleted $bread\\n\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: private function categoriesTranslations()\\n    {\\n        // Adding translations for 'categories'\\n        //\\n        $cat = Category::where('slug', 'category-1')->firstOrFail();\\n        if ($cat->exists) {\\n            $this->trans('pt', $this->arr(['categories', 'slug'], $cat->id), 'categoria-1');\\n            $this->trans('pt', $this->arr(['categories', 'name'], $cat->id), 'Categoria 1');\\n        }\\n        $cat = Category::where('slug', 'category-2')->firstOrFail();\\n        if ($cat->exists) {\\n            $this->trans('pt', $this->arr(['categories', 'slug'], $cat->id), 'categoria-2');\\n            $this->trans('pt', $this->arr(['categories', 'name'], $cat->id), 'Categoria 2');\\n        }\\n    }\", \"output\": \"Auto generate Categories Translations.\\n\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: public function highestOrderMenuItem($parent = null)\\n    {\\n        $order = 1;\\n\\n        $item = $this->where('parent_id', '=', $parent)\\n            ->orderBy('order', 'DESC')\\n            ->first();\\n\\n        if (!is_null($item)) {\\n            $order = intval($item->order) + 1;\\n        }\\n\\n        return $order;\\n    }\", \"output\": \"Return the Highest Order Menu Item.\\n\\n@param number $parent (Optional) Parent id. Default null\\n\\n@return number Order number\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function createName(array $columns, $type, $table = null)\\n    {\\n        $table = isset($table) ? trim($table).'_' : '';\\n        $type = trim($type);\\n        $name = strtolower($table.implode('_', $columns).'_'.$type);\\n\\n        return str_replace(['-', '.'], '_', $name);\\n    }\", \"output\": \"Create a default index name.\\n\\n@param array  $columns\\n@param string $type\\n@param string $table\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function handle(BreadAdded $bread)\\n    {\\n        if (config('voyager.bread.add_menu_item') && file_exists(base_path('routes/web.php'))) {\\n            require base_path('routes/web.php');\\n\\n            $menu = Voyager::model('Menu')->where('name', config('voyager.bread.default_menu'))->firstOrFail();\\n\\n            $menuItem = Voyager::model('MenuItem')->firstOrNew([\\n                'menu_id' => $menu->id,\\n                'title'   => $bread->dataType->display_name_plural,\\n                'url'     => '',\\n                'route'   => 'voyager.'.$bread->dataType->slug.'.index',\\n            ]);\\n\\n            $order = Voyager::model('MenuItem')->highestOrderMenuItem();\\n\\n            if (!$menuItem->exists) {\\n                $menuItem->fill([\\n                    'target'     => '_self',\\n                    'icon_class' => $bread->dataType->icon,\\n                    'color'      => null,\\n                    'parent_id'  => null,\\n                    'order'      => $order,\\n                ])->save();\\n            }\\n        }\\n    }\", \"output\": \"Create a MenuItem for a given BREAD.\\n\\n@param BreadAdded $event\\n\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function update($table)\\n    {\\n        if (!is_array($table)) {\\n            $table = json_decode($table, true);\\n        }\\n\\n        if (!SchemaManager::tableExists($table['oldName'])) {\\n            throw SchemaException::tableDoesNotExist($table['oldName']);\\n        }\\n\\n        $updater = new self($table);\\n\\n        $updater->updateTable();\\n    }\", \"output\": \"Update the table.\\n\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: public function updateTable()\\n    {\\n        // Get table new name\\n        if (($newName = $this->table->getName()) != $this->originalTable->getName()) {\\n            // Make sure the new name doesn't already exist\\n            if (SchemaManager::tableExists($newName)) {\\n                throw SchemaException::tableAlreadyExists($newName);\\n            }\\n        } else {\\n            $newName = false;\\n        }\\n\\n        // Rename columns\\n        if ($renamedColumnsDiff = $this->getRenamedColumnsDiff()) {\\n            SchemaManager::alterTable($renamedColumnsDiff);\\n\\n            // Refresh original table after renaming the columns\\n            $this->originalTable = SchemaManager::listTableDetails($this->tableArr['oldName']);\\n        }\\n\\n        $tableDiff = $this->originalTable->diff($this->table);\\n\\n        // Add new table name to tableDiff\\n        if ($newName) {\\n            if (!$tableDiff) {\\n                $tableDiff = new TableDiff($this->tableArr['oldName']);\\n                $tableDiff->fromTable = $this->originalTable;\\n            }\\n\\n            $tableDiff->newName = $newName;\\n        }\\n\\n        // Update the table\\n        if ($tableDiff) {\\n            SchemaManager::alterTable($tableDiff);\\n        }\\n    }\", \"output\": \"Updates the table.\\n\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function getRenamedColumnsDiff()\\n    {\\n        $renamedColumns = $this->getRenamedColumns();\\n\\n        if (empty($renamedColumns)) {\\n            return false;\\n        }\\n\\n        $renamedColumnsDiff = new TableDiff($this->tableArr['oldName']);\\n        $renamedColumnsDiff->fromTable = $this->originalTable;\\n\\n        foreach ($renamedColumns as $oldName => $newName) {\\n            $renamedColumnsDiff->renamedColumns[$oldName] = $this->table->getColumn($newName);\\n        }\\n\\n        return $renamedColumnsDiff;\\n    }\", \"output\": \"Get the table diff to rename columns.\\n\\n@return \\\\Doctrine\\\\DBAL\\\\Schema\\\\TableDiff\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function getRenamedDiff()\\n    {\\n        $renamedColumns = $this->getRenamedColumns();\\n        $renamedIndexes = $this->getRenamedIndexes();\\n\\n        if (empty($renamedColumns) && empty($renamedIndexes)) {\\n            return false;\\n        }\\n\\n        $renamedDiff = new TableDiff($this->tableArr['oldName']);\\n        $renamedDiff->fromTable = $this->originalTable;\\n\\n        foreach ($renamedColumns as $oldName => $newName) {\\n            $renamedDiff->renamedColumns[$oldName] = $this->table->getColumn($newName);\\n        }\\n\\n        foreach ($renamedIndexes as $oldName => $newName) {\\n            $renamedDiff->renamedIndexes[$oldName] = $this->table->getIndex($newName);\\n        }\\n\\n        return $renamedDiff;\\n    }\", \"output\": \"Get the table diff to rename columns and indexes.\\n\\n@return \\\\Doctrine\\\\DBAL\\\\Schema\\\\TableDiff\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function getRenamedColumns()\\n    {\\n        $renamedColumns = [];\\n\\n        foreach ($this->tableArr['columns'] as $column) {\\n            $oldName = $column['oldName'];\\n\\n            // make sure this is an existing column and not a new one\\n            if ($this->originalTable->hasColumn($oldName)) {\\n                $name = $column['name'];\\n\\n                if ($name != $oldName) {\\n                    $renamedColumns[$oldName] = $name;\\n                }\\n            }\\n        }\\n\\n        return $renamedColumns;\\n    }\", \"output\": \"Get columns that were renamed.\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function getRenamedIndexes()\\n    {\\n        $renamedIndexes = [];\\n\\n        foreach ($this->tableArr['indexes'] as $index) {\\n            $oldName = $index['oldName'];\\n\\n            // make sure this is an existing index and not a new one\\n            if ($this->originalTable->hasIndex($oldName)) {\\n                $name = $index['name'];\\n\\n                if ($name != $oldName) {\\n                    $renamedIndexes[$oldName] = $name;\\n                }\\n            }\\n        }\\n\\n        return $renamedIndexes;\\n    }\", \"output\": \"Get indexes that were renamed.\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: public function thumbnail($type, $attribute = 'image')\\n    {\\n        // Return empty string if the field not found\\n        if (!isset($this->attributes[$attribute])) {\\n            return '';\\n        }\\n\\n        // We take image from posts field\\n        $image = $this->attributes[$attribute];\\n\\n        return $this->getThumbnail($image, $type);\\n    }\", \"output\": \"Method for returning specific thumbnail for model.\\n\\n@param string $type\\n@param string $attribute\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getThumbnail($image, $type)\\n    {\\n        // We need to get extension type ( .jpeg , .png ...)\\n        $ext = pathinfo($image, PATHINFO_EXTENSION);\\n\\n        // We remove extension from file name so we can append thumbnail type\\n        $name = Str::replaceLast('.'.$ext, '', $image);\\n\\n        // We merge original name + type + extension\\n        return $name.'-'.$type.'.'.$ext;\\n    }\", \"output\": \"Generate thumbnail URL.\\n\\n@param $image\\n@param $type\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function editRoles(User $user, $model)\\n    {\\n        // Does this record belong to another user?\\n        $another = $user->id != $model->id;\\n\\n        return $another && $user->hasPermission('edit_users');\\n    }\", \"output\": \"Determine if the given user can change a user a role.\\n\\n@param \\\\TCG\\\\Voyager\\\\Contracts\\\\User $user\\n@param  $model\\n\\n@return bool\"}"}
{"text": "{\"input\": \"Summarize the following code: public function dimmers()\\n    {\\n        $widgetClasses = config('voyager.dashboard.widgets');\\n        $dimmers = Widget::group('voyager::dimmers');\\n\\n        foreach ($widgetClasses as $widgetClass) {\\n            $widget = app($widgetClass);\\n\\n            if ($widget->shouldBeDisplayed()) {\\n                $dimmers->addWidget($widgetClass);\\n            }\\n        }\\n\\n        return $dimmers;\\n    }\", \"output\": \"Get a collection of the dashboard widgets.\\n\\n@return \\\\Arrilot\\\\Widgets\\\\WidgetGroup\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function prepareMenuTranslations(&$data)\\n    {\\n        $trans = json_decode($data['title_i18n'], true);\\n\\n        // Set field value with the default locale\\n        $data['title'] = $trans[config('voyager.multilingual.default', 'en')];\\n\\n        unset($data['title_i18n']);     // Remove hidden input holding translations\\n        unset($data['i18n_selector']);  // Remove language selector input radio\\n\\n        return $trans;\\n    }\", \"output\": \"Prepare menu translations.\\n\\n@param array $data menu data\\n\\n@return JSON translated item\"}"}
{"text": "{\"input\": \"Summarize the following code: public function save()\\n    {\\n        $attributes = $this->getModifiedAttributes();\\n        $savings = [];\\n\\n        foreach ($attributes as $key => $attribute) {\\n            if ($attribute['exists']) {\\n                $translation = $this->getTranslationModel($key);\\n            } else {\\n                $translation = VoyagerFacade::model('Translation')->where('table_name', $this->model->getTable())\\n                    ->where('column_name', $key)\\n                    ->where('foreign_key', $this->model->getKey())\\n                    ->where('locale', $this->locale)\\n                    ->first();\\n            }\\n\\n            if (is_null($translation)) {\\n                $translation = VoyagerFacade::model('Translation');\\n            }\\n\\n            $translation->fill([\\n                'table_name'  => $this->model->getTable(),\\n                'column_name' => $key,\\n                'foreign_key' => $this->model->getKey(),\\n                'value'       => $attribute['value'],\\n                'locale'      => $this->locale,\\n            ]);\\n\\n            $savings[] = $translation->save();\\n\\n            $this->attributes[$key]['locale'] = $this->locale;\\n            $this->attributes[$key]['exists'] = true;\\n            $this->attributes[$key]['modified'] = false;\\n        }\\n\\n        return in_array(false, $savings);\\n    }\", \"output\": \"Save changes made to the translator attributes.\\n\\n@return bool\"}"}
{"text": "{\"input\": \"Summarize the following code: public function read(User $user, $model)\\n    {\\n        // Does this post belong to the current user?\\n        $current = $user->id === $model->author_id;\\n\\n        return $current || $this->checkPermission($user, $model, 'read');\\n    }\", \"output\": \"Determine if the given model can be viewed by the user.\\n\\n@param \\\\TCG\\\\Voyager\\\\Contracts\\\\User $user\\n@param  $model\\n\\n@return bool\"}"}
{"text": "{\"input\": \"Summarize the following code: public function create(Request $request, $table)\\n    {\\n        $this->authorize('browse_bread');\\n\\n        $dataType = Voyager::model('DataType')->whereName($table)->first();\\n\\n        $data = $this->prepopulateBreadInfo($table);\\n        $data['fieldOptions'] = SchemaManager::describeTable((isset($dataType) && strlen($dataType->model_name) != 0)\\n            ? app($dataType->model_name)->getTable()\\n            : $table\\n        );\\n\\n        return Voyager::view('voyager::tools.bread.edit-add', $data);\\n    }\", \"output\": \"Create BREAD.\\n\\n@param Request $request\\n@param string  $table   Table name.\\n\\n@return \\\\Illuminate\\\\Contracts\\\\View\\\\Factory|\\\\Illuminate\\\\View\\\\View\"}"}
{"text": "{\"input\": \"Summarize the following code: public function store(Request $request)\\n    {\\n        $this->authorize('browse_bread');\\n\\n        try {\\n            $dataType = Voyager::model('DataType');\\n            $res = $dataType->updateDataType($request->all(), true);\\n            $data = $res\\n                ? $this->alertSuccess(__('voyager::bread.success_created_bread'))\\n                : $this->alertError(__('voyager::bread.error_creating_bread'));\\n            if ($res) {\\n                event(new BreadAdded($dataType, $data));\\n            }\\n\\n            return redirect()->route('voyager.bread.index')->with($data);\\n        } catch (Exception $e) {\\n            return redirect()->route('voyager.bread.index')->with($this->alertException($e, 'Saving Failed'));\\n        }\\n    }\", \"output\": \"Store BREAD.\\n\\n@param \\\\Illuminate\\\\Http\\\\Request $request\\n\\n@return \\\\Illuminate\\\\Http\\\\RedirectResponse\"}"}
{"text": "{\"input\": \"Summarize the following code: public function edit($table)\\n    {\\n        $this->authorize('browse_bread');\\n\\n        $dataType = Voyager::model('DataType')->whereName($table)->first();\\n\\n        $fieldOptions = SchemaManager::describeTable((strlen($dataType->model_name) != 0)\\n            ? app($dataType->model_name)->getTable()\\n            : $dataType->name\\n        );\\n\\n        $isModelTranslatable = is_bread_translatable($dataType);\\n        $tables = SchemaManager::listTableNames();\\n        $dataTypeRelationships = Voyager::model('DataRow')->where('data_type_id', '=', $dataType->id)->where('type', '=', 'relationship')->get();\\n        $scopes = [];\\n        if ($dataType->model_name != '') {\\n            $scopes = $this->getModelScopes($dataType->model_name);\\n        }\\n\\n        return Voyager::view('voyager::tools.bread.edit-add', compact('dataType', 'fieldOptions', 'isModelTranslatable', 'tables', 'dataTypeRelationships', 'scopes'));\\n    }\", \"output\": \"Edit BREAD.\\n\\n@param string $table\\n\\n@return \\\\Illuminate\\\\Contracts\\\\View\\\\Factory|\\\\Illuminate\\\\View\\\\View\"}"}
{"text": "{\"input\": \"Summarize the following code: public function update(Request $request, $id)\\n    {\\n        $this->authorize('browse_bread');\\n\\n        /* @var \\\\TCG\\\\Voyager\\\\Models\\\\DataType $dataType */\\n        try {\\n            $dataType = Voyager::model('DataType')->find($id);\\n\\n            // Prepare Translations and Transform data\\n            $translations = is_bread_translatable($dataType)\\n                ? $dataType->prepareTranslations($request)\\n                : [];\\n\\n            $res = $dataType->updateDataType($request->all(), true);\\n            $data = $res\\n                ? $this->alertSuccess(__('voyager::bread.success_update_bread', ['datatype' => $dataType->name]))\\n                : $this->alertError(__('voyager::bread.error_updating_bread'));\\n            if ($res) {\\n                event(new BreadUpdated($dataType, $data));\\n            }\\n\\n            // Save translations if applied\\n            $dataType->saveTranslations($translations);\\n\\n            return redirect()->route('voyager.bread.index')->with($data);\\n        } catch (Exception $e) {\\n            return back()->with($this->alertException($e, __('voyager::generic.update_failed')));\\n        }\\n    }\", \"output\": \"Update BREAD.\\n\\n@param \\\\Illuminate\\\\Http\\\\Request $request\\n@param number                   $id\\n\\n@return \\\\Illuminate\\\\Contracts\\\\View\\\\Factory|\\\\Illuminate\\\\View\\\\View\"}"}
{"text": "{\"input\": \"Summarize the following code: public function destroy($id)\\n    {\\n        $this->authorize('browse_bread');\\n\\n        /* @var \\\\TCG\\\\Voyager\\\\Models\\\\DataType $dataType */\\n        $dataType = Voyager::model('DataType')->find($id);\\n\\n        // Delete Translations, if present\\n        if (is_bread_translatable($dataType)) {\\n            $dataType->deleteAttributeTranslations($dataType->getTranslatableAttributes());\\n        }\\n\\n        $res = Voyager::model('DataType')->destroy($id);\\n        $data = $res\\n            ? $this->alertSuccess(__('voyager::bread.success_remove_bread', ['datatype' => $dataType->name]))\\n            : $this->alertError(__('voyager::bread.error_updating_bread'));\\n        if ($res) {\\n            event(new BreadDeleted($dataType, $data));\\n        }\\n\\n        if (!is_null($dataType)) {\\n            Voyager::model('Permission')->removeFrom($dataType->name);\\n        }\\n\\n        return redirect()->route('voyager.bread.index')->with($data);\\n    }\", \"output\": \"Delete BREAD.\\n\\n@param Number $id BREAD data_type id.\\n\\n@return \\\\Illuminate\\\\Http\\\\RedirectResponse\"}"}
{"text": "{\"input\": \"Summarize the following code: public function addRelationship(Request $request)\\n    {\\n        $relationshipField = $this->getRelationshipField($request);\\n\\n        if (!class_exists($request->relationship_model)) {\\n            return back()->with([\\n                'message'    => 'Model Class '.$request->relationship_model.' does not exist. Please create Model before creating relationship.',\\n                'alert-type' => 'error',\\n            ]);\\n        }\\n\\n        try {\\n            DB::beginTransaction();\\n\\n            $relationship_column = $request->relationship_column_belongs_to;\\n            if ($request->relationship_type == 'hasOne' || $request->relationship_type == 'hasMany') {\\n                $relationship_column = $request->relationship_column;\\n            }\\n\\n            // Build the relationship details\\n            $relationshipDetails = [\\n                'model'       => $request->relationship_model,\\n                'table'       => $request->relationship_table,\\n                'type'        => $request->relationship_type,\\n                'column'      => $relationship_column,\\n                'key'         => $request->relationship_key,\\n                'label'       => $request->relationship_label,\\n                'pivot_table' => $request->relationship_pivot,\\n                'pivot'       => ($request->relationship_type == 'belongsToMany') ? '1' : '0',\\n                'taggable'    => $request->relationship_taggable,\\n            ];\\n\\n            $className = Voyager::modelClass('DataRow');\\n            $newRow = new $className();\\n\\n            $newRow->data_type_id = $request->data_type_id;\\n            $newRow->field = $relationshipField;\\n            $newRow->type = 'relationship';\\n            $newRow->display_name = $request->relationship_table;\\n            $newRow->required = 0;\\n\\n            foreach (['browse', 'read', 'edit', 'add', 'delete'] as $check) {\\n                $newRow->{$check} = 1;\\n            }\\n\\n            $newRow->details = $relationshipDetails;\\n            $newRow->order = intval(Voyager::model('DataType')->find($request->data_type_id)->lastRow()->order) + 1;\\n\\n            if (!$newRow->save()) {\\n                return back()->with([\\n                    'message'    => 'Error saving new relationship row for '.$request->relationship_table,\\n                    'alert-type' => 'error',\\n                ]);\\n            }\\n\\n            DB::commit();\\n\\n            return back()->with([\\n                'message'    => 'Successfully created new relationship for '.$request->relationship_table,\\n                'alert-type' => 'success',\\n            ]);\\n        } catch (\\\\Exception $e) {\\n            DB::rollBack();\\n\\n            return back()->with([\\n                'message'    => 'Error creating new relationship: '.$e->getMessage(),\\n                'alert-type' => 'error',\\n            ]);\\n        }\\n    }\", \"output\": \"Add Relationship.\\n\\n@param Request $request\"}"}
{"text": "{\"input\": \"Summarize the following code: private function getRelationshipField($request)\\n    {\\n        // We need to make sure that we aren't creating an already existing field\\n\\n        $dataType = Voyager::model('DataType')->find($request->data_type_id);\\n\\n        $field = Str::singular($dataType->name).'_'.$request->relationship_type.'_'.Str::singular($request->relationship_table).'_relationship';\\n\\n        $relationshipFieldOriginal = $relationshipField = strtolower($field);\\n\\n        $existingRow = Voyager::model('DataRow')->where('field', '=', $relationshipField)->first();\\n        $index = 1;\\n\\n        while (isset($existingRow->id)) {\\n            $relationshipField = $relationshipFieldOriginal.'_'.$index;\\n            $existingRow = Voyager::model('DataRow')->where('field', '=', $relationshipField)->first();\\n            $index += 1;\\n        }\\n\\n        return $relationshipField;\\n    }\", \"output\": \"Get Relationship Field.\\n\\n@param Request $request\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function handle()\\n    {\\n        return empty($this->request->input($this->row->field)) ? null :\\n            bcrypt($this->request->input($this->row->field));\\n    }\", \"output\": \"Handle password fields.\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function edit($table)\\n    {\\n        $this->authorize('browse_database');\\n\\n        if (!SchemaManager::tableExists($table)) {\\n            return redirect()\\n                ->route('voyager.database.index')\\n                ->with($this->alertError(__('voyager::database.edit_table_not_exist')));\\n        }\\n\\n        $db = $this->prepareDbManager('update', $table);\\n\\n        return Voyager::view('voyager::tools.database.edit-add', compact('db'));\\n    }\", \"output\": \"Edit database table.\\n\\n@param string $table\\n\\n@return \\\\Illuminate\\\\Http\\\\RedirectResponse\"}"}
{"text": "{\"input\": \"Summarize the following code: public function update(Request $request)\\n    {\\n        $this->authorize('browse_database');\\n\\n        $table = json_decode($request->table, true);\\n\\n        try {\\n            DatabaseUpdater::update($table);\\n            // TODO: synch BREAD with Table\\n            // $this->cleanOldAndCreateNew($request->original_name, $request->name);\\n            event(new TableUpdated($table));\\n        } catch (Exception $e) {\\n            return back()->with($this->alertException($e))->withInput();\\n        }\\n\\n        return redirect()\\n               ->route('voyager.database.index')\\n               ->with($this->alertSuccess(__('voyager::database.success_create_table', ['table' => $table['name']])));\\n    }\", \"output\": \"Update database table.\\n\\n@param \\\\Illuminate\\\\Http\\\\Request $request\\n\\n@return \\\\Illuminate\\\\Http\\\\RedirectResponse\"}"}
{"text": "{\"input\": \"Summarize the following code: public function show($table)\\n    {\\n        $this->authorize('browse_database');\\n\\n        $additional_attributes = [];\\n        $model_name = Voyager::model('DataType')->where('name', $table)->pluck('model_name')->first();\\n        if (isset($model_name)) {\\n            $model = app($model_name);\\n            if (isset($model->additional_attributes)) {\\n                foreach ($model->additional_attributes as $attribute) {\\n                    $additional_attributes[$attribute] = [];\\n                }\\n            }\\n        }\\n\\n        return response()->json(collect(SchemaManager::describeTable($table))->merge($additional_attributes));\\n    }\", \"output\": \"Show table.\\n\\n@param string $table\\n\\n@return JSON\"}"}
{"text": "{\"input\": \"Summarize the following code: public function destroy($table)\\n    {\\n        $this->authorize('browse_database');\\n\\n        try {\\n            SchemaManager::dropTable($table);\\n            event(new TableDeleted($table));\\n\\n            return redirect()\\n                ->route('voyager.database.index')\\n                ->with($this->alertSuccess(__('voyager::database.success_delete_table', ['table' => $table])));\\n        } catch (Exception $e) {\\n            return back()->with($this->alertException($e));\\n        }\\n    }\", \"output\": \"Destroy table.\\n\\n@param string $table\\n\\n@return \\\\Illuminate\\\\Http\\\\RedirectResponse\"}"}
{"text": "{\"input\": \"Summarize the following code: public function sortByUrl($orderBy, $sortOrder)\\n    {\\n        $params = [];\\n        $isDesc = $sortOrder != 'asc';\\n        if ($this->isCurrentSortField($orderBy) && $isDesc) {\\n            $params['sort_order'] = 'asc';\\n        } else {\\n            $params['sort_order'] = 'desc';\\n        }\\n        $params['order_by'] = $this->field;\\n\\n        return url()->current().'?'.http_build_query(array_merge(\\\\Request::all(), $params));\\n    }\", \"output\": \"Build the URL to sort data type by this field.\\n\\n@return string Built URL\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function display($menuName, $type = null, array $options = [])\\n    {\\n        // GET THE MENU - sort collection in blade\\n        $menu = \\\\Cache::remember('voyager_menu_'.$menuName, \\\\Carbon\\\\Carbon::now()->addDays(30), function () use ($menuName) {\\n            return static::where('name', '=', $menuName)\\n            ->with(['parent_items.children' => function ($q) {\\n                $q->orderBy('order');\\n            }])\\n            ->first();\\n        });\\n\\n        // Check for Menu Existence\\n        if (!isset($menu)) {\\n            return false;\\n        }\\n\\n        event(new MenuDisplay($menu));\\n\\n        // Convert options array into object\\n        $options = (object) $options;\\n\\n        $items = $menu->parent_items->sortBy('order');\\n\\n        if ($menuName == 'admin' && $type == '_json') {\\n            $items = static::processItems($items);\\n        }\\n\\n        if ($type == 'admin') {\\n            $type = 'voyager::menu.'.$type;\\n        } else {\\n            if (is_null($type)) {\\n                $type = 'voyager::menu.default';\\n            } elseif ($type == 'bootstrap' && !view()->exists($type)) {\\n                $type = 'voyager::menu.bootstrap';\\n            }\\n        }\\n\\n        if (!isset($options->locale)) {\\n            $options->locale = app()->getLocale();\\n        }\\n\\n        if ($type === '_json') {\\n            return $items;\\n        }\\n\\n        return new \\\\Illuminate\\\\Support\\\\HtmlString(\\n            \\\\Illuminate\\\\Support\\\\Facades\\\\View::make($type, ['items' => $items, 'options' => $options])->render()\\n        );\\n    }\", \"output\": \"Display menu.\\n\\n@param string      $menuName\\n@param string|null $type\\n@param array       $options\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function translatable()\\n    {\\n        if (isset($this->translatable) && $this->translatable == false) {\\n            return false;\\n        }\\n\\n        return !empty($this->getTranslatableAttributes());\\n    }\", \"output\": \"Check if this model can translate.\\n\\n@return bool\"}"}
{"text": "{\"input\": \"Summarize the following code: public function translations()\\n    {\\n        return $this->hasMany(Voyager::model('Translation'), 'foreign_key', $this->getKeyName())\\n            ->where('table_name', $this->getTable())\\n            ->whereIn('locale', config('voyager.multilingual.locales', []));\\n    }\", \"output\": \"Load translations relation.\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getTranslatedAttribute($attribute, $language = null, $fallback = true)\\n    {\\n        list($value) = $this->getTranslatedAttributeMeta($attribute, $language, $fallback);\\n\\n        return $value;\\n    }\", \"output\": \"Get a single translated attribute.\\n\\n@param $attribute\\n@param null $language\\n@param bool $fallback\\n\\n@return null\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function scopeWhereTranslation($query, $field, $operator, $value = null, $locales = null, $default = true)\\n    {\\n        if ($locales && !is_array($locales)) {\\n            $locales = [$locales];\\n        }\\n        if (!isset($value)) {\\n            $value = $operator;\\n            $operator = '=';\\n        }\\n\\n        $self = new static();\\n        $table = $self->getTable();\\n\\n        return $query->whereIn($self->getKeyName(), Translation::where('table_name', $table)\\n            ->where('column_name', $field)\\n            ->where('value', $operator, $value)\\n            ->when(!is_null($locales), function ($query) use ($locales) {\\n                return $query->whereIn('locale', $locales);\\n            })\\n            ->pluck('foreign_key')\\n        )->when($default, function ($query) use ($field, $operator, $value) {\\n            return $query->orWhere($field, $operator, $value);\\n        });\\n    }\", \"output\": \"Get entries filtered by translated value.\\n\\n@example  Class::whereTranslation('title', '=', 'zuhause', ['de', 'iu'])\\n@example  $query->whereTranslation('title', '=', 'zuhause', ['de', 'iu'])\\n\\n@param string       $field    {required} the field your looking to find a value in.\\n@param string       $operator {required} value you are looking for or a relation modifier such as LIKE, =, etc.\\n@param string       $value    {optional} value you are looking for. Only use if you supplied an operator.\\n@param string|array $locales  {optional} locale(s) you are looking for the field.\\n@param bool         $default  {optional} if true checks for $value is in default database before checking translations.\\n\\n@return Builder\"}"}
{"text": "{\"input\": \"Summarize the following code: public function saveTranslations($translations)\\n    {\\n        foreach ($translations as $field => $locales) {\\n            foreach ($locales as $locale => $translation) {\\n                $translation->save();\\n            }\\n        }\\n    }\", \"output\": \"Save translations.\\n\\n@param object $translations\\n\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function describeTable($tableName)\\n    {\\n        Type::registerCustomPlatformTypes();\\n\\n        $table = static::listTableDetails($tableName);\\n\\n        return collect($table->columns)->map(function ($column) use ($table) {\\n            $columnArr = Column::toArray($column);\\n\\n            $columnArr['field'] = $columnArr['name'];\\n            $columnArr['type'] = $columnArr['type']['name'];\\n\\n            // Set the indexes and key\\n            $columnArr['indexes'] = [];\\n            $columnArr['key'] = null;\\n            if ($columnArr['indexes'] = $table->getColumnsIndexes($columnArr['name'], true)) {\\n                // Convert indexes to Array\\n                foreach ($columnArr['indexes'] as $name => $index) {\\n                    $columnArr['indexes'][$name] = Index::toArray($index);\\n                }\\n\\n                // If there are multiple indexes for the column\\n                // the Key will be one with highest priority\\n                $indexType = array_values($columnArr['indexes'])[0]['type'];\\n                $columnArr['key'] = substr($indexType, 0, 3);\\n            }\\n\\n            return $columnArr;\\n        });\\n    }\", \"output\": \"Describes given table.\\n\\n@param string $tableName\\n\\n@return \\\\Illuminate\\\\Support\\\\Collection\"}"}
{"text": "{\"input\": \"Summarize the following code: public function handle(BreadAdded $bread)\\n    {\\n        if (config('voyager.bread.add_permission') && file_exists(base_path('routes/web.php'))) {\\n            // Create permission\\n            //\\n            // Permission::generateFor(snake_case($bread->dataType->slug));\\n            $role = Voyager::model('Role')->where('name', config('voyager.bread.default_role'))->firstOrFail();\\n\\n            // Get permission for added table\\n            $permissions = Voyager::model('Permission')->where(['table_name' => $bread->dataType->name])->get()->pluck('id')->all();\\n\\n            // Assign permission to admin\\n            $role->permissions()->attach($permissions);\\n        }\\n    }\", \"output\": \"Create Permission for a given BREAD.\\n\\n@param BreadAdded $event\\n\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function addStorageSymlinkAlert()\\n    {\\n        if (app('router')->current() !== null) {\\n            $currentRouteAction = app('router')->current()->getAction();\\n        } else {\\n            $currentRouteAction = null;\\n        }\\n        $routeName = is_array($currentRouteAction) ? Arr::get($currentRouteAction, 'as') : null;\\n\\n        if ($routeName != 'voyager.dashboard') {\\n            return;\\n        }\\n\\n        $storage_disk = (!empty(config('voyager.storage.disk'))) ? config('voyager.storage.disk') : 'public';\\n\\n        if (request()->has('fix-missing-storage-symlink')) {\\n            if (file_exists(public_path('storage'))) {\\n                if (@readlink(public_path('storage')) == public_path('storage')) {\\n                    rename(public_path('storage'), 'storage_old');\\n                }\\n            }\\n\\n            if (!file_exists(public_path('storage'))) {\\n                $this->fixMissingStorageSymlink();\\n            }\\n        } elseif ($storage_disk == 'public') {\\n            if (!file_exists(public_path('storage')) || @readlink(public_path('storage')) == public_path('storage')) {\\n                $alert = (new Alert('missing-storage-symlink', 'warning'))\\n                    ->title(__('voyager::error.symlink_missing_title'))\\n                    ->text(__('voyager::error.symlink_missing_text'))\\n                    ->button(__('voyager::error.symlink_missing_button'), '?fix-missing-storage-symlink=1');\\n                VoyagerFacade::addAlert($alert);\\n            }\\n        }\\n    }\", \"output\": \"Add storage symlink alert.\"}"}
{"text": "{\"input\": \"Summarize the following code: private function registerConsoleCommands()\\n    {\\n        $this->commands(Commands\\\\InstallCommand::class);\\n        $this->commands(Commands\\\\ControllersCommand::class);\\n        $this->commands(Commands\\\\AdminCommand::class);\\n    }\", \"output\": \"Register the commands accessible from the Console.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function cleanup($dataType, $data)\\n    {\\n        // Delete Translations, if present\\n        if (is_bread_translatable($data)) {\\n            $data->deleteAttributeTranslations($data->getTranslatableAttributes());\\n        }\\n\\n        // Delete Images\\n        $this->deleteBreadImages($data, $dataType->deleteRows->where('type', 'image'));\\n\\n        // Delete Files\\n        foreach ($dataType->deleteRows->where('type', 'file') as $row) {\\n            if (isset($data->{$row->field})) {\\n                foreach (json_decode($data->{$row->field}) as $file) {\\n                    $this->deleteFileIfExists($file->download_link);\\n                }\\n            }\\n        }\\n\\n        // Delete media-picker files\\n        $dataType->rows->where('type', 'media_picker')->where('details.delete_files', true)->each(function ($row) use ($data) {\\n            $content = $data->{$row->field};\\n            if (isset($content)) {\\n                if (!is_array($content)) {\\n                    $content = json_decode($content);\\n                }\\n                if (is_array($content)) {\\n                    foreach ($content as $file) {\\n                        $this->deleteFileIfExists($file);\\n                    }\\n                } else {\\n                    $this->deleteFileIfExists($content);\\n                }\\n            }\\n        });\\n    }\", \"output\": \"Remove translations, images and files related to a BREAD item.\\n\\n@param \\\\Illuminate\\\\Database\\\\Eloquent\\\\Model $dataType\\n@param \\\\Illuminate\\\\Database\\\\Eloquent\\\\Model $data\\n\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: public function deleteBreadImages($data, $rows)\\n    {\\n        foreach ($rows as $row) {\\n            if ($data->{$row->field} != config('voyager.user.default_avatar')) {\\n                $this->deleteFileIfExists($data->{$row->field});\\n            }\\n\\n            if (isset($row->details->thumbnails)) {\\n                foreach ($row->details->thumbnails as $thumbnail) {\\n                    $ext = explode('.', $data->{$row->field});\\n                    $extension = '.'.$ext[count($ext) - 1];\\n\\n                    $path = str_replace($extension, '', $data->{$row->field});\\n\\n                    $thumb_name = $thumbnail->name;\\n\\n                    $this->deleteFileIfExists($path.'-'.$thumb_name.$extension);\\n                }\\n            }\\n        }\\n\\n        if ($rows->count() > 0) {\\n            event(new BreadImagesDeleted($data, $rows));\\n        }\\n    }\", \"output\": \"Delete all images related to a BREAD item.\\n\\n@param \\\\Illuminate\\\\Database\\\\Eloquent\\\\Model $data\\n@param \\\\Illuminate\\\\Database\\\\Eloquent\\\\Model $rows\\n\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: public function order(Request $request)\\n    {\\n        $slug = $this->getSlug($request);\\n\\n        $dataType = Voyager::model('DataType')->where('slug', '=', $slug)->first();\\n\\n        // Check permission\\n        $this->authorize('edit', app($dataType->model_name));\\n\\n        if (!isset($dataType->order_column) || !isset($dataType->order_display_column)) {\\n            return redirect()\\n            ->route(\\\"voyager.{$dataType->slug}.index\\\")\\n            ->with([\\n                'message'    => __('voyager::bread.ordering_not_set'),\\n                'alert-type' => 'error',\\n            ]);\\n        }\\n\\n        $model = app($dataType->model_name);\\n        if ($model && in_array(SoftDeletes::class, class_uses($model))) {\\n            $model = $model->withTrashed();\\n        }\\n        $results = $model->orderBy($dataType->order_column, $dataType->order_direction)->get();\\n\\n        $display_column = $dataType->order_display_column;\\n\\n        $dataRow = Voyager::model('DataRow')->whereDataTypeId($dataType->id)->whereField($display_column)->first();\\n\\n        $view = 'voyager::bread.order';\\n\\n        if (view()->exists(\\\"voyager::$slug.order\\\")) {\\n            $view = \\\"voyager::$slug.order\\\";\\n        }\\n\\n        return Voyager::view($view, compact(\\n            'dataType',\\n            'display_column',\\n            'dataRow',\\n            'results'\\n        ));\\n    }\", \"output\": \"Order BREAD items.\\n\\n@param string $table\\n\\n@return \\\\Illuminate\\\\Contracts\\\\View\\\\Factory|\\\\Illuminate\\\\View\\\\View\"}"}
{"text": "{\"input\": \"Summarize the following code: public function relation(Request $request)\\n    {\\n        $slug = $this->getSlug($request);\\n        $page = $request->input('page');\\n        $on_page = 50;\\n        $search = $request->input('search', false);\\n        $dataType = Voyager::model('DataType')->where('slug', '=', $slug)->first();\\n\\n        foreach ($dataType->editRows as $key => $row) {\\n            if ($row->field === $request->input('type')) {\\n                $options = $row->details;\\n                $skip = $on_page * ($page - 1);\\n\\n                // If search query, use LIKE to filter results depending on field label\\n                if ($search) {\\n                    $total_count = app($options->model)->where($options->label, 'LIKE', '%'.$search.'%')->count();\\n                    $relationshipOptions = app($options->model)->take($on_page)->skip($skip)\\n                        ->where($options->label, 'LIKE', '%'.$search.'%')\\n                        ->get();\\n                } else {\\n                    $total_count = app($options->model)->count();\\n                    $relationshipOptions = app($options->model)->take($on_page)->skip($skip)->get();\\n                }\\n\\n                $results = [];\\n                foreach ($relationshipOptions as $relationshipOption) {\\n                    $results[] = [\\n                        'id'   => $relationshipOption->{$options->key},\\n                        'text' => $relationshipOption->{$options->label},\\n                    ];\\n                }\\n\\n                return response()->json([\\n                    'results'    => $results,\\n                    'pagination' => [\\n                        'more' => ($total_count > ($skip + $on_page)),\\n                    ],\\n                ]);\\n            }\\n        }\\n\\n        // No result found, return empty array\\n        return response()->json([], 404);\\n    }\", \"output\": \"Get BREAD relations data.\\n\\n@param Request $request\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function resolveRelations($dataTypeContent, DataType $dataType)\\n    {\\n        // In case of using server-side pagination, we need to work on the Collection (BROWSE)\\n        if ($dataTypeContent instanceof LengthAwarePaginator) {\\n            $dataTypeCollection = $dataTypeContent->getCollection();\\n        }\\n        // If it's a model just make the changes directly on it (READ / EDIT)\\n        elseif ($dataTypeContent instanceof Model) {\\n            return $dataTypeContent;\\n        }\\n        // Or we assume it's a Collection\\n        else {\\n            $dataTypeCollection = $dataTypeContent;\\n        }\\n\\n        return $dataTypeContent instanceof LengthAwarePaginator ? $dataTypeContent->setCollection($dataTypeCollection) : $dataTypeCollection;\\n    }\", \"output\": \"Replace relationships' keys for labels and create READ links if a slug is provided.\\n\\n@param  $dataTypeContent     Can be either an eloquent Model, Collection or LengthAwarePaginator instance.\\n@param DataType $dataType\\n\\n@return $dataTypeContent\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function addSoftDelete(&$stub)\\n    {\\n        $traitIncl = $trait = '';\\n\\n        if ($this->option('softdelete')) {\\n            $traitIncl = 'use Illuminate\\\\Database\\\\Eloquent\\\\SoftDeletes;';\\n            $trait = 'use SoftDeletes;';\\n        }\\n\\n        $stub = str_replace('//DummySDTraitInclude', $traitIncl, $stub);\\n        $stub = str_replace('//DummySDTrait', $trait, $stub);\\n\\n        return $this;\\n    }\", \"output\": \"Add SoftDelete to the given stub.\\n\\n@param string $stub\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: public function validateBread($request, $data, $name = null, $id = null)\\n    {\\n        $rules = [];\\n        $messages = [];\\n        $customAttributes = [];\\n        $is_update = $name && $id;\\n\\n        $fieldsWithValidationRules = $this->getFieldsWithValidationRules($data);\\n\\n        foreach ($fieldsWithValidationRules as $field) {\\n            $fieldRules = $field->details->validation->rule;\\n            $fieldName = $field->field;\\n\\n            // Show the field's display name on the error message\\n            if (!empty($field->display_name)) {\\n                $customAttributes[$fieldName] = $field->display_name;\\n            }\\n\\n            // Get the rules for the current field whatever the format it is in\\n            $rules[$fieldName] = is_array($fieldRules) ? $fieldRules : explode('|', $fieldRules);\\n\\n            if ($id && property_exists($field->details->validation, 'edit')) {\\n                $action_rules = $field->details->validation->edit->rule;\\n                $rules[$fieldName] = array_merge($rules[$fieldName], (is_array($action_rules) ? $action_rules : explode('|', $action_rules)));\\n            } elseif (!$id && property_exists($field->details->validation, 'add')) {\\n                $action_rules = $field->details->validation->add->rule;\\n                $rules[$fieldName] = array_merge($rules[$fieldName], (is_array($action_rules) ? $action_rules : explode('|', $action_rules)));\\n            }\\n            // Fix Unique validation rule on Edit Mode\\n            if ($is_update) {\\n                foreach ($rules[$fieldName] as &$fieldRule) {\\n                    if (strpos(strtoupper($fieldRule), 'UNIQUE') !== false) {\\n                        $fieldRule = \\\\Illuminate\\\\Validation\\\\Rule::unique($name)->ignore($id);\\n                    }\\n                }\\n            }\\n\\n            // Set custom validation messages if any\\n            if (!empty($field->details->validation->messages)) {\\n                foreach ($field->details->validation->messages as $key => $msg) {\\n                    $messages[\\\"{$fieldName}.{$key}\\\"] = $msg;\\n                }\\n            }\\n        }\\n\\n        return Validator::make($request, $rules, $messages, $customAttributes);\\n    }\", \"output\": \"Validates bread POST request.\\n\\n@param \\\\Illuminate\\\\Http\\\\Request $request The Request\\n@param array                    $data    Field data\\n@param string                   $slug    Slug\\n@param int                      $id      Id of the record to update\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function getFieldsWithValidationRules($fieldsConfig)\\n    {\\n        return $fieldsConfig->filter(function ($value) {\\n            if (empty($value->details)) {\\n                return false;\\n            }\\n\\n            return !empty($value->details->validation->rule);\\n        });\\n    }\", \"output\": \"Get fields having validation rules in proper format.\\n\\n@param array $fieldsConfig\\n\\n@return \\\\Illuminate\\\\Support\\\\Collection\"}"}
{"text": "{\"input\": \"Summarize the following code: public function verifyIdToken($idToken, $audience = null)\\n  {\\n    if (empty($idToken)) {\\n      throw new LogicException('id_token cannot be null');\\n    }\\n\\n    // set phpseclib constants if applicable\\n    $this->setPhpsecConstants();\\n\\n    // Check signature\\n    $certs = $this->getFederatedSignOnCerts();\\n    foreach ($certs as $cert) {\\n      $bigIntClass = $this->getBigIntClass();\\n      $rsaClass = $this->getRsaClass();\\n      $modulus = new $bigIntClass($this->jwt->urlsafeB64Decode($cert['n']), 256);\\n      $exponent = new $bigIntClass($this->jwt->urlsafeB64Decode($cert['e']), 256);\\n\\n      $rsa = new $rsaClass();\\n      $rsa->loadKey(array('n' => $modulus, 'e' => $exponent));\\n\\n      try {\\n        $payload = $this->jwt->decode(\\n            $idToken,\\n            $rsa->getPublicKey(),\\n            array('RS256')\\n        );\\n\\n        if (property_exists($payload, 'aud')) {\\n          if ($audience && $payload->aud != $audience) {\\n            return false;\\n          }\\n        }\\n\\n        // support HTTP and HTTPS issuers\\n        // @see https://developers.google.com/identity/sign-in/web/backend-auth\\n        $issuers = array(self::OAUTH2_ISSUER, self::OAUTH2_ISSUER_HTTPS);\\n        if (!isset($payload->iss) || !in_array($payload->iss, $issuers)) {\\n          return false;\\n        }\\n\\n        return (array) $payload;\\n      } catch (ExpiredException $e) {\\n        return false;\\n      } catch (ExpiredExceptionV3 $e) {\\n        return false;\\n      } catch (SignatureInvalidException $e) {\\n        // continue\\n      } catch (DomainException $e) {\\n        // continue\\n      }\\n    }\\n\\n    return false;\\n  }\", \"output\": \"Verifies an id token and returns the authenticated apiLoginTicket.\\nThrows an exception if the id token is not valid.\\nThe audience parameter can be used to control which id tokens are\\naccepted.  By default, the id token must have been issued to this OAuth2 client.\\n\\n@param $audience\\n@return array the token payload, if successful\"}"}
{"text": "{\"input\": \"Summarize the following code: private function retrieveCertsFromLocation($url)\\n  {\\n    // If we're retrieving a local file, just grab it.\\n    if (0 !== strpos($url, 'http')) {\\n      if (!$file = file_get_contents($url)) {\\n        throw new Google_Exception(\\n            \\\"Failed to retrieve verification certificates: '\\\" .\\n            $url . \\\"'.\\\"\\n        );\\n      }\\n\\n      return json_decode($file, true);\\n    }\\n\\n    $response = $this->http->get($url);\\n\\n    if ($response->getStatusCode() == 200) {\\n      return json_decode((string) $response->getBody(), true);\\n    }\\n    throw new Google_Exception(\\n        sprintf(\\n            'Failed to retrieve verification certificates: \\\"%s\\\".',\\n            $response->getBody()->getContents()\\n        ),\\n        $response->getStatusCode()\\n    );\\n  }\", \"output\": \"Retrieve and cache a certificates file.\\n\\n@param $url string location\\n@throws Google_Exception\\n@return array certificates\"}"}
{"text": "{\"input\": \"Summarize the following code: private function getFederatedSignOnCerts()\\n  {\\n    $certs = null;\\n    if ($cache = $this->getCache()) {\\n      $cacheItem = $cache->getItem('federated_signon_certs_v3');\\n      $certs = $cacheItem->get();\\n    }\\n\\n\\n    if (!$certs) {\\n      $certs = $this->retrieveCertsFromLocation(\\n          self::FEDERATED_SIGNON_CERT_URL\\n      );\\n\\n      if ($cache) {\\n        $cacheItem->expiresAt(new DateTime('+1 hour'));\\n        $cacheItem->set($certs);\\n        $cache->save($cacheItem);\\n      }\\n    }\\n\\n    if (!isset($certs['keys'])) {\\n      throw new InvalidArgumentException(\\n          'federated sign-on certs expects \\\"keys\\\" to be set'\\n      );\\n    }\\n\\n    return $certs['keys'];\\n  }\", \"output\": \"are PEM encoded certificates.\"}"}
{"text": "{\"input\": \"Summarize the following code: private function setPhpsecConstants()\\n  {\\n    if (filter_var(getenv('GAE_VM'), FILTER_VALIDATE_BOOLEAN)) {\\n      if (!defined('MATH_BIGINTEGER_OPENSSL_ENABLED')) {\\n        define('MATH_BIGINTEGER_OPENSSL_ENABLED', true);\\n      }\\n      if (!defined('CRYPT_RSA_MODE')) {\\n        define('CRYPT_RSA_MODE', constant($this->getOpenSslConstant()));\\n      }\\n    }\\n  }\", \"output\": \"phpseclib calls \\\"phpinfo\\\" by default, which requires special\\nwhitelisting in the AppEngine VM environment. This function\\nsets constants to bypass the need for phpseclib to check phpinfo\\n\\n@see phpseclib/Math/BigInteger\\n@see https://github.com/GoogleCloudPlatform/getting-started-php/issues/85\"}"}
{"text": "{\"input\": \"Summarize the following code: public function fetchAccessTokenWithAuthCode($code)\\n  {\\n    if (strlen($code) == 0) {\\n      throw new InvalidArgumentException(\\\"Invalid code\\\");\\n    }\\n\\n    $auth = $this->getOAuth2Service();\\n    $auth->setCode($code);\\n    $auth->setRedirectUri($this->getRedirectUri());\\n\\n    $httpHandler = HttpHandlerFactory::build($this->getHttpClient());\\n    $creds = $auth->fetchAuthToken($httpHandler);\\n    if ($creds && isset($creds['access_token'])) {\\n      $creds['created'] = time();\\n      $this->setAccessToken($creds);\\n    }\\n\\n    return $creds;\\n  }\", \"output\": \"Attempt to exchange a code for an valid authentication token.\\nHelper wrapped around the OAuth 2.0 implementation.\\n\\n@param $code string code from accounts.google.com\\n@return array access token\"}"}
{"text": "{\"input\": \"Summarize the following code: public function fetchAccessTokenWithAssertion(ClientInterface $authHttp = null)\\n  {\\n    if (!$this->isUsingApplicationDefaultCredentials()) {\\n      throw new DomainException(\\n          'set the JSON service account credentials using'\\n          . ' Google_Client::setAuthConfig or set the path to your JSON file'\\n          . ' with the \\\"GOOGLE_APPLICATION_CREDENTIALS\\\" environment variable'\\n          . ' and call Google_Client::useApplicationDefaultCredentials to'\\n          . ' refresh a token with assertion.'\\n      );\\n    }\\n\\n    $this->getLogger()->log(\\n        'info',\\n        'OAuth2 access token refresh with Signed JWT assertion grants.'\\n    );\\n\\n    $credentials = $this->createApplicationDefaultCredentials();\\n\\n    $httpHandler = HttpHandlerFactory::build($authHttp);\\n    $creds = $credentials->fetchAuthToken($httpHandler);\\n    if ($creds && isset($creds['access_token'])) {\\n      $creds['created'] = time();\\n      $this->setAccessToken($creds);\\n    }\\n\\n    return $creds;\\n  }\", \"output\": \"Fetches a fresh access token with a given assertion token.\\n@param ClientInterface $authHttp optional.\\n@return array access token\"}"}
{"text": "{\"input\": \"Summarize the following code: public function fetchAccessTokenWithRefreshToken($refreshToken = null)\\n  {\\n    if (null === $refreshToken) {\\n      if (!isset($this->token['refresh_token'])) {\\n        throw new LogicException(\\n            'refresh token must be passed in or set as part of setAccessToken'\\n        );\\n      }\\n      $refreshToken = $this->token['refresh_token'];\\n    }\\n    $this->getLogger()->info('OAuth2 access token refresh');\\n    $auth = $this->getOAuth2Service();\\n    $auth->setRefreshToken($refreshToken);\\n\\n    $httpHandler = HttpHandlerFactory::build($this->getHttpClient());\\n    $creds = $auth->fetchAuthToken($httpHandler);\\n    if ($creds && isset($creds['access_token'])) {\\n      $creds['created'] = time();\\n      if (!isset($creds['refresh_token'])) {\\n        $creds['refresh_token'] = $refreshToken;\\n      }\\n      $this->setAccessToken($creds);\\n    }\\n\\n    return $creds;\\n  }\", \"output\": \"Fetches a fresh OAuth 2.0 access token with the given refresh token.\\n@param string $refreshToken\\n@return array access token\"}"}
{"text": "{\"input\": \"Summarize the following code: public function authorize(ClientInterface $http = null)\\n  {\\n    $credentials = null;\\n    $token = null;\\n    $scopes = null;\\n    if (null === $http) {\\n      $http = $this->getHttpClient();\\n    }\\n\\n    // These conditionals represent the decision tree for authentication\\n    //   1.  Check for Application Default Credentials\\n    //   2.  Check for API Key\\n    //   3a. Check for an Access Token\\n    //   3b. If access token exists but is expired, try to refresh it\\n    if ($this->isUsingApplicationDefaultCredentials()) {\\n      $credentials = $this->createApplicationDefaultCredentials();\\n    } elseif ($token = $this->getAccessToken()) {\\n      $scopes = $this->prepareScopes();\\n      // add refresh subscriber to request a new token\\n      if (isset($token['refresh_token']) && $this->isAccessTokenExpired()) {\\n        $credentials = $this->createUserRefreshCredentials(\\n            $scopes,\\n            $token['refresh_token']\\n        );\\n      }\\n    }\\n\\n    $authHandler = $this->getAuthHandler();\\n\\n    if ($credentials) {\\n      $callback = $this->config['token_callback'];\\n      $http = $authHandler->attachCredentials($http, $credentials, $callback);\\n    } elseif ($token) {\\n      $http = $authHandler->attachToken($http, $token, (array) $scopes);\\n    } elseif ($key = $this->config['developer_key']) {\\n      $http = $authHandler->attachKey($http, $key);\\n    }\\n\\n    return $http;\\n  }\", \"output\": \"Adds auth listeners to the HTTP client based on the credentials\\nset in the Google API Client object\\n\\n@param GuzzleHttp\\\\ClientInterface $http the http client object.\\n@return GuzzleHttp\\\\ClientInterface the http client object\"}"}
{"text": "{\"input\": \"Summarize the following code: public function isAccessTokenExpired()\\n  {\\n    if (!$this->token) {\\n      return true;\\n    }\\n\\n    $created = 0;\\n    if (isset($this->token['created'])) {\\n      $created = $this->token['created'];\\n    } elseif (isset($this->token['id_token'])) {\\n      // check the ID token for \\\"iat\\\"\\n      // signature verification is not required here, as we are just\\n      // using this for convenience to save a round trip request\\n      // to the Google API server\\n      $idToken = $this->token['id_token'];\\n      if (substr_count($idToken, '.') == 2) {\\n        $parts = explode('.', $idToken);\\n        $payload = json_decode(base64_decode($parts[1]), true);\\n        if ($payload && isset($payload['iat'])) {\\n          $created = $payload['iat'];\\n        }\\n      }\\n    }\\n\\n    // If the token is set to expire in the next 30 seconds.\\n    return ($created + ($this->token['expires_in'] - 30)) < time();\\n  }\", \"output\": \"Returns if the access_token is expired.\\n@return bool Returns True if the access_token is expired.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function verifyIdToken($idToken = null)\\n  {\\n    $tokenVerifier = new Google_AccessToken_Verify(\\n        $this->getHttpClient(),\\n        $this->getCache(),\\n        $this->config['jwt']\\n    );\\n\\n    if (null === $idToken) {\\n      $token = $this->getAccessToken();\\n      if (!isset($token['id_token'])) {\\n        throw new LogicException(\\n            'id_token must be passed in or set as part of setAccessToken'\\n        );\\n      }\\n      $idToken = $token['id_token'];\\n    }\\n\\n    return $tokenVerifier->verifyIdToken(\\n        $idToken,\\n        $this->getClientId()\\n    );\\n  }\", \"output\": \"Verify an id_token. This method will verify the current id_token, if one\\nisn't provided.\\n\\n@throws LogicException If no token was provided and no token was set using `setAccessToken`.\\n@throws UnexpectedValueException If the token is not a valid JWT.\\n@param string|null $idToken The token (id_token) that should be verified.\\n@return array|false Returns the token payload as an array if the verification was\\nsuccessful, false otherwise.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function addScope($scope_or_scopes)\\n  {\\n    if (is_string($scope_or_scopes) && !in_array($scope_or_scopes, $this->requestedScopes)) {\\n      $this->requestedScopes[] = $scope_or_scopes;\\n    } else if (is_array($scope_or_scopes)) {\\n      foreach ($scope_or_scopes as $scope) {\\n        $this->addScope($scope);\\n      }\\n    }\\n  }\", \"output\": \"This functions adds a scope to be requested as part of the OAuth2.0 flow.\\nWill append any scopes not previously requested to the scope parameter.\\nA single string will be treated as a scope to request. An array of strings\\nwill each be appended.\\n@param $scope_or_scopes string|array e.g. \\\"profile\\\"\"}"}
{"text": "{\"input\": \"Summarize the following code: public function execute(RequestInterface $request, $expectedClass = null)\\n  {\\n    $request = $request->withHeader(\\n        'User-Agent',\\n        $this->config['application_name']\\n        . \\\" \\\" . self::USER_AGENT_SUFFIX\\n        . $this->getLibraryVersion()\\n    );\\n\\n    // call the authorize method\\n    // this is where most of the grunt work is done\\n    $http = $this->authorize();\\n\\n    return Google_Http_REST::execute(\\n        $http,\\n        $request,\\n        $expectedClass,\\n        $this->config['retry'],\\n        $this->config['retry_map']\\n    );\\n  }\", \"output\": \"Helper method to execute deferred HTTP requests.\\n\\n@param $request Psr\\\\Http\\\\Message\\\\RequestInterface|Google_Http_Batch\\n@throws Google_Exception\\n@return object of the type of the expected class or Psr\\\\Http\\\\Message\\\\ResponseInterface.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setAuthConfig($config)\\n  {\\n    if (is_string($config)) {\\n      if (!file_exists($config)) {\\n        throw new InvalidArgumentException(sprintf('file \\\"%s\\\" does not exist', $config));\\n      }\\n\\n      $json = file_get_contents($config);\\n\\n      if (!$config = json_decode($json, true)) {\\n        throw new LogicException('invalid json for auth config');\\n      }\\n    }\\n\\n    $key = isset($config['installed']) ? 'installed' : 'web';\\n    if (isset($config['type']) && $config['type'] == 'service_account') {\\n      // application default credentials\\n      $this->useApplicationDefaultCredentials();\\n\\n      // set the information from the config\\n      $this->setClientId($config['client_id']);\\n      $this->config['client_email'] = $config['client_email'];\\n      $this->config['signing_key'] = $config['private_key'];\\n      $this->config['signing_algorithm'] = 'HS256';\\n    } elseif (isset($config[$key])) {\\n      // old-style\\n      $this->setClientId($config[$key]['client_id']);\\n      $this->setClientSecret($config[$key]['client_secret']);\\n      if (isset($config[$key]['redirect_uris'])) {\\n        $this->setRedirectUri($config[$key]['redirect_uris'][0]);\\n      }\\n    } else {\\n      // new-style\\n      $this->setClientId($config['client_id']);\\n      $this->setClientSecret($config['client_secret']);\\n      if (isset($config['redirect_uris'])) {\\n        $this->setRedirectUri($config['redirect_uris'][0]);\\n      }\\n    }\\n  }\", \"output\": \"Set the auth config from new or deprecated JSON config.\\nThis structure should match the file downloaded from\\nthe \\\"Download JSON\\\" button on in the Google Developer\\nConsole.\\n@param string|array $config the configuration json\\n@throws Google_Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function createOAuth2Service()\\n  {\\n    $auth = new OAuth2(\\n        [\\n          'clientId'          => $this->getClientId(),\\n          'clientSecret'      => $this->getClientSecret(),\\n          'authorizationUri'   => self::OAUTH2_AUTH_URL,\\n          'tokenCredentialUri' => self::OAUTH2_TOKEN_URI,\\n          'redirectUri'       => $this->getRedirectUri(),\\n          'issuer'            => $this->config['client_id'],\\n          'signingKey'        => $this->config['signing_key'],\\n          'signingAlgorithm'  => $this->config['signing_algorithm'],\\n        ]\\n    );\\n\\n    return $auth;\\n  }\", \"output\": \"create a default google auth object\"}"}
{"text": "{\"input\": \"Summarize the following code: public function allowedRetries($code, $errors = array())\\n  {\\n    if (isset($this->retryMap[$code])) {\\n      return $this->retryMap[$code];\\n    }\\n\\n    if (\\n        !empty($errors) &&\\n        isset($errors[0]['reason'], $this->retryMap[$errors[0]['reason']])\\n    ) {\\n      return $this->retryMap[$errors[0]['reason']];\\n    }\\n\\n    return 0;\\n  }\", \"output\": \"Gets the number of times the associated task can be retried.\\n\\nNOTE: -1 is returned if the task can be retried indefinitely\\n\\n@return integer\"}"}
{"text": "{\"input\": \"Summarize the following code: public function nextChunk($chunk = false)\\n  {\\n    $resumeUri = $this->getResumeUri();\\n\\n    if (false == $chunk) {\\n      $chunk = substr($this->data, $this->progress, $this->chunkSize);\\n    }\\n\\n    $lastBytePos = $this->progress + strlen($chunk) - 1;\\n    $headers = array(\\n      'content-range' => \\\"bytes $this->progress-$lastBytePos/$this->size\\\",\\n      'content-length' => strlen($chunk),\\n      'expect' => '',\\n    );\\n\\n    $request = new Request(\\n        'PUT',\\n        $resumeUri,\\n        $headers,\\n        Psr7\\\\stream_for($chunk)\\n    );\\n\\n    return $this->makePutRequest($request);\\n  }\", \"output\": \"Send the next part of the file to upload.\\n@param [$chunk] the next set of bytes to send. If false will used $data passed\\nat construct time.\"}"}
{"text": "{\"input\": \"Summarize the following code: private function parseHttpResponse($respData, $headerSize)\\n  {\\n    // check proxy header\\n    foreach (self::$CONNECTION_ESTABLISHED_HEADERS as $established_header) {\\n      if (stripos($respData, $established_header) !== false) {\\n        // existed, remove it\\n        $respData = str_ireplace($established_header, '', $respData);\\n        // Subtract the proxy header size unless the cURL bug prior to 7.30.0\\n        // is present which prevented the proxy header size from being taken into\\n        // account.\\n        // @TODO look into this\\n        // if (!$this->needsQuirk()) {\\n        //   $headerSize -= strlen($established_header);\\n        // }\\n        break;\\n      }\\n    }\\n\\n    if ($headerSize) {\\n      $responseBody = substr($respData, $headerSize);\\n      $responseHeaders = substr($respData, 0, $headerSize);\\n    } else {\\n      $responseSegments = explode(\\\"\\\\r\\\\n\\\\r\\\\n\\\", $respData, 2);\\n      $responseHeaders = $responseSegments[0];\\n      $responseBody = isset($responseSegments[1]) ? $responseSegments[1] :\\n                                                    null;\\n    }\\n\\n    $responseHeaders = $this->parseRawHeaders($responseHeaders);\\n\\n    return array($responseHeaders, $responseBody);\\n  }\", \"output\": \"Used by the IO lib and also the batch processing.\\n\\n@param $respData\\n@param $headerSize\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: private function getDataType($data)\\n  {\\n    if (is_array($data)) {\\n      reset($data);\\n      if (key($data) !== 0) {\\n        return self::TYPE_MAP;\\n      }\\n      return self::TYPE_LIST;\\n    }\\n    return self::TYPE_SCALAR;\\n  }\", \"output\": \"Return the type of a passed in value\"}"}
{"text": "{\"input\": \"Summarize the following code: private function combineList(\\n      $vars,\\n      $sep,\\n      $parameters,\\n      $combine,\\n      $reserved,\\n      $tag_empty,\\n      $combine_on_empty\\n  ) {\\n    $ret = array();\\n    foreach ($vars as $var) {\\n      $response = $this->combine(\\n          $var,\\n          $parameters,\\n          $sep,\\n          $combine,\\n          $reserved,\\n          $tag_empty,\\n          $combine_on_empty\\n      );\\n      if ($response === false) {\\n        continue;\\n      }\\n      $ret[] = $response;\\n    }\\n    return implode($sep, $ret);\\n  }\", \"output\": \"Utility function that merges multiple combine calls\\nfor multi-key templates.\"}"}
{"text": "{\"input\": \"Summarize the following code: private function getValue($value, $length)\\n  {\\n    if ($length) {\\n      $value = substr($value, 0, $length);\\n    }\\n    $value = rawurlencode($value);\\n    return $value;\\n  }\", \"output\": \"Utility function to encode and trim values\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function doExecute(ClientInterface $client, RequestInterface $request, $expectedClass = null)\\n  {\\n    try {\\n      $httpHandler = HttpHandlerFactory::build($client);\\n      $response = $httpHandler($request);\\n    } catch (RequestException $e) {\\n      // if Guzzle throws an exception, catch it and handle the response\\n      if (!$e->hasResponse()) {\\n        throw $e;\\n      }\\n\\n      $response = $e->getResponse();\\n      // specific checking for Guzzle 5: convert to PSR7 response\\n      if ($response instanceof \\\\GuzzleHttp\\\\Message\\\\ResponseInterface) {\\n        $response = new Response(\\n            $response->getStatusCode(),\\n            $response->getHeaders() ?: [],\\n            $response->getBody(),\\n            $response->getProtocolVersion(),\\n            $response->getReasonPhrase()\\n        );\\n      }\\n    }\\n\\n    return self::decodeHttpResponse($response, $request, $expectedClass);\\n  }\", \"output\": \"Executes a Psr\\\\Http\\\\Message\\\\RequestInterface\\n\\n@param Google_Client $client\\n@param Psr\\\\Http\\\\Message\\\\RequestInterface $request\\n@return array decoded result\\n@throws Google_Service_Exception on server side error (ie: not authenticated,\\ninvalid or malformed post body, invalid url)\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function decodeHttpResponse(\\n      ResponseInterface $response,\\n      RequestInterface $request = null,\\n      $expectedClass = null\\n  ) {\\n    $code = $response->getStatusCode();\\n\\n    // retry strategy\\n    if (intVal($code) >= 400) {\\n      // if we errored out, it should be safe to grab the response body\\n      $body = (string) $response->getBody();\\n\\n      // Check if we received errors, and add those to the Exception for convenience\\n      throw new Google_Service_Exception($body, $code, null, self::getResponseErrors($body));\\n    }\\n\\n    // Ensure we only pull the entire body into memory if the request is not\\n    // of media type\\n    $body = self::decodeBody($response, $request);\\n\\n    if ($expectedClass = self::determineExpectedClass($expectedClass, $request)) {\\n      $json = json_decode($body, true);\\n\\n      return new $expectedClass($json);\\n    }\\n\\n    return $response;\\n  }\", \"output\": \"Decode an HTTP Response.\\n@static\\n@throws Google_Service_Exception\\n@param Psr\\\\Http\\\\Message\\\\RequestInterface $response The http response to be decoded.\\n@param Psr\\\\Http\\\\Message\\\\ResponseInterface $response\\n@return mixed|null\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function mapTypes($array)\\n  {\\n    // Hard initialise simple types, lazy load more complex ones.\\n    foreach ($array as $key => $val) {\\n      if ($keyType = $this->keyType($key)) {\\n        $dataType = $this->dataType($key);\\n        if ($dataType == 'array' || $dataType == 'map') {\\n          $this->$key = array();\\n          foreach ($val as $itemKey => $itemVal) {\\n            if ($itemVal instanceof $keyType) {\\n              $this->{$key}[$itemKey] = $itemVal;\\n            } else {\\n              $this->{$key}[$itemKey] = new $keyType($itemVal);\\n            }\\n          }\\n        } elseif ($val instanceof $keyType) {\\n          $this->$key = $val;\\n        } else {\\n          $this->$key = new $keyType($val);\\n        }\\n        unset($array[$key]);\\n      } elseif (property_exists($this, $key)) {\\n          $this->$key = $val;\\n          unset($array[$key]);\\n      } elseif (property_exists($this, $camelKey = $this->camelCase($key))) {\\n          // This checks if property exists as camelCase, leaving it in array as snake_case\\n          // in case of backwards compatibility issues.\\n          $this->$camelKey = $val;\\n      }\\n    }\\n    $this->modelData = $array;\\n  }\", \"output\": \"Initialize this object's properties from an array.\\n\\n@param array $array Used to seed this object's properties.\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: public function toSimpleObject()\\n  {\\n    $object = new stdClass();\\n\\n    // Process all other data.\\n    foreach ($this->modelData as $key => $val) {\\n      $result = $this->getSimpleValue($val);\\n      if ($result !== null) {\\n        $object->$key = $this->nullPlaceholderCheck($result);\\n      }\\n    }\\n\\n    // Process all public properties.\\n    $reflect = new ReflectionObject($this);\\n    $props = $reflect->getProperties(ReflectionProperty::IS_PUBLIC);\\n    foreach ($props as $member) {\\n      $name = $member->getName();\\n      $result = $this->getSimpleValue($this->$name);\\n      if ($result !== null) {\\n        $name = $this->getMappedName($name);\\n        $object->$name = $this->nullPlaceholderCheck($result);\\n      }\\n    }\\n\\n    return $object;\\n  }\", \"output\": \"Create a simplified object suitable for straightforward\\nconversion to JSON. This is relatively expensive\\ndue to the usage of reflection, but shouldn't be called\\na whole lot, and is the most straightforward way to filter.\"}"}
{"text": "{\"input\": \"Summarize the following code: private function getSimpleValue($value)\\n  {\\n    if ($value instanceof Google_Model) {\\n      return $value->toSimpleObject();\\n    } else if (is_array($value)) {\\n      $return = array();\\n      foreach ($value as $key => $a_value) {\\n        $a_value = $this->getSimpleValue($a_value);\\n        if ($a_value !== null) {\\n          $key = $this->getMappedName($key);\\n          $return[$key] = $this->nullPlaceholderCheck($a_value);\\n        }\\n      }\\n      return $return;\\n    }\\n    return $value;\\n  }\", \"output\": \"Handle different types of values, primarily\\nother objects and map and array data types.\"}"}
{"text": "{\"input\": \"Summarize the following code: private function getMappedName($key)\\n  {\\n    if (isset($this->internal_gapi_mappings, $this->internal_gapi_mappings[$key])) {\\n      $key = $this->internal_gapi_mappings[$key];\\n    }\\n    return $key;\\n  }\", \"output\": \"If there is an internal name mapping, use that.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function isAssociativeArray($array)\\n  {\\n    if (!is_array($array)) {\\n      return false;\\n    }\\n    $keys = array_keys($array);\\n    foreach ($keys as $key) {\\n      if (is_string($key)) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\", \"output\": \"Returns true only if the array is associative.\\n@param array $array\\n@return bool True if the array is associative.\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function build($cache = null, array $cacheConfig = [])\\n  {\\n    $version = ClientInterface::VERSION;\\n\\n    switch ($version[0]) {\\n      case '5':\\n        return new Google_AuthHandler_Guzzle5AuthHandler($cache, $cacheConfig);\\n      case '6':\\n        return new Google_AuthHandler_Guzzle6AuthHandler($cache, $cacheConfig);\\n      default:\\n        throw new Exception('Version not supported');\\n    }\\n  }\", \"output\": \"Builds out a default http handler for the installed version of guzzle.\\n\\n@return Google_AuthHandler_Guzzle5AuthHandler|Google_AuthHandler_Guzzle6AuthHandler\\n@throws Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public function find_config() {\\n\\n        $config = $this->fix_win32_path($this->config);\\n\\n        if (!empty($config) && is_readable($config)) {\\n            return $config;\\n        }\\n\\n        if (!empty($config) && !is_readable($config)) {\\n            throw new ConfigException(\\\"User defined config not found at '$config'\\\");\\n        }\\n\\n        // config.php in /user/\\n        if (file_exists($this->root . '/user/config.php')) {\\n            return $this->root . '/user/config.php';\\n        }\\n\\n        // config.php in /includes/\\n        if (file_exists($this->root . '/includes/config.php')) {\\n            return $this->root . '/includes/config.php';\\n        }\\n\\n        // config.php not found :(\\n\\n        throw new ConfigException('Cannot find config.php. Please read the readme.html to learn how to install YOURLS');\\n    }\", \"output\": \"Find config.php, either user defined or from standard location\\n\\n@since  1.7.3\\n@return string         path to found config file\\n@throws ConfigException\"}"}
{"text": "{\"input\": \"Summarize the following code: public function define_core_constants() {\\n        // Check minimal config job has been properly done\\n        $must_haves = array('YOURLS_DB_USER', 'YOURLS_DB_PASS', 'YOURLS_DB_NAME', 'YOURLS_DB_HOST', 'YOURLS_DB_PREFIX', 'YOURLS_SITE');\\n        foreach($must_haves as $must_have) {\\n            if (!defined($must_have)) {\\n                throw new ConfigException('Config is incomplete (missing at least '.$must_have.') Check config-sample.php and edit your config accordingly');\\n            }\\n        }\\n\\n        /**\\n         * The following has an awful CRAP index and it would be much shorter reduced to something like\\n         * defining an array of ('YOURLS_SOMETHING' => 'default value') and then a simple loop over the\\n         * array, checking if $current is defined as a constant and otherwise define said constant with\\n         * its default value. I did not wrote it that way because that would make it difficult for code\\n         * parsers to identify which constants are defined and where. So, here it is, that long list of\\n         * if (!defined) define(). Ho and by the way, such beautiful comment, much right aligned, wow !\\n         */\\n\\n        // physical path of YOURLS root\\n        if (!defined( 'YOURLS_ABSPATH' ))\\n            define('YOURLS_ABSPATH', $this->root);\\n\\n        // physical path of includes directory\\n        if (!defined( 'YOURLS_INC' ))\\n            define('YOURLS_INC', YOURLS_ABSPATH.'/includes');\\n\\n        // physical path of user directory\\n        if (!defined( 'YOURLS_USERDIR' ))\\n            define( 'YOURLS_USERDIR', YOURLS_ABSPATH.'/user' );\\n\\n        // URL of user directory\\n        if (!defined( 'YOURLS_USERURL' ))\\n            define( 'YOURLS_USERURL', YOURLS_SITE.'/user' );\\n\\n        // physical path of asset directory\\n        if( !defined( 'YOURLS_ASSETDIR' ) )\\n            define( 'YOURLS_ASSETDIR', YOURLS_ABSPATH.'/assets' );\\n\\n        // URL of asset directory\\n        if( !defined( 'YOURLS_ASSETURL' ) )\\n            define( 'YOURLS_ASSETURL', YOURLS_SITE.'/assets' );\\n\\n        // physical path of translations directory\\n        if (!defined( 'YOURLS_LANG_DIR' ))\\n            define( 'YOURLS_LANG_DIR', YOURLS_USERDIR.'/languages' );\\n\\n        // physical path of plugins directory\\n        if (!defined( 'YOURLS_PLUGINDIR' ))\\n            define( 'YOURLS_PLUGINDIR', YOURLS_USERDIR.'/plugins' );\\n\\n        // URL of plugins directory\\n        if (!defined( 'YOURLS_PLUGINURL' ))\\n            define( 'YOURLS_PLUGINURL', YOURLS_USERURL.'/plugins' );\\n\\n        // physical path of themes directory\\n        if( !defined( 'YOURLS_THEMEDIR' ) )\\n            define( 'YOURLS_THEMEDIR', YOURLS_USERDIR.'/themes' );\\n\\n        // URL of themes directory\\n        if( !defined( 'YOURLS_THEMEURL' ) )\\n            define( 'YOURLS_THEMEURL', YOURLS_USERURL.'/themes' );\\n\\n        // physical path of pages directory\\n        if (!defined( 'YOURLS_PAGEDIR' ))\\n            define('YOURLS_PAGEDIR', YOURLS_ABSPATH.'/pages' );\\n\\n        // table to store URLs\\n        if (!defined( 'YOURLS_DB_TABLE_URL' ))\\n            define( 'YOURLS_DB_TABLE_URL', YOURLS_DB_PREFIX.'url' );\\n\\n        // table to store options\\n        if (!defined( 'YOURLS_DB_TABLE_OPTIONS' ))\\n            define( 'YOURLS_DB_TABLE_OPTIONS', YOURLS_DB_PREFIX.'options' );\\n\\n        // table to store hits, for stats\\n        if (!defined( 'YOURLS_DB_TABLE_LOG' ))\\n            define( 'YOURLS_DB_TABLE_LOG', YOURLS_DB_PREFIX.'log' );\\n\\n        // minimum delay in sec before a same IP can add another URL. Note: logged in users are not throttled down.\\n        if (!defined( 'YOURLS_FLOOD_DELAY_SECONDS' ))\\n            define( 'YOURLS_FLOOD_DELAY_SECONDS', 15 );\\n\\n        // comma separated list of IPs that can bypass flood check.\\n        if (!defined( 'YOURLS_FLOOD_IP_WHITELIST' ))\\n            define( 'YOURLS_FLOOD_IP_WHITELIST', '' );\\n\\n        // life span of an auth cookie in seconds (60*60*24*7 = 7 days)\\n        if (!defined( 'YOURLS_COOKIE_LIFE' ))\\n            define( 'YOURLS_COOKIE_LIFE', 60*60*24*7 );\\n\\n        // life span of a nonce in seconds\\n        if (!defined( 'YOURLS_NONCE_LIFE' ))\\n            define( 'YOURLS_NONCE_LIFE', 43200 ); // 3600 * 12\\n\\n        // if set to true, disable stat logging (no use for it, too busy servers, ...)\\n        if (!defined( 'YOURLS_NOSTATS' ))\\n            define( 'YOURLS_NOSTATS', false );\\n\\n        // if set to true, force https:// in the admin area\\n        if (!defined( 'YOURLS_ADMIN_SSL' ))\\n            define( 'YOURLS_ADMIN_SSL', false );\\n\\n        // if set to true, verbose debug infos. Will break things. Don't enable.\\n        if (!defined( 'YOURLS_DEBUG' ))\\n            define( 'YOURLS_DEBUG', false );\\n\\n        // Error reporting\\n        if (defined( 'YOURLS_DEBUG' ) && YOURLS_DEBUG == true ) {\\n            error_reporting( -1 );\\n        } else {\\n            error_reporting( E_ERROR | E_PARSE );\\n        }\\n    }\", \"output\": \"Define core constants that have not been user defined in config.php\\n\\n@since  1.7.3\\n@return void\\n@throws ConfigException\"}"}
{"text": "{\"input\": \"Summarize the following code: public function set_emulate_state() {\\n        try {\\n            $this->is_emulate_prepare = $this->getAttribute(PDO::ATTR_EMULATE_PREPARES);\\n        } catch (\\\\PDOException $e) {\\n            $this->is_emulate_prepare = false;\\n        }\\n    }\", \"output\": \"Check if we emulate prepare statements, and set bool flag accordingly\\n\\nCheck if current driver can PDO::getAttribute(PDO::ATTR_EMULATE_PREPARES)\\nSome combinations of PHP/MySQL don't support this function. See\\nhttps://travis-ci.org/YOURLS/YOURLS/jobs/271423782#L481\\n\\n@since  1.7.3\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: public function dead_or_error(\\\\Exception $exception) {\\n        // Use any /user/db_error.php file\\n        if( file_exists( YOURLS_USERDIR . '/db_error.php' ) ) {\\n            include_once( YOURLS_USERDIR . '/db_error.php' );\\n            die();\\n        }\\n\\n        $message  = yourls__( 'Incorrect DB config, or could not connect to DB' );\\n        $message .= '<br/>' . get_class($exception) .': ' . $exception->getMessage();\\n\\n        yourls_die( yourls__( $message ), yourls__( 'Fatal error' ), 503 );\\n        die();\\n    }\", \"output\": \"Die with an error message\\n\\n@since  1.7.3\\n\\n@param \\\\Exception $exception\\n\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: public function get_queries() {\\n        $queries = $this->getProfiler()->getProfiles();\\n\\n        if ($this->get_emulate_state()) {\\n            // keep queries if $query['function'] != 'prepare'\\n            $queries = array_filter($queries, function($query) {return $query['function'] !== 'prepare';});\\n        }\\n\\n        return $queries;\\n    }\", \"output\": \"Return SQL queries performed\\n\\nAura\\\\Sql\\\\Profiler logs every PDO command issued. But depending on PDO::ATTR_EMULATE_PREPARES, some are\\nactually sent to the mysql server or not :\\n- if PDO::ATTR_EMULATE_PREPARES is true, prepare() statements are not sent to the server and are performed\\ninternally, so they are removed from the logger\\n- if PDO::ATTR_EMULATE_PREPARES is false, prepare() statements are actually performed by the mysql server,\\nand count as an actual query\\n\\nResulting array is something like:\\narray (\\n0 => array (\\n'duration' => 1.0010569095611572265625,\\n'function' => 'connect',\\n'statement' => NULL,\\n'bind_values' => array (),\\n'trace' => ...back trace...,\\n),\\n// key index might not be sequential if 'prepare' function are filtered out\\n2 => array (\\n'duration' => 0.000999927520751953125,\\n'function' => 'perform',\\n'statement' => 'SELECT option_value FROM yourls_options WHERE option_name = :option_name LIMIT 1',\\n'bind_values' => array ( 'option_name' => 'test_option' ),\\n'trace' => ...back trace...,\\n),\\n);\\n\\n@since  1.7.3\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: function register_globals() {\\n\\t\\t$GLOBALS['weekday']         = $this->weekday;\\n\\t\\t$GLOBALS['weekday_initial'] = $this->weekday_initial;\\n\\t\\t$GLOBALS['weekday_abbrev']  = $this->weekday_abbrev;\\n\\t\\t$GLOBALS['month']           = $this->month;\\n\\t\\t$GLOBALS['month_abbrev']    = $this->month_abbrev;\\n\\t}\", \"output\": \"Global variables are deprecated. For backwards compatibility only.\\n\\n@deprecated For backwards compatibility only.\\n@access private\\n\\n@since 1.6\"}"}
{"text": "{\"input\": \"Summarize the following code: public function get_all_options() {\\n        // Get option values from DB\\n        $table = YOURLS_DB_TABLE_OPTIONS;\\n        $sql = \\\"SELECT option_name, option_value FROM $table WHERE 1=1\\\";\\n\\n        try {\\n            $options = (array) $this->ydb->fetchPairs($sql);\\n\\n        } catch ( PDOException $e ) {\\n\\n            // We could not fetch value from the table. Let's check if the option table exists\\n            try {\\n                $check = $this->ydb->fetchAffected(sprintf(\\\"SHOW TABLES LIKE '%s'\\\", $table));\\n                // Table doesn't exist\\n                if ($check ==0) {\\n                    return false;\\n                }\\n\\n            // Error at this point means the database isn't readable\\n            } catch ( PDOException $e ) {\\n                $this->ydb->dead_or_error($e);\\n            }\\n\\n        }\\n\\n\\n        // Unlikely scenario, but who knows: table exists, but is empty\\n        if (empty($options)) {\\n            return false;\\n        }\\n\\n        foreach ($options as $name => $value) {\\n            $this->ydb->set_option($name, yourls_maybe_unserialize($value));\\n        }\\n\\n        yourls_apply_filter('get_all_options', 'deprecated');\\n\\n        return true;\\n    }\", \"output\": \"Read all options from DB at once, return bool\\n\\n@since  1.7.3\\n@return bool    True on success, false on failure (eg table missing or empty)\"}"}
{"text": "{\"input\": \"Summarize the following code: public function add($name, $value) {\\n        $name = trim((string)$name);\\n        if (empty($name)) {\\n            return false;\\n        }\\n\\n        // Use clone to break object refs -- see commit 09b989d375bac65e692277f61a84fede2fb04ae3\\n        if (is_object($value)) {\\n            $value = clone $value;\\n        }\\n\\n        // Make sure the option doesn't already exist\\n        if ($this->ydb->has_option($name)) {\\n            return false;\\n        }\\n        // if (false !== yourls_get_option($name)) {\\n            // return false;\\n        // }\\n\\n        $table = YOURLS_DB_TABLE_OPTIONS;\\n        $_value = yourls_maybe_serialize($value);\\n        $sql  = \\\"INSERT INTO $table (option_name, option_value) VALUES (:name, :value)\\\";\\n        $bind = array('name' => $name, 'value' => $_value);\\n        $do   = $this->ydb->fetchAffected($sql, $bind);\\n\\n        if($do !== 1) {\\n            // Something went wrong :(\\n            return false;\\n        }\\n\\n        // Cache option value to save a DB query if needed later\\n        $this->ydb->set_option($name, $value);\\n        yourls_do_action('add_option', $name, $_value);\\n\\n        return true;\\n    }\", \"output\": \"Add an option to the DB\\n\\n@since  1.7.3\\n@param  string $name   Name of option to add. Expected to not be SQL-escaped.\\n@param  mixed  $value  Optional option value. Must be serializable if non-scalar. Expected to not be SQL-escaped.\\n@return bool           False if option was not added (eg already exists), true otherwise.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function delete($name) {\\n        $name = trim((string)$name);\\n        if (empty($name)) {\\n            return false;\\n        }\\n\\n        $table = YOURLS_DB_TABLE_OPTIONS;\\n        $sql = \\\"DELETE FROM $table WHERE option_name = :name\\\";\\n        $bind = array('name' => $name);\\n        $do   = $this->ydb->fetchAffected($sql, $bind);\\n\\n        if($do !== 1) {\\n            // Something went wrong :(\\n            return false;\\n        }\\n\\n        yourls_do_action('delete_option', $name);\\n        $this->ydb->delete_option($name);\\n        return true;\\n    }\", \"output\": \"Delete option from DB\\n\\n@since  1.7.3\\n@param  string $name  Option name to delete. Expected to not be SQL-escaped.\\n@return bool          False if option was not deleted (eg not found), true otherwise.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function addPlaceholder($placeholder, string $pattern = null): RouteCollectionInterface\\n\\t{\\n\\t\\tif (! is_array($placeholder))\\n\\t\\t{\\n\\t\\t\\t$placeholder = [$placeholder => $pattern];\\n\\t\\t}\\n\\n\\t\\t$this->placeholders = array_merge($this->placeholders, $placeholder);\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Registers a new constraint with the system. Constraints are used\\nby the routes as placeholders for regular expressions to make defining\\nthe routes more human-friendly.\\n\\nYou can pass an associative array as $placeholder, and have\\nmultiple placeholders added at once.\\n\\n@param string|array $placeholder\\n@param string       $pattern\\n\\n@return \\\\CodeIgniter\\\\Router\\\\RouteCollectionInterface\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setDefaultNamespace(string $value): RouteCollectionInterface\\n\\t{\\n\\t\\t$this->defaultNamespace = filter_var($value, FILTER_SANITIZE_STRING);\\n\\t\\t$this->defaultNamespace = rtrim($this->defaultNamespace, '\\\\\\\\') . '\\\\\\\\';\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Sets the default namespace to use for Controllers when no other\\nnamespace has been specified.\\n\\n@param $value\\n\\n@return \\\\CodeIgniter\\\\Router\\\\RouteCollectionInterface\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setDefaultController(string $value): RouteCollectionInterface\\n\\t{\\n\\t\\t$this->defaultController = filter_var($value, FILTER_SANITIZE_STRING);\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Sets the default controller to use when no other controller has been\\nspecified.\\n\\n@param $value\\n\\n@return \\\\CodeIgniter\\\\Router\\\\RouteCollectionInterface\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setDefaultMethod(string $value): RouteCollectionInterface\\n\\t{\\n\\t\\t$this->defaultMethod = filter_var($value, FILTER_SANITIZE_STRING);\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Sets the default method to call on the controller when no other\\nmethod has been set in the route.\\n\\n@param $value\\n\\n@return \\\\CodeIgniter\\\\Router\\\\RouteCollectionInterface\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function discoverRoutes()\\n\\t{\\n\\t\\tif ($this->didDiscover)\\n\\t\\t{\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// We need this var in local scope\\n\\t\\t// so route files can access it.\\n\\t\\t$routes = $this;\\n\\n\\t\\tif ($this->moduleConfig->shouldDiscover('routes'))\\n\\t\\t{\\n\\t\\t\\t$files = $this->fileLocator->search('Config/Routes.php');\\n\\n\\t\\t\\tforeach ($files as $file)\\n\\t\\t\\t{\\n\\t\\t\\t\\t// Don't include our main file again...\\n\\t\\t\\t\\tif ($file === APPPATH . 'Config/Routes.php')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tinclude $file;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t$this->didDiscover = true;\\n\\t}\", \"output\": \"Will attempt to discover any additional routes, either through\\nthe local PSR4 namespaces, or through selected Composer packages.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setDefaultConstraint(string $placeholder): RouteCollectionInterface\\n\\t{\\n\\t\\tif (array_key_exists($placeholder, $this->placeholders))\\n\\t\\t{\\n\\t\\t\\t$this->defaultPlaceholder = $placeholder;\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Sets the default constraint to be used in the system. Typically\\nfor use with the 'resource' method.\\n\\n@param string $placeholder\\n\\n@return RouteCollectionInterface\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getRoutes($verb = null): array\\n\\t{\\n\\t\\tif (empty($verb))\\n\\t\\t{\\n\\t\\t\\t$verb = $this->getHTTPVerb();\\n\\t\\t}\\n\\n\\t\\t// Since this is the entry point for the Router,\\n\\t\\t// take a moment to do any route discovery\\n\\t\\t// we might need to do.\\n\\t\\t$this->discoverRoutes();\\n\\n\\t\\t$routes = [];\\n\\n\\t\\tif (isset($this->routes[$verb]))\\n\\t\\t{\\n\\t\\t\\t// Keep current verb's routes at the beginning so they're matched\\n\\t\\t\\t// before any of the generic, \\\"add\\\" routes.\\n\\t\\t\\tif (isset($this->routes['*']))\\n\\t\\t\\t{\\n\\t\\t\\t\\t$extraRules = array_diff_key($this->routes['*'], $this->routes[$verb]);\\n\\t\\t\\t\\t$collection = array_merge($this->routes[$verb], $extraRules);\\n\\t\\t\\t}\\n\\t\\t\\tforeach ($collection as $r)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$key          = key($r['route']);\\n\\t\\t\\t\\t$routes[$key] = $r['route'][$key];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $routes;\\n\\t}\", \"output\": \"Returns the raw array of available routes.\\n\\n@param mixed $verb\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getRoutesOptions(string $from = null): array\\n\\t{\\n\\t\\treturn $from ? $this->routesOptions[$from] ?? [] : $this->routesOptions;\\n\\t}\", \"output\": \"Returns one or all routes options\\n\\n@param string $from\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: public function map(array $routes = [], array $options = null): RouteCollectionInterface\\n\\t{\\n\\t\\tforeach ($routes as $from => $to)\\n\\t\\t{\\n\\t\\t\\t$this->add($from, $to, $options);\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"A shortcut method to add a number of routes at a single time.\\nIt does not allow any options to be set on the route, or to\\ndefine the method used.\\n\\n@param array $routes\\n@param array $options\\n\\n@return RouteCollectionInterface\"}"}
{"text": "{\"input\": \"Summarize the following code: public function addRedirect(string $from, string $to, int $status = 302)\\n\\t{\\n\\t\\t// Use the named route's pattern if this is a named route.\\n\\t\\tif (array_key_exists($to, $this->routes['*']))\\n\\t\\t{\\n\\t\\t\\t$to = $this->routes['*'][$to]['route'];\\n\\t\\t}\\n\\n\\t\\t$this->create('*', $from, $to, ['redirect' => $status]);\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Adds a temporary redirect from one route to another. Used for\\nredirecting traffic from old, non-existing routes to the new\\nmoved routes.\\n\\n@param string  $from   The pattern to match against\\n@param string  $to     Either a route name or a URI to redirect to\\n@param integer $status The HTTP status code that should be returned with this redirect\\n\\n@return RouteCollection\"}"}
{"text": "{\"input\": \"Summarize the following code: public function isRedirect(string $from): bool\\n\\t{\\n\\t\\tforeach ($this->routes['*'] as $name => $route)\\n\\t\\t{\\n\\t\\t\\t// Named route?\\n\\t\\t\\tif ($name === $from || key($route['route']) === $from)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn isset($route['redirect']) && is_numeric($route['redirect']);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\", \"output\": \"Determines if the route is a redirecting route.\\n\\n@param string $from\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getRedirectCode(string $from): int\\n\\t{\\n\\t\\tforeach ($this->routes['*'] as $name => $route)\\n\\t\\t{\\n\\t\\t\\t// Named route?\\n\\t\\t\\tif ($name === $from || key($route['route']) === $from)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn $route['redirect'] ?? 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn 0;\\n\\t}\", \"output\": \"Grabs the HTTP status code from a redirecting Route.\\n\\n@param string $from\\n\\n@return integer\"}"}
{"text": "{\"input\": \"Summarize the following code: public function match(array $verbs = [], string $from, $to, array $options = null): RouteCollectionInterface\\n\\t{\\n\\t\\tforeach ($verbs as $verb)\\n\\t\\t{\\n\\t\\t\\t$verb = strtolower($verb);\\n\\n\\t\\t\\t$this->{$verb}($from, $to, $options);\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Specifies a single route to match for multiple HTTP Verbs.\\n\\nExample:\\n$route->match( ['get', 'post'], 'users/(:num)', 'users/$1);\\n\\n@param array        $verbs\\n@param string       $from\\n@param string|array $to\\n@param array        $options\\n\\n@return \\\\CodeIgniter\\\\Router\\\\RouteCollectionInterface\"}"}
{"text": "{\"input\": \"Summarize the following code: public function options(string $from, $to, array $options = null): RouteCollectionInterface\\n\\t{\\n\\t\\t$this->create('options', $from, $to, $options);\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Specifies a route that is only available to OPTIONS requests.\\n\\n@param string       $from\\n@param string|array $to\\n@param array        $options\\n\\n@return \\\\CodeIgniter\\\\Router\\\\RouteCollectionInterface\"}"}
{"text": "{\"input\": \"Summarize the following code: public function environment(string $env, \\\\Closure $callback): RouteCollectionInterface\\n\\t{\\n\\t\\tif (ENVIRONMENT === $env)\\n\\t\\t{\\n\\t\\t\\t$callback($this);\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Limits the routes to a specified ENVIRONMENT or they won't run.\\n\\n@param string   $env\\n@param \\\\Closure $callback\\n\\n@return RouteCollectionInterface\"}"}
{"text": "{\"input\": \"Summarize the following code: public function reverseRoute(string $search, ...$params)\\n\\t{\\n\\t\\t// Named routes get higher priority.\\n\\t\\tforeach ($this->routes as $verb => $collection)\\n\\t\\t{\\n\\t\\t\\tif (array_key_exists($search, $collection))\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn $this->fillRouteParams(key($collection[$search]['route']), $params);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// If it's not a named route, then loop over\\n\\t\\t// all routes to find a match.\\n\\t\\tforeach ($this->routes as $verb => $collection)\\n\\t\\t{\\n\\t\\t\\tforeach ($collection as $route)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$from = key($route['route']);\\n\\t\\t\\t\\t$to   = $route['route'][$from];\\n\\n\\t\\t\\t\\t// Lose any namespace slash at beginning of strings\\n\\t\\t\\t\\t// to ensure more consistent match.\\n\\t\\t\\t\\t$to     = ltrim($to, '\\\\\\\\');\\n\\t\\t\\t\\t$search = ltrim($search, '\\\\\\\\');\\n\\n\\t\\t\\t\\t// If there's any chance of a match, then it will\\n\\t\\t\\t\\t// be with $search at the beginning of the $to string.\\n\\t\\t\\t\\tif (strpos($to, $search) !== 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Ensure that the number of $params given here\\n\\t\\t\\t\\t// matches the number of back-references in the route\\n\\t\\t\\t\\tif (substr_count($to, '$') !== count($params))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn $this->fillRouteParams($from, $params);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// If we're still here, then we did not find a match.\\n\\t\\treturn false;\\n\\t}\", \"output\": \"Attempts to look up a route based on it's destination.\\n\\nIf a route exists:\\n\\n'path/(:any)/(:any)' => 'Controller::method/$1/$2'\\n\\nThis method allows you to know the Controller and method\\nand get the route that leads to it.\\n\\n// Equals 'path/$param1/$param2'\\nreverseRoute('Controller::method', $param1, $param2);\\n\\n@param string $search\\n@param array  ...$params\\n\\n@return string|false\"}"}
{"text": "{\"input\": \"Summarize the following code: private function determineCurrentSubdomain()\\n\\t{\\n\\t\\t// We have to ensure that a scheme exists\\n\\t\\t// on the URL else parse_url will mis-interpret\\n\\t\\t// 'host' as the 'path'.\\n\\t\\t$url = $_SERVER['HTTP_HOST'];\\n\\t\\tif (strpos($url, 'http') !== 0)\\n\\t\\t{\\n\\t\\t\\t$url = 'http://' . $url;\\n\\t\\t}\\n\\n\\t\\t$parsedUrl = parse_url($url);\\n\\n\\t\\t$host = explode('.', $parsedUrl['host']);\\n\\n\\t\\tif ($host[0] === 'www')\\n\\t\\t{\\n\\t\\t\\tunset($host[0]);\\n\\t\\t}\\n\\n\\t\\t// Get rid of any domains, which will be the last\\n\\t\\tunset($host[count($host)]);\\n\\n\\t\\t// Account for .co.uk, .co.nz, etc. domains\\n\\t\\tif (end($host) === 'co')\\n\\t\\t{\\n\\t\\t\\t$host = array_slice($host, 0, -1);\\n\\t\\t}\\n\\n\\t\\t// If we only have 1 part left, then we don't have a sub-domain.\\n\\t\\tif (count($host) === 1)\\n\\t\\t{\\n\\t\\t\\t// Set it to false so we don't make it back here again.\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\treturn array_shift($host);\\n\\t}\", \"output\": \"Examines the HTTP_HOST to get a best match for the subdomain. It\\nwon't be perfect, but should work for our needs.\\n\\nIt's especially not perfect since it's possible to register a domain\\nwith a period (.) as part of the domain name.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function resetRoutes()\\n\\t{\\n\\t\\t$this->routes = ['*' => []];\\n\\t\\tforeach ($this->defaultHTTPMethods as $verb)\\n\\t\\t{\\n\\t\\t\\t$this->routes[$verb] = [];\\n\\t\\t}\\n\\t}\", \"output\": \"Reset the routes, so that a FeatureTestCase can provide the\\nexplicit ones needed for it.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function errorHandler(int $severity, string $message, string $file = null, int $line = null, $context = null)\\n\\t{\\n\\t\\tif (! (error_reporting() & $severity))\\n\\t\\t{\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Convert it to an exception and pass it along.\\n\\t\\tthrow new ErrorException($message, 0, $severity, $file, $line);\\n\\t}\", \"output\": \"Even in PHP7, some errors make it through to the errorHandler, so\\nconvert these to Exceptions and let the exception handler log it and\\ndisplay it.\\n\\nThis seems to be primarily when a user triggers it with trigger_error().\\n\\n@param integer      $severity\\n@param string       $message\\n@param string|null  $file\\n@param integer|null $line\\n@param null         $context\\n\\n@throws \\\\ErrorException\"}"}
{"text": "{\"input\": \"Summarize the following code: public function shutdownHandler()\\n\\t{\\n\\t\\t$error = error_get_last();\\n\\n\\t\\t// If we've got an error that hasn't been displayed, then convert\\n\\t\\t// it to an Exception and use the Exception handler to display it\\n\\t\\t// to the user.\\n\\t\\tif (! is_null($error))\\n\\t\\t{\\n\\t\\t\\t// Fatal Error?\\n\\t\\t\\tif (in_array($error['type'], [E_ERROR, E_CORE_ERROR, E_COMPILE_ERROR, E_PARSE]))\\n\\t\\t\\t{\\n\\t\\t\\t\\t$this->exceptionHandler(new ErrorException($error['message'], $error['type'], 0, $error['file'], $error['line']));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\", \"output\": \"Checks to see if any errors have happened during shutdown that\\nneed to be caught and handle them.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function determineView(Throwable $exception, string $template_path): string\\n\\t{\\n\\t\\t// Production environments should have a custom exception file.\\n\\t\\t$view          = 'production.php';\\n\\t\\t$template_path = rtrim($template_path, '/ ') . '/';\\n\\n\\t\\tif (str_ireplace(['off', 'none', 'no', 'false', 'null'], '', ini_get('display_errors')))\\n\\t\\t{\\n\\t\\t\\t$view = 'error_exception.php';\\n\\t\\t}\\n\\n\\t\\t// 404 Errors\\n\\t\\tif ($exception instanceof PageNotFoundException)\\n\\t\\t{\\n\\t\\t\\treturn 'error_404.php';\\n\\t\\t}\\n\\n\\t\\t// Allow for custom views based upon the status code\\n\\t\\telse if (is_file($template_path . 'error_' . $exception->getCode() . '.php'))\\n\\t\\t{\\n\\t\\t\\treturn 'error_' . $exception->getCode() . '.php';\\n\\t\\t}\\n\\n\\t\\treturn $view;\\n\\t}\", \"output\": \"Determines the view to display based on the exception thrown,\\nwhether an HTTP or CLI request, etc.\\n\\n@param \\\\Throwable $exception\\n@param string     $template_path\\n\\n@return string       The path and filename of the view file to use\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function render(Throwable $exception, int $statusCode)\\n\\t{\\n\\t\\t// Determine directory with views\\n\\t\\t$path = $this->viewPath;\\n\\t\\tif (empty($path))\\n\\t\\t{\\n\\t\\t\\t$paths = new Paths();\\n\\t\\t\\t$path  = $paths->viewDirectory . '/errors/';\\n\\t\\t}\\n\\n\\t\\t$path = is_cli()\\n\\t\\t\\t? $path . 'cli/'\\n\\t\\t\\t: $path . 'html/';\\n\\n\\t\\t// Determine the vew\\n\\t\\t$view = $this->determineView($exception, $path);\\n\\n\\t\\t// Prepare the vars\\n\\t\\t$vars = $this->collectVars($exception, $statusCode);\\n\\t\\textract($vars);\\n\\n\\t\\t// Render it\\n\\t\\tif (ob_get_level() > $this->ob_level + 1)\\n\\t\\t{\\n\\t\\t\\tob_end_clean();\\n\\t\\t}\\n\\n\\t\\tob_start();\\n\\t\\tinclude($path . $view);\\n\\t\\t$buffer = ob_get_contents();\\n\\t\\tob_end_clean();\\n\\t\\techo $buffer;\\n\\t}\", \"output\": \"Given an exception and status code will display the error to the client.\\n\\n@param \\\\Throwable $exception\\n@param integer    $statusCode\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function collectVars(Throwable $exception, int $statusCode): array\\n\\t{\\n\\t\\treturn [\\n\\t\\t\\t'title'   => get_class($exception),\\n\\t\\t\\t'type'    => get_class($exception),\\n\\t\\t\\t'code'    => $statusCode,\\n\\t\\t\\t'message' => $exception->getMessage() ?? '(null)',\\n\\t\\t\\t'file'    => $exception->getFile(),\\n\\t\\t\\t'line'    => $exception->getLine(),\\n\\t\\t\\t'trace'   => $exception->getTrace(),\\n\\t\\t];\\n\\t}\", \"output\": \"Gathers the variables that will be made available to the view.\\n\\n@param \\\\Throwable $exception\\n@param integer    $statusCode\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function determineCodes(Throwable $exception): array\\n\\t{\\n\\t\\t$statusCode = abs($exception->getCode());\\n\\n\\t\\tif ($statusCode < 100 || $statusCode > 599)\\n\\t\\t{\\n\\t\\t\\t$exitStatus = $statusCode + EXIT__AUTO_MIN; // 9 is EXIT__AUTO_MIN\\n\\t\\t\\tif ($exitStatus > EXIT__AUTO_MAX) // 125 is EXIT__AUTO_MAX\\n\\t\\t\\t{\\n\\t\\t\\t\\t$exitStatus = EXIT_ERROR; // EXIT_ERROR\\n\\t\\t\\t}\\n\\t\\t\\t$statusCode = 500;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t$exitStatus = 1; // EXIT_ERROR\\n\\t\\t}\\n\\n\\t\\treturn [\\n\\t\\t\\t$statusCode ?? 500,\\n\\t\\t\\t$exitStatus,\\n\\t\\t];\\n\\t}\", \"output\": \"Determines the HTTP status code and the exit status code for this request.\\n\\n@param \\\\Throwable $exception\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function describeMemory(int $bytes): string\\n\\t{\\n\\t\\tif ($bytes < 1024)\\n\\t\\t{\\n\\t\\t\\treturn $bytes . 'B';\\n\\t\\t}\\n\\t\\telse if ($bytes < 1048576)\\n\\t\\t{\\n\\t\\t\\treturn round($bytes / 1024, 2) . 'KB';\\n\\t\\t}\\n\\n\\t\\treturn round($bytes / 1048576, 2) . 'MB';\\n\\t}\", \"output\": \"Describes memory usage in real-world units. Intended for use\\nwith memory_get_usage, etc.\\n\\n@param $bytes\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function alpha_space(string $value = null): bool\\n\\t{\\n\\t\\tif ($value === null)\\n\\t\\t{\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\treturn (bool) preg_match('/^[A-Z ]+$/i', $value);\\n\\t}\", \"output\": \"Alpha with spaces.\\n\\n@param string $value Value.\\n\\n@return boolean True if alpha with spaces, else false.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function regex_match(string $str = null, string $pattern, array $data): bool\\n\\t{\\n\\t\\tif (strpos($pattern, '/') !== 0)\\n\\t\\t{\\n\\t\\t\\t$pattern = \\\"/{$pattern}/\\\";\\n\\t\\t}\\n\\n\\t\\treturn (bool) preg_match($pattern, $str);\\n\\t}\", \"output\": \"Compares value against a regular expression pattern.\\n\\n@param string $str\\n@param string $pattern\\n@param array  $data    Other field/value pairs\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: public function valid_email(string $str = null): bool\\n\\t{\\n\\t\\tif (function_exists('idn_to_ascii') && defined('INTL_IDNA_VARIANT_UTS46') && preg_match('#\\\\A([^@]+)@(.+)\\\\z#', $str, $matches))\\n\\t\\t{\\n\\t\\t\\t$str = $matches[1] . '@' . idn_to_ascii($matches[2], 0, INTL_IDNA_VARIANT_UTS46);\\n\\t\\t}\\n\\n\\t\\treturn (bool) filter_var($str, FILTER_VALIDATE_EMAIL);\\n\\t}\", \"output\": \"Checks for a correctly formatted email address\\n\\n@param string\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: public function valid_emails(string $str = null): bool\\n\\t{\\n\\t\\tforeach (explode(',', $str) as $email)\\n\\t\\t{\\n\\t\\t\\t$email = trim($email);\\n\\t\\t\\tif ($email === '')\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ($this->valid_email($email) === false)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\", \"output\": \"Validate a comma-separated list of email addresses.\\n\\nExample:\\nvalid_emails[one@example.com,two@example.com]\\n\\n@param string\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: public function valid_url(string $str = null): bool\\n\\t{\\n\\t\\tif (empty($str))\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\telseif (preg_match('/^(?:([^:]*)\\\\:)?\\\\/\\\\/(.+)$/', $str, $matches))\\n\\t\\t{\\n\\t\\t\\tif (! in_array($matches[1], ['http', 'https'], true))\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$str = $matches[2];\\n\\t\\t}\\n\\n\\t\\t$str = 'http://' . $str;\\n\\n\\t\\treturn (filter_var($str, FILTER_VALIDATE_URL) !== false);\\n\\t}\", \"output\": \"Checks a URL to ensure it's formed correctly.\\n\\n@param string $str\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: public function valid_date(string $str = null, string $format = null): bool\\n\\t{\\n\\t\\tif (empty($format))\\n\\t\\t{\\n\\t\\t\\treturn (bool) strtotime($str);\\n\\t\\t}\\n\\n\\t\\t$date = \\\\DateTime::createFromFormat($format, $str);\\n\\n\\t\\treturn (bool) $date && \\\\DateTime::getLastErrors()['warning_count'] === 0 && \\\\DateTime::getLastErrors()['error_count'] === 0;\\n\\t}\", \"output\": \"Checks for a valid date and matches a given date format\\n\\n@param string $str\\n@param string $format\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function forMoveFailed(string $source, string $target, string $error)\\n\\t{\\n\\t\\treturn new static(lang('HTTP.moveFailed', [$source, $target, $error]));\\n\\t}\", \"output\": \"For Uploaded file move\\n\\n@return \\\\CodeIgniter\\\\HTTP\\\\Exceptions\\\\HTTPException\"}"}
{"text": "{\"input\": \"Summarize the following code: public function valid_cc_number(string $ccNumber = null, string $type, array $data): bool\\n\\t{\\n\\t\\t$type = strtolower($type);\\n\\t\\t$info = null;\\n\\n\\t\\t// Get our card info based on provided name.\\n\\t\\tforeach ($this->cards as $card)\\n\\t\\t{\\n\\t\\t\\tif ($card['name'] === $type)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$info = $card;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// If empty, it's not a card type we recognize, or invalid type.\\n\\t\\tif (empty($info))\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// Make sure we have a valid length\\n\\t\\tif (strlen($ccNumber) === 0)\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// Remove any spaces and dashes\\n\\t\\t$ccNumber = str_replace([' ', '-'], '', $ccNumber);\\n\\n\\t\\t// Non-numeric values cannot be a number...duh\\n\\t\\tif (! is_numeric($ccNumber))\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// Make sure it's a valid length for this card\\n\\t\\t$lengths = explode(',', $info['length']);\\n\\n\\t\\tif (! in_array(strlen($ccNumber), $lengths))\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// Make sure it has a valid prefix\\n\\t\\t$prefixes = explode(',', $info['prefixes']);\\n\\n\\t\\t$validPrefix = false;\\n\\n\\t\\tforeach ($prefixes as $prefix)\\n\\t\\t{\\n\\t\\t\\tif (strpos($ccNumber, $prefix) === 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t  $validPrefix = true;\\n\\t\\t\\t\\t\\t\\t\\t  break;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ($validPrefix === false)\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// Still here? Then check the number against the Luhn algorithm, if required\\n\\t\\t// @see https://en.wikipedia.org/wiki/Luhn_algorithm\\n\\t\\t// @see https://gist.github.com/troelskn/1287893\\n\\t\\tif ($info['checkdigit'] === true)\\n\\t\\t{\\n\\t\\t\\treturn $this->isValidLuhn($ccNumber);\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\", \"output\": \"Verifies that a credit card number is valid and matches the known\\nformats for a wide number of credit card types. This does not verify\\nthat the card is a valid card, only that the number is formatted correctly.\\n\\nExample:\\n$rules = [\\n'cc_num' => 'valid_cc_number[visa]'\\n];\\n\\n@param string $ccNumber\\n@param string $type\\n@param array  $data\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function isValidLuhn(string $number = null): bool\\n\\t{\\n\\t\\tsettype($number, 'string');\\n\\n\\t\\t$sumTable = [\\n\\t\\t\\t[\\n\\t\\t\\t\\t0,\\n\\t\\t\\t\\t1,\\n\\t\\t\\t\\t2,\\n\\t\\t\\t\\t3,\\n\\t\\t\\t\\t4,\\n\\t\\t\\t\\t5,\\n\\t\\t\\t\\t6,\\n\\t\\t\\t\\t7,\\n\\t\\t\\t\\t8,\\n\\t\\t\\t\\t9,\\n\\t\\t\\t],\\n\\t\\t\\t[\\n\\t\\t\\t\\t0,\\n\\t\\t\\t\\t2,\\n\\t\\t\\t\\t4,\\n\\t\\t\\t\\t6,\\n\\t\\t\\t\\t8,\\n\\t\\t\\t\\t1,\\n\\t\\t\\t\\t3,\\n\\t\\t\\t\\t5,\\n\\t\\t\\t\\t7,\\n\\t\\t\\t\\t9,\\n\\t\\t\\t],\\n\\t\\t];\\n\\n\\t\\t$sum  = 0;\\n\\t\\t$flip = 0;\\n\\n\\t\\tfor ($i = strlen($number) - 1; $i >= 0; $i --)\\n\\t\\t{\\n\\t\\t\\t$sum += $sumTable[$flip ++ & 0x1][$number[$i]];\\n\\t\\t}\\n\\n\\t\\treturn $sum % 10 === 0;\\n\\t}\", \"output\": \"Checks the given number to see if the number passing a Luhn check.\\n\\n@param string $number\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: protected static function moveFile(string $source, string $destination): bool\\n\\t{\\n\\t\\t$source = realpath($source);\\n\\n\\t\\tif (empty($source))\\n\\t\\t{\\n\\t\\t\\tdie('Cannot move file. Source path invalid.');\\n\\t\\t}\\n\\n\\t\\tif (! is_file($source))\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\treturn copy($source, $destination);\\n\\t}\", \"output\": \"Move a file.\\n\\n@param string $source\\n@param string $destination\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function moveEscaper()\\n\\t{\\n\\t\\tif (class_exists('\\\\\\\\Zend\\\\\\\\Escaper\\\\\\\\Escaper') && is_file(static::getClassFilePath('\\\\\\\\Zend\\\\\\\\Escaper\\\\\\\\Escaper')))\\n\\t\\t{\\n\\t\\t\\t$base = basename(__DIR__) . '/' . static::$basePath . 'ZendEscaper';\\n\\n\\t\\t\\tforeach ([$base, $base . '/Exception'] as $path)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (! is_dir($path))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmkdir($path, 0755);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t$files = [\\n\\t\\t\\t\\tstatic::getClassFilePath('\\\\\\\\Zend\\\\\\\\Escaper\\\\\\\\Exception\\\\\\\\ExceptionInterface')       => $base . '/Exception/ExceptionInterface.php',\\n\\t\\t\\t\\tstatic::getClassFilePath('\\\\\\\\Zend\\\\\\\\Escaper\\\\\\\\Exception\\\\\\\\InvalidArgumentException') => $base . '/Exception/InvalidArgumentException.php',\\n\\t\\t\\t\\tstatic::getClassFilePath('\\\\\\\\Zend\\\\\\\\Escaper\\\\\\\\Exception\\\\\\\\RuntimeException')         => $base . '/Exception/RuntimeException.php',\\n\\t\\t\\t\\tstatic::getClassFilePath('\\\\\\\\Zend\\\\\\\\Escaper\\\\\\\\Escaper')                             => $base . '/Escaper.php',\\n\\t\\t\\t];\\n\\n\\t\\t\\tforeach ($files as $source => $dest)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (! static::moveFile($source, $dest))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdie('Error moving: ' . $source);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\", \"output\": \"Moves the Zend Escaper files into our base repo so that it's\\navailable for packaged releases where the users don't user Composer.\\n\\n@throws \\\\ReflectionException\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function moveKint()\\n\\t{\\n\\t\\t$filename = 'vendor/kint-php/kint/build/kint-aante-light.php';\\n\\n\\t\\tif (is_file($filename))\\n\\t\\t{\\n\\t\\t\\t$base = basename(__DIR__) . '/' . static::$basePath . 'Kint';\\n\\n\\t\\t\\t// Remove the contents of the previous Kint folder, if any.\\n\\t\\t\\tif (is_dir($base))\\n\\t\\t\\t{\\n\\t\\t\\t\\tstatic::removeDir($base);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Create Kint if it doesn't exist already\\n\\t\\t\\tif (! is_dir($base))\\n\\t\\t\\t{\\n\\t\\t\\t\\tmkdir($base, 0755);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (! static::moveFile($filename, $base . '/kint.php'))\\n\\t\\t\\t{\\n\\t\\t\\t\\tdie('Error moving: ' . $filename);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\", \"output\": \"Moves the Kint file into our base repo so that it's\\navailable for packaged releases where the users don't user Composer.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function start()\\n\\t{\\n\\t\\tif (is_cli() && ENVIRONMENT !== 'testing')\\n\\t\\t{\\n\\t\\t\\t$this->logger->debug('Session: Initialization under CLI aborted.');\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telseif ((bool) ini_get('session.auto_start'))\\n\\t\\t{\\n\\t\\t\\t$this->logger->error('Session: session.auto_start is enabled in php.ini. Aborting.');\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telseif (session_status() === PHP_SESSION_ACTIVE)\\n\\t\\t{\\n\\t\\t\\t$this->logger->warning('Session: Sessions is enabled, and one exists.Please don\\\\'t $session->start();');\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (! $this->driver instanceof \\\\SessionHandlerInterface)\\n\\t\\t{\\n\\t\\t\\t$this->logger->error(\\\"Session: Handler '\\\" . $this->driver .\\n\\t\\t\\t\\t\\t\\\"' doesn't implement SessionHandlerInterface. Aborting.\\\");\\n\\t\\t}\\n\\n\\t\\t$this->configure();\\n\\n\\t\\t$this->setSaveHandler();\\n\\n\\t\\t// Sanitize the cookie, because apparently PHP doesn't do that for userspace handlers\\n\\t\\tif (isset($_COOKIE[$this->sessionCookieName]) && (\\n\\t\\t\\t\\t! is_string($_COOKIE[$this->sessionCookieName]) || ! preg_match('#\\\\A' . $this->sidRegexp . '\\\\z#', $_COOKIE[$this->sessionCookieName])\\n\\t\\t\\t\\t)\\n\\t\\t)\\n\\t\\t{\\n\\t\\t\\tunset($_COOKIE[$this->sessionCookieName]);\\n\\t\\t}\\n\\n\\t\\t$this->startSession();\\n\\n\\t\\t// Is session ID auto-regeneration configured? (ignoring ajax requests)\\n\\t\\tif ((empty($_SERVER['HTTP_X_REQUESTED_WITH']) ||\\n\\t\\t\\t\\tstrtolower($_SERVER['HTTP_X_REQUESTED_WITH']) !== 'xmlhttprequest') && ($regenerate_time = $this->sessionTimeToUpdate) > 0\\n\\t\\t)\\n\\t\\t{\\n\\t\\t\\tif (! isset($_SESSION['__ci_last_regenerate']))\\n\\t\\t\\t{\\n\\t\\t\\t\\t$_SESSION['__ci_last_regenerate'] = time();\\n\\t\\t\\t}\\n\\t\\t\\telseif ($_SESSION['__ci_last_regenerate'] < (time() - $regenerate_time))\\n\\t\\t\\t{\\n\\t\\t\\t\\t$this->regenerate((bool) $this->sessionRegenerateDestroy);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// Another work-around ... PHP doesn't seem to send the session cookie\\n\\t\\t// unless it is being currently created or regenerated\\n\\t\\telseif (isset($_COOKIE[$this->sessionCookieName]) && $_COOKIE[$this->sessionCookieName] === session_id())\\n\\t\\t{\\n\\t\\t\\t$this->setCookie();\\n\\t\\t}\\n\\n\\t\\t$this->initVars();\\n\\n\\t\\t$this->logger->info(\\\"Session: Class initialized using '\\\" . $this->sessionDriverName . \\\"' driver.\\\");\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Initialize the session container and starts up the session.\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function configureSidLength()\\n\\t{\\n\\t\\t$bits_per_character = (int) (ini_get('session.sid_bits_per_character') !== false\\n\\t\\t\\t? ini_get('session.sid_bits_per_character')\\n\\t\\t\\t: 4);\\n\\t\\t$sid_length         = (int) (ini_get('session.sid_length') !== false\\n\\t\\t\\t? ini_get('session.sid_length')\\n\\t\\t\\t: 40);\\n\\t\\tif (($sid_length * $bits_per_character) < 160)\\n\\t\\t{\\n\\t\\t\\t$bits = ($sid_length * $bits_per_character);\\n\\t\\t\\t// Add as many more characters as necessary to reach at least 160 bits\\n\\t\\t\\t$sid_length += (int) ceil((160 % $bits) / $bits_per_character);\\n\\t\\t\\tini_set('session.sid_length', $sid_length);\\n\\t\\t}\\n\\n\\t\\t// Yes, 4,5,6 are the only known possible values as of 2016-10-27\\n\\t\\tswitch ($bits_per_character)\\n\\t\\t{\\n\\t\\t\\tcase 4:\\n\\t\\t\\t\\t$this->sidRegexp = '[0-9a-f]';\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 5:\\n\\t\\t\\t\\t$this->sidRegexp = '[0-9a-v]';\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 6:\\n\\t\\t\\t\\t$this->sidRegexp = '[0-9a-zA-Z,-]';\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\t$this->sidRegexp .= '{' . $sid_length . '}';\\n\\t}\", \"output\": \"Configure session ID length\\n\\nTo make life easier, we used to force SHA-1 and 4 bits per\\ncharacter on everyone. And of course, someone was unhappy.\\n\\nThen PHP 7.1 broke backwards-compatibility because ext/session\\nis such a mess that nobody wants to touch it with a pole stick,\\nand the one guy who does, nobody has the energy to argue with.\\n\\nSo we were forced to make changes, and OF COURSE something was\\ngoing to break and now we have this pile of shit. -- Narf\\n\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function initVars()\\n\\t{\\n\\t\\tif (empty($_SESSION['__ci_vars']))\\n\\t\\t{\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t$current_time = time();\\n\\n\\t\\tforeach ($_SESSION['__ci_vars'] as $key => &$value)\\n\\t\\t{\\n\\t\\t\\tif ($value === 'new')\\n\\t\\t\\t{\\n\\t\\t\\t\\t$_SESSION['__ci_vars'][$key] = 'old';\\n\\t\\t\\t}\\n\\t\\t\\t// Hacky, but 'old' will (implicitly) always be less than time() ;)\\n\\t\\t\\t// DO NOT move this above the 'new' check!\\n\\t\\t\\telseif ($value < $current_time)\\n\\t\\t\\t{\\n\\t\\t\\t\\tunset($_SESSION[$key], $_SESSION['__ci_vars'][$key]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (empty($_SESSION['__ci_vars']))\\n\\t\\t{\\n\\t\\t\\tunset($_SESSION['__ci_vars']);\\n\\t\\t}\\n\\t}\", \"output\": \"Handle temporary variables\\n\\nClears old \\\"flash\\\" data, marks the new one for deletion and handles\\n\\\"temp\\\" data deletion.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function set($data, $value = null)\\n\\t{\\n\\t\\tif (is_array($data))\\n\\t\\t{\\n\\t\\t\\tforeach ($data as $key => &$value)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (is_int($key))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$_SESSION[$value] = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$_SESSION[$key] = $value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t$_SESSION[$data] = $value;\\n\\t}\", \"output\": \"Sets user data into the session.\\n\\nIf $data is a string, then it is interpreted as a session property\\nkey, and  $value is expected to be non-null.\\n\\nIf $data is an array, it is expected to be an array of key/value pairs\\nto be set as session properties.\\n\\n@param string|array $data  Property name or associative array of properties\\n@param string|array $value Property value if single key provided\"}"}
{"text": "{\"input\": \"Summarize the following code: public function get(string $key = null)\\n\\t{\\n\\t\\tif (! empty($key) && $value = dot_array_search($key, $_SESSION))\\n\\t\\t{\\n\\t\\t\\treturn $value;\\n\\t\\t}\\n\\t\\telseif (empty($_SESSION))\\n\\t\\t{\\n\\t\\t\\treturn [];\\n\\t\\t}\\n\\n\\t\\tif (! empty($key))\\n\\t\\t{\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\t$userdata = [];\\n\\t\\t$_exclude = array_merge(\\n\\t\\t\\t['__ci_vars'], $this->getFlashKeys(), $this->getTempKeys()\\n\\t\\t);\\n\\n\\t\\t$keys = array_keys($_SESSION);\\n\\t\\tforeach ($keys as $key)\\n\\t\\t{\\n\\t\\t\\tif (! in_array($key, $_exclude, true))\\n\\t\\t\\t{\\n\\t\\t\\t\\t$userdata[$key] = $_SESSION[$key];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $userdata;\\n\\t}\", \"output\": \"Get user data that has been set in the session.\\n\\nIf the property exists as \\\"normal\\\", returns it.\\nOtherwise, returns an array of any temp or flash data values with the\\nproperty key.\\n\\nReplaces the legacy method $session->userdata();\\n\\n@param  string $key Identifier of the session property to retrieve\\n@return array|null\\tThe property value(s)\"}"}
{"text": "{\"input\": \"Summarize the following code: public function push(string $key, array $data)\\n\\t{\\n\\t\\tif ($this->has($key) && is_array($value = $this->get($key)))\\n\\t\\t\\t   {\\n\\t\\t\\t$this->set($key, array_merge($value, $data));\\n\\t\\t}\\n\\t}\", \"output\": \"Push new value onto session value that is array.\\n\\n@param string $key  Identifier of the session property we are interested in.\\n@param array  $data value to be pushed to existing session key.\\n\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: public function remove($key)\\n\\t{\\n\\t\\tif (is_array($key))\\n\\t\\t{\\n\\t\\t\\tforeach ($key as $k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tunset($_SESSION[$k]);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tunset($_SESSION[$key]);\\n\\t}\", \"output\": \"Remove one or more session properties.\\n\\nIf $key is an array, it is interpreted as an array of string property\\nidentifiers to remove. Otherwise, it is interpreted as the identifier\\nof a specific session property to remove.\\n\\n@param string|array $key Identifier of the session property or properties to remove.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setFlashdata($data, $value = null)\\n\\t{\\n\\t\\t$this->set($data, $value);\\n\\t\\t$this->markAsFlashdata(is_array($data) ? array_keys($data) : $data);\\n\\t}\", \"output\": \"Sets data into the session that will only last for a single request.\\nPerfect for use with single-use status update messages.\\n\\nIf $data is an array, it is interpreted as an associative array of\\nkey/value pairs for flashdata properties.\\nOtherwise, it is interpreted as the identifier of a specific\\nflashdata property, with $value containing the property value.\\n\\n@param array|string $data  Property identifier or associative array of properties\\n@param string|array $value Property value if $data is a scalar\"}"}
{"text": "{\"input\": \"Summarize the following code: public function markAsFlashdata($key): bool\\n\\t{\\n\\t\\tif (is_array($key))\\n\\t\\t{\\n\\t\\t\\tfor ($i = 0, $c = count($key); $i < $c; $i ++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (! isset($_SESSION[$key[$i]]))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t$new = array_fill_keys($key, 'new');\\n\\n\\t\\t\\t$_SESSION['__ci_vars'] = isset($_SESSION['__ci_vars']) ? array_merge($_SESSION['__ci_vars'], $new) : $new;\\n\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tif (! isset($_SESSION[$key]))\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t$_SESSION['__ci_vars'][$key] = 'new';\\n\\n\\t\\treturn true;\\n\\t}\", \"output\": \"Mark a session property or properties as flashdata.\\n\\n@param array|string $key Property identifier or array of them\\n\\n@return boolean False if any of the properties are not already set\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getFlashKeys(): array\\n\\t{\\n\\t\\tif (! isset($_SESSION['__ci_vars']))\\n\\t\\t{\\n\\t\\t\\treturn [];\\n\\t\\t}\\n\\n\\t\\t$keys = [];\\n\\t\\tforeach (array_keys($_SESSION['__ci_vars']) as $key)\\n\\t\\t{\\n\\t\\t\\tis_int($_SESSION['__ci_vars'][$key]) || $keys[] = $key;\\n\\t\\t}\\n\\n\\t\\treturn $keys;\\n\\t}\", \"output\": \"Retrieve all of the keys for session data marked as flashdata.\\n\\n@return array\\tThe property names of all flashdata\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setTempdata($data, $value = null, int $ttl = 300)\\n\\t{\\n\\t\\t$this->set($data, $value);\\n\\t\\t$this->markAsTempdata($data, $ttl);\\n\\t}\", \"output\": \"Sets new data into the session, and marks it as temporary data\\nwith a set lifespan.\\n\\n@param string|array $data  Session data key or associative array of items\\n@param null         $value Value to store\\n@param integer      $ttl   Time-to-live in seconds\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getTempdata(string $key = null)\\n\\t{\\n\\t\\tif (isset($key))\\n\\t\\t{\\n\\t\\t\\treturn (isset($_SESSION['__ci_vars'], $_SESSION['__ci_vars'][$key], $_SESSION[$key]) &&\\n\\t\\t\\t\\t\\tis_int($_SESSION['__ci_vars'][$key])) ? $_SESSION[$key] : null;\\n\\t\\t}\\n\\n\\t\\t$tempdata = [];\\n\\n\\t\\tif (! empty($_SESSION['__ci_vars']))\\n\\t\\t{\\n\\t\\t\\tforeach ($_SESSION['__ci_vars'] as $key => &$value)\\n\\t\\t\\t{\\n\\t\\t\\t\\tis_int($value) && $tempdata[$key] = $_SESSION[$key];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $tempdata;\\n\\t}\", \"output\": \"Returns either a single piece of tempdata, or all temp data currently\\nin the session.\\n\\n@param  string   $key   Session data key\\n@return mixed  Session data value or null if not found.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function markAsTempdata($key, int $ttl = 300): bool\\n\\t{\\n\\t\\t$ttl += time();\\n\\n\\t\\tif (is_array($key))\\n\\t\\t{\\n\\t\\t\\t$temp = [];\\n\\n\\t\\t\\tforeach ($key as $k => $v)\\n\\t\\t\\t{\\n\\t\\t\\t\\t// Do we have a key => ttl pair, or just a key?\\n\\t\\t\\t\\tif (is_int($k))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$k = $v;\\n\\t\\t\\t\\t\\t$v = $ttl;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telseif (is_string($v))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$v = time() + $ttl;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$v += time();\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (! array_key_exists($k, $_SESSION))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t$temp[$k] = $v;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$_SESSION['__ci_vars'] = isset($_SESSION['__ci_vars']) ? array_merge($_SESSION['__ci_vars'], $temp) : $temp;\\n\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tif (! isset($_SESSION[$key]))\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t$_SESSION['__ci_vars'][$key] = $ttl;\\n\\n\\t\\treturn true;\\n\\t}\", \"output\": \"Mark one of more pieces of data as being temporary, meaning that\\nit has a set lifespan within the session.\\n\\n@param string|array $key Property identifier or array of them\\n@param integer      $ttl Time to live, in seconds\\n\\n@return boolean    False if any of the properties were not set\"}"}
{"text": "{\"input\": \"Summarize the following code: public function unmarkTempdata($key)\\n\\t{\\n\\t\\tif (empty($_SESSION['__ci_vars']))\\n\\t\\t{\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tis_array($key) || $key = [$key];\\n\\n\\t\\tforeach ($key as $k)\\n\\t\\t{\\n\\t\\t\\tif (isset($_SESSION['__ci_vars'][$k]) && is_int($_SESSION['__ci_vars'][$k]))\\n\\t\\t\\t{\\n\\t\\t\\t\\tunset($_SESSION['__ci_vars'][$k]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (empty($_SESSION['__ci_vars']))\\n\\t\\t{\\n\\t\\t\\tunset($_SESSION['__ci_vars']);\\n\\t\\t}\\n\\t}\", \"output\": \"Unmarks temporary data in the session, effectively removing its\\nlifespan and allowing it to live as long as the session does.\\n\\n@param string|array $key\\tProperty identifier or array of them\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getTempKeys(): array\\n\\t{\\n\\t\\tif (! isset($_SESSION['__ci_vars']))\\n\\t\\t{\\n\\t\\t\\treturn [];\\n\\t\\t}\\n\\n\\t\\t$keys = [];\\n\\t\\tforeach (array_keys($_SESSION['__ci_vars']) as $key)\\n\\t\\t{\\n\\t\\t\\tis_int($_SESSION['__ci_vars'][$key]) && $keys[] = $key;\\n\\t\\t}\\n\\n\\t\\treturn $keys;\\n\\t}\", \"output\": \"Retrieve the keys of all session data that have been marked as temporary data.\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: public function check(string $key, int $capacity, int $seconds, int $cost = 1): bool\\n\\t{\\n\\t\\t$tokenName = $this->prefix . $key;\\n\\n\\t\\t// Check to see if the bucket has even been created yet.\\n\\t\\tif (($tokens = $this->cache->get($tokenName)) === false)\\n\\t\\t{\\n\\t\\t\\t// If it hasn't been created, then we'll set it to the maximum\\n\\t\\t\\t// capacity - 1, and save it to the cache.\\n\\t\\t\\t$this->cache->save($tokenName, $capacity - $cost, $seconds);\\n\\t\\t\\t$this->cache->save($tokenName . 'Time', time());\\n\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\t// If $tokens > 0, then we need to replenish the bucket\\n\\t\\t// based on how long it's been since the last update.\\n\\t\\t$throttleTime = $this->cache->get($tokenName . 'Time');\\n\\t\\t$elapsed      = $this->time() - $throttleTime;\\n\\t\\t// Number of tokens to add back per second\\n\\t\\t$rate = $capacity / $seconds;\\n\\n\\t\\t// We must have a minimum wait of 1 second for a new token\\n\\t\\t// Primarily stored to allow devs to report back to users.\\n\\t\\t$this->tokenTime = max(1, $rate);\\n\\n\\t\\t// Add tokens based up on number per second that\\n\\t\\t// should be refilled, then checked against capacity\\n\\t\\t// to be sure the bucket didn't overflow.\\n\\t\\t$tokens += $rate * $elapsed;\\n\\t\\t$tokens  = $tokens > $capacity ? $capacity : $tokens;\\n\\n\\t\\t// If $tokens > 0, then we are save to perform the action, but\\n\\t\\t// we need to decrement the number of available tokens.\\n\\t\\t$response = false;\\n\\n\\t\\tif ($tokens > 0)\\n\\t\\t{\\n\\t\\t\\t$response = true;\\n\\n\\t\\t\\t$this->cache->save($tokenName, $tokens - $cost, $elapsed);\\n\\t\\t\\t$this->cache->save($tokenName . 'Time', time());\\n\\t\\t}\\n\\n\\t\\treturn $response;\\n\\t}\", \"output\": \"Restricts the number of requests made by a single IP address within\\na set number of seconds.\\n\\nExample:\\n\\nif (! $throttler->check($request->ipAddress(), 60, MINUTE))\\n{\\ndie('You submitted over 60 requests within a minute.');\\n}\\n\\n@param string  $key      The name to use as the \\\"bucket\\\" name.\\n@param integer $capacity The number of requests the \\\"bucket\\\" can hold\\n@param integer $seconds  The time it takes the \\\"bucket\\\" to completely refill\\n@param integer $cost     The number of tokens this action uses.\\n\\n@return   boolean\\n@internal param int $maxRequests\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function guessTypeFromExtension(string $extension)\\n\\t{\\n\\t\\t$extension = trim(strtolower($extension), '. ');\\n\\n\\t\\tif (! array_key_exists($extension, static::$mimes))\\n\\t\\t{\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\treturn is_array(static::$mimes[$extension]) ? static::$mimes[$extension][0] : static::$mimes[$extension];\\n\\t}\", \"output\": \"Attempts to determine the best mime type for the given file extension.\\n\\n@param string $extension\\n\\n@return string|null The mime type found, or none if unable to determine.\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function guessExtensionFromType(string $type, ?string $proposed_extension = null)\\n\\t{\\n\\t\\t$type = trim(strtolower($type), '. ');\\n\\n\\t\\t$proposed_extension = trim(strtolower($proposed_extension));\\n\\n\\t\\tif (! is_null($proposed_extension) && array_key_exists($proposed_extension, static::$mimes) && in_array($type, is_string(static::$mimes[$proposed_extension]) ? [static::$mimes[$proposed_extension]] : static::$mimes[$proposed_extension]))\\n\\t\\t{\\n\\t\\t\\treturn $proposed_extension;\\n\\t\\t}\\n\\n\\t\\tforeach (static::$mimes as $ext => $types)\\n\\t\\t{\\n\\t\\t\\tif (is_string($types) && $types === $type)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn $ext;\\n\\t\\t\\t}\\n\\t\\t\\telse if (is_array($types) && in_array($type, $types))\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn $ext;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn null;\\n\\t}\", \"output\": \"Attempts to determine the best file extension for a given mime type.\\n\\n@param string $type\\n@param string $proposed_extension - default extension (in case there is more than one with the same mime type)\\n\\n@return string|null The extension determined, or null if unable to match.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function to(string $uri, int $code = null, string $method = 'auto')\\n\\t{\\n\\t\\t// If it appears to be a relative URL, then convert to full URL\\n\\t\\t// for better security.\\n\\t\\tif (strpos($uri, 'http') !== 0)\\n\\t\\t{\\n\\t\\t\\t$url = current_url(true)->resolveRelativeURI($uri);\\n\\t\\t\\t$uri = (string)$url;\\n\\t\\t}\\n\\n\\t\\treturn $this->redirect($uri, $method, $code);\\n\\t}\", \"output\": \"Sets the URI to redirect to and, optionally, the HTTP status code to use.\\nIf no code is provided it will be automatically determined.\\n\\n@param string       $uri    The URI to redirect to\\n@param integer|null $code   HTTP status code\\n@param string       $method\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: public function route(string $route, array $params = [], int $code = 302, string $method = 'auto')\\n\\t{\\n\\t\\t$routes = Services::routes(true);\\n\\n\\t\\t$route = $routes->reverseRoute($route, ...$params);\\n\\n\\t\\tif (! $route)\\n\\t\\t{\\n\\t\\t\\tthrow HTTPException::forInvalidRedirectRoute($route);\\n\\t\\t}\\n\\n\\t\\treturn $this->redirect(base_url($route), $method, $code);\\n\\t}\", \"output\": \"Sets the URI to redirect to but as a reverse-routed or named route\\ninstead of a raw URI.\\n\\n@param string       $route\\n@param array        $params\\n@param integer|null $code\\n@param string       $method\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: public function back(int $code = null, string $method = 'auto')\\n\\t{\\n\\t\\t$this->ensureSession();\\n\\n\\t\\treturn $this->redirect(previous_url(), $method, $code);\\n\\t}\", \"output\": \"Helper function to return to previous page.\\n\\nExample:\\nreturn redirect()->back();\\n\\n@param integer|null $code\\n@param string       $method\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: public function with(string $key, $message)\\n\\t{\\n\\t\\t$session = $this->ensureSession();\\n\\n\\t\\t$session->setFlashdata($key, $message);\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Adds a key and message to the session as Flashdata.\\n\\n@param string       $key\\n@param string|array $message\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: public function run(string $uri, string $position = 'before')\\n\\t{\\n\\t\\t$this->initialize(strtolower($uri));\\n\\n\\t\\tforeach ($this->filters[$position] as $alias => $rules)\\n\\t\\t{\\n\\t\\t\\tif (is_numeric($alias) && is_string($rules))\\n\\t\\t\\t{\\n\\t\\t\\t\\t$alias = $rules;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (! array_key_exists($alias, $this->config->aliases))\\n\\t\\t\\t{\\n\\t\\t\\t\\tthrow FilterException::forNoAlias($alias);\\n\\t\\t\\t}\\n\\n\\t\\t\\t$class = new $this->config->aliases[$alias]();\\n\\n\\t\\t\\tif (! $class instanceof FilterInterface)\\n\\t\\t\\t{\\n\\t\\t\\t\\tthrow FilterException::forIncorrectInterface(get_class($class));\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ($position === 'before')\\n\\t\\t\\t{\\n\\t\\t\\t\\t$result = $class->before($this->request, $this->arguments[$alias] ?? null);\\n\\n\\t\\t\\t\\tif ($result instanceof RequestInterface)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$this->request = $result;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// If the response object was sent back,\\n\\t\\t\\t\\t// then send it and quit.\\n\\t\\t\\t\\tif ($result instanceof ResponseInterface)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t// short circuit - bypass any other filters\\n\\t\\t\\t\\t\\treturn $result;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Ignore an empty result\\n\\t\\t\\t\\tif (empty($result))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn $result;\\n\\t\\t\\t}\\n\\t\\t\\telseif ($position === 'after')\\n\\t\\t\\t{\\n\\t\\t\\t\\t$result = $class->after($this->request, $this->response);\\n\\n\\t\\t\\t\\tif ($result instanceof ResponseInterface)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$this->response = $result;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $position === 'before' ? $this->request : $this->response;\\n\\t}\", \"output\": \"Runs through all of the filters for the specified\\nuri and position.\\n\\n@param string $uri\\n@param string $position\\n\\n@return \\\\CodeIgniter\\\\HTTP\\\\RequestInterface|\\\\CodeIgniter\\\\HTTP\\\\ResponseInterface|mixed\\n@throws \\\\CodeIgniter\\\\Filters\\\\Exceptions\\\\FilterException\"}"}
{"text": "{\"input\": \"Summarize the following code: public function initialize(string $uri = null)\\n\\t{\\n\\t\\tif ($this->initialized === true)\\n\\t\\t{\\n\\t\\t\\treturn $this;\\n\\t\\t}\\n\\n\\t\\t$this->processGlobals($uri);\\n\\t\\t$this->processMethods();\\n\\t\\t$this->processFilters($uri);\\n\\n\\t\\t$this->initialized = true;\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Runs through our list of filters provided by the configuration\\nobject to get them ready for use, including getting uri masks\\nto proper regex, removing those we can from the possibilities\\nbased on HTTP method, etc.\\n\\nThe resulting $this->filters is an array of only filters\\nthat should be applied to this request.\\n\\nWe go ahead an process the entire tree because we'll need to\\nrun through both a before and after and don't want to double\\nprocess the rows.\\n\\n@param string $uri\\n\\n@return Filters\"}"}
{"text": "{\"input\": \"Summarize the following code: public function enableFilter(string $name, string $when = 'before')\\n\\t{\\n\\t\\t// Get parameters and clean name\\n\\t\\tif (strpos($name, ':') !== false)\\n\\t\\t{\\n\\t\\t\\tlist($name, $params) = explode(':', $name);\\n\\n\\t\\t\\t$params = explode(',', $params);\\n\\t\\t\\tarray_walk($params, function (&$item) {\\n\\t\\t\\t\\t$item = trim($item);\\n\\t\\t\\t});\\n\\n\\t\\t\\t$this->arguments[$name] = $params;\\n\\t\\t}\\n\\n\\t\\tif (! array_key_exists($name, $this->config->aliases))\\n\\t\\t{\\n\\t\\t\\tthrow FilterException::forNoAlias($name);\\n\\t\\t}\\n\\n\\t\\tif (! isset($this->filters[$when][$name]))\\n\\t\\t{\\n\\t\\t\\t$this->filters[$when][] = $name;\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Ensures that a specific filter is on and enabled for the current request.\\n\\nFilters can have \\\"arguments\\\". This is done by placing a colon immediately\\nafter the filter name, followed by a comma-separated list of arguments that\\nare passed to the filter when executed.\\n\\n@param string $name\\n@param string $when\\n\\n@return \\\\CodeIgniter\\\\Filters\\\\Filters\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getArguments(string $key = null)\\n\\t{\\n\\t\\treturn is_null($key)\\n\\t\\t\\t? $this->arguments\\n\\t\\t\\t: $this->arguments[$key];\\n\\t}\", \"output\": \"Returns the arguments for a specified key, or all.\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function format($object)\\n\\t{\\n\\t\\tif (! is_object($object))\\n\\t\\t{\\n\\t\\t\\treturn $object;\\n\\t\\t}\\n\\n\\t\\t// @todo Modify formatting of objects once we can view them in browser.\\n\\t\\t$objectArray = (array) $object;\\n\\n\\t\\t$objectArray['___class_name'] = get_class($object);\\n\\n\\t\\treturn $objectArray;\\n\\t}\", \"output\": \"Converts the object to display nicely in the Chrome Logger UI.\\n\\n@param $object\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: public function sendLogs(ResponseInterface &$response = null)\\n\\t{\\n\\t\\tif (is_null($response))\\n\\t\\t{\\n\\t\\t\\t$response = Services::response(null, true);\\n\\t\\t}\\n\\n\\t\\t$data = base64_encode(utf8_encode(json_encode($this->json)));\\n\\n\\t\\t$response->setHeader($this->header, $data);\\n\\t}\", \"output\": \"Attaches the header and the content to the passed in request object.\\n\\n@param ResponseInterface $response\"}"}
{"text": "{\"input\": \"Summarize the following code: public function detectLocale($config)\\n\\t{\\n\\t\\t$this->locale = $this->defaultLocale = $config->defaultLocale;\\n\\n\\t\\tif (! $config->negotiateLocale)\\n\\t\\t{\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t$this->setLocale($this->negotiate('language', $config->supportedLocales));\\n\\t}\", \"output\": \"Handles setting up the locale, perhaps auto-detecting through\\ncontent negotiation.\\n\\n@param $config\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setLocale(string $locale)\\n\\t{\\n\\t\\t// If it's not a valid locale, set it\\n\\t\\t// to the default locale for the site.\\n\\t\\tif (! in_array($locale, $this->validLocales))\\n\\t\\t{\\n\\t\\t\\t$locale = $this->defaultLocale;\\n\\t\\t}\\n\\n\\t\\t$this->locale = $locale;\\n\\n\\t\\t// If the intl extension is loaded, make sure\\n\\t\\t// that we set the locale for it... if not, though,\\n\\t\\t// don't worry about it.\\n\\t\\t// this should not block code coverage thru unit testing\\n\\t\\t// @codeCoverageIgnoreStart\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tif (class_exists('\\\\Locale', false))\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\\\Locale::setDefault($locale);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcatch (\\\\Exception $e)\\n\\t\\t{\\n\\t\\t}\\n\\t\\t// @codeCoverageIgnoreEnd\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Sets the locale string for this request.\\n\\n@param string $locale\\n\\n@return IncomingRequest\"}"}
{"text": "{\"input\": \"Summarize the following code: public function isSecure(): bool\\n\\t{\\n\\t\\tif (! empty($_SERVER['HTTPS']) && strtolower($_SERVER['HTTPS']) !== 'off')\\n\\t\\t{\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\telseif (isset($_SERVER['HTTP_X_FORWARDED_PROTO']) && $_SERVER['HTTP_X_FORWARDED_PROTO'] === 'https')\\n\\t\\t{\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\telseif (! empty($_SERVER['HTTP_FRONT_END_HTTPS']) && strtolower($_SERVER['HTTP_FRONT_END_HTTPS']) !== 'off')\\n\\t\\t{\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\", \"output\": \"Attempts to detect if the current connection is secure through\\na few different methods.\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getJSON(bool $assoc = false, int $depth = 512, int $options = 0)\\n\\t{\\n\\t\\treturn json_decode($this->body, $assoc, $depth, $options);\\n\\t}\", \"output\": \"A convenience method that grabs the raw input stream and decodes\\nthe JSON into an array.\\n\\nIf $assoc == true, then all objects in the response will be converted\\nto associative arrays.\\n\\n@param boolean $assoc   Whether to return objects as associative arrays\\n@param integer $depth   How many levels deep to decode\\n@param integer $options Bitmask of options\\n\\n@see http://php.net/manual/en/function.json-decode.php\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getGet($index = null, $filter = null, $flags = null)\\n\\t{\\n\\t\\treturn $this->fetchGlobal('get', $index, $filter, $flags);\\n\\t}\", \"output\": \"Fetch an item from GET data.\\n\\n@param string|array|null $index  Index for item to fetch from $_GET.\\n@param integer|null      $filter A filter name to apply.\\n@param mixed|null        $flags\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getPost($index = null, $filter = null, $flags = null)\\n\\t{\\n\\t\\treturn $this->fetchGlobal('post', $index, $filter, $flags);\\n\\t}\", \"output\": \"Fetch an item from POST.\\n\\n@param string|array|null $index  Index for item to fetch from $_POST.\\n@param integer|null      $filter A filter name to apply\\n@param mixed             $flags\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getGetPost($index = null, $filter = null, $flags = null)\\n\\t{\\n\\t\\t// Use $_GET directly here, since filter_has_var only\\n\\t\\t// checks the initial GET data, not anything that might\\n\\t\\t// have been added since.\\n\\t\\treturn isset($_GET[$index]) ? $this->getGet($index, $filter, $flags) : $this->getPost($index, $filter, $flags);\\n\\t}\", \"output\": \"Fetch an item from GET data with fallback to POST.\\n\\n@param string|array|null $index  Index for item to be fetched from $_GET or $_POST\\n@param integer|null      $filter A filter name to apply\\n@param mixed             $flags\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getCookie($index = null, $filter = null, $flags = null)\\n\\t{\\n\\t\\treturn $this->fetchGlobal('cookie', $index, $filter, $flags);\\n\\t}\", \"output\": \"Fetch an item from the COOKIE array.\\n\\n@param string|array|null $index  Index for item to be fetched from $_COOKIE\\n@param integer|null      $filter A filter name to be applied\\n@param mixed             $flags\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getFiles(): array\\n\\t{\\n\\t\\tif (is_null($this->files))\\n\\t\\t{\\n\\t\\t\\t$this->files = new FileCollection();\\n\\t\\t}\\n\\n\\t\\treturn $this->files->all(); // return all files\\n\\t}\", \"output\": \"Returns an array of all files that have been uploaded with this\\nrequest. Each file is represented by an UploadedFile instance.\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getFile(string $fileID)\\n\\t{\\n\\t\\tif (is_null($this->files))\\n\\t\\t{\\n\\t\\t\\t$this->files = new FileCollection();\\n\\t\\t}\\n\\n\\t\\treturn $this->files->getFile($fileID);\\n\\t}\", \"output\": \"Retrieves a single file by the name of the input field used\\nto upload it.\\n\\n@param string $fileID\\n\\n@return UploadedFile|null\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function detectURI(string $protocol, string $baseURL)\\n\\t{\\n\\t\\t$this->uri->setPath($this->detectPath($protocol));\\n\\n\\t\\t// It's possible the user forgot a trailing slash on their\\n\\t\\t// baseURL, so let's help them out.\\n\\t\\t$baseURL = ! empty($baseURL) ? rtrim($baseURL, '/ ') . '/' : $baseURL;\\n\\n\\t\\t// Based on our baseURL provided by the developer (if set)\\n\\t\\t// set our current domain name, scheme\\n\\t\\tif (! empty($baseURL))\\n\\t\\t{\\n\\t\\t\\t// We cannot add the path here, otherwise it's possible\\n\\t\\t\\t// that the routing will not work correctly if we are\\n\\t\\t\\t// within a sub-folder scheme. So it's modified in\\n\\t\\t\\t// the\\n\\t\\t\\t$this->uri->setScheme(parse_url($baseURL, PHP_URL_SCHEME));\\n\\t\\t\\t$this->uri->setHost(parse_url($baseURL, PHP_URL_HOST));\\n\\t\\t\\t$this->uri->setPort(parse_url($baseURL, PHP_URL_PORT));\\n\\t\\t\\t$this->uri->resolveRelativeURI(parse_url($baseURL, PHP_URL_PATH));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t// @codeCoverageIgnoreStart\\n\\t\\t\\tif (! is_cli())\\n\\t\\t\\t{\\n\\t\\t\\t\\tdie('You have an empty or invalid base URL. The baseURL value must be set in Config\\\\App.php, or through the .env file.');\\n\\t\\t\\t}\\n\\t\\t\\t// @codeCoverageIgnoreEnd\\n\\t\\t}\\n\\t}\", \"output\": \"Sets up our URI object based on the information we have. This is\\neither provided by the user in the baseURL Config setting, or\\ndetermined from the environment as needed.\\n\\n@param string $protocol\\n@param string $baseURL\"}"}
{"text": "{\"input\": \"Summarize the following code: public function detectPath(string $protocol = ''): string\\n\\t{\\n\\t\\tif (empty($protocol))\\n\\t\\t{\\n\\t\\t\\t$protocol = 'REQUEST_URI';\\n\\t\\t}\\n\\n\\t\\tswitch ($protocol)\\n\\t\\t{\\n\\t\\t\\tcase 'REQUEST_URI':\\n\\t\\t\\t\\t$path = $this->parseRequestURI();\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 'QUERY_STRING':\\n\\t\\t\\t\\t$path = $this->parseQueryString();\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 'PATH_INFO':\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\t$path = $this->fetchGlobal('server', $protocol) ?? $this->parseRequestURI();\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\treturn $path;\\n\\t}\", \"output\": \"Based on the URIProtocol Config setting, will attempt to\\ndetect the path portion of the current URI.\\n\\n@param string $protocol\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function negotiate(string $type, array $supported, bool $strictMatch = false): string\\n\\t{\\n\\t\\tif (is_null($this->negotiator))\\n\\t\\t{\\n\\t\\t\\t$this->negotiator = Services::negotiator($this, true);\\n\\t\\t}\\n\\n\\t\\tswitch (strtolower($type))\\n\\t\\t{\\n\\t\\t\\tcase 'media':\\n\\t\\t\\t\\treturn $this->negotiator->media($supported, $strictMatch);\\n\\t\\t\\tcase 'charset':\\n\\t\\t\\t\\treturn $this->negotiator->charset($supported);\\n\\t\\t\\tcase 'encoding':\\n\\t\\t\\t\\treturn $this->negotiator->encoding($supported);\\n\\t\\t\\tcase 'language':\\n\\t\\t\\t\\treturn $this->negotiator->language($supported);\\n\\t\\t}\\n\\n\\t\\tthrow HTTPException::forInvalidNegotiationType($type);\\n\\t}\", \"output\": \"Provides a convenient way to work with the Negotiate class\\nfor content negotiation.\\n\\n@param string  $type\\n@param array   $supported\\n@param boolean $strictMatch\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function parseRequestURI(): string\\n\\t{\\n\\t\\tif (! isset($_SERVER['REQUEST_URI'], $_SERVER['SCRIPT_NAME']))\\n\\t\\t{\\n\\t\\t\\treturn '';\\n\\t\\t}\\n\\n\\t\\t// parse_url() returns false if no host is present, but the path or query string\\n\\t\\t// contains a colon followed by a number\\n\\t\\t$parts = parse_url('http://dummy' . $_SERVER['REQUEST_URI']);\\n\\t\\t$query = $parts['query'] ?? '';\\n\\t\\t$uri   = $parts['path'] ?? '';\\n\\n\\t\\tif (isset($_SERVER['SCRIPT_NAME'][0]))\\n\\t\\t{\\n\\t\\t\\t// strip the script name from the beginning of the URI\\n\\t\\t\\tif (strpos($uri, $_SERVER['SCRIPT_NAME']) === 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$uri = (string) substr($uri, strlen($_SERVER['SCRIPT_NAME']));\\n\\t\\t\\t}\\n\\t\\t\\t// if the script is nested, strip the parent folder & script from the URI\\n\\t\\t\\telseif (strpos($uri, $_SERVER['SCRIPT_NAME']) > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$uri = (string) substr($uri, strpos($uri, $_SERVER['SCRIPT_NAME']) + strlen($_SERVER['SCRIPT_NAME']));\\n\\t\\t\\t}\\n\\t\\t\\t// or if index.php is implied\\n\\t\\t\\telseif (strpos($uri, dirname($_SERVER['SCRIPT_NAME'])) === 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$uri = (string) substr($uri, strlen(dirname($_SERVER['SCRIPT_NAME'])));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// This section ensures that even on servers that require the URI to contain the query string (Nginx) a correct\\n\\t\\t// URI is found, and also fixes the QUERY_STRING getServer var and $_GET array.\\n\\t\\tif (trim($uri, '/') === '' && strncmp($query, '/', 1) === 0)\\n\\t\\t{\\n\\t\\t\\t$query                   = explode('?', $query, 2);\\n\\t\\t\\t$uri                     = $query[0];\\n\\t\\t\\t$_SERVER['QUERY_STRING'] = $query[1] ?? '';\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t$_SERVER['QUERY_STRING'] = $query;\\n\\t\\t}\\n\\n\\t\\tparse_str($_SERVER['QUERY_STRING'], $_GET);\\n\\n\\t\\tif ($uri === '/' || $uri === '')\\n\\t\\t{\\n\\t\\t\\treturn '/';\\n\\t\\t}\\n\\n\\t\\treturn $this->removeRelativeDirectory($uri);\\n\\t}\", \"output\": \"Will parse the REQUEST_URI and automatically detect the URI from it,\\nfixing the query string if necessary.\\n\\n@return string The URI it found.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function buildDSN()\\n\\t{\\n\\t\\t$this->DSN === '' || $this->DSN = '';\\n\\n\\t\\t// If UNIX sockets are used, we shouldn't set a port\\n\\t\\tif (strpos($this->hostname, '/') !== false)\\n\\t\\t{\\n\\t\\t\\t$this->port = '';\\n\\t\\t}\\n\\n\\t\\t$this->hostname === '' || $this->DSN = \\\"host={$this->hostname} \\\";\\n\\n\\t\\tif (! empty($this->port) && ctype_digit($this->port))\\n\\t\\t{\\n\\t\\t\\t$this->DSN .= \\\"port={$this->port} \\\";\\n\\t\\t}\\n\\n\\t\\tif ($this->username !== '')\\n\\t\\t{\\n\\t\\t\\t$this->DSN .= \\\"user={$this->username} \\\";\\n\\n\\t\\t\\t// An empty password is valid!\\n\\t\\t\\t// password must be set to null to ignore it.\\n\\n\\t\\t\\t$this->password === null || $this->DSN .= \\\"password='{$this->password}' \\\";\\n\\t\\t}\\n\\n\\t\\t$this->database === '' || $this->DSN .= \\\"dbname={$this->database} \\\";\\n\\n\\t\\t// We don't have these options as elements in our standard configuration\\n\\t\\t// array, but they might be set by parse_url() if the configuration was\\n\\t\\t// provided via string> Example:\\n\\t\\t//\\n\\t\\t// postgre://username:password@localhost:5432/database?connect_timeout=5&sslmode=1\\n\\t\\tforeach (['connect_timeout', 'options', 'sslmode', 'service'] as $key)\\n\\t\\t{\\n\\t\\t\\tif (isset($this->{$key}) && is_string($this->{$key}) && $this->{$key} !== '')\\n\\t\\t\\t{\\n\\t\\t\\t\\t$this->DSN .= \\\"{$key}='{$this->{$key}}' \\\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t$this->DSN = rtrim($this->DSN);\\n\\t}\", \"output\": \"Build a DSN from the provided parameters\\n\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getFormatter(string $mime)\\n\\t{\\n\\t\\tif (! array_key_exists($mime, $this->formatters))\\n\\t\\t{\\n\\t\\t\\tthrow new \\\\InvalidArgumentException('No Formatter defined for mime type: ' . $mime);\\n\\t\\t}\\n\\n\\t\\t$class = $this->formatters[$mime];\\n\\n\\t\\tif (! class_exists($class))\\n\\t\\t{\\n\\t\\t\\tthrow new \\\\BadMethodCallException($class . ' is not a valid Formatter.');\\n\\t\\t}\\n\\n\\t\\treturn new $class();\\n\\t}\", \"output\": \"A Factory method to return the appropriate formatter for the given mime type.\\n\\n@param string $mime\\n\\n@return \\\\CodeIgniter\\\\Format\\\\FormatterInterface\"}"}
{"text": "{\"input\": \"Summarize the following code: public function before(RequestInterface $request)\\n\\t{\\n\\t\\t$honeypot = Services::honeypot(new \\\\Config\\\\Honeypot());\\n\\t\\tif ($honeypot->hasContent($request))\\n\\t\\t{\\n\\t\\t\\tthrow HoneypotException::isBot();\\n\\t\\t}\\n\\t}\", \"output\": \"Checks if Honeypot field is empty; if not\\nthen the requester is a bot\\n\\n@param \\\\CodeIgniter\\\\HTTP\\\\RequestInterface $request\\n\\n@return void\\n\\n@throws \\\\CodeIgniter\\\\Honeypot\\\\Exceptions\\\\HoneypotException\"}"}
{"text": "{\"input\": \"Summarize the following code: public function after(RequestInterface $request, ResponseInterface $response)\\n\\t{\\n\\t\\t$honeypot = Services::honeypot(new \\\\Config\\\\Honeypot());\\n\\t\\t$honeypot->attachHoneypot($response);\\n\\t}\", \"output\": \"Attach a honeypot to the current response.\\n\\n@param  \\\\CodeIgniter\\\\HTTP\\\\RequestInterface  $request\\n@param  \\\\CodeIgniter\\\\HTTP\\\\ResponseInterface $response\\n\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: public function _resize(bool $maintainRatio = false)\\n\\t{\\n\\t\\t$source      = ! empty($this->resource) ? $this->resource : $this->image->getPathname();\\n\\t\\t$destination = $this->getResourcePath();\\n\\n\\t\\t$escape = '\\\\\\\\';\\n\\t\\tif (stripos(PHP_OS, 'WIN') === 0)\\n\\t\\t{\\n\\t\\t\\t$escape = '';\\n\\t\\t}\\n\\n\\t\\t$action = $maintainRatio === true ? ' -resize ' . $this->width . 'x' . $this->height . ' \\\"' . $source . '\\\" \\\"' . $destination . '\\\"' : ' -resize ' . $this->width . 'x' . $this->height . \\\"{$escape}! \\\\\\\"\\\" . $source . '\\\" \\\"' . $destination . '\\\"';\\n\\n\\t\\t$this->process($action);\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Handles the actual resizing of the image.\\n\\n@param boolean $maintainRatio\\n\\n@return ImageMagickHandler\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public function _crop()\\n\\t{\\n\\t\\t$source      = ! empty($this->resource) ? $this->resource : $this->image->getPathname();\\n\\t\\t$destination = $this->getResourcePath();\\n\\n\\t\\t$action = ' -crop ' . $this->width . 'x' . $this->height . '+' . $this->xAxis . '+' . $this->yAxis . ' \\\"' . $source . '\\\" \\\"' . $destination . '\\\"';\\n\\n\\t\\t$this->process($action);\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Crops the image.\\n\\n@return boolean|\\\\CodeIgniter\\\\Images\\\\Handlers\\\\ImageMagickHandler\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getVersion(): string\\n\\t{\\n\\t\\t$result = $this->process('-version');\\n\\n\\t\\t// The first line has the version in it...\\n\\t\\tpreg_match('/(ImageMagick\\\\s[\\\\S]+)/', $result[0], $matches);\\n\\n\\t\\treturn str_replace('ImageMagick ', '', $matches[0]);\\n\\t}\", \"output\": \"Get GD version\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function getResourcePath()\\n\\t{\\n\\t\\tif (! is_null($this->resource))\\n\\t\\t{\\n\\t\\t\\treturn $this->resource;\\n\\t\\t}\\n\\n\\t\\t$this->resource = WRITEPATH . 'cache/' . time() . '_' . bin2hex(random_bytes(10)) . '.png';\\n\\n\\t\\treturn $this->resource;\\n\\t}\", \"output\": \"Get Image Resource\\n\\nThis simply creates an image resource handle\\nbased on the type of image being processed.\\nSince ImageMagick is used on the cli, we need to\\nensure we have a temporary file on the server\\nthat we can use.\\n\\nTo ensure we can use all features, like transparency,\\nduring the process, we'll use a PNG as the temp file type.\\n\\n@return resource|boolean\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public function addForeignKey(string $fieldName = '', string $tableName = '', string $tableField = '', string $onUpdate = '', string $onDelete = '')\\n\\t{\\n\\t\\tif (! isset($this->fields[$fieldName]))\\n\\t\\t{\\n\\t\\t\\tthrow new DatabaseException(lang('Database.fieldNotExists', [$fieldName]));\\n\\t\\t}\\n\\n\\t\\t$this->foreignKeys[$fieldName] = [\\n\\t\\t\\t'table'    => $tableName,\\n\\t\\t\\t'field'    => $tableField,\\n\\t\\t\\t'onDelete' => strtoupper($onDelete),\\n\\t\\t\\t'onUpdate' => strtoupper($onUpdate),\\n\\t\\t];\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Add Foreign Key\\n\\n@param string  $fieldName\\n@param string  $tableName\\n@param string  $tableField\\n@param string  $onUpdate\\n@param string  $onDelete\\n\\n@return \\\\CodeIgniter\\\\Database\\\\Forge\\n@throws \\\\CodeIgniter\\\\Database\\\\Exceptions\\\\DatabaseException\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function _attributeUnsigned(array &$attributes, array &$field)\\n\\t{\\n\\t\\tif (empty($attributes['UNSIGNED']) || $attributes['UNSIGNED'] !== true)\\n\\t\\t{\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Reset the attribute in order to avoid issues if we do type conversion\\n\\t\\t$attributes['UNSIGNED'] = false;\\n\\n\\t\\tif (is_array($this->unsigned))\\n\\t\\t{\\n\\t\\t\\tforeach (array_keys($this->unsigned) as $key)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (is_int($key) && strcasecmp($attributes['TYPE'], $this->unsigned[$key]) === 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$field['unsigned'] = ' UNSIGNED';\\n\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telseif (is_string($key) && strcasecmp($attributes['TYPE'], $key) === 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$field['type'] = $key;\\n\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t$field['unsigned'] = ($this->unsigned === true) ? ' UNSIGNED' : '';\\n\\t}\", \"output\": \"Field attribute UNSIGNED\\n\\nDepending on the unsigned property value:\\n\\n- TRUE will always set $field['unsigned'] to 'UNSIGNED'\\n- FALSE will always set $field['unsigned'] to ''\\n- array(TYPE) will set $field['unsigned'] to 'UNSIGNED',\\nif $attributes['TYPE'] is found in the array\\n- array(TYPE => UTYPE) will change $field['type'],\\nfrom TYPE to UTYPE in case of a match\\n\\n@param array &$attributes\\n@param array &$field\\n\\n@return null|void\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function _attributeDefault(array &$attributes, array &$field)\\n\\t{\\n\\t\\tif ($this->default === false)\\n\\t\\t{\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (array_key_exists('DEFAULT', $attributes))\\n\\t\\t{\\n\\t\\t\\tif ($attributes['DEFAULT'] === null)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$field['default'] = empty($this->null) ? '' : $this->default . $this->null;\\n\\n\\t\\t\\t\\t// Override the NULL attribute if that's our default\\n\\t\\t\\t\\t$attributes['NULL'] = true;\\n\\t\\t\\t\\t$field['null']      = empty($this->null) ? '' : ' ' . $this->null;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t$field['default'] = $this->default . $this->db->escape($attributes['DEFAULT']);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\", \"output\": \"Field attribute DEFAULT\\n\\n@param array &$attributes\\n@param array &$field\\n\\n@return null|void\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function _processPrimaryKeys(string $table): string\\n\\t{\\n\\t\\t$sql = '';\\n\\n\\t\\tfor ($i = 0, $c = count($this->primaryKeys); $i < $c; $i++)\\n\\t\\t{\\n\\t\\t\\tif (! isset($this->fields[$this->primaryKeys[$i]]))\\n\\t\\t\\t{\\n\\t\\t\\t\\tunset($this->primaryKeys[$i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (count($this->primaryKeys) > 0)\\n\\t\\t{\\n\\t\\t\\t$sql .= \\\",\\\\n\\\\tCONSTRAINT \\\" . $this->db->escapeIdentifiers('pk_' . $table)\\n\\t\\t\\t\\t\\t. ' PRIMARY KEY(' . implode(', ', $this->db->escapeIdentifiers($this->primaryKeys)) . ')';\\n\\t\\t}\\n\\n\\t\\treturn $sql;\\n\\t}\", \"output\": \"Process primary keys\\n\\n@param string $table Table name\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setLocale(string $locale = null)\\n\\t{\\n\\t\\tif (! is_null($locale))\\n\\t\\t{\\n\\t\\t\\t$this->locale = $locale;\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Sets the current locale to use when performing string lookups.\\n\\n@param string $locale\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getLine(string $line, array $args = [])\\n\\t{\\n\\t\\t// ignore requests with no file specified\\n\\t\\tif (! strpos($line, '.'))\\n\\t\\t{\\n\\t\\t\\treturn $line;\\n\\t\\t}\\n\\n\\t\\t// Parse out the file name and the actual alias.\\n\\t\\t// Will load the language file and strings.\\n\\t\\t[\\n\\t\\t\\t$file,\\n\\t\\t\\t$parsedLine,\\n\\t\\t] = $this->parseLine($line, $this->locale);\\n\\n\\t\\t$output = $this->language[$this->locale][$file][$parsedLine] ?? null;\\n\\n\\t\\tif ($output === null && strpos($this->locale, '-'))\\n\\t\\t{\\n\\t\\t\\t[$locale] = explode('-', $this->locale, 2);\\n\\n\\t\\t\\t[\\n\\t\\t\\t\\t$file,\\n\\t\\t\\t\\t$parsedLine,\\n\\t\\t\\t] = $this->parseLine($line, $locale);\\n\\n\\t\\t\\t$output = $this->language[$locale][$file][$parsedLine] ?? null;\\n\\t\\t}\\n\\n\\t\\t// if still not found, try English\\n\\t\\tif (empty($output))\\n\\t\\t{\\n\\t\\t\\t$this->parseLine($line, 'en');\\n\\t\\t\\t$output = $this->language['en'][$file][$parsedLine] ?? null;\\n\\t\\t}\\n\\n\\t\\t$output = $output ?? $line;\\n\\n\\t\\tif (! empty($args))\\n\\t\\t{\\n\\t\\t\\t$output = $this->formatMessage($output, $args);\\n\\t\\t}\\n\\n\\t\\treturn $output;\\n\\t}\", \"output\": \"Parses the language string for a file, loads the file, if necessary,\\ngetting the line.\\n\\n@param string $line Line.\\n@param array  $args Arguments.\\n\\n@return string|string[] Returns line.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function formatMessage($message, array $args = [])\\n\\t{\\n\\t\\tif (! $this->intlSupport || ! $args)\\n\\t\\t{\\n\\t\\t\\treturn $message;\\n\\t\\t}\\n\\n\\t\\tif (is_array($message))\\n\\t\\t{\\n\\t\\t\\tforeach ($message as $index => $value)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$message[$index] = $this->formatMessage($value, $args);\\n\\t\\t\\t}\\n\\t\\t\\treturn $message;\\n\\t\\t}\\n\\n\\t\\treturn \\\\MessageFormatter::formatMessage($this->locale, $message, $args);\\n\\t}\", \"output\": \"Advanced message formatting.\\n\\n@param string|array $message Message.\\n@param array\\t       $args    Arguments.\\n\\n@return string|array Returns formatted message.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function requireFile(string $path): array\\n\\t{\\n\\t\\t$files   = Services::locator()->search($path);\\n\\t\\t$strings = [];\\n\\n\\t\\tforeach ($files as $file)\\n\\t\\t{\\n\\t\\t\\t// On some OS's we were seeing failures\\n\\t\\t\\t// on this command returning boolean instead\\n\\t\\t\\t// of array during testing, so we've removed\\n\\t\\t\\t// the require_once for now.\\n\\t\\t\\tif (is_file($file))\\n\\t\\t\\t{\\n\\t\\t\\t\\t$strings[] = require $file;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (isset($strings[1]))\\n\\t\\t{\\n\\t\\t\\t$strings = array_replace_recursive(...$strings);\\n\\t\\t}\\n\\t\\telseif (isset($strings[0]))\\n\\t\\t{\\n\\t\\t\\t$strings = $strings[0];\\n\\t\\t}\\n\\n\\t\\treturn $strings;\\n\\t}\", \"output\": \"A simple method for including files that can be\\noverridden during testing.\\n\\n@param string $path\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: public function addBaseURI($uri, ?bool $explicitReporting = null)\\n\\t{\\n\\t\\t$this->addOption($uri, 'baseURI', $explicitReporting ?? $this->reportOnly);\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Adds a new base_uri value. Can be either a URI class or a simple string.\\n\\nbase_uri restricts the URLs that can appear in a page\\u2019s <base> element.\\n\\n@see http://www.w3.org/TR/CSP/#directive-base-uri\\n\\n@param string|array $uri\\n@param boolean|null $explicitReporting\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: public function addImageSrc($uri, ?bool $explicitReporting = null)\\n\\t{\\n\\t\\t$this->addOption($uri, 'imageSrc', $explicitReporting ?? $this->reportOnly);\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Adds a new valid endpoint for valid image sources. Can be either\\na URI class or a simple string.\\n\\n@see http://www.w3.org/TR/CSP/#directive-img-src\\n\\n@param string|array $uri\\n@param boolean|null $explicitReporting\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: public function addMediaSrc($uri, ?bool $explicitReporting = null)\\n\\t{\\n\\t\\t$this->addOption($uri, 'mediaSrc', $explicitReporting ?? $this->reportOnly);\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Adds a new valid endpoint for valid video and audio. Can be either\\na URI class or a simple string.\\n\\n@see http://www.w3.org/TR/CSP/#directive-media-src\\n\\n@param string|array $uri\\n@param boolean|null $explicitReporting\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: public function addManifestSrc($uri, ?bool $explicitReporting = null)\\n\\t{\\n\\t\\t$this->addOption($uri, 'manifestSrc', $explicitReporting ?? $this->reportOnly);\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Adds a new valid endpoint for manifest sources. Can be either\\na URI class or simple string.\\n\\n@see https://www.w3.org/TR/CSP/#directive-manifest-src\\n\\n@param string|array $uri\\n@param boolean|null $explicitReporting\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: public function addObjectSrc($uri, ?bool $explicitReporting = null)\\n\\t{\\n\\t\\t$this->addOption($uri, 'objectSrc', $explicitReporting ?? $this->reportOnly);\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Adds a new valid endpoint for Flash and other plugin sources. Can be either\\na URI class or a simple string.\\n\\n@see http://www.w3.org/TR/CSP/#directive-object-src\\n\\n@param string|array $uri\\n@param boolean|null $explicitReporting\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: public function addPluginType($mime, ?bool $explicitReporting = null)\\n\\t{\\n\\t\\t$this->addOption($mime, 'pluginTypes', $explicitReporting ?? $this->reportOnly);\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Limits the types of plugins that can be used. Can be either\\na URI class or a simple string.\\n\\n@see http://www.w3.org/TR/CSP/#directive-plugin-types\\n\\n@param string|array $mime              One or more plugin mime types, separate by spaces\\n@param boolean|null $explicitReporting\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: public function addSandbox($flags, ?bool $explicitReporting = null)\\n\\t{\\n\\t\\t$this->addOption($flags, 'sandbox', $explicitReporting ?? $this->reportOnly);\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"specifies an HTML sandbox policy that the user agent applies to\\nthe protected resource.\\n\\n@see http://www.w3.org/TR/CSP/#directive-sandbox\\n\\n@param string|array $flags             An array of sandbox flags that can be added to the directive.\\n@param boolean|null $explicitReporting\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: public function addScriptSrc($uri, ?bool $explicitReporting = null)\\n\\t{\\n\\t\\t$this->addOption($uri, 'scriptSrc', $explicitReporting ?? $this->reportOnly);\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Adds a new valid endpoint for javascript file sources. Can be either\\na URI class or a simple string.\\n\\n@see http://www.w3.org/TR/CSP/#directive-connect-src\\n\\n@param string|array $uri\\n@param boolean|null $explicitReporting\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: public function addStyleSrc($uri, ?bool $explicitReporting = null)\\n\\t{\\n\\t\\t$this->addOption($uri, 'styleSrc', $explicitReporting ?? $this->reportOnly);\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Adds a new valid endpoint for CSS file sources. Can be either\\na URI class or a simple string.\\n\\n@see http://www.w3.org/TR/CSP/#directive-connect-src\\n\\n@param string|array $uri\\n@param boolean|null $explicitReporting\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function addOption($options, string $target, ?bool $explicitReporting = null)\\n\\t{\\n\\t\\t// Ensure we have an array to work with...\\n\\t\\tif (is_string($this->{$target}))\\n\\t\\t{\\n\\t\\t\\t$this->{$target} = [$this->{$target}];\\n\\t\\t}\\n\\n\\t\\tif (is_array($options))\\n\\t\\t{\\n\\t\\t\\tforeach ($options as $opt)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$this->{$target}[$opt] = $explicitReporting ?? $this->reportOnly;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t$this->{$target}[$options] = $explicitReporting ?? $this->reportOnly;\\n\\t\\t}\\n\\t}\", \"output\": \"DRY method to add an string or array to a class property.\\n\\n@param string|array $options\\n@param string       $target\\n@param boolean|null $explicitReporting\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function generateNonces(ResponseInterface &$response)\\n\\t{\\n\\t\\t$body = $response->getBody();\\n\\n\\t\\tif (empty($body))\\n\\t\\t{\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (! is_array($this->styleSrc))\\n\\t\\t{\\n\\t\\t\\t$this->styleSrc = [$this->styleSrc];\\n\\t\\t}\\n\\t\\tif (! is_array($this->scriptSrc))\\n\\t\\t{\\n\\t\\t\\t$this->scriptSrc = [$this->scriptSrc];\\n\\t\\t}\\n\\n\\t\\t// Replace style placeholders with nonces\\n\\t\\t$body = preg_replace_callback(\\n\\t\\t\\t\\t'/{csp-style-nonce}/', function ($matches) {\\n\\t\\t\\t\\t\\t$nonce = bin2hex(random_bytes(12));\\n\\n\\t\\t\\t\\t\\t$this->styleSrc[] = 'nonce-' . $nonce;\\n\\n\\t\\t\\t\\t\\treturn \\\"nonce=\\\\\\\"{$nonce}\\\\\\\"\\\";\\n\\t\\t\\t\\t}, $body\\n\\t\\t);\\n\\n\\t\\t// Replace script placeholders with nonces\\n\\t\\t$body = preg_replace_callback(\\n\\t\\t\\t\\t'/{csp-script-nonce}/', function ($matches) {\\n\\t\\t\\t\\t\\t$nonce = bin2hex(random_bytes(12));\\n\\n\\t\\t\\t\\t\\t$this->scriptSrc[] = 'nonce-' . $nonce;\\n\\n\\t\\t\\t\\t\\treturn \\\"nonce=\\\\\\\"{$nonce}\\\\\\\"\\\";\\n\\t\\t\\t\\t}, $body\\n\\t\\t);\\n\\n\\t\\t$response->setBody($body);\\n\\t}\", \"output\": \"Scans the body of the request message and replaces any nonce\\nplaceholders with actual nonces, that we'll then add to our\\nheaders.\\n\\n@param ResponseInterface|\\\\CodeIgniter\\\\HTTP\\\\Response $response\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getTitle(bool $safe = false): string\\n\\t{\\n\\t\\tif ($safe)\\n\\t\\t{\\n\\t\\t\\treturn str_replace(' ', '-', strtolower($this->title));\\n\\t\\t}\\n\\n\\t\\treturn $this->title;\\n\\t}\", \"output\": \"Gets the Collector's title.\\n\\n@param  boolean $safe\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function collectLogs()\\n\\t{\\n\\t\\tif (! is_null($this->data))\\n\\t\\t{\\n\\t\\t\\treturn $this->data;\\n\\t\\t}\\n\\n\\t\\treturn $this->data = Services::logger(true)->logCache ?? [];\\n\\t}\", \"output\": \"Ensures the data has been collected.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function prepareParams($params)\\n\\t{\\n\\t\\tif (empty($params) || ( ! is_string($params) && ! is_array($params)))\\n\\t\\t{\\n\\t\\t\\treturn [];\\n\\t\\t}\\n\\n\\t\\tif (is_string($params))\\n\\t\\t{\\n\\t\\t\\t$new_params = [];\\n\\t\\t\\t$separator  = ' ';\\n\\n\\t\\t\\tif (strpos($params, ',') !== false)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$separator = ',';\\n\\t\\t\\t}\\n\\n\\t\\t\\t$params = explode($separator, $params);\\n\\t\\t\\tunset($separator);\\n\\n\\t\\t\\tforeach ($params as $p)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (! empty($p))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlist($key, $val)        = explode('=', $p);\\n\\t\\t\\t\\t\\t$new_params[trim($key)] = trim($val, ', ');\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t$params = $new_params;\\n\\n\\t\\t\\tunset($new_params);\\n\\t\\t}\\n\\n\\t\\tif (is_array($params) && empty($params))\\n\\t\\t{\\n\\t\\t\\treturn [];\\n\\t\\t}\\n\\n\\t\\treturn $params;\\n\\t}\", \"output\": \"Parses the params attribute. If an array, returns untouched.\\nIf a string, it should be in the format \\\"key1=value key2=value\\\".\\nIt will be split and returned as an array.\\n\\n@param $params\\n\\n@return array|null\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function determineClass(string $library): array\\n\\t{\\n\\t\\t// We don't want to actually call static methods\\n\\t\\t// by default, so convert any double colons.\\n\\t\\t$library = str_replace('::', ':', $library);\\n\\n\\t\\tlist($class, $method) = explode(':', $library);\\n\\n\\t\\tif (empty($class))\\n\\t\\t{\\n\\t\\t\\tthrow ViewException::forNoCellClass();\\n\\t\\t}\\n\\n\\t\\tif (! class_exists($class, true))\\n\\t\\t{\\n\\t\\t\\tthrow ViewException::forInvalidCellClass($class);\\n\\t\\t}\\n\\n\\t\\tif (empty($method))\\n\\t\\t{\\n\\t\\t\\t$method = 'index';\\n\\t\\t}\\n\\n\\t\\treturn [\\n\\t\\t\\t$class,\\n\\t\\t\\t$method,\\n\\t\\t];\\n\\t}\", \"output\": \"Given the library string, attempts to determine the class and method\\nto call.\\n\\n@param string $library\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getResult(string $type = 'object'): array\\n\\t{\\n\\t\\tif ($type === 'array')\\n\\t\\t{\\n\\t\\t\\treturn $this->getResultArray();\\n\\t\\t}\\n\\t\\telseif ($type === 'object')\\n\\t\\t{\\n\\t\\t\\treturn $this->getResultObject();\\n\\t\\t}\\n\\n\\t\\treturn $this->getCustomResultObject($type);\\n\\t}\", \"output\": \"Retrieve the results of the query. Typically an array of\\nindividual data rows, which can be either an 'array', an\\n'object', or a custom class name.\\n\\n@param string $type The row type. Either 'array', 'object', or a class name to use\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getCustomResultObject(string $className)\\n\\t{\\n\\t\\tif (isset($this->customResultObject[$className]))\\n\\t\\t{\\n\\t\\t\\treturn $this->customResultObject[$className];\\n\\t\\t}\\n\\n\\t\\tif (is_bool($this->resultID) || ! $this->resultID || $this->numRows === 0)\\n\\t\\t{\\n\\t\\t\\treturn [];\\n\\t\\t}\\n\\n\\t\\t// Don't fetch the result set again if we already have it\\n\\t\\t$_data = null;\\n\\t\\tif (($c = count($this->resultArray)) > 0)\\n\\t\\t{\\n\\t\\t\\t$_data = 'result_array';\\n\\t\\t}\\n\\t\\telseif (($c = count($this->resultObject)) > 0)\\n\\t\\t{\\n\\t\\t\\t$_data = 'result_object';\\n\\t\\t}\\n\\n\\t\\tif ($_data !== null)\\n\\t\\t{\\n\\t\\t\\tfor ($i = 0; $i < $c; $i ++)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$this->customResultObject[$className][$i] = new $className();\\n\\n\\t\\t\\t\\tforeach ($this->{$_data}[$i] as $key => $value)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$this->customResultObject[$className][$i]->$key = $value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn $this->customResultObject[$className];\\n\\t\\t}\\n\\n\\t\\tis_null($this->rowData) || $this->dataSeek(0);\\n\\t\\t$this->customResultObject[$className] = [];\\n\\n\\t\\twhile ($row = $this->fetchObject($className))\\n\\t\\t{\\n\\t\\t\\t$this->customResultObject[$className][] = $row;\\n\\t\\t}\\n\\n\\t\\treturn $this->customResultObject[$className];\\n\\t}\", \"output\": \"Returns the results as an array of custom objects.\\n\\n@param string $className The name of the class to use.\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getResultObject(): array\\n\\t{\\n\\t\\tif (! empty($this->resultObject))\\n\\t\\t{\\n\\t\\t\\treturn $this->resultObject;\\n\\t\\t}\\n\\n\\t\\t// In the event that query caching is on, the result_id variable\\n\\t\\t// will not be a valid resource so we'll simply return an empty\\n\\t\\t// array.\\n\\t\\tif (is_bool($this->resultID) || ! $this->resultID || $this->numRows === 0)\\n\\t\\t{\\n\\t\\t\\treturn [];\\n\\t\\t}\\n\\n\\t\\tif ($this->resultArray)\\n\\t\\t{\\n\\t\\t\\tforeach ($this->resultArray as $row)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$this->resultObject[] = (object) $row;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn $this->resultObject;\\n\\t\\t}\\n\\n\\t\\tis_null($this->rowData) || $this->dataSeek(0);\\n\\t\\twhile ($row = $this->fetchObject())\\n\\t\\t{\\n\\t\\t\\t$this->resultObject[] = $row;\\n\\t\\t}\\n\\n\\t\\treturn $this->resultObject;\\n\\t}\", \"output\": \"Returns the results as an array of objects.\\n\\nIf no results, an empty array is returned.\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getRow($n = 0, string $type = 'object')\\n\\t{\\n\\t\\tif (! is_numeric($n))\\n\\t\\t{\\n\\t\\t\\t// We cache the row data for subsequent uses\\n\\t\\t\\tis_array($this->rowData) || $this->rowData = $this->getRowArray(0);\\n\\n\\t\\t\\t// array_key_exists() instead of isset() to allow for NULL values\\n\\t\\t\\tif (empty($this->rowData) || ! array_key_exists($n, $this->rowData))\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn $this->rowData[$n];\\n\\t\\t}\\n\\n\\t\\tif ($type === 'object')\\n\\t\\t{\\n\\t\\t\\treturn $this->getRowObject($n);\\n\\t\\t}\\n\\t\\telseif ($type === 'array')\\n\\t\\t{\\n\\t\\t\\treturn $this->getRowArray($n);\\n\\t\\t}\\n\\n\\t\\treturn $this->getCustomRowObject($n, $type);\\n\\t}\", \"output\": \"Wrapper object to return a row as either an array, an object, or\\na custom class.\\n\\nIf row doesn't exist, returns null.\\n\\n@param mixed   $n    The index of the results to return\\n@param string  $type The type of result object. 'array', 'object' or class name.\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getCustomRowObject(int $n, string $className)\\n\\t{\\n\\t\\tisset($this->customResultObject[$className]) || $this->getCustomResultObject($className);\\n\\n\\t\\tif (empty($this->customResultObject[$className]))\\n\\t\\t{\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\tif ($n !== $this->currentRow && isset($this->customResultObject[$className][$n]))\\n\\t\\t{\\n\\t\\t\\t$this->currentRow = $n;\\n\\t\\t}\\n\\n\\t\\treturn $this->customResultObject[$className][$this->currentRow];\\n\\t}\", \"output\": \"Returns a row as a custom class instance.\\n\\nIf row doesn't exists, returns null.\\n\\n@param integer $n\\n@param string  $className\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getRowArray(int $n = 0)\\n\\t{\\n\\t\\t$result = $this->getResultArray();\\n\\t\\tif (empty($result))\\n\\t\\t{\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\tif ($n !== $this->currentRow && isset($result[$n]))\\n\\t\\t{\\n\\t\\t\\t$this->currentRow = $n;\\n\\t\\t}\\n\\n\\t\\treturn $result[$this->currentRow];\\n\\t}\", \"output\": \"Returns a single row from the results as an array.\\n\\nIf row doesn't exist, returns null.\\n\\n@param integer $n\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getRowObject(int $n = 0)\\n\\t{\\n\\t\\t$result = $this->getResultObject();\\n\\t\\tif (empty($result))\\n\\t\\t{\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\tif ($n !== $this->customResultObject && isset($result[$n]))\\n\\t\\t{\\n\\t\\t\\t$this->currentRow = $n;\\n\\t\\t}\\n\\n\\t\\treturn $result[$this->currentRow];\\n\\t}\", \"output\": \"Returns a single row from the results as an object.\\n\\nIf row doesn't exist, returns null.\\n\\n@param integer $n\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setRow($key, $value = null)\\n\\t{\\n\\t\\t// We cache the row data for subsequent uses\\n\\t\\tif (! is_array($this->rowData))\\n\\t\\t{\\n\\t\\t\\t$this->rowData = $this->getRowArray(0);\\n\\t\\t}\\n\\n\\t\\tif (is_array($key))\\n\\t\\t{\\n\\t\\t\\tforeach ($key as $k => $v)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$this->rowData[$k] = $v;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ($key !== '' && $value !== null)\\n\\t\\t{\\n\\t\\t\\t$this->rowData[$key] = $value;\\n\\t\\t}\\n\\t}\", \"output\": \"Assigns an item into a particular column slot.\\n\\n@param mixed $key\\n@param mixed $value\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getFirstRow(string $type = 'object')\\n\\t{\\n\\t\\t$result = $this->getResult($type);\\n\\n\\t\\treturn (empty($result)) ? null : $result[0];\\n\\t}\", \"output\": \"Returns the \\\"first\\\" row of the current results.\\n\\n@param string $type\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getLastRow(string $type = 'object')\\n\\t{\\n\\t\\t$result = $this->getResult($type);\\n\\n\\t\\treturn (empty($result)) ? null : $result[count($result) - 1];\\n\\t}\", \"output\": \"Returns the \\\"last\\\" row of the current results.\\n\\n@param string $type\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getNextRow(string $type = 'object')\\n\\t{\\n\\t\\t$result = $this->getResult($type);\\n\\t\\tif (empty($result))\\n\\t\\t{\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\treturn isset($result[$this->currentRow + 1]) ? $result[++ $this->currentRow] : null;\\n\\t}\", \"output\": \"Returns the \\\"next\\\" row of the current results.\\n\\n@param string $type\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getUnbufferedRow(string $type = 'object')\\n\\t{\\n\\t\\tif ($type === 'array')\\n\\t\\t{\\n\\t\\t\\treturn $this->fetchAssoc();\\n\\t\\t}\\n\\t\\telseif ($type === 'object')\\n\\t\\t{\\n\\t\\t\\treturn $this->fetchObject();\\n\\t\\t}\\n\\n\\t\\treturn $this->fetchObject($type);\\n\\t}\", \"output\": \"Returns an unbuffered row and move the pointer to the next row.\\n\\n@param string $type\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function match(array $acceptable, string $supported, bool $enforceTypes = false): bool\\n\\t{\\n\\t\\t$supported = $this->parseHeader($supported);\\n\\t\\tif (is_array($supported) && count($supported) === 1)\\n\\t\\t{\\n\\t\\t\\t$supported = $supported[0];\\n\\t\\t}\\n\\n\\t\\t// Is it an exact match?\\n\\t\\tif ($acceptable['value'] === $supported['value'])\\n\\t\\t{\\n\\t\\t\\treturn $this->matchParameters($acceptable, $supported);\\n\\t\\t}\\n\\n\\t\\t// Do we need to compare types/sub-types? Only used\\n\\t\\t// by negotiateMedia().\\n\\t\\tif ($enforceTypes)\\n\\t\\t{\\n\\t\\t\\treturn $this->matchTypes($acceptable, $supported);\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\", \"output\": \"Match-maker\\n\\n@param  array   $acceptable\\n@param  string  $supported\\n@param  boolean $enforceTypes\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function matchParameters(array $acceptable, array $supported): bool\\n\\t{\\n\\t\\tif (count($acceptable['params']) !== count($supported['params']))\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tforeach ($supported['params'] as $label => $value)\\n\\t\\t{\\n\\t\\t\\tif (! isset($acceptable['params'][$label]) ||\\n\\t\\t\\t\\t\\t$acceptable['params'][$label] !== $value)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\", \"output\": \"Checks two Accept values with matching 'values' to see if their\\n'params' are the same.\\n\\n@param array $acceptable\\n@param array $supported\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: public function run(bool $useSafeOutput = false)\\n\\t{\\n\\t\\t$path = CLI::getURI() ?: 'list';\\n\\n\\t\\t// Set the path for the application to route to.\\n\\t\\t$this->app->setPath(\\\"ci{$path}\\\");\\n\\n\\t\\treturn $this->app->useSafeOutput($useSafeOutput)->run();\\n\\t}\", \"output\": \"Runs the current command discovered on the CLI.\\n\\n@param boolean $useSafeOutput\\n\\n@return \\\\CodeIgniter\\\\HTTP\\\\RequestInterface|\\\\CodeIgniter\\\\HTTP\\\\Response|\\\\CodeIgniter\\\\HTTP\\\\ResponseInterface|mixed\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public function showHeader()\\n\\t{\\n\\t\\tCLI::newLine(1);\\n\\n\\t\\tCLI::write(CLI::color('CodeIgniter CLI Tool', 'green')\\n\\t\\t\\t\\t. ' - Version ' . CodeIgniter::CI_VERSION\\n\\t\\t\\t\\t. ' - Server-Time: ' . date('Y-m-d H:i:sa'));\\n\\n\\t\\tCLI::newLine(1);\\n\\t}\", \"output\": \"Displays basic information about the Console.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function makeLinks(int $page, int $perPage, int $total, string $template = 'default_full', int $segment = 0): string\\n\\t{\\n\\t\\t$name = time();\\n\\n\\t\\t$this->store($name, $page, $perPage, $total, $segment);\\n\\n\\t\\treturn $this->displayLinks($name, $template);\\n\\t}\", \"output\": \"Allows for a simple, manual, form of pagination where all of the data\\nis provided by the user. The URL is the current URI.\\n\\n@param integer $page\\n@param integer $perPage\\n@param integer $total\\n@param string  $template The output template alias to render.\\n@param integer $segment  (if page number is provided by URI segment)\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function store(string $group, int $page, int $perPage, int $total, int $segment = 0)\\n\\t{\\n\\t\\t$this->segment[$group] = $segment;\\n\\n\\t\\t$this->ensureGroup($group);\\n\\n\\t\\t$this->groups[$group]['currentPage'] = $page;\\n\\t\\t$this->groups[$group]['perPage']     = $perPage;\\n\\t\\t$this->groups[$group]['total']       = $total;\\n\\t\\t$this->groups[$group]['pageCount']   = (int)ceil($total / $perPage);\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Stores a set of pagination data for later display. Most commonly used\\nby the model to automate the process.\\n\\n@param string  $group\\n@param integer $page\\n@param integer $perPage\\n@param integer $total\\n@param integer $segment\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setPath(string $path, string $group = 'default')\\n\\t{\\n\\t\\t$this->ensureGroup($group);\\n\\n\\t\\t$this->groups[$group]['uri']->setPath($path);\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Sets the path that an aliased group of links will use.\\n\\n@param string $group\\n@param string $path\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getPageCount(string $group = 'default'): int\\n\\t{\\n\\t\\t$this->ensureGroup($group);\\n\\n\\t\\treturn $this->groups[$group]['pageCount'];\\n\\t}\", \"output\": \"Returns the total number of pages.\\n\\n@param string|null $group\\n\\n@return integer\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getCurrentPage(string $group = 'default'): int\\n\\t{\\n\\t\\t$this->ensureGroup($group);\\n\\n\\t\\treturn $this->groups[$group]['currentPage'];\\n\\t}\", \"output\": \"Returns the number of the current page of results.\\n\\n@param string|null $group\\n\\n@return integer\"}"}
{"text": "{\"input\": \"Summarize the following code: public function hasMore(string $group = 'default'): bool\\n\\t{\\n\\t\\t$this->ensureGroup($group);\\n\\n\\t\\treturn ($this->groups[$group]['currentPage'] * $this->groups[$group]['perPage']) < $this->groups[$group]['total'];\\n\\t}\", \"output\": \"Tells whether this group of results has any more pages of results.\\n\\n@param string|null $group\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getLastPage(string $group = 'default')\\n\\t{\\n\\t\\t$this->ensureGroup($group);\\n\\n\\t\\tif (! is_numeric($this->groups[$group]['total']) || ! is_numeric($this->groups[$group]['perPage']))\\n\\t\\t{\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\treturn (int)ceil($this->groups[$group]['total'] / $this->groups[$group]['perPage']);\\n\\t}\", \"output\": \"Returns the last page, if we have a total that we can calculate with.\\n\\n@param string $group\\n\\n@return integer|null\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getPageURI(int $page = null, string $group = 'default', bool $returnObject = false)\\n\\t{\\n\\t\\t$this->ensureGroup($group);\\n\\n\\t\\t/**\\n\\t\\t * @var \\\\CodeIgniter\\\\HTTP\\\\URI $uri\\n\\t\\t */\\n\\t\\t$uri = $this->groups[$group]['uri'];\\n\\n\\t\\t$segment = $this->segment[$group] ?? 0;\\n\\n\\t\\tif ($segment)\\n\\t\\t{\\n\\t\\t\\t$uri->setSegment($segment, $page);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t$uri->addQuery('page', $page);\\n\\t\\t}\\n\\n\\t\\tif ($this->only)\\n\\t\\t{\\n\\t\\t\\t$query = array_intersect_key($_GET, array_flip($this->only));\\n\\n\\t\\t\\tif (! $segment)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$query['page'] = $page;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$uri->setQueryArray($query);\\n\\t\\t}\\n\\n\\t\\treturn $returnObject === true ? $uri : (string) $uri;\\n\\t}\", \"output\": \"Returns the URI for a specific page for the specified group.\\n\\n@param integer|null $page\\n@param string       $group\\n@param boolean      $returnObject\\n\\n@return string|\\\\CodeIgniter\\\\HTTP\\\\URI\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getNextPageURI(string $group = 'default', bool $returnObject = false)\\n\\t{\\n\\t\\t$this->ensureGroup($group);\\n\\n\\t\\t$last = $this->getLastPage($group);\\n\\t\\t$curr = $this->getCurrentPage($group);\\n\\t\\t$page = null;\\n\\n\\t\\tif (! empty($last) && ! empty($curr) && $last === $curr)\\n\\t\\t{\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\tif ($last > $curr)\\n\\t\\t{\\n\\t\\t\\t$page = $curr + 1;\\n\\t\\t}\\n\\n\\t\\treturn $this->getPageURI($page, $group, $returnObject);\\n\\t}\", \"output\": \"Returns the full URI to the next page of results, or null.\\n\\n@param string  $group\\n@param boolean $returnObject\\n\\n@return string|null\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getPreviousPageURI(string $group = 'default', bool $returnObject = false)\\n\\t{\\n\\t\\t$this->ensureGroup($group);\\n\\n\\t\\t$first = $this->getFirstPage($group);\\n\\t\\t$curr  = $this->getCurrentPage($group);\\n\\t\\t$page  = null;\\n\\n\\t\\tif (! empty($first) && ! empty($curr) && $first === $curr)\\n\\t\\t{\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\tif ($first < $curr)\\n\\t\\t{\\n\\t\\t\\t$page = $curr - 1;\\n\\t\\t}\\n\\n\\t\\treturn $this->getPageURI($page, $group, $returnObject);\\n\\t}\", \"output\": \"Returns the full URL to the previous page of results, or null.\\n\\n@param string  $group\\n@param boolean $returnObject\\n\\n@return string|null\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getPerPage(string $group = 'default'): int\\n\\t{\\n\\t\\t$this->ensureGroup($group);\\n\\n\\t\\treturn (int) $this->groups[$group]['perPage'];\\n\\t}\", \"output\": \"Returns the number of results per page that should be shown.\\n\\n@param string $group\\n\\n@return integer\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getDetails(string $group = 'default'): array\\n\\t{\\n\\t\\tif (! array_key_exists($group, $this->groups))\\n\\t\\t{\\n\\t\\t\\tthrow PagerException::forInvalidPaginationGroup($group);\\n\\t\\t}\\n\\n\\t\\t$newGroup = $this->groups[$group];\\n\\n\\t\\t$newGroup['next']     = $this->getNextPageURI($group);\\n\\t\\t$newGroup['previous'] = $this->getPreviousPageURI($group);\\n\\t\\t$newGroup['segment']  = $this->segment[$group] ?? 0;\\n\\n\\t\\treturn $newGroup;\\n\\t}\", \"output\": \"Returns an array with details about the results, including\\ntotal, per_page, current_page, last_page, next_url, prev_url, from, to.\\nDoes not include the actual data. This data is suitable for adding\\na 'data' object to with the result set and converting to JSON.\\n\\n@param string $group\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function ensureGroup(string $group)\\n\\t{\\n\\t\\tif (array_key_exists($group, $this->groups))\\n\\t\\t{\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t$this->groups[$group] = [\\n\\t\\t\\t'uri'       => clone Services::request()->uri,\\n\\t\\t\\t'hasMore'   => false,\\n\\t\\t\\t'total'     => null,\\n\\t\\t\\t'perPage'   => $this->config->perPage,\\n\\t\\t\\t'pageCount' => 1,\\n\\t\\t];\\n\\n\\t\\tif (array_key_exists($group, $this->segment))\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\t$this->groups[$group]['currentPage'] = $this->groups[$group]['uri']->getSegment($this->segment[$group]);\\n\\t\\t\\t}\\n\\t\\t\\tcatch (\\\\CodeIgniter\\\\HTTP\\\\Exceptions\\\\HTTPException $e)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$this->groups[$group]['currentPage'] = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t$this->groups[$group]['currentPage'] = $_GET['page_' . $group] ?? $_GET['page'] ?? 1;\\n\\t\\t}\\n\\n\\t\\tif ($_GET)\\n\\t\\t{\\n\\t\\t\\t$this->groups[$group]['uri'] = $this->groups[$group]['uri']->setQueryArray($_GET);\\n\\t\\t}\\n\\t}\", \"output\": \"Ensures that an array exists for the group specified.\\n\\n@param string $group\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getYears(bool $raw = false)\\n\\t{\\n\\t\\tif ($raw)\\n\\t\\t{\\n\\t\\t\\treturn $this->difference / YEAR;\\n\\t\\t}\\n\\n\\t\\t$time = clone($this->currentTime);\\n\\t\\treturn $time->fieldDifference($this->testTime, IntlCalendar::FIELD_YEAR);\\n\\t}\", \"output\": \"Returns the number of years of difference between the two.\\n\\n@param boolean $raw\\n\\n@return float|integer\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getMonths(bool $raw = false)\\n\\t{\\n\\t\\tif ($raw)\\n\\t\\t{\\n\\t\\t\\treturn $this->difference / MONTH;\\n\\t\\t}\\n\\n\\t\\t$time = clone($this->currentTime);\\n\\t\\treturn $time->fieldDifference($this->testTime, IntlCalendar::FIELD_MONTH);\\n\\t}\", \"output\": \"Returns the number of months difference between the two dates.\\n\\n@param boolean $raw\\n\\n@return float|integer\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getWeeks(bool $raw = false)\\n\\t{\\n\\t\\tif ($raw)\\n\\t\\t{\\n\\t\\t\\treturn $this->difference / WEEK;\\n\\t\\t}\\n\\n\\t\\t$time = clone($this->currentTime);\\n\\t\\treturn (int)($time->fieldDifference($this->testTime, IntlCalendar::FIELD_DAY_OF_YEAR) / 7);\\n\\t}\", \"output\": \"Returns the number of weeks difference between the two dates.\\n\\n@param boolean $raw\\n\\n@return float|integer\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getDays(bool $raw = false)\\n\\t{\\n\\t\\tif ($raw)\\n\\t\\t{\\n\\t\\t\\treturn $this->difference / DAY;\\n\\t\\t}\\n\\n\\t\\t$time = clone($this->currentTime);\\n\\t\\treturn $time->fieldDifference($this->testTime, IntlCalendar::FIELD_DAY_OF_YEAR);\\n\\t}\", \"output\": \"Returns the number of days difference between the two dates.\\n\\n@param boolean $raw\\n\\n@return float|integer\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getHours(bool $raw = false)\\n\\t{\\n\\t\\tif ($raw)\\n\\t\\t{\\n\\t\\t\\treturn $this->difference / HOUR;\\n\\t\\t}\\n\\n\\t\\t$time = clone($this->currentTime);\\n\\t\\treturn $time->fieldDifference($this->testTime, IntlCalendar::FIELD_HOUR_OF_DAY);\\n\\t}\", \"output\": \"Returns the number of hours difference between the two dates.\\n\\n@param boolean $raw\\n\\n@return float|integer\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getMinutes(bool $raw = false)\\n\\t{\\n\\t\\tif ($raw)\\n\\t\\t{\\n\\t\\t\\treturn $this->difference / MINUTE;\\n\\t\\t}\\n\\n\\t\\t$time = clone($this->currentTime);\\n\\t\\treturn $time->fieldDifference($this->testTime, IntlCalendar::FIELD_MINUTE);\\n\\t}\", \"output\": \"Returns the number of minutes difference between the two dates.\\n\\n@param boolean $raw\\n\\n@return float|integer\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getSeconds(bool $raw = false)\\n\\t{\\n\\t\\tif ($raw)\\n\\t\\t{\\n\\t\\t\\treturn $this->difference;\\n\\t\\t}\\n\\n\\t\\t$time = clone($this->currentTime);\\n\\t\\treturn $time->fieldDifference($this->testTime, IntlCalendar::FIELD_SECOND);\\n\\t}\", \"output\": \"Returns the number of seconds difference between the two dates.\\n\\n@param boolean $raw\\n\\n@return integer\"}"}
{"text": "{\"input\": \"Summarize the following code: public function humanize(string $locale = null): string\\n\\t{\\n\\t\\t$current = clone($this->currentTime);\\n\\n\\t\\t$years   = $current->fieldDifference($this->testTime, IntlCalendar::FIELD_YEAR);\\n\\t\\t$months  = $current->fieldDifference($this->testTime, IntlCalendar::FIELD_MONTH);\\n\\t\\t$days    = $current->fieldDifference($this->testTime, IntlCalendar::FIELD_DAY_OF_YEAR);\\n\\t\\t$hours   = $current->fieldDifference($this->testTime, IntlCalendar::FIELD_HOUR_OF_DAY);\\n\\t\\t$minutes = $current->fieldDifference($this->testTime, IntlCalendar::FIELD_MINUTE);\\n\\n\\t\\t$phrase = null;\\n\\n\\t\\tif ($years !== 0)\\n\\t\\t{\\n\\t\\t\\t$phrase = lang('Time.years', [abs($years)], $locale);\\n\\t\\t\\t$before = $years < 0;\\n\\t\\t}\\n\\t\\telse if ($months !== 0)\\n\\t\\t{\\n\\t\\t\\t$phrase = lang('Time.months', [abs($months)], $locale);\\n\\t\\t\\t$before = $months < 0;\\n\\t\\t}\\n\\t\\telse if ($days !== 0 && (abs($days) >= 7))\\n\\t\\t{\\n\\t\\t\\t$weeks  = ceil($days / 7);\\n\\t\\t\\t$phrase = lang('Time.weeks', [abs($weeks)], $locale);\\n\\t\\t\\t$before = $days < 0;\\n\\t\\t}\\n\\t\\telse if ($days !== 0)\\n\\t\\t{\\n\\t\\t\\t$phrase = lang('Time.days', [abs($days)], $locale);\\n\\t\\t\\t$before = $days < 0;\\n\\t\\t}\\n\\t\\telse if ($hours !== 0)\\n\\t\\t{\\n\\t\\t\\t$phrase = lang('Time.hours', [abs($hours)], $locale);\\n\\t\\t\\t$before = $hours < 0;\\n\\t\\t}\\n\\t\\telse if ($minutes !== 0)\\n\\t\\t{\\n\\t\\t\\t$phrase = lang('Time.minutes', [abs($minutes)], $locale);\\n\\t\\t\\t$before = $minutes < 0;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\treturn lang('Time.now', [], $locale);\\n\\t\\t}\\n\\n\\t\\treturn $before\\n\\t\\t\\t? lang('Time.ago', [$phrase], $locale)\\n\\t\\t\\t: lang('Time.inFuture', [$phrase], $locale);\\n\\t}\", \"output\": \"Convert the time to human readable format\\n\\n@param string|null $locale\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function load(array $params = [], string $alias)\\n\\t{\\n\\t\\t// No DB specified? Beat them senseless...\\n\\t\\tif (empty($params['DBDriver']))\\n\\t\\t{\\n\\t\\t\\tthrow new \\\\InvalidArgumentException('You have not selected a database type to connect to.');\\n\\t\\t}\\n\\n\\t\\t$className = strpos($params['DBDriver'], '\\\\\\\\') === false\\n\\t\\t\\t? '\\\\CodeIgniter\\\\Database\\\\\\\\' . $params['DBDriver'] . '\\\\\\\\Connection'\\n\\t\\t\\t: $params['DBDriver'] . '\\\\\\\\Connection';\\n\\n\\t\\t$class = new $className($params);\\n\\n\\t\\t// Store the connection\\n\\t\\t$this->connections[$alias] = $class;\\n\\n\\t\\treturn $this->connections[$alias];\\n\\t}\", \"output\": \"Parses the connection binds and returns an instance of\\nthe driver ready to go.\\n\\n@param array  $params\\n@param string $alias\\n\\n@return   mixed\\n@internal param bool $useBuilder\"}"}
{"text": "{\"input\": \"Summarize the following code: public function loadForge(ConnectionInterface $db)\\n\\t{\\n\\t\\t$className = strpos($db->DBDriver, '\\\\\\\\') === false ? '\\\\CodeIgniter\\\\Database\\\\\\\\' . $db->DBDriver . '\\\\\\\\Forge' : $db->DBDriver . '\\\\\\\\Forge';\\n\\n\\t\\t// Make sure a connection exists\\n\\t\\tif (! $db->connID)\\n\\t\\t{\\n\\t\\t\\t$db->initialize();\\n\\t\\t}\\n\\n\\t\\t$class = new $className($db);\\n\\n\\t\\treturn $class;\\n\\t}\", \"output\": \"Creates a new Forge instance for the current database type.\\n\\n@param ConnectionInterface|BaseConnection $db\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function hasPropertyChanged(string $key, $value = null): bool\\n\\t{\\n\\t\\treturn ! (($this->_original[$key] === null && $value === null) || $this->_original[$key] === $value);\\n\\t}\", \"output\": \"Checks a property to see if it has changed since the entity was created.\\n\\n@param string $key\\n@param null   $value\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function mapProperty(string $key)\\n\\t{\\n\\t\\tif (empty($this->_options['datamap']))\\n\\t\\t{\\n\\t\\t\\treturn $key;\\n\\t\\t}\\n\\n\\t\\tif (isset($this->_options['datamap'][$key]) && ! empty($this->_options['datamap'][$key]))\\n\\t\\t{\\n\\t\\t\\treturn $this->_options['datamap'][$key];\\n\\t\\t}\\n\\n\\t\\treturn $key;\\n\\t}\", \"output\": \"Checks the datamap to see if this column name is being mapped,\\nand returns the mapped name, if any, or the original name.\\n\\n@param string $key\\n\\n@return mixed|string\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function mutateDate($value)\\n\\t{\\n\\t\\tif ($value instanceof Time)\\n\\t\\t{\\n\\t\\t\\treturn $value;\\n\\t\\t}\\n\\n\\t\\tif ($value instanceof \\\\DateTime)\\n\\t\\t{\\n\\t\\t\\treturn Time::instance($value);\\n\\t\\t}\\n\\n\\t\\tif (is_numeric($value))\\n\\t\\t{\\n\\t\\t\\treturn Time::createFromTimestamp($value);\\n\\t\\t}\\n\\n\\t\\tif (is_string($value))\\n\\t\\t{\\n\\t\\t\\treturn Time::parse($value);\\n\\t\\t}\\n\\n\\t\\treturn $value;\\n\\t}\", \"output\": \"Converts the given string|timestamp|DateTime|Time instance\\ninto a \\\\CodeIgniter\\\\I18n\\\\Time object.\\n\\n@param $value\\n\\n@return \\\\CodeIgniter\\\\I18n\\\\Time\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: private function castAsJson($value, bool $asArray = false)\\n\\t{\\n\\t\\t$tmp = ! is_null($value) ? ($asArray ? [] : new \\\\stdClass) : null;\\n\\t\\tif (function_exists('json_decode'))\\n\\t\\t{\\n\\t\\t\\tif ((is_string($value) && (strpos($value, '[') === 0 || strpos($value, '{') === 0 || (strpos($value, '\\\"') === 0 && strrpos($value, '\\\"') === 0 ))) || is_numeric($value))\\n\\t\\t\\t{\\n\\t\\t\\t\\t$tmp = json_decode($value, $asArray);\\n\\n\\t\\t\\t\\tif (json_last_error() !== JSON_ERROR_NONE)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tthrow CastException::forInvalidJsonFormatException(json_last_error());\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn $tmp;\\n\\t}\", \"output\": \"Cast as JSON\\n\\n@param mixed   $value\\n@param boolean $asArray\\n\\n@return mixed\\n@throws \\\\CodeIgniter\\\\Exceptions\\\\CastException\"}"}
{"text": "{\"input\": \"Summarize the following code: public function shouldDiscover(string $alias)\\n\\t{\\n\\t\\tif (! $this->enabled)\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t$alias = strtolower($alias);\\n\\n\\t\\treturn in_array($alias, $this->activeExplorers);\\n\\t}\", \"output\": \"Should the application auto-discover the requested resources.\\n\\nValid values are:\\n- events\\n- registrars\\n- routes\\n- services\\n\\n@param string $alias\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: public function first()\\n\\t{\\n\\t\\t$builder = $this->builder();\\n\\n\\t\\tif ($this->tempUseSoftDeletes === true)\\n\\t\\t{\\n\\t\\t\\t$builder->where($this->table . '.' . $this->deletedField, 0);\\n\\t\\t}\\n\\n\\t\\t// Some databases, like PostgreSQL, need order\\n\\t\\t// information to consistently return correct results.\\n\\t\\tif (empty($builder->QBOrderBy) && ! empty($this->primaryKey))\\n\\t\\t{\\n\\t\\t\\t$builder->orderBy($this->table . '.' . $this->primaryKey, 'asc');\\n\\t\\t}\\n\\n\\t\\t$row = $builder->limit(1, 0)\\n\\t\\t\\t\\t->get();\\n\\n\\t\\t$row = $row->getFirstRow($this->tempReturnType);\\n\\n\\t\\t$row = $this->trigger('afterFind', ['data' => $row]);\\n\\n\\t\\t$this->tempReturnType = $this->returnType;\\n\\n\\t\\treturn $row['data'];\\n\\t}\", \"output\": \"Returns the first row of the result set. Will take any previous\\nQuery Builder calls into account when determining the result set.\\n\\n@return array|object|null\"}"}
{"text": "{\"input\": \"Summarize the following code: public function insertBatch(array $set = null, bool $escape = null, int $batchSize = 100, bool $testing = false)\\n\\t{\\n\\t\\tif (is_array($set) && $this->skipValidation === false)\\n\\t\\t{\\n\\t\\t\\tforeach ($set as $row)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif ($this->validate($row) === false)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $this->builder()->insertBatch($set, $escape, $batchSize, $testing);\\n\\t}\", \"output\": \"Compiles batch insert strings and runs the queries, validating each row prior.\\n\\n@param array   $set       An associative array of insert values\\n@param boolean $escape    Whether to escape values and identifiers\\n\\n@param integer $batchSize\\n@param boolean $testing\\n\\n@return integer|boolean Number of rows inserted or FALSE on failure\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function builder(string $table = null)\\n\\t{\\n\\t\\tif ($this->builder instanceof BaseBuilder)\\n\\t\\t{\\n\\t\\t\\treturn $this->builder;\\n\\t\\t}\\n\\n\\t\\t// We're going to force a primary key to exist\\n\\t\\t// so we don't have overly convoluted code,\\n\\t\\t// and future features are likely to require them.\\n\\t\\tif (empty($this->primaryKey))\\n\\t\\t{\\n\\t\\t\\tthrow ModelException::forNoPrimaryKey(get_class($this));\\n\\t\\t}\\n\\n\\t\\t$table = empty($table) ? $this->table : $table;\\n\\n\\t\\t// Ensure we have a good db connection\\n\\t\\tif (! $this->db instanceof BaseConnection)\\n\\t\\t{\\n\\t\\t\\t$this->db = Database::connect($this->DBGroup);\\n\\t\\t}\\n\\n\\t\\t$this->builder = $this->db->table($table);\\n\\n\\t\\treturn $this->builder;\\n\\t}\", \"output\": \"Provides a shared instance of the Query Builder.\\n\\n@param string $table\\n\\n@return BaseBuilder\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function doProtectFields(array $data): array\\n\\t{\\n\\t\\tif ($this->protectFields === false)\\n\\t\\t{\\n\\t\\t\\treturn $data;\\n\\t\\t}\\n\\n\\t\\tif (empty($this->allowedFields))\\n\\t\\t{\\n\\t\\t\\tthrow DataException::forInvalidAllowedFields(get_class($this));\\n\\t\\t}\\n\\n\\t\\tif (is_array($data) && count($data))\\n\\t\\t{\\n\\t\\t\\tforeach ($data as $key => $val)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (! in_array($key, $this->allowedFields))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tunset($data[$key]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $data;\\n\\t}\", \"output\": \"Ensures that only the fields that are allowed to be updated\\nare in the data array.\\n\\nUsed by insert() and update() to protect against mass assignment\\nvulnerabilities.\\n\\n@param array $data\\n\\n@return array\\n@throws \\\\CodeIgniter\\\\Database\\\\Exceptions\\\\DataException\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function cleanValidationRules(array $rules, array $data = null): array\\n\\t{\\n\\t\\tif (empty($data))\\n\\t\\t{\\n\\t\\t\\treturn [];\\n\\t\\t}\\n\\n\\t\\tforeach ($rules as $field => $rule)\\n\\t\\t{\\n\\t\\t\\tif (! array_key_exists($field, $data))\\n\\t\\t\\t{\\n\\t\\t\\t\\tunset($rules[$field]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $rules;\\n\\t}\", \"output\": \"Removes any rules that apply to fields that have not been set\\ncurrently so that rules don't block updating when only updating\\na partial row.\\n\\n@param array      $rules\\n\\n@param array|null $data\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getValidationRules(array $options = []): array\\n\\t{\\n\\t\\t$rules = $this->validationRules;\\n\\n\\t\\tif (isset($options['except']))\\n\\t\\t{\\n\\t\\t\\t$rules = array_diff_key($rules, array_flip($options['except']));\\n\\t\\t}\\n\\t\\telseif (isset($options['only']))\\n\\t\\t{\\n\\t\\t\\t$rules = array_intersect_key($rules, array_flip($options['only']));\\n\\t\\t}\\n\\n\\t\\treturn $rules;\\n\\t}\", \"output\": \"Returns the model's defined validation rules so that they\\ncan be used elsewhere, if needed.\\n\\n@param array $options\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: public function countAllResults(bool $reset = true, bool $test = false)\\n\\t{\\n\\t\\tif ($this->tempUseSoftDeletes === true)\\n\\t\\t{\\n\\t\\t\\t$this->builder()->where($this->deletedField, 0);\\n\\t\\t}\\n\\n\\t\\treturn $this->builder()->countAllResults($reset, $test);\\n\\t}\", \"output\": \"Override countAllResults to account for soft deleted accounts.\\n\\n@param boolean $reset\\n@param boolean $test\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setAuth(string $username, string $password, string $type = 'basic')\\n\\t{\\n\\t\\t$this->config['auth'] = [\\n\\t\\t\\t$username,\\n\\t\\t\\t$password,\\n\\t\\t\\t$type,\\n\\t\\t];\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Set the HTTP Authentication.\\n\\n@param string $username\\n@param string $password\\n@param string $type     basic or digest\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setForm(array $params, bool $multipart = false)\\n\\t{\\n\\t\\tif ($multipart)\\n\\t\\t{\\n\\t\\t\\t$this->config['multipart'] = $params;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t$this->config['form_params'] = $params;\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Set form data to be sent.\\n\\n@param array   $params\\n@param boolean $multipart Set TRUE if you are sending CURLFiles\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function parseOptions(array $options)\\n\\t{\\n\\t\\tif (array_key_exists('baseURI', $options))\\n\\t\\t{\\n\\t\\t\\t$this->baseURI = $this->baseURI->setURI($options['baseURI']);\\n\\t\\t\\tunset($options['baseURI']);\\n\\t\\t}\\n\\n\\t\\tif (array_key_exists('headers', $options) && is_array($options['headers']))\\n\\t\\t{\\n\\t\\t\\tforeach ($options['headers'] as $name => $value)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$this->setHeader($name, $value);\\n\\t\\t\\t}\\n\\n\\t\\t\\tunset($options['headers']);\\n\\t\\t}\\n\\n\\t\\tif (array_key_exists('delay', $options))\\n\\t\\t{\\n\\t\\t\\t// Convert from the milliseconds passed in\\n\\t\\t\\t// to the seconds that sleep requires.\\n\\t\\t\\t$this->delay = (float) $options['delay'] / 1000;\\n\\t\\t\\tunset($options['delay']);\\n\\t\\t}\\n\\n\\t\\tforeach ($options as $key => $value)\\n\\t\\t{\\n\\t\\t\\t$this->config[$key] = $value;\\n\\t\\t}\\n\\t}\", \"output\": \"Sets the correct settings based on the options array\\npassed in.\\n\\n@param array $options\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getMethod(bool $upper = false): string\\n\\t{\\n\\t\\treturn ($upper) ? strtoupper($this->method) : strtolower($this->method);\\n\\t}\", \"output\": \"Get the request method. Overrides the Request class' method\\nsince users expect a different answer here.\\n\\n@param boolean|false $upper Whether to return in upper or lower case.\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function send(string $method, string $url)\\n\\t{\\n\\t\\t// Reset our curl options so we're on a fresh slate.\\n\\t\\t$curl_options = [];\\n\\n\\t\\tif (! empty($this->config['query']) && is_array($this->config['query']))\\n\\t\\t{\\n\\t\\t\\t// This is likely too naive a solution.\\n\\t\\t\\t// Should look into handling when $url already\\n\\t\\t\\t// has query vars on it.\\n\\t\\t\\t$url .= '?' . http_build_query($this->config['query']);\\n\\t\\t\\tunset($this->config['query']);\\n\\t\\t}\\n\\n\\t\\t$curl_options[CURLOPT_URL]            = $url;\\n\\t\\t$curl_options[CURLOPT_RETURNTRANSFER] = true;\\n\\t\\t$curl_options[CURLOPT_HEADER]         = true;\\n\\t\\t$curl_options[CURLOPT_FRESH_CONNECT]  = true;\\n\\t\\t// Disable @file uploads in post data.\\n\\t\\t$curl_options[CURLOPT_SAFE_UPLOAD] = true;\\n\\n\\t\\t$curl_options = $this->setCURLOptions($curl_options, $this->config);\\n\\t\\t$curl_options = $this->applyMethod($method, $curl_options);\\n\\t\\t$curl_options = $this->applyRequestHeaders($curl_options);\\n\\n\\t\\t// Do we need to delay this request?\\n\\t\\tif ($this->delay > 0)\\n\\t\\t{\\n\\t\\t\\tsleep($this->delay);\\n\\t\\t}\\n\\n\\t\\t$output = $this->sendRequest($curl_options);\\n\\n\\t\\t$continueStr = \\\"HTTP/1.1 100 Continue\\\\x0d\\\\x0a\\\\x0d\\\\x0a\\\";\\n\\t\\tif (strpos($output, $continueStr) === 0)\\n\\t\\t{\\n\\t\\t\\t$output = substr($output, strlen($continueStr));\\n\\t\\t}\\n\\n\\t\\t// Split out our headers and body\\n\\t\\t$break = strpos($output, \\\"\\\\r\\\\n\\\\r\\\\n\\\");\\n\\n\\t\\tif ($break !== false)\\n\\t\\t{\\n\\t\\t\\t// Our headers\\n\\t\\t\\t$headers = explode(\\\"\\\\n\\\", substr($output, 0, $break));\\n\\n\\t\\t\\t$this->setResponseHeaders($headers);\\n\\n\\t\\t\\t// Our body\\n\\t\\t\\t$body = substr($output, $break + 4);\\n\\t\\t\\t$this->response->setBody($body);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t$this->response->setBody($output);\\n\\t\\t}\\n\\n\\t\\treturn $this->response;\\n\\t}\", \"output\": \"Fires the actual cURL request.\\n\\n@param string $method\\n@param string $url\\n\\n@return \\\\CodeIgniter\\\\HTTP\\\\ResponseInterface\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function applyRequestHeaders(array $curl_options = []): array\\n\\t{\\n\\t\\t$headers = $this->getHeaders();\\n\\n\\t\\tif (empty($headers))\\n\\t\\t{\\n\\t\\t\\treturn $curl_options;\\n\\t\\t}\\n\\n\\t\\t$set = [];\\n\\n\\t\\tforeach ($headers as $name => $value)\\n\\t\\t{\\n\\t\\t\\t$set[] = $name . ': ' . $this->getHeaderLine($name);\\n\\t\\t}\\n\\n\\t\\t$curl_options[CURLOPT_HTTPHEADER] = $set;\\n\\n\\t\\treturn $curl_options;\\n\\t}\", \"output\": \"Takes all headers current part of this request and adds them\\nto the cURL request.\\n\\n@param array $curl_options\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function setResponseHeaders(array $headers = [])\\n\\t{\\n\\t\\tforeach ($headers as $header)\\n\\t\\t{\\n\\t\\t\\tif (($pos = strpos($header, ':')) !== false)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$title = substr($header, 0, $pos);\\n\\t\\t\\t\\t$value = substr($header, $pos + 1);\\n\\n\\t\\t\\t\\t$this->response->setHeader($title, $value);\\n\\t\\t\\t}\\n\\t\\t\\telse if (strpos($header, 'HTTP') === 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tpreg_match('#^HTTP\\\\/([12]\\\\.[01]) ([0-9]+) (.+)#', $header, $matches);\\n\\n\\t\\t\\t\\tif (isset($matches[1]))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$this->response->setProtocolVersion($matches[1]);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (isset($matches[2]))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$this->response->setStatusCode($matches[2], $matches[3] ?? null);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\", \"output\": \"Parses the header retrieved from the cURL response into\\nour Response object.\\n\\n@param array $headers\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function sendRequest(array $curl_options = []): string\\n\\t{\\n\\t\\t$ch = curl_init();\\n\\n\\t\\tcurl_setopt_array($ch, $curl_options);\\n\\n\\t\\t// Send the request and wait for a response.\\n\\t\\t$output = curl_exec($ch);\\n\\n\\t\\tif ($output === false)\\n\\t\\t{\\n\\t\\t\\tthrow HTTPException::forCurlError(curl_errno($ch), curl_error($ch));\\n\\t\\t}\\n\\n\\t\\tcurl_close($ch);\\n\\n\\t\\treturn $output;\\n\\t}\", \"output\": \"Does the actual work of initializing cURL, setting the options,\\nand grabbing the output.\\n\\n@codeCoverageIgnore\\n\\n@param array $curl_options\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function version(string $targetVersion, string $namespace = null, string $group = null)\\n\\t{\\n\\t\\tif (! $this->enabled)\\n\\t\\t{\\n\\t\\t\\tthrow ConfigException::forDisabledMigrations();\\n\\t\\t}\\n\\n\\t\\t$this->ensureTable();\\n\\n\\t\\t// Set Namespace if not null\\n\\t\\tif (! is_null($namespace))\\n\\t\\t{\\n\\t\\t\\t$this->setNamespace($namespace);\\n\\t\\t}\\n\\n\\t\\t// Set database group if not null\\n\\t\\tif (! is_null($group))\\n\\t\\t{\\n\\t\\t\\t$this->setGroup($group);\\n\\t\\t}\\n\\n\\t\\t// Sequential versions need adjusting to 3 places so they can be found later.\\n\\t\\tif ($this->type === 'sequential')\\n\\t\\t{\\n\\t\\t\\t$targetVersion = str_pad($targetVersion, 3, '0', STR_PAD_LEFT);\\n\\t\\t}\\n\\n\\t\\t$migrations = $this->findMigrations();\\n\\n\\t\\tif (empty($migrations))\\n\\t\\t{\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\t// Get Namespace current version\\n\\t\\t// Note: We use strings, so that timestamp versions work on 32-bit systems\\n\\t\\t$currentVersion = $this->getVersion();\\n\\t\\tif ($targetVersion > $currentVersion)\\n\\t\\t{\\n\\t\\t\\t// Moving Up\\n\\t\\t\\t$method = 'up';\\n\\t\\t\\tksort($migrations);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t// Moving Down, apply in reverse order\\n\\t\\t\\t$method = 'down';\\n\\t\\t\\tkrsort($migrations);\\n\\t\\t}\\n\\n\\t\\t// Check Migration consistency\\n\\t\\t$this->checkMigrations($migrations, $method, $targetVersion);\\n\\n\\t\\t// loop migration for each namespace (module)\\n\\n\\t\\t$migrationStatus = false;\\n\\t\\tforeach ($migrations as $version => $migration)\\n\\t\\t{\\n\\t\\t\\t// Only include migrations within the scoop\\n\\t\\t\\tif (($method === 'up' && $version > $currentVersion && $version <= $targetVersion) || ( $method === 'down' && $version <= $currentVersion && $version > $targetVersion))\\n\\t\\t\\t{\\n\\t\\t\\t\\t$migrationStatus = false;\\n\\t\\t\\t\\tinclude_once $migration->path;\\n\\t\\t\\t\\t// Get namespaced class name\\n\\t\\t\\t\\t$class = $this->namespace . '\\\\Database\\\\Migrations\\\\Migration_' . ($migration->name);\\n\\n\\t\\t\\t\\t$this->setName($migration->name);\\n\\n\\t\\t\\t\\t// Validate the migration file structure\\n\\t\\t\\t\\tif (! class_exists($class, false))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tthrow new \\\\RuntimeException(sprintf(lang('Migrations.classNotFound'), $class));\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Forcing migration to selected database group\\n\\t\\t\\t\\t$instance = new $class(\\\\Config\\\\Database::forge($this->group));\\n\\n\\t\\t\\t\\tif (! is_callable([$instance, $method]))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tthrow new \\\\RuntimeException(sprintf(lang('Migrations.missingMethod'), $method));\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t$instance->{$method}();\\n\\t\\t\\t\\tif ($method === 'up')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$this->addHistory($migration->version);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telseif ($method === 'down')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$this->removeHistory($migration->version);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t$migrationStatus = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ($migrationStatus) ? $targetVersion : false;\\n\\t}\", \"output\": \"Migrate to a schema version\\n\\nCalls each migration step required to get to the schema version of\\nchoice\\n\\n@param string      $targetVersion Target schema version\\n@param string|null $namespace\\n@param string|null $group\\n\\n@return mixed Current version string on success, FALSE on failure or no migrations are found\\n@throws ConfigException\"}"}
{"text": "{\"input\": \"Summarize the following code: public function findMigrations(): array\\n\\t{\\n\\t\\t$migrations = [];\\n\\n\\t\\t// If $this->path contains a valid directory use it.\\n\\t\\tif (! empty($this->path))\\n\\t\\t{\\n\\t\\t\\thelper('filesystem');\\n\\t\\t\\t$dir   = rtrim($this->path, DIRECTORY_SEPARATOR) . '/';\\n\\t\\t\\t$files = get_filenames($dir, true);\\n\\t\\t}\\n\\t\\t// Otherwise use FileLocator to search files in the subdirectory of the namespace\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t$locator = Services::locator(true);\\n\\t\\t\\t$files   = $locator->listNamespaceFiles($this->namespace, '/Database/Migrations/');\\n\\t\\t}\\n\\n\\t\\t// Load all *_*.php files in the migrations path\\n\\t\\t// We can't use glob if we want it to be testable....\\n\\t\\tforeach ($files as $file)\\n\\t\\t{\\n\\t\\t\\tif (substr($file, -4) !== '.php')\\n\\t\\t\\t{\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Remove the extension\\n\\t\\t\\t$name = basename($file, '.php');\\n\\n\\t\\t\\t// Filter out non-migration files\\n\\t\\t\\tif (preg_match($this->regex, $name))\\n\\t\\t\\t{\\n\\t\\t\\t\\t// Create migration object using stdClass\\n\\t\\t\\t\\t$migration = new \\\\stdClass();\\n\\n\\t\\t\\t\\t// Get migration version number\\n\\t\\t\\t\\t$migration->version = $this->getMigrationNumber($name);\\n\\t\\t\\t\\t$migration->name    = $this->getMigrationName($name);\\n\\t\\t\\t\\t$migration->path    = ! empty($this->path) && strpos($file, $this->path) !== 0\\n\\t\\t\\t\\t\\t? $this->path . $file\\n\\t\\t\\t\\t\\t: $file;\\n\\n\\t\\t\\t\\t// Add to migrations[version]\\n\\t\\t\\t\\t$migrations[$migration->version] = $migration;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tksort($migrations);\\n\\n\\t\\treturn $migrations;\\n\\t}\", \"output\": \"Retrieves list of available migration scripts for one namespace\\n\\n@return array    list of migrations as $version for one namespace\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function checkMigrations(array $migrations, string $method, string $targetVersion): bool\\n\\t{\\n\\t\\t// Check if no migrations found\\n\\t\\tif (empty($migrations))\\n\\t\\t{\\n\\t\\t\\tif ($this->silent)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tthrow new \\\\RuntimeException(lang('Migrations.empty'));\\n\\t\\t}\\n\\n\\t\\t// Check if $targetVersion file is found\\n\\t\\tif ((int)$targetVersion !== 0 && ! array_key_exists($targetVersion, $migrations))\\n\\t\\t{\\n\\t\\t\\tif ($this->silent)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tthrow new \\\\RuntimeException(lang('Migrations.notFound') . $targetVersion);\\n\\t\\t}\\n\\n\\t\\tksort($migrations);\\n\\n\\t\\tif ($method === 'down')\\n\\t\\t{\\n\\t\\t\\t$history_migrations = $this->getHistory($this->group);\\n\\t\\t\\t$history_size       = count($history_migrations) - 1;\\n\\t\\t}\\n\\t\\t// Check for sequence gaps\\n\\t\\t$loop = 0;\\n\\t\\tforeach ($migrations as $migration)\\n\\t\\t{\\n\\t\\t\\tif ($this->type === 'sequential' && abs($migration->version - $loop) > 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tthrow new \\\\RuntimeException(lang('Migrations.gap') . ' ' . $migration->version);\\n\\t\\t\\t}\\n\\t\\t\\t// Check if all old migration files are all available to do downgrading\\n\\t\\t\\tif ($method === 'down')\\n\\t\\t\\t{\\n\\t\\t\\t\\tif ($loop <= $history_size && $history_migrations[$loop]['version'] !== $migration->version)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tthrow new \\\\RuntimeException(lang('Migrations.gap') . ' ' . $migration->version);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t$loop ++;\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\", \"output\": \"checks if the list of available migration scripts list are consistent\\nif sequential check if no gaps and check if all consistent with migrations table if downgrading\\nif timestamp check if consistent with migrations table if downgrading\\n\\n@param array  $migrations\\n@param string $method\\n@param string $targetVersion\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getHistory(string $group = 'default'): array\\n\\t{\\n\\t\\t$this->ensureTable();\\n\\n\\t\\t$query = $this->db->table($this->table)\\n\\t\\t\\t\\t->where('group', $group)\\n\\t\\t\\t\\t->where('namespace', $this->namespace)\\n\\t\\t\\t\\t->orderBy('version', 'ASC')\\n\\t\\t\\t\\t->get();\\n\\n\\t\\tif (! $query)\\n\\t\\t{\\n\\t\\t\\treturn [];\\n\\t\\t}\\n\\n\\t\\treturn $query->getResultArray();\\n\\t}\", \"output\": \"Grabs the full migration history from the database.\\n\\n@param string $group\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function getMigrationName(string $migration): string\\n\\t{\\n\\t\\t$parts = explode('_', $migration);\\n\\t\\tarray_shift($parts);\\n\\n\\t\\treturn implode('_', $parts);\\n\\t}\", \"output\": \"Extracts the migration class name from a filename\\n\\n@param string $migration\\n\\n@return string    text portion of a migration filename\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function getVersion(): string\\n\\t{\\n\\t\\t$this->ensureTable();\\n\\n\\t\\t$row = $this->db->table($this->table)\\n\\t\\t\\t\\t->select('version')\\n\\t\\t\\t\\t->where('group', $this->group)\\n\\t\\t\\t\\t->where('namespace', $this->namespace)\\n\\t\\t\\t\\t->orderBy('version', 'DESC')\\n\\t\\t\\t\\t->get();\\n\\n\\t\\treturn $row && ! is_null($row->getRow()) ? $row->getRow()->version : '0';\\n\\t}\", \"output\": \"Retrieves current schema version\\n\\n@return string    Current migration version\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function addHistory(string $version)\\n\\t{\\n\\t\\t$this->db->table($this->table)\\n\\t\\t\\t\\t->insert([\\n\\t\\t\\t\\t\\t'version'   => $version,\\n\\t\\t\\t\\t\\t'name'      => $this->name,\\n\\t\\t\\t\\t\\t'group'     => $this->group,\\n\\t\\t\\t\\t\\t'namespace' => $this->namespace,\\n\\t\\t\\t\\t\\t'time'      => time(),\\n\\t\\t\\t\\t]);\\n\\t\\tif (is_cli())\\n\\t\\t{\\n\\t\\t\\t$this->cliMessages[] = \\\"\\\\t\\\" . CLI::color(lang('Migrations.added'), 'yellow') . \\\"($this->namespace) \\\" . $version . '_' . $this->name;\\n\\t\\t}\\n\\t}\", \"output\": \"Stores the current schema version.\\n\\n@param string $version\\n\\n@internal param string $migration Migration reached\\n\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function removeHistory(string $version)\\n\\t{\\n\\t\\t$this->db->table($this->table)\\n\\t\\t\\t\\t->where('version', $version)\\n\\t\\t\\t\\t->where('group', $this->group)\\n\\t\\t\\t\\t->where('namespace', $this->namespace)\\n\\t\\t\\t\\t->delete();\\n\\t\\tif (is_cli())\\n\\t\\t{\\n\\t\\t\\t$this->cliMessages[] = \\\"\\\\t\\\" . CLI::color(lang('Migrations.removed'), 'yellow') . \\\"($this->namespace) \\\" . $version . '_' . $this->name;\\n\\t\\t}\\n\\t}\", \"output\": \"Removes a single history\\n\\n@param string $version\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: public function ensureTable()\\n\\t{\\n\\t\\tif ($this->tableChecked || $this->db->tableExists($this->table))\\n\\t\\t{\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t$forge = \\\\Config\\\\Database::forge($this->db);\\n\\n\\t\\t$forge->addField([\\n\\t\\t\\t'version'   => [\\n\\t\\t\\t\\t'type'       => 'VARCHAR',\\n\\t\\t\\t\\t'constraint' => 255,\\n\\t\\t\\t\\t'null'       => false,\\n\\t\\t\\t],\\n\\t\\t\\t'name'      => [\\n\\t\\t\\t\\t'type'       => 'VARCHAR',\\n\\t\\t\\t\\t'constraint' => 255,\\n\\t\\t\\t\\t'null'       => false,\\n\\t\\t\\t],\\n\\t\\t\\t'group'     => [\\n\\t\\t\\t\\t'type'       => 'VARCHAR',\\n\\t\\t\\t\\t'constraint' => 255,\\n\\t\\t\\t\\t'null'       => false,\\n\\t\\t\\t],\\n\\t\\t\\t'namespace' => [\\n\\t\\t\\t\\t'type'       => 'VARCHAR',\\n\\t\\t\\t\\t'constraint' => 255,\\n\\t\\t\\t\\t'null'       => false,\\n\\t\\t\\t],\\n\\t\\t\\t'time'      => [\\n\\t\\t\\t\\t'type'       => 'INT',\\n\\t\\t\\t\\t'constraint' => 11,\\n\\t\\t\\t\\t'null'       => false,\\n\\t\\t\\t],\\n\\t\\t]);\\n\\n\\t\\t$forge->createTable($this->table, true);\\n\\n\\t\\t$this->tableChecked = true;\\n\\t}\", \"output\": \"Ensures that we have created our migrations table\\nin the database.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function check($value, string $rule, array $errors = []): bool\\n\\t{\\n\\t\\t$this->reset();\\n\\t\\t$this->setRule('check', null, $rule, $errors);\\n\\n\\t\\treturn $this->run([\\n\\t\\t\\t'check' => $value,\\n\\t\\t]);\\n\\t}\", \"output\": \"Check; runs the validation process, returning true or false\\ndetermining whether validation was successful or not.\\n\\n@param mixed    $value  Value to validation.\\n@param string   $rule   Rule.\\n@param string[] $errors Errors.\\n\\n@return boolean True if valid, else false.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function withRequest(RequestInterface $request): ValidationInterface\\n\\t{\\n\\t\\tif (in_array($request->getMethod(), ['put', 'patch', 'delete']))\\n\\t\\t{\\n\\t\\t\\t$this->data = $request->getRawInput();\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t$this->data = $request->getVar() ?? [];\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Takes a Request object and grabs the input data to use from its\\narray values.\\n\\n@param \\\\CodeIgniter\\\\HTTP\\\\RequestInterface|\\\\CodeIgniter\\\\HTTP\\\\IncomingRequest $request\\n\\n@return \\\\CodeIgniter\\\\Validation\\\\ValidationInterface\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setRule(string $field, string $label = null, string $rules, array $errors = [])\\n\\t{\\n\\t\\t$this->rules[$field] = [\\n\\t\\t\\t'label' => $label,\\n\\t\\t\\t'rules' => $rules,\\n\\t\\t];\\n\\t\\t$this->customErrors  = array_merge($this->customErrors, [\\n\\t\\t\\t$field => $errors,\\n\\t\\t]);\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Sets an individual rule and custom error messages for a single field.\\n\\nThe custom error message should be just the messages that apply to\\nthis field, like so:\\n\\n[\\n'rule' => 'message',\\n'rule' => 'message'\\n]\\n\\n@param string      $field\\n@param string|null $label\\n@param string      $rules\\n@param array       $errors\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getRuleGroup(string $group): array\\n\\t{\\n\\t\\tif (! isset($this->config->$group))\\n\\t\\t{\\n\\t\\t\\tthrow ValidationException::forGroupNotFound($group);\\n\\t\\t}\\n\\n\\t\\tif (! is_array($this->config->$group))\\n\\t\\t{\\n\\t\\t\\tthrow ValidationException::forGroupNotArray($group);\\n\\t\\t}\\n\\n\\t\\treturn $this->config->$group;\\n\\t}\", \"output\": \"Get rule group.\\n\\n@param string $group Group.\\n\\n@return string[] Rule group.\\n\\n@throws \\\\InvalidArgumentException If group not found.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setRuleGroup(string $group)\\n\\t{\\n\\t\\t$rules       = $this->getRuleGroup($group);\\n\\t\\t$this->rules = $rules;\\n\\n\\t\\t$errorName = $group . '_errors';\\n\\t\\tif (isset($this->config->$errorName))\\n\\t\\t{\\n\\t\\t\\t$this->customErrors = $this->config->$errorName;\\n\\t\\t}\\n\\t}\", \"output\": \"Set rule group.\\n\\n@param string $group Group.\\n\\n@throws \\\\InvalidArgumentException If group not found.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function loadRuleSets()\\n\\t{\\n\\t\\tif (empty($this->ruleSetFiles))\\n\\t\\t{\\n\\t\\t\\tthrow ValidationException::forNoRuleSets();\\n\\t\\t}\\n\\n\\t\\tforeach ($this->ruleSetFiles as $file)\\n\\t\\t{\\n\\t\\t\\t$this->ruleSetInstances[] = new $file();\\n\\t\\t}\\n\\t}\", \"output\": \"Loads all of the rulesets classes that have been defined in the\\nConfig\\\\Validation and stores them locally so we can use them.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setError(string $field, string $error): ValidationInterface\\n\\t{\\n\\t\\t$this->errors[$field] = $error;\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Sets the error for a specific field. Used by custom validation methods.\\n\\n@param string $field\\n@param string $error\\n\\n@return \\\\CodeIgniter\\\\Validation\\\\ValidationInterface\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function getErrorMessage(string $rule, string $field, string $label = null, string $param = null): string\\n\\t{\\n\\t\\t// Check if custom message has been defined by user\\n\\t\\tif (isset($this->customErrors[$field][$rule]))\\n\\t\\t{\\n\\t\\t\\t$message = $this->customErrors[$field][$rule];\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t// Try to grab a localized version of the message...\\n\\t\\t\\t// lang() will return the rule name back if not found,\\n\\t\\t\\t// so there will always be a string being returned.\\n\\t\\t\\t$message = lang('Validation.' . $rule);\\n\\t\\t}\\n\\n\\t\\t$message = str_replace('{field}', $label ?? $field, $message);\\n\\t\\t$message = str_replace('{param}', $this->rules[$param]['label'] ?? $param, $message);\\n\\n\\t\\treturn $message;\\n\\t}\", \"output\": \"Attempts to find the appropriate error message\\n\\n@param string      $rule\\n@param string      $field\\n@param string|null $label\\n@param string      $param\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function splitRules(string $rules): array\\n\\t{\\n\\t\\t$non_escape_bracket  = '((?<!\\\\\\\\\\\\\\\\)(?:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\)*[\\\\[\\\\]])';\\n\\t\\t$pipe_not_in_bracket = sprintf(\\n\\t\\t\\t'/\\\\|(?=(?:[^\\\\[\\\\]]*%s[^\\\\[\\\\]]*%s)*(?![^\\\\[\\\\]]*%s))/',\\n\\t\\t\\t$non_escape_bracket,\\n\\t\\t\\t$non_escape_bracket,\\n\\t\\t\\t$non_escape_bracket\\n\\t\\t);\\n\\n\\t\\t$_rules = preg_split(\\n\\t\\t\\t$pipe_not_in_bracket,\\n\\t\\t\\t$rules\\n\\t\\t);\\n\\n\\t\\treturn array_unique($_rules);\\n\\t}\", \"output\": \"Split rules string by pipe operator.\\n\\n@param string $rules\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: public function reset(): ValidationInterface\\n\\t{\\n\\t\\t$this->data         = [];\\n\\t\\t$this->rules        = [];\\n\\t\\t$this->errors       = [];\\n\\t\\t$this->customErrors = [];\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Resets the class to a blank slate. Should be called whenever\\nyou need to process more than one array.\\n\\n@return \\\\CodeIgniter\\\\Validation\\\\ValidationInterface\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function arrayToXML(array $data, &$output)\\n\\t{\\n\\t\\tforeach ($data as $key => $value)\\n\\t\\t{\\n\\t\\t\\tif (is_array($value))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (! is_numeric($key))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$subnode = $output->addChild(\\\"$key\\\");\\n\\t\\t\\t\\t\\t$this->arrayToXML($value, $subnode);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$subnode = $output->addChild(\\\"item{$key}\\\");\\n\\t\\t\\t\\t\\t$this->arrayToXML($value, $subnode);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t$output->addChild(\\\"$key\\\", htmlspecialchars(\\\"$value\\\"));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\", \"output\": \"A recursive method to convert an array into a valid XML string.\\n\\nWritten by CodexWorld. Received permission by email on Nov 24, 2016 to use this code.\\n\\n@see http://www.codexworld.com/convert-array-to-xml-in-php/\\n\\n@param array             $data\\n@param \\\\SimpleXMLElement $output\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function cleanFileNames(string $file): string\\n\\t{\\n\\t\\t$file = str_replace(APPPATH, 'APPPATH/', $file);\\n\\t\\t$file = str_replace(SYSTEMPATH, 'SYSTEMPATH/', $file);\\n\\t\\t$file = str_replace(FCPATH, 'FCPATH/', $file);\\n\\n\\t\\treturn $file;\\n\\t}\", \"output\": \"Cleans the paths of filenames by replacing APPPATH, SYSTEMPATH, FCPATH\\nwith the actual var. i.e.\\n\\n/var/www/site/app/Controllers/Home.php\\nbecomes:\\nAPPPATH/Controllers/Home.php\\n\\n@param $file\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setURI(string $uri = null)\\n\\t{\\n\\t\\tif (! is_null($uri))\\n\\t\\t{\\n\\t\\t\\t$parts = parse_url($uri);\\n\\n\\t\\t\\tif ($parts === false)\\n\\t\\t\\t{\\n\\t\\t\\t\\tthrow HTTPException::forUnableToParseURI($uri);\\n\\t\\t\\t}\\n\\n\\t\\t\\t$this->applyParts($parts);\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Sets and overwrites any current URI information.\\n\\n@param string|null $uri\\n\\n@return URI\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getUserInfo()\\n\\t{\\n\\t\\t$userInfo = $this->user;\\n\\n\\t\\tif ($this->showPassword === true && ! empty($this->password))\\n\\t\\t{\\n\\t\\t\\t$userInfo .= ':' . $this->password;\\n\\t\\t}\\n\\n\\t\\treturn $userInfo;\\n\\t}\", \"output\": \"Retrieve the user information component of the URI.\\n\\nIf no user information is present, this method MUST return an empty\\nstring.\\n\\nIf a user is present in the URI, this will return that value;\\nadditionally, if the password is also present, it will be appended to the\\nuser value, with a colon (\\\":\\\") separating the values.\\n\\nNOTE that be default, the password, if available, will NOT be shown\\nas a security measure as discussed in RFC 3986, Section 7.5. If you know\\nthe password is not a security issue, you can force it to be shown\\nwith $this->showPassword();\\n\\nThe trailing \\\"@\\\" character is not part of the user information and MUST\\nNOT be added.\\n\\n@return string|null The URI user information, in \\\"username[:password]\\\" format.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getQuery(array $options = []): string\\n\\t{\\n\\t\\t$vars = $this->query;\\n\\n\\t\\tif (array_key_exists('except', $options))\\n\\t\\t{\\n\\t\\t\\tif (! is_array($options['except']))\\n\\t\\t\\t{\\n\\t\\t\\t\\t$options['except'] = [$options['except']];\\n\\t\\t\\t}\\n\\n\\t\\t\\tforeach ($options['except'] as $var)\\n\\t\\t\\t{\\n\\t\\t\\t\\tunset($vars[$var]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telseif (array_key_exists('only', $options))\\n\\t\\t{\\n\\t\\t\\t$temp = [];\\n\\n\\t\\t\\tif (! is_array($options['only']))\\n\\t\\t\\t{\\n\\t\\t\\t\\t$options['only'] = [$options['only']];\\n\\t\\t\\t}\\n\\n\\t\\t\\tforeach ($options['only'] as $var)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (array_key_exists($var, $vars))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$temp[$var] = $vars[$var];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t$vars = $temp;\\n\\t\\t}\\n\\n\\t\\treturn empty($vars) ? '' : http_build_query($vars);\\n\\t}\", \"output\": \"Retrieve the query string\\n\\n@param array $options\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getSegment(int $number): string\\n\\t{\\n\\t\\t// The segment should treat the array as 1-based for the user\\n\\t\\t// but we still have to deal with a zero-based array.\\n\\t\\t$number -= 1;\\n\\n\\t\\tif ($number > count($this->segments))\\n\\t\\t{\\n\\t\\t\\tthrow HTTPException::forURISegmentOutOfRange($number);\\n\\t\\t}\\n\\n\\t\\treturn $this->segments[$number] ?? '';\\n\\t}\", \"output\": \"Returns the value of a specific segment of the URI path.\\n\\n@param integer $number\\n\\n@return string     The value of the segment. If no segment is found,\\nthrows InvalidArgumentError\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setSegment(int $number, $value)\\n\\t{\\n\\t\\t// The segment should treat the array as 1-based for the user\\n\\t\\t// but we still have to deal with a zero-based array.\\n\\t\\t$number -= 1;\\n\\n\\t\\tif ($number > count($this->segments) + 1)\\n\\t\\t{\\n\\t\\t\\tthrow HTTPException::forURISegmentOutOfRange($number);\\n\\t\\t}\\n\\n\\t\\t$this->segments[$number] = $value;\\n\\t\\t$this->refreshPath();\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Set the value of a specific segment of the URI path.\\nAllows to set only existing segments or add new one.\\n\\n@param integer $number\\n@param mixed   $value  (string or int)\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function createURIString(string $scheme = null, string $authority = null, string $path = null, string $query = null, string $fragment = null): string\\n\\t{\\n\\t\\t$uri = '';\\n\\t\\tif (! empty($scheme))\\n\\t\\t{\\n\\t\\t\\t$uri .= $scheme . '://';\\n\\t\\t}\\n\\n\\t\\tif (! empty($authority))\\n\\t\\t{\\n\\t\\t\\t$uri .= $authority;\\n\\t\\t}\\n\\n\\t\\tif ($path)\\n\\t\\t{\\n\\t\\t\\t$uri .= substr($uri, -1, 1) !== '/' ? '/' . ltrim($path, '/') : $path;\\n\\t\\t}\\n\\n\\t\\tif ($query)\\n\\t\\t{\\n\\t\\t\\t$uri .= '?' . $query;\\n\\t\\t}\\n\\n\\t\\tif ($fragment)\\n\\t\\t{\\n\\t\\t\\t$uri .= '#' . $fragment;\\n\\t\\t}\\n\\n\\t\\treturn $uri;\\n\\t}\", \"output\": \"Builds a representation of the string from the component parts.\\n\\n@param string $scheme\\n@param string $authority\\n@param string $path\\n@param string $query\\n@param string $fragment\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setAuthority(string $str)\\n\\t{\\n\\t\\t$parts = parse_url($str);\\n\\n\\t\\tif (empty($parts['host']) && ! empty($parts['path']))\\n\\t\\t{\\n\\t\\t\\t$parts['host'] = $parts['path'];\\n\\t\\t\\tunset($parts['path']);\\n\\t\\t}\\n\\n\\t\\t$this->applyParts($parts);\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Parses the given string an saves the appropriate authority pieces.\\n\\n@param string $str\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setScheme(string $str)\\n\\t{\\n\\t\\t$str = strtolower($str);\\n\\t\\t$str = preg_replace('#:(//)?$#', '', $str);\\n\\n\\t\\t$this->scheme = $str;\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Sets the scheme for this URI.\\n\\nBecause of the large number of valid schemes we cannot limit this\\nto only http or https.\\n\\n@see https://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml\\n\\n@param $str\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setPort(int $port = null)\\n\\t{\\n\\t\\tif (is_null($port))\\n\\t\\t{\\n\\t\\t\\treturn $this;\\n\\t\\t}\\n\\n\\t\\tif ($port <= 0 || $port > 65535)\\n\\t\\t{\\n\\t\\t\\tthrow HTTPException::forInvalidPort($port);\\n\\t\\t}\\n\\n\\t\\t$this->port = $port;\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Sets the port portion of the URI.\\n\\n@param integer $port\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setPath(string $path)\\n\\t{\\n\\t\\t$this->path = $this->filterPath($path);\\n\\n\\t\\t$this->segments = explode('/', $this->path);\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Sets the path portion of the URI.\\n\\n@param string $path\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: public function refreshPath()\\n\\t{\\n\\t\\t$this->path = $this->filterPath(implode('/', $this->segments));\\n\\n\\t\\t$this->segments = explode('/', $this->path);\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Sets the path portion of the URI based on segments.\\n\\n@param string $path\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setQuery(string $query)\\n\\t{\\n\\t\\tif (strpos($query, '#') !== false)\\n\\t\\t{\\n\\t\\t\\tthrow HTTPException::forMalformedQueryString();\\n\\t\\t}\\n\\n\\t\\t// Can't have leading ?\\n\\t\\tif (! empty($query) && strpos($query, '?') === 0)\\n\\t\\t{\\n\\t\\t\\t$query = substr($query, 1);\\n\\t\\t}\\n\\n\\t\\t$temp  = explode('&', $query);\\n\\t\\t$parts = [];\\n\\n\\t\\tforeach ($temp as $index => $part)\\n\\t\\t{\\n\\t\\t\\tlist($key, $value) = $this->splitQueryPart($part);\\n\\n\\t\\t\\t// Only 1 part?\\n\\t\\t\\tif (is_null($value))\\n\\t\\t\\t{\\n\\t\\t\\t\\t$parts[$key] = null;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// URL Decode the value to protect\\n\\t\\t\\t// from double-encoding a URL.\\n\\t\\t\\t// Especially useful with the Pager.\\n\\t\\t\\t$parts[$this->decode($key)] = $this->decode($value);\\n\\t\\t}\\n\\n\\t\\t$this->query = $parts;\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Sets the query portion of the URI, while attempting\\nto clean the various parts of the query keys and values.\\n\\n@param string $query\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function decode(string $value): string\\n\\t{\\n\\t\\tif (empty($value))\\n\\t\\t{\\n\\t\\t\\treturn $value;\\n\\t\\t}\\n\\n\\t\\t$decoded = urldecode($value);\\n\\n\\t\\t// This won't catch all cases, specifically\\n\\t\\t// changing ' ' to '+' has the same length\\n\\t\\t// but doesn't really matter for our cases here.\\n\\t\\treturn strlen($decoded) < strlen($value) ? $decoded : $value;\\n\\t}\", \"output\": \"Checks the value to see if it has been urlencoded and decodes it if so.\\nThe urlencode check is not perfect but should catch most cases.\\n\\n@param string $value\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function addQuery(string $key, $value = null)\\n\\t{\\n\\t\\t$this->query[$key] = $value;\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Adds a single new element to the query vars.\\n\\n@param string $key\\n@param mixed  $value\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: public function keepQuery(...$params)\\n\\t{\\n\\t\\t$temp = [];\\n\\n\\t\\tforeach ($this->query as $key => $value)\\n\\t\\t{\\n\\t\\t\\tif (! in_array($key, $params))\\n\\t\\t\\t{\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$temp[$key] = $value;\\n\\t\\t}\\n\\n\\t\\t$this->query = $temp;\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Filters the query variables so that only the keys passed in\\nare kept. The rest are removed from the object.\\n\\n@param array ...$params\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function filterPath(string $path = null): string\\n\\t{\\n\\t\\t$orig = $path;\\n\\n\\t\\t// Decode/normalize percent-encoded chars so\\n\\t\\t// we can always have matching for Routes, etc.\\n\\t\\t$path = urldecode($path);\\n\\n\\t\\t// Remove dot segments\\n\\t\\t$path = $this->removeDotSegments($path);\\n\\n\\t\\t// Fix up some leading slash edge cases...\\n\\t\\tif (strpos($orig, './') === 0)\\n\\t\\t{\\n\\t\\t\\t$path = '/' . $path;\\n\\t\\t}\\n\\t\\tif (strpos($orig, '../') === 0)\\n\\t\\t{\\n\\t\\t\\t$path = '/' . $path;\\n\\t\\t}\\n\\n\\t\\t// Encode characters\\n\\t\\t$path = preg_replace_callback(\\n\\t\\t\\t\\t'/(?:[^' . static::CHAR_UNRESERVED . ':@&=\\\\+\\\\$,\\\\/;%]+|%(?![A-Fa-f0-9]{2}))/', function (array $matches) {\\n\\t\\t\\t\\t\\treturn rawurlencode($matches[0]);\\n\\t\\t\\t\\t}, $path\\n\\t\\t);\\n\\n\\t\\treturn $path;\\n\\t}\", \"output\": \"Encodes any dangerous characters, and removes dot segments.\\nWhile dot segments have valid uses according to the spec,\\nthis URI class does not allow them.\\n\\n@param $path\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function applyParts(array $parts)\\n\\t{\\n\\t\\tif (! empty($parts['host']))\\n\\t\\t{\\n\\t\\t\\t$this->host = $parts['host'];\\n\\t\\t}\\n\\t\\tif (! empty($parts['user']))\\n\\t\\t{\\n\\t\\t\\t$this->user = $parts['user'];\\n\\t\\t}\\n\\t\\tif (! empty($parts['path']))\\n\\t\\t{\\n\\t\\t\\t$this->path = $this->filterPath($parts['path']);\\n\\t\\t}\\n\\t\\tif (! empty($parts['query']))\\n\\t\\t{\\n\\t\\t\\t$this->setQuery($parts['query']);\\n\\t\\t}\\n\\t\\tif (! empty($parts['fragment']))\\n\\t\\t{\\n\\t\\t\\t$this->fragment = $parts['fragment'];\\n\\t\\t}\\n\\n\\t\\t// Scheme\\n\\t\\tif (isset($parts['scheme']))\\n\\t\\t{\\n\\t\\t\\t$this->setScheme(rtrim($parts['scheme'], ':/'));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t$this->setScheme('http');\\n\\t\\t}\\n\\n\\t\\t// Port\\n\\t\\tif (isset($parts['port']))\\n\\t\\t{\\n\\t\\t\\tif (! is_null($parts['port']))\\n\\t\\t\\t{\\n\\t\\t\\t\\t// Valid port numbers are enforced by earlier parse_url or setPort()\\n\\t\\t\\t\\t$port       = $parts['port'];\\n\\t\\t\\t\\t$this->port = $port;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (isset($parts['pass']))\\n\\t\\t{\\n\\t\\t\\t$this->password = $parts['pass'];\\n\\t\\t}\\n\\n\\t\\t// Populate our segments array\\n\\t\\tif (! empty($parts['path']))\\n\\t\\t{\\n\\t\\t\\t$this->segments = explode('/', trim($parts['path'], '/'));\\n\\t\\t}\\n\\t}\", \"output\": \"Saves our parts from a parse_url call.\\n\\n@param array $parts\"}"}
{"text": "{\"input\": \"Summarize the following code: public function resolveRelativeURI(string $uri)\\n\\t{\\n\\t\\t/*\\n\\t\\t * NOTE: We don't use removeDotSegments in this\\n\\t\\t * algorithm since it's already done by this line!\\n\\t\\t */\\n\\t\\t$relative = new URI();\\n\\t\\t$relative->setURI($uri);\\n\\n\\t\\tif ($relative->getScheme() === $this->getScheme())\\n\\t\\t{\\n\\t\\t\\t$relative->setScheme('');\\n\\t\\t}\\n\\n\\t\\t$transformed = clone $relative;\\n\\n\\t\\t// 5.2.2 Transform References in a non-strict method (no scheme)\\n\\t\\tif (! empty($relative->getAuthority()))\\n\\t\\t{\\n\\t\\t\\t$transformed->setAuthority($relative->getAuthority())\\n\\t\\t\\t\\t\\t->setPath($relative->getPath())\\n\\t\\t\\t\\t\\t->setQuery($relative->getQuery());\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif ($relative->getPath() === '')\\n\\t\\t\\t{\\n\\t\\t\\t\\t$transformed->setPath($this->getPath());\\n\\n\\t\\t\\t\\tif ($relative->getQuery())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$transformed->setQuery($relative->getQuery());\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$transformed->setQuery($this->getQuery());\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (strpos($relative->getPath(), '/') === 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$transformed->setPath($relative->getPath());\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$transformed->setPath($this->mergePaths($this, $relative));\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t$transformed->setQuery($relative->getQuery());\\n\\t\\t\\t}\\n\\n\\t\\t\\t$transformed->setAuthority($this->getAuthority());\\n\\t\\t}\\n\\n\\t\\t$transformed->setScheme($this->getScheme());\\n\\n\\t\\t$transformed->setFragment($relative->getFragment());\\n\\n\\t\\treturn $transformed;\\n\\t}\", \"output\": \"Combines one URI string with this one based on the rules set out in\\nRFC 3986 Section 2\\n\\n@see http://tools.ietf.org/html/rfc3986#section-5.2\\n\\n@param string $uri\\n\\n@return \\\\CodeIgniter\\\\HTTP\\\\URI\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function mergePaths(URI $base, URI $reference): string\\n\\t{\\n\\t\\tif (! empty($base->getAuthority()) && empty($base->getPath()))\\n\\t\\t{\\n\\t\\t\\treturn '/' . ltrim($reference->getPath(), '/ ');\\n\\t\\t}\\n\\n\\t\\t$path = explode('/', $base->getPath());\\n\\n\\t\\tif (empty($path[0]))\\n\\t\\t{\\n\\t\\t\\tunset($path[0]);\\n\\t\\t}\\n\\n\\t\\tarray_pop($path);\\n\\t\\tarray_push($path, $reference->getPath());\\n\\n\\t\\treturn implode('/', $path);\\n\\t}\", \"output\": \"Given 2 paths, will merge them according to rules set out in RFC 2986,\\nSection 5.2\\n\\n@see http://tools.ietf.org/html/rfc3986#section-5.2.3\\n\\n@param URI $base\\n@param URI $reference\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function removeDotSegments(string $path): string\\n\\t{\\n\\t\\tif (empty($path) || $path === '/')\\n\\t\\t{\\n\\t\\t\\treturn $path;\\n\\t\\t}\\n\\n\\t\\t$output = [];\\n\\n\\t\\t$input = explode('/', $path);\\n\\n\\t\\tif (empty($input[0]))\\n\\t\\t{\\n\\t\\t\\tunset($input[0]);\\n\\t\\t\\t$input = array_values($input);\\n\\t\\t}\\n\\n\\t\\t// This is not a perfect representation of the\\n\\t\\t// RFC, but matches most cases and is pretty\\n\\t\\t// much what Guzzle uses. Should be good enough\\n\\t\\t// for almost every real use case.\\n\\t\\tforeach ($input as $segment)\\n\\t\\t{\\n\\t\\t\\tif ($segment === '..')\\n\\t\\t\\t{\\n\\t\\t\\t\\tarray_pop($output);\\n\\t\\t\\t}\\n\\t\\t\\telse if ($segment !== '.' && $segment !== '')\\n\\t\\t\\t{\\n\\t\\t\\t\\tarray_push($output, $segment);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t$output = implode('/', $output);\\n\\t\\t$output = ltrim($output, '/ ');\\n\\n\\t\\tif ($output !== '/')\\n\\t\\t{\\n\\t\\t\\t// Add leading slash if necessary\\n\\t\\t\\tif (strpos($path, '/') === 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$output = '/' . $output;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Add trailing slash if necessary\\n\\t\\t\\tif (substr($path, -1, 1) === '/')\\n\\t\\t\\t{\\n\\t\\t\\t\\t$output .= '/';\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $output;\\n\\t}\", \"output\": \"Used when resolving and merging paths to correctly interpret and\\nremove single and double dot segments from the path per\\nRFC 3986 Section 5.2.4\\n\\n@see http://tools.ietf.org/html/rfc3986#section-5.2.4\\n\\n@param string $path\\n\\n@return   string\\n@internal param \\\\CodeIgniter\\\\HTTP\\\\URI $uri\"}"}
{"text": "{\"input\": \"Summarize the following code: public function appendValue($value = null)\\n\\t{\\n\\t\\tif (! is_array($this->value))\\n\\t\\t{\\n\\t\\t\\t$this->value = [$this->value];\\n\\t\\t}\\n\\n\\t\\t$this->value[] = $value;\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Appends a value to the list of values for this header. If the\\nheader is a single value string, it will be converted to an array.\\n\\n@param null $value\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: public function prependValue($value = null)\\n\\t{\\n\\t\\tif (! is_array($this->value))\\n\\t\\t{\\n\\t\\t\\t$this->value = [$this->value];\\n\\t\\t}\\n\\n\\t\\tarray_unshift($this->value, $value);\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Prepends a value to the list of values for this header. If the\\nheader is a single value string, it will be converted to an array.\\n\\n@param null $value\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getPrevious()\\n\\t{\\n\\t\\tif (! $this->hasPrevious())\\n\\t\\t{\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\t$uri = clone $this->uri;\\n\\n\\t\\tif ($this->segment === 0)\\n\\t\\t{\\n\\t\\t\\t$uri->addQuery('page', $this->first - 1);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t$uri->setSegment($this->segment, $this->first - 1);\\n\\t\\t}\\n\\n\\t\\treturn (string) $uri;\\n\\t}\", \"output\": \"Returns a URL to the \\\"previous\\\" page. The previous page is NOT the\\npage before the current page, but is the page just before the\\n\\\"first\\\" page.\\n\\nYou MUST call hasPrevious() first, or this value may be invalid.\\n\\n@return string|null\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getNext()\\n\\t{\\n\\t\\tif (! $this->hasNext())\\n\\t\\t{\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\t$uri = clone $this->uri;\\n\\n\\t\\tif ($this->segment === 0)\\n\\t\\t{\\n\\t\\t\\t$uri->addQuery('page', $this->last + 1);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t$uri->setSegment($this->segment, $this->last + 1);\\n\\t\\t}\\n\\n\\t\\treturn (string) $uri;\\n\\t}\", \"output\": \"Returns a URL to the \\\"next\\\" page. The next page is NOT, the\\npage after the current page, but is the page that follows the\\n\\\"last\\\" page.\\n\\nYou MUST call hasNext() first, or this value may be invalid.\\n\\n@return string|null\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getFirst(): string\\n\\t{\\n\\t\\t$uri = clone $this->uri;\\n\\n\\t\\tif ($this->segment === 0)\\n\\t\\t{\\n\\t\\t\\t$uri->addQuery('page', 1);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t$uri->setSegment($this->segment, 1);\\n\\t\\t}\\n\\n\\t\\treturn (string) $uri;\\n\\t}\", \"output\": \"Returns the URI of the first page.\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getLast(): string\\n\\t{\\n\\t\\t$uri = clone $this->uri;\\n\\n\\t\\tif ($this->segment === 0)\\n\\t\\t{\\n\\t\\t\\t$uri->addQuery('page', $this->pageCount);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t$uri->setSegment($this->segment, $this->pageCount);\\n\\t\\t}\\n\\n\\t\\treturn (string) $uri;\\n\\t}\", \"output\": \"Returns the URI of the last page.\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getCurrent(): string\\n\\t{\\n\\t\\t$uri = clone $this->uri;\\n\\n\\t\\tif ($this->segment === 0)\\n\\t\\t{\\n\\t\\t\\t$uri->addQuery('page', $this->current);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t$uri->setSegment($this->segment, $this->current);\\n\\t\\t}\\n\\n\\t\\treturn (string) $uri;\\n\\t}\", \"output\": \"Returns the URI of the current page.\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function start(string $name, float $time = null)\\n\\t{\\n\\t\\t$this->timers[strtolower($name)] = [\\n\\t\\t\\t'start' => ! empty($time) ? $time : microtime(true),\\n\\t\\t\\t'end'   => null,\\n\\t\\t];\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Starts a timer running.\\n\\nMultiple calls can be made to this method so that several\\nexecution points can be measured.\\n\\n@param string $name The name of this timer.\\n@param float  $time Allows user to provide time.\\n\\n@return Timer\"}"}
{"text": "{\"input\": \"Summarize the following code: public function stop(string $name)\\n\\t{\\n\\t\\t$name = strtolower($name);\\n\\n\\t\\tif (empty($this->timers[$name]))\\n\\t\\t{\\n\\t\\t\\tthrow new \\\\RuntimeException('Cannot stop timer: invalid name given.');\\n\\t\\t}\\n\\n\\t\\t$this->timers[$name]['end'] = microtime(true);\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Stops a running timer.\\n\\nIf the timer is not stopped before the timers() method is called,\\nit will be automatically stopped at that point.\\n\\n@param string $name The name of this timer.\\n\\n@return Timer\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getElapsedTime(string $name, int $decimals = 4)\\n\\t{\\n\\t\\t$name = strtolower($name);\\n\\n\\t\\tif (empty($this->timers[$name]))\\n\\t\\t{\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\t$timer = $this->timers[$name];\\n\\n\\t\\tif (empty($timer['end']))\\n\\t\\t{\\n\\t\\t\\t$timer['end'] = microtime(true);\\n\\t\\t}\\n\\n\\t\\treturn (float) number_format($timer['end'] - $timer['start'], $decimals);\\n\\t}\", \"output\": \"Returns the duration of a recorded timer.\\n\\n@param string  $name     The name of the timer.\\n@param integer $decimals Number of decimal places.\\n\\n@return null|float       Returns null if timer exists by that name.\\nReturns a float representing the number of\\nseconds elapsed while that timer was running.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getTimers(int $decimals = 4): array\\n\\t{\\n\\t\\t$timers = $this->timers;\\n\\n\\t\\tforeach ($timers as &$timer)\\n\\t\\t{\\n\\t\\t\\tif (empty($timer['end']))\\n\\t\\t\\t{\\n\\t\\t\\t\\t$timer['end'] = microtime(true);\\n\\t\\t\\t}\\n\\n\\t\\t\\t$timer['duration'] = (float) number_format($timer['end'] - $timer['start'], $decimals);\\n\\t\\t}\\n\\n\\t\\treturn $timers;\\n\\t}\", \"output\": \"Returns the array of timers, with the duration pre-calculated for you.\\n\\n@param integer $decimals Number of decimal places\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: public function addTableAlias(string $table)\\n\\t{\\n\\t\\tif (! in_array($table, $this->aliasedTables))\\n\\t\\t{\\n\\t\\t\\t$this->aliasedTables[] = $table;\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Add a table alias to our list.\\n\\n@param string $table\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: public function table($tableName)\\n\\t{\\n\\t\\tif (empty($tableName))\\n\\t\\t{\\n\\t\\t\\tthrow new DatabaseException('You must set the database table to be used with your query.');\\n\\t\\t}\\n\\n\\t\\t$className = str_replace('Connection', 'Builder', get_class($this));\\n\\n\\t\\treturn new $className($tableName, $this);\\n\\t}\", \"output\": \"Returns an instance of the query builder for this connection.\\n\\n@param string|array $tableName\\n\\n@return BaseBuilder\\n@throws DatabaseException\"}"}
{"text": "{\"input\": \"Summarize the following code: public function prepare(\\\\Closure $func, array $options = [])\\n\\t{\\n\\t\\tif (empty($this->connID))\\n\\t\\t{\\n\\t\\t\\t$this->initialize();\\n\\t\\t}\\n\\n\\t\\t$this->pretend(true);\\n\\n\\t\\t$sql = $func($this);\\n\\n\\t\\t$this->pretend(false);\\n\\n\\t\\tif ($sql instanceof QueryInterface)\\n\\t\\t{\\n\\t\\t\\t$sql = $sql->getOriginalQuery();\\n\\t\\t}\\n\\n\\t\\t$class = str_ireplace('Connection', 'PreparedQuery', get_class($this));\\n\\t\\t/**\\n\\t\\t * @var BasePreparedQuery $class\\n\\t\\t */\\n\\t\\t$class = new $class($this);\\n\\n\\t\\treturn $class->prepare($sql, $options);\\n\\t}\", \"output\": \"Creates a prepared statement with the database that can then\\nbe used to execute multiple statements against. Within the\\nclosure, you would build the query in any normal way, though\\nthe Query Builder is the expected manner.\\n\\nExample:\\n$stmt = $db->prepare(function($db)\\n{\\nreturn $db->table('users')\\n->where('id', 1)\\n->get();\\n})\\n\\n@param \\\\Closure $func\\n@param array    $options Passed to the prepare() method\\n\\n@return BasePreparedQuery|null\"}"}
{"text": "{\"input\": \"Summarize the following code: public function escapeIdentifiers($item)\\n\\t{\\n\\t\\tif ($this->escapeChar === '' || empty($item) || in_array($item, $this->reservedIdentifiers))\\n\\t\\t{\\n\\t\\t\\treturn $item;\\n\\t\\t}\\n\\t\\telseif (is_array($item))\\n\\t\\t{\\n\\t\\t\\tforeach ($item as $key => $value)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$item[$key] = $this->escapeIdentifiers($value);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn $item;\\n\\t\\t}\\n\\t\\t// Avoid breaking functions and literal values inside queries\\n\\t\\telseif (ctype_digit($item) || $item[0] === \\\"'\\\" || ( $this->escapeChar !== '\\\"' && $item[0] === '\\\"') ||\\n\\t\\t\\t\\tstrpos($item, '(') !== false\\n\\t\\t)\\n\\t\\t{\\n\\t\\t\\treturn $item;\\n\\t\\t}\\n\\n\\t\\tstatic $preg_ec = [];\\n\\n\\t\\tif (empty($preg_ec))\\n\\t\\t{\\n\\t\\t\\tif (is_array($this->escapeChar))\\n\\t\\t\\t{\\n\\t\\t\\t\\t$preg_ec = [\\n\\t\\t\\t\\t\\tpreg_quote($this->escapeChar[0], '/'),\\n\\t\\t\\t\\t\\tpreg_quote($this->escapeChar[1], '/'),\\n\\t\\t\\t\\t\\t$this->escapeChar[0],\\n\\t\\t\\t\\t\\t$this->escapeChar[1],\\n\\t\\t\\t\\t];\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t$preg_ec[0] = $preg_ec[1] = preg_quote($this->escapeChar, '/');\\n\\t\\t\\t\\t$preg_ec[2] = $preg_ec[3] = $this->escapeChar;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tforeach ($this->reservedIdentifiers as $id)\\n\\t\\t{\\n\\t\\t\\tif (strpos($item, '.' . $id) !== false)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn preg_replace('/' . $preg_ec[0] . '?([^' . $preg_ec[1] . '\\\\.]+)' . $preg_ec[1] . '?\\\\./i', $preg_ec[2] . '$1' . $preg_ec[3] . '.', $item);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn preg_replace('/' . $preg_ec[0] . '?([^' . $preg_ec[1] . '\\\\.]+)' . $preg_ec[1] . '?(\\\\.)?/i', $preg_ec[2] . '$1' . $preg_ec[3] . '$2', $item);\\n\\t}\", \"output\": \"Escape the SQL Identifiers\\n\\nThis function escapes column and table names\\n\\n@param mixed $item\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public function callFunction(string $functionName, ...$params): bool\\n\\t{\\n\\t\\t$driver = ($this->DBDriver === 'postgre' ? 'pg' : strtolower($this->DBDriver)) . '_';\\n\\n\\t\\tif (false === strpos($driver, $functionName))\\n\\t\\t{\\n\\t\\t\\t$functionName = $driver . $functionName;\\n\\t\\t}\\n\\n\\t\\tif (! function_exists($functionName))\\n\\t\\t{\\n\\t\\t\\tif ($this->DBDebug)\\n\\t\\t\\t{\\n\\t\\t\\t\\tthrow new DatabaseException('This feature is not available for the database you are using.');\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\treturn $functionName(...$params);\\n\\t}\", \"output\": \"This function enables you to call PHP database functions that are not natively included\\nin CodeIgniter, in a platform independent manner.\\n\\n@param string $functionName\\n@param array  ...$params\\n\\n@return boolean\\n@throws DatabaseException\"}"}
{"text": "{\"input\": \"Summarize the following code: public function listTables(bool $constrainByPrefix = false)\\n\\t{\\n\\t\\t// Is there a cached result?\\n\\t\\tif (isset($this->dataCache['table_names']) && $this->dataCache['table_names'])\\n\\t\\t{\\n\\t\\t\\treturn $this->dataCache['table_names'];\\n\\t\\t}\\n\\n\\t\\tif (false === ($sql = $this->_listTables($constrainByPrefix)))\\n\\t\\t{\\n\\t\\t\\tif ($this->DBDebug)\\n\\t\\t\\t{\\n\\t\\t\\t\\tthrow new DatabaseException('This feature is not available for the database you are using.');\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t$this->dataCache['table_names'] = [];\\n\\t\\t$query                          = $this->query($sql);\\n\\n\\t\\tforeach ($query->getResultArray() as $row)\\n\\t\\t{\\n\\t\\t\\t// Do we know from which column to get the table name?\\n\\t\\t\\tif (! isset($key))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (isset($row['table_name']))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$key = 'table_name';\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telseif (isset($row['TABLE_NAME']))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$key = 'TABLE_NAME';\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t/* We have no other choice but to just get the first element's key.\\n\\t\\t\\t\\t\\t * Due to array_shift() accepting its argument by reference, if\\n\\t\\t\\t\\t\\t * E_STRICT is on, this would trigger a warning. So we'll have to\\n\\t\\t\\t\\t\\t * assign it first.\\n\\t\\t\\t\\t\\t */\\n\\t\\t\\t\\t\\t$key = array_keys($row);\\n\\t\\t\\t\\t\\t$key = array_shift($key);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t$this->dataCache['table_names'][] = $row[$key];\\n\\t\\t}\\n\\n\\t\\treturn $this->dataCache['table_names'];\\n\\t}\", \"output\": \"Returns an array of table names\\n\\n@param  boolean $constrainByPrefix = FALSE\\n@return boolean|array\\n@throws \\\\CodeIgniter\\\\Database\\\\Exceptions\\\\DatabaseException\"}"}
{"text": "{\"input\": \"Summarize the following code: public function tableExists(string $tableName): bool\\n\\t{\\n\\t\\treturn in_array($this->protectIdentifiers($tableName, true, false, false), $this->listTables());\\n\\t}\", \"output\": \"Determine if a particular table exists\\n\\n@param  string $tableName\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: public function fieldExists(string $fieldName, string $tableName): bool\\n\\t{\\n\\t\\treturn in_array($fieldName, $this->getFieldNames($tableName));\\n\\t}\", \"output\": \"Determine if a particular field exists\\n\\n@param  string   $fieldName\\n@param  string   $tableName\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getFieldData(string $table)\\n\\t{\\n\\t\\t$fields = $this->_fieldData($this->protectIdentifiers($table, true, false, false));\\n\\n\\t\\treturn $fields ?? false;\\n\\t}\", \"output\": \"Returns an object with field data\\n\\n@param  string $table the table name\\n@return array|false\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getIndexData(string $table)\\n\\t{\\n\\t\\t$fields = $this->_indexData($this->protectIdentifiers($table, true, false, false));\\n\\n\\t\\treturn $fields ?? false;\\n\\t}\", \"output\": \"Returns an object with key data\\n\\n@param  string $table the table name\\n@return array|false\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getForeignKeyData(string $table)\\n\\t{\\n\\t\\t$fields = $this->_foreignKeyData($this->protectIdentifiers($table, true, false, false));\\n\\n\\t\\treturn $fields ?? false;\\n\\t}\", \"output\": \"Returns an object with foreign key data\\n\\n@param  string $table the table name\\n@return array|false\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function getEnvValue(string $property, string $prefix, string $shortPrefix)\\n\\t{\\n\\t\\t$shortPrefix = ltrim($shortPrefix, '\\\\\\\\');\\n\\t\\tswitch (true)\\n\\t\\t{\\n\\t\\t\\tcase array_key_exists(\\\"{$shortPrefix}.{$property}\\\", $_ENV):\\n\\t\\t\\t\\treturn $_ENV[\\\"{$shortPrefix}.{$property}\\\"];\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase array_key_exists(\\\"{$shortPrefix}.{$property}\\\", $_SERVER):\\n\\t\\t\\t\\treturn $_SERVER[\\\"{$shortPrefix}.{$property}\\\"];\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase array_key_exists(\\\"{$prefix}.{$property}\\\", $_ENV):\\n\\t\\t\\t\\treturn $_ENV[\\\"{$prefix}.{$property}\\\"];\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase array_key_exists(\\\"{$prefix}.{$property}\\\", $_SERVER):\\n\\t\\t\\t\\treturn $_SERVER[\\\"{$prefix}.{$property}\\\"];\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\t$value = getenv($property);\\n\\t\\t\\t\\treturn $value === false ? null : $value;\\n\\t\\t}\\n\\t}\", \"output\": \"Retrieve an environment-specific configuration setting\\n\\n@param string $property\\n@param string $prefix\\n@param string $shortPrefix\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function registerProperties()\\n\\t{\\n\\t\\tif (! static::$moduleConfig->shouldDiscover('registrars'))\\n\\t\\t{\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (! static::$didDiscovery)\\n\\t\\t{\\n\\t\\t\\t$locator         = \\\\Config\\\\Services::locator();\\n\\t\\t\\t$registrarsFiles = $locator->search('Config/Registrar.php');\\n\\n\\t\\t\\tforeach ($registrarsFiles as $file)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$className = $locator->getClassname($file);\\n\\t\\t\\t\\tstatic::$registrars[] = new $className();\\n\\t\\t\\t}\\n\\n\\t\\t\\tstatic::$didDiscovery = true;\\n\\t\\t}\\n\\n\\t\\t$shortName = (new \\\\ReflectionClass($this))->getShortName();\\n\\n\\t\\t// Check the registrar class for a method named after this class' shortName\\n\\t\\tforeach (static::$registrars as $callable)\\n\\t\\t{\\n\\t\\t\\t// ignore non-applicable registrars\\n\\t\\t\\tif (! method_exists($callable, $shortName))\\n\\t\\t\\t{\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$properties = $callable::$shortName();\\n\\n\\t\\t\\tif (! is_array($properties))\\n\\t\\t\\t{\\n\\t\\t\\t\\tthrow new \\\\RuntimeException('Registrars must return an array of properties and their values.');\\n\\t\\t\\t}\\n\\n\\t\\t\\tforeach ($properties as $property => $value)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (isset($this->$property) && is_array($this->$property) && is_array($value))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$this->$property = array_merge($this->$property, $value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$this->$property = $value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\", \"output\": \"Provides external libraries a simple way to register one or more\\noptions into a config file.\\n\\n@throws \\\\ReflectionException\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function getItem(string $key)\\n\\t{\\n\\t\\tif (! is_file($this->path . $key))\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t$data = unserialize(file_get_contents($this->path . $key));\\n\\n\\t\\tif ($data['ttl'] > 0 && time() > $data['time'] + $data['ttl'])\\n\\t\\t{\\n\\t\\t\\tunlink($this->path . $key);\\n\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\treturn $data;\\n\\t}\", \"output\": \"Does the heavy lifting of actually retrieving the file and\\nverifying it's age.\\n\\n@param string $key\\n\\n@return boolean|mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function writeFile($path, $data, $mode = 'wb')\\n\\t{\\n\\t\\tif (($fp = @fopen($path, $mode)) === false)\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tflock($fp, LOCK_EX);\\n\\n\\t\\tfor ($result = $written = 0, $length = strlen($data); $written < $length; $written += $result)\\n\\t\\t{\\n\\t\\t\\tif (($result = fwrite($fp, substr($data, $written))) === false)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tflock($fp, LOCK_UN);\\n\\t\\tfclose($fp);\\n\\n\\t\\treturn is_int($result);\\n\\t}\", \"output\": \"Writes a file to disk, or returns false if not successful.\\n\\n@param $path\\n@param $data\\n@param string $mode\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function getDirFileInfo(string $source_dir, bool $top_level_only = true, bool $_recursion = false)\\n\\t{\\n\\t\\tstatic $_filedata = [];\\n\\t\\t$relative_path    = $source_dir;\\n\\n\\t\\tif ($fp = @opendir($source_dir))\\n\\t\\t{\\n\\t\\t\\t// reset the array and make sure $source_dir has a trailing slash on the initial call\\n\\t\\t\\tif ($_recursion === false)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$_filedata  = [];\\n\\t\\t\\t\\t$source_dir = rtrim(realpath($source_dir), DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Used to be foreach (scandir($source_dir, 1) as $file), but scandir() is simply not as fast\\n\\t\\t\\twhile (false !== ($file = readdir($fp)))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (is_dir($source_dir . $file) && $file[0] !== '.' && $top_level_only === false)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$this->getDirFileInfo($source_dir . $file . DIRECTORY_SEPARATOR, $top_level_only, true);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telseif ($file[0] !== '.')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$_filedata[$file]                  = $this->getFileInfo($source_dir . $file);\\n\\t\\t\\t\\t\\t$_filedata[$file]['relative_path'] = $relative_path;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tclosedir($fp);\\n\\n\\t\\t\\treturn $_filedata;\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\", \"output\": \"Get Directory File Information\\n\\nReads the specified directory and builds an array containing the filenames,\\nfilesize, dates, and permissions\\n\\nAny sub-folders contained within the specified path are read as well.\\n\\n@param string  $source_dir     Path to source\\n@param boolean $top_level_only Look only at the top level directory specified?\\n@param boolean $_recursion     Internal variable to determine recursion status - do not use in calls\\n\\n@return array|false\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function getFileInfo(string $file, $returned_values = ['name', 'server_path', 'size', 'date'])\\n\\t{\\n\\t\\tif (! is_file($file))\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tif (is_string($returned_values))\\n\\t\\t{\\n\\t\\t\\t$returned_values = explode(',', $returned_values);\\n\\t\\t}\\n\\n\\t\\tforeach ($returned_values as $key)\\n\\t\\t{\\n\\t\\t\\tswitch ($key)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcase 'name':\\n\\t\\t\\t\\t\\t$fileInfo['name'] = basename($file);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase 'server_path':\\n\\t\\t\\t\\t\\t$fileInfo['server_path'] = $file;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase 'size':\\n\\t\\t\\t\\t\\t$fileInfo['size'] = filesize($file);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase 'date':\\n\\t\\t\\t\\t\\t$fileInfo['date'] = filemtime($file);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase 'readable':\\n\\t\\t\\t\\t\\t$fileInfo['readable'] = is_readable($file);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase 'writable':\\n\\t\\t\\t\\t\\t$fileInfo['writable'] = is_writable($file);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase 'executable':\\n\\t\\t\\t\\t\\t$fileInfo['executable'] = is_executable($file);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase 'fileperms':\\n\\t\\t\\t\\t\\t$fileInfo['fileperms'] = fileperms($file);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $fileInfo;\\n\\t}\", \"output\": \"Get File Info\\n\\nGiven a file and path, returns the name, path, size, date modified\\nSecond parameter allows you to explicitly declare what information you want returned\\nOptions are: name, server_path, size, date, readable, writable, executable, fileperms\\nReturns FALSE if the file cannot be found.\\n\\n@param string $file            Path to file\\n@param mixed  $returned_values Array or comma separated string of information returned\\n\\n@return array|false\"}"}
{"text": "{\"input\": \"Summarize the following code: public function initialize()\\n\\t{\\n\\t\\t// Set default timezone on the server\\n\\t\\tdate_default_timezone_set($this->config->appTimezone ?? 'UTC');\\n\\n\\t\\t// Setup Exception Handling\\n\\t\\tServices::exceptions()\\n\\t\\t\\t\\t->initialize();\\n\\n\\t\\t$this->detectEnvironment();\\n\\t\\t$this->bootstrapEnvironment();\\n\\n\\t\\tif (CI_DEBUG)\\n\\t\\t{\\n\\t\\t\\trequire_once SYSTEMPATH . 'ThirdParty/Kint/kint.php';\\n\\t\\t}\\n\\t}\", \"output\": \"Handles some basic app and environment setup.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function run(RouteCollectionInterface $routes = null, bool $returnResponse = false)\\n\\t{\\n\\t\\t$this->startBenchmark();\\n\\n\\t\\t$this->getRequestObject();\\n\\t\\t$this->getResponseObject();\\n\\n\\t\\t$this->forceSecureAccess();\\n\\n\\t\\t$this->spoofRequestMethod();\\n\\n\\t\\tEvents::trigger('pre_system');\\n\\n\\t\\t// Check for a cached page. Execution will stop\\n\\t\\t// if the page has been cached.\\n\\t\\t$cacheConfig = new Cache();\\n\\t\\t$response    = $this->displayCache($cacheConfig);\\n\\t\\tif ($response instanceof ResponseInterface)\\n\\t\\t{\\n\\t\\t\\tif ($returnResponse)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn $response;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$this->response->pretend($this->useSafeOutput)->send();\\n\\t\\t\\t$this->callExit(EXIT_SUCCESS);\\n\\t\\t}\\n\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treturn $this->handleRequest($routes, $cacheConfig, $returnResponse);\\n\\t\\t}\\n\\t\\tcatch (FilterException $e)\\n\\t\\t{\\n\\t\\t\\t$logger = Services::logger();\\n\\t\\t\\t$logger->info('REDIRECTED ROUTE at ' . $e->getMessage());\\n\\n\\t\\t\\t// If the route is a 'redirect' route, it throws\\n\\t\\t\\t// the exception with the $to as the message\\n\\t\\t\\t$this->response->redirect($e->getMessage(), 'auto', $e->getCode());\\n\\t\\t\\t$this->callExit(EXIT_SUCCESS);\\n\\t\\t}\\n\\t\\tcatch (PageNotFoundException $e)\\n\\t\\t{\\n\\t\\t\\t$this->display404errors($e);\\n\\t\\t}\\n\\t}\", \"output\": \"Launch the application!\\n\\nThis is \\\"the loop\\\" if you will. The main entry point into the script\\nthat gets the required class instances, fires off the filters,\\ntries to route the response, loads the controller and generally\\nmakes all of the pieces work together.\\n\\n@param \\\\CodeIgniter\\\\Router\\\\RouteCollectionInterface $routes\\n@param boolean                                      $returnResponse\\n\\n@return boolean|\\\\CodeIgniter\\\\HTTP\\\\RequestInterface|\\\\CodeIgniter\\\\HTTP\\\\Response|\\\\CodeIgniter\\\\HTTP\\\\ResponseInterface|mixed\\n@throws \\\\CodeIgniter\\\\Filters\\\\Exceptions\\\\FilterException\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function startBenchmark()\\n\\t{\\n\\t\\t$this->startTime = microtime(true);\\n\\n\\t\\t$this->benchmark = Services::timer();\\n\\t\\t$this->benchmark->start('total_execution', $this->startTime);\\n\\t\\t$this->benchmark->start('bootstrap');\\n\\t}\", \"output\": \"Start the Benchmark\\n\\nThe timer is used to display total script execution both in the\\ndebug toolbar, and potentially on the displayed page.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function getResponseObject()\\n\\t{\\n\\t\\t$this->response = Services::response($this->config);\\n\\n\\t\\tif (! is_cli() || ENVIRONMENT === 'testing')\\n\\t\\t{\\n\\t\\t\\t$this->response->setProtocolVersion($this->request->getProtocolVersion());\\n\\t\\t}\\n\\n\\t\\t// Assume success until proven otherwise.\\n\\t\\t$this->response->setStatusCode(200);\\n\\t}\", \"output\": \"Get our Response object, and set some default values, including\\nthe HTTP protocol version and a default successful response.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function forceSecureAccess($duration = 31536000)\\n\\t{\\n\\t\\tif ($this->config->forceGlobalSecureRequests !== true)\\n\\t\\t{\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tforce_https($duration, $this->request, $this->response);\\n\\t}\", \"output\": \"Force Secure Site Access? If the config value 'forceGlobalSecureRequests'\\nis true, will enforce that all requests to this site are made through\\nHTTPS. Will redirect the user to the current page with HTTPS, as well\\nas set the HTTP Strict Transport Security header for those browsers\\nthat support it.\\n\\n@param integer $duration How long the Strict Transport Security\\nshould be enforced for this URL.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function displayCache($config)\\n\\t{\\n\\t\\tif ($cachedResponse = cache()->get($this->generateCacheName($config)))\\n\\t\\t{\\n\\t\\t\\t$cachedResponse = unserialize($cachedResponse);\\n\\t\\t\\tif (! is_array($cachedResponse) || ! isset($cachedResponse['output']) || ! isset($cachedResponse['headers']))\\n\\t\\t\\t{\\n\\t\\t\\t\\tthrow new Exception('Error unserializing page cache');\\n\\t\\t\\t}\\n\\n\\t\\t\\t$headers = $cachedResponse['headers'];\\n\\t\\t\\t$output  = $cachedResponse['output'];\\n\\n\\t\\t\\t// Clear all default headers\\n\\t\\t\\tforeach ($this->response->getHeaders() as $key => $val)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$this->response->removeHeader($key);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Set cached headers\\n\\t\\t\\tforeach ($headers as $name => $value)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$this->response->setHeader($name, $value);\\n\\t\\t\\t}\\n\\n\\t\\t\\t$output = $this->displayPerformanceMetrics($output);\\n\\t\\t\\t$this->response->setBody($output);\\n\\n\\t\\t\\treturn $this->response;\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\", \"output\": \"Determines if a response has been cached for the given URI.\\n\\n@param \\\\Config\\\\Cache $config\\n\\n@throws \\\\Exception\\n\\n@return boolean|\\\\CodeIgniter\\\\HTTP\\\\ResponseInterface\"}"}
{"text": "{\"input\": \"Summarize the following code: public function cachePage(Cache $config)\\n\\t{\\n\\t\\t$headers = [];\\n\\t\\tforeach ($this->response->getHeaders() as $header)\\n\\t\\t{\\n\\t\\t\\t$headers[$header->getName()] = $header->getValueLine();\\n\\t\\t}\\n\\n\\t\\treturn cache()->save(\\n\\t\\t\\t\\t\\t\\t$this->generateCacheName($config), serialize(['headers' => $headers, 'output' => $this->output]), static::$cacheTTL\\n\\t\\t);\\n\\t}\", \"output\": \"Caches the full response from the current request. Used for\\nfull-page caching for very high performance.\\n\\n@param \\\\Config\\\\Cache $config\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function generateCacheName($config): string\\n\\t{\\n\\t\\tif (is_cli() && ! (ENVIRONMENT === 'testing'))\\n\\t\\t{\\n\\t\\t\\treturn md5($this->request->getPath());\\n\\t\\t}\\n\\n\\t\\t$uri = $this->request->uri;\\n\\n\\t\\tif ($config->cacheQueryString)\\n\\t\\t{\\n\\t\\t\\t$name = URI::createURIString(\\n\\t\\t\\t\\t\\t\\t\\t$uri->getScheme(), $uri->getAuthority(), $uri->getPath(), $uri->getQuery()\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t$name = URI::createURIString(\\n\\t\\t\\t\\t\\t\\t\\t$uri->getScheme(), $uri->getAuthority(), $uri->getPath()\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\treturn md5($name);\\n\\t}\", \"output\": \"Generates the cache name to use for our full-page caching.\\n\\n@param $config\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function displayPerformanceMetrics(string $output): string\\n\\t{\\n\\t\\t$this->totalTime = $this->benchmark->getElapsedTime('total_execution');\\n\\n\\t\\t$output = str_replace('{elapsed_time}', $this->totalTime, $output);\\n\\n\\t\\treturn $output;\\n\\t}\", \"output\": \"Replaces the memory_usage and elapsed_time tags.\\n\\n@param string $output\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function tryToRouteIt(RouteCollectionInterface $routes = null)\\n\\t{\\n\\t\\tif (empty($routes) || ! $routes instanceof RouteCollectionInterface)\\n\\t\\t{\\n\\t\\t\\trequire APPPATH . 'Config/Routes.php';\\n\\t\\t}\\n\\n\\t\\t// $routes is defined in Config/Routes.php\\n\\t\\t$this->router = Services::router($routes);\\n\\n\\t\\t$path = $this->determinePath();\\n\\n\\t\\t$this->benchmark->stop('bootstrap');\\n\\t\\t$this->benchmark->start('routing');\\n\\n\\t\\tob_start();\\n\\n\\t\\t$this->controller = $this->router->handle($path);\\n\\t\\t$this->method     = $this->router->methodName();\\n\\n\\t\\t// If a {locale} segment was matched in the final route,\\n\\t\\t// then we need to set the correct locale on our Request.\\n\\t\\tif ($this->router->hasLocale())\\n\\t\\t{\\n\\t\\t\\t$this->request->setLocale($this->router->getLocale());\\n\\t\\t}\\n\\n\\t\\t$this->benchmark->stop('routing');\\n\\n\\t\\treturn $this->router->getFilter();\\n\\t}\", \"output\": \"Try to Route It - As it sounds like, works with the router to\\nmatch a route against the current URI. If the route is a\\n\\\"redirect route\\\", will also handle the redirect.\\n\\n@param RouteCollectionInterface $routes An collection interface to use in place\\nof the config file.\\n\\n@return string\\n@throws \\\\CodeIgniter\\\\Router\\\\Exceptions\\\\RedirectException\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function runController($class)\\n\\t{\\n\\t\\tif (method_exists($class, '_remap'))\\n\\t\\t{\\n\\t\\t\\t$output = $class->_remap($this->method, ...$this->router->params());\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t$output = $class->{$this->method}(...$this->router->params());\\n\\t\\t}\\n\\n\\t\\t$this->benchmark->stop('controller');\\n\\n\\t\\treturn $output;\\n\\t}\", \"output\": \"Runs the controller, allowing for _remap methods to function.\\n\\n@param mixed $class\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function gatherOutput($cacheConfig = null, $returned = null)\\n\\t{\\n\\t\\t$this->output = ob_get_contents();\\n\\t\\t// If buffering is not null.\\n\\t\\t// Clean (erase) the output buffer and turn off output buffering\\n\\t\\tif (ob_get_length())\\n\\t\\t{\\n\\t\\t\\tob_end_clean();\\n\\t\\t}\\n\\n\\t\\tif ($returned instanceof DownloadResponse)\\n\\t\\t{\\n\\t\\t\\t$this->response = $returned;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t// If the controller returned a response object,\\n\\t\\t// we need to grab the body from it so it can\\n\\t\\t// be added to anything else that might have been\\n\\t\\t// echoed already.\\n\\t\\t// We also need to save the instance locally\\n\\t\\t// so that any status code changes, etc, take place.\\n\\t\\tif ($returned instanceof Response)\\n\\t\\t{\\n\\t\\t\\t$this->response = $returned;\\n\\t\\t\\t$returned       = $returned->getBody();\\n\\t\\t}\\n\\n\\t\\tif (is_string($returned))\\n\\t\\t{\\n\\t\\t\\t$this->output .= $returned;\\n\\t\\t}\\n\\n\\t\\t// Cache it without the performance metrics replaced\\n\\t\\t// so that we can have live speed updates along the way.\\n\\t\\tif (static::$cacheTTL > 0)\\n\\t\\t{\\n\\t\\t\\t$this->cachePage($cacheConfig);\\n\\t\\t}\\n\\n\\t\\t$this->output = $this->displayPerformanceMetrics($this->output);\\n\\n\\t\\t$this->response->setBody($this->output);\\n\\t}\", \"output\": \"Gathers the script output from the buffer, replaces some execution\\ntime tag in the output and displays the debug toolbar, if required.\\n\\n@param null $cacheConfig\\n@param null $returned\"}"}
{"text": "{\"input\": \"Summarize the following code: public function storePreviousURL($uri)\\n\\t{\\n\\t\\t// This is mainly needed during testing...\\n\\t\\tif (is_string($uri))\\n\\t\\t{\\n\\t\\t\\t$uri = new URI($uri);\\n\\t\\t}\\n\\n\\t\\tif (isset($_SESSION))\\n\\t\\t{\\n\\t\\t\\t$_SESSION['_ci_previous_url'] = (string) $uri;\\n\\t\\t}\\n\\t}\", \"output\": \"If we have a session object to use, store the current URI\\nas the previous URI. This is called just prior to sending the\\nresponse to the client, and will make it available next request.\\n\\nThis helps provider safer, more reliable previous_url() detection.\\n\\n@param \\\\CodeIgniter\\\\HTTP\\\\URI $uri\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function getHandler($config, string $handler = null, string $backup = null)\\n\\t{\\n\\t\\tif (! isset($config->validHandlers) || ! is_array($config->validHandlers))\\n\\t\\t{\\n\\t\\t\\tthrow CacheException::forInvalidHandlers();\\n\\t\\t}\\n\\n\\t\\tif (! isset($config->handler) || ! isset($config->backupHandler))\\n\\t\\t{\\n\\t\\t\\tthrow CacheException::forNoBackup();\\n\\t\\t}\\n\\n\\t\\t$handler = ! empty($handler) ? $handler : $config->handler;\\n\\t\\t$backup  = ! empty($backup) ? $backup : $config->backupHandler;\\n\\n\\t\\tif (! array_key_exists($handler, $config->validHandlers) || ! array_key_exists($backup, $config->validHandlers))\\n\\t\\t{\\n\\t\\t\\tthrow CacheException::forHandlerNotFound();\\n\\t\\t}\\n\\n\\t\\t// Get an instance of our handler.\\n\\t\\t$adapter = new $config->validHandlers[$handler]($config);\\n\\n\\t\\tif (! $adapter->isSupported())\\n\\t\\t{\\n\\t\\t\\t$adapter = new $config->validHandlers[$backup]($config);\\n\\n\\t\\t\\tif (! $adapter->isSupported())\\n\\t\\t\\t{\\n\\t\\t\\t\\t// Log stuff here, don't throw exception. No need to raise a fuss.\\n\\t\\t\\t\\t// Fall back to the dummy adapter.\\n\\t\\t\\t\\t$adapter = new $config->validHandlers['dummy']();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t$adapter->initialize();\\n\\n\\t\\treturn $adapter;\\n\\t}\", \"output\": \"Attempts to create the desired cache handler, based upon the\\n\\n@param $config\\n@param string $handler\\n@param string $backup\\n\\n@return \\\\CodeIgniter\\\\Cache\\\\CacheInterface\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function createAliasFromTable(string $item): string\\n\\t{\\n\\t\\tif (strpos($item, '.') !== false)\\n\\t\\t{\\n\\t\\t\\t$item = explode('.', $item);\\n\\n\\t\\t\\treturn end($item);\\n\\t\\t}\\n\\n\\t\\treturn $item;\\n\\t}\", \"output\": \"Determines the alias name based on the table\\n\\n@param string $item\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function whereNotIn(string $key = null, array $values = null, bool $escape = null)\\n\\t{\\n\\t\\treturn $this->_whereIn($key, $values, true, 'AND ', $escape);\\n\\t}\", \"output\": \"WHERE NOT IN\\n\\nGenerates a WHERE field NOT IN('item', 'item') SQL query,\\njoined with 'AND' if appropriate.\\n\\n@param string  $key    The field to search\\n@param array   $values The values searched on\\n@param boolean $escape\\n\\n@return BaseBuilder\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function _whereIn(string $key = null, array $values = null, bool $not = false, string $type = 'AND ', bool $escape = null)\\n\\t{\\n\\t\\tif ($key === null || $values === null)\\n\\t\\t{\\n\\t\\t\\treturn $this;\\n\\t\\t}\\n\\n\\t\\tis_bool($escape) || $escape = $this->db->protectIdentifiers;\\n\\n\\t\\t$ok = $key;\\n\\n\\t\\tif ($escape === true)\\n\\t\\t{\\n\\t\\t\\t$key = $this->db->protectIdentifiers($key);\\n\\t\\t}\\n\\n\\t\\t$not = ($not) ? ' NOT' : '';\\n\\n\\t\\t$where_in = array_values($values);\\n\\t\\t$ok       = $this->setBind($ok, $where_in, $escape);\\n\\n\\t\\t$prefix = empty($this->QBWhere) ? $this->groupGetType('') : $this->groupGetType($type);\\n\\n\\t\\t$where_in = [\\n\\t\\t\\t'condition' => $prefix . $key . $not . \\\" IN :{$ok}:\\\",\\n\\t\\t\\t'escape'    => false,\\n\\t\\t];\\n\\n\\t\\t$this->QBWhere[] = $where_in;\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Internal WHERE IN\\n\\n@used-by WhereIn()\\n@used-by orWhereIn()\\n@used-by whereNotIn()\\n@used-by orWhereNotIn()\\n\\n@param string  $key    The field to search\\n@param array   $values The values searched on\\n@param boolean $not    If the statement would be IN or NOT IN\\n@param string  $type\\n@param boolean $escape\\n\\n@return BaseBuilder\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function _like_statement(string $prefix = null, string $column, string $not = null, string $bind, bool $insensitiveSearch = false): string\\n\\t{\\n\\t\\t$like_statement = \\\"{$prefix} {$column} {$not} LIKE :{$bind}:\\\";\\n\\n\\t\\tif ($insensitiveSearch === true)\\n\\t\\t{\\n\\t\\t\\t$like_statement = \\\"{$prefix} LOWER({$column}) {$not} LIKE :{$bind}:\\\";\\n\\t\\t}\\n\\n\\t\\treturn $like_statement;\\n\\t}\", \"output\": \"Platform independent LIKE statement builder.\\n\\n@param string    $prefix\\n@param string    $column\\n@param string    $not\\n@param string    $bind\\n@param boolean   $insensitiveSearch\\n\\n@return string     $like_statement\"}"}
{"text": "{\"input\": \"Summarize the following code: public function groupStart(string $not = '', string $type = 'AND ')\\n\\t{\\n\\t\\t$type = $this->groupGetType($type);\\n\\n\\t\\t$this->QBWhereGroupStarted = true;\\n\\t\\t$prefix                    = empty($this->QBWhere) ? '' : $type;\\n\\t\\t$where                     = [\\n\\t\\t\\t'condition' => $prefix . $not . str_repeat(' ', ++ $this->QBWhereGroupCount) . ' (',\\n\\t\\t\\t'escape'    => false,\\n\\t\\t];\\n\\n\\t\\t$this->QBWhere[] = $where;\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Starts a query group.\\n\\n@param string $not  (Internal use only)\\n@param string $type (Internal use only)\\n\\n@return BaseBuilder\"}"}
{"text": "{\"input\": \"Summarize the following code: public function groupEnd()\\n\\t{\\n\\t\\t$this->QBWhereGroupStarted = false;\\n\\t\\t$where                     = [\\n\\t\\t\\t'condition' => str_repeat(' ', $this->QBWhereGroupCount -- ) . ')',\\n\\t\\t\\t'escape'    => false,\\n\\t\\t];\\n\\n\\t\\t$this->QBWhere[] = $where;\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Ends a query group\\n\\n@return BaseBuilder\"}"}
{"text": "{\"input\": \"Summarize the following code: public function offset(int $offset)\\n\\t{\\n\\t\\tif (! empty($offset))\\n\\t\\t{\\n\\t\\t\\t$this->QBOffset = (int) $offset;\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Sets the OFFSET value\\n\\n@param integer $offset OFFSET value\\n\\n@return BaseBuilder\"}"}
{"text": "{\"input\": \"Summarize the following code: public function set($key, string $value = '', bool $escape = null)\\n\\t{\\n\\t\\t$key = $this->objectToArray($key);\\n\\n\\t\\tif (! is_array($key))\\n\\t\\t{\\n\\t\\t\\t$key = [$key => $value];\\n\\t\\t}\\n\\n\\t\\t$escape = is_bool($escape) ? $escape : $this->db->protectIdentifiers;\\n\\n\\t\\tforeach ($key as $k => $v)\\n\\t\\t{\\n\\t\\t\\tif ($escape)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$bind = $this->setBind($k, $v, $escape);\\n\\t\\t\\t\\t$this->QBSet[$this->db->protectIdentifiers($k, false, $escape)] = \\\":$bind:\\\";\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t$this->QBSet[$this->db->protectIdentifiers($k, false, $escape)] = $v;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"The \\\"set\\\" function.\\n\\nAllows key/value pairs to be set for insert(), update() or replace().\\n\\n@param string|array|object $key    Field name, or an array of field/value pairs\\n@param string              $value  Field value, if $key is a single field\\n@param boolean             $escape Whether to escape values and identifiers\\n\\n@return BaseBuilder\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getCompiledSelect(bool $reset = true): string\\n\\t{\\n\\t\\t$select = $this->compileSelect();\\n\\n\\t\\tif ($reset === true)\\n\\t\\t{\\n\\t\\t\\t$this->resetSelect();\\n\\t\\t}\\n\\n\\t\\treturn $this->compileFinalQuery($select);\\n\\t}\", \"output\": \"Get SELECT query string\\n\\nCompiles a SELECT query string and returns the sql.\\n\\n@param boolean $reset TRUE: resets QB values; FALSE: leave QB values alone\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function compileFinalQuery(string $sql): string\\n\\t{\\n\\t\\t$query = new Query($this->db);\\n\\t\\t$query->setQuery($sql, $this->binds, false);\\n\\n\\t\\tif (! empty($this->db->swapPre) && ! empty($this->db->DBPrefix))\\n\\t\\t{\\n\\t\\t\\t$query->swapPrefix($this->db->DBPrefix, $this->db->swapPre);\\n\\t\\t}\\n\\n\\t\\treturn $query->getQuery();\\n\\t}\", \"output\": \"Returns a finalized, compiled query string with the bindings\\ninserted and prefixes swapped out.\\n\\n@param string $sql\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function countAll(bool $reset = true, bool $test = false)\\n\\t{\\n\\t\\t$table = $this->QBFrom[0];\\n\\n\\t\\t$sql = $this->countString . $this->db->escapeIdentifiers('numrows') . ' FROM ' .\\n\\t\\t\\t\\t$this->db->protectIdentifiers($table, true, null, false);\\n\\n\\t\\tif ($test)\\n\\t\\t{\\n\\t\\t\\treturn $sql;\\n\\t\\t}\\n\\n\\t\\t$query = $this->db->query($sql, null, false);\\n\\t\\tif (empty($query->getResult()))\\n\\t\\t{\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\t$query = $query->getRow();\\n\\n\\t\\tif ($reset === true)\\n\\t\\t{\\n\\t\\t\\t$this->resetSelect();\\n\\t\\t}\\n\\n\\t\\treturn (int) $query->numrows;\\n\\t}\", \"output\": \"\\\"Count All\\\" query\\n\\nGenerates a platform-specific query string that counts all records in\\nthe specified database\\n\\n@param boolean $reset Are we want to clear query builder values?\\n@param boolean $test  Are we running automated tests?\\n\\n@return integer|string when $test = true\"}"}
{"text": "{\"input\": \"Summarize the following code: public function countAllResults(bool $reset = true, bool $test = false)\\n\\t{\\n\\t\\t// ORDER BY usage is often problematic here (most notably\\n\\t\\t// on Microsoft SQL Server) and ultimately unnecessary\\n\\t\\t// for selecting COUNT(*) ...\\n\\t\\t$orderBy = [];\\n\\t\\tif (! empty($this->QBOrderBy))\\n\\t\\t{\\n\\t\\t\\t$orderBy         = $this->QBOrderBy;\\n\\t\\t\\t$this->QBOrderBy = null;\\n\\t\\t}\\n\\n\\t\\t$sql = ($this->QBDistinct === true)\\n\\t\\t\\t?\\n\\t\\t\\t$this->countString . $this->db->protectIdentifiers('numrows') . \\\"\\\\nFROM (\\\\n\\\" . $this->compileSelect() . \\\"\\\\n) CI_count_all_results\\\"\\n\\t\\t\\t:\\n\\t\\t\\t$this->compileSelect($this->countString . $this->db->protectIdentifiers('numrows'));\\n\\n\\t\\tif ($test)\\n\\t\\t{\\n\\t\\t\\treturn $sql;\\n\\t\\t}\\n\\n\\t\\t$result = $this->db->query($sql, $this->binds, false);\\n\\n\\t\\tif ($reset === true)\\n\\t\\t{\\n\\t\\t\\t$this->resetSelect();\\n\\t\\t}\\n\\t\\t// If we've previously reset the QBOrderBy values, get them back\\n\\t\\telseif (! isset($this->QBOrderBy))\\n\\t\\t{\\n\\t\\t\\t$this->QBOrderBy = $orderBy ?? [];\\n\\t\\t}\\n\\n\\t\\t$row = (! $result instanceof ResultInterface)\\n\\t\\t\\t? null\\n\\t\\t\\t: $result->getRow();\\n\\n\\t\\tif (empty($row))\\n\\t\\t{\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\treturn (int) $row->numrows;\\n\\t}\", \"output\": \"\\\"Count All Results\\\" query\\n\\nGenerates a platform-specific query string that counts all records\\nreturned by an Query Builder query.\\n\\n@param boolean $reset\\n@param boolean $test  The reset clause\\n\\n@return integer|string when $test = true\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function _insertBatch(string $table, array $keys, array $values): string\\n\\t{\\n\\t\\treturn 'INSERT INTO ' . $table . ' (' . implode(', ', $keys) . ') VALUES ' . implode(', ', $values);\\n\\t}\", \"output\": \"Insert batch statement\\n\\nGenerates a platform-specific insert string from the supplied data.\\n\\n@param string $table  Table name\\n@param array  $keys   INSERT keys\\n@param array  $values INSERT values\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getCompiledInsert(bool $reset = true): string\\n\\t{\\n\\t\\tif ($this->validateInsert() === false)\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t$sql = $this->_insert(\\n\\t\\t\\t\\t$this->db->protectIdentifiers(\\n\\t\\t\\t\\t\\t\\t$this->QBFrom[0], true, null, false\\n\\t\\t\\t\\t), array_keys($this->QBSet), array_values($this->QBSet)\\n\\t\\t);\\n\\n\\t\\tif ($reset === true)\\n\\t\\t{\\n\\t\\t\\t$this->resetWrite();\\n\\t\\t}\\n\\n\\t\\treturn $this->compileFinalQuery($sql);\\n\\t}\", \"output\": \"Get INSERT query string\\n\\nCompiles an insert query and returns the sql\\n\\n@param boolean $reset TRUE: reset QB values; FALSE: leave QB values alone\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getCompiledUpdate(bool $reset = true): string\\n\\t{\\n\\t\\tif ($this->validateUpdate() === false)\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t$sql = $this->_update($this->QBFrom[0], $this->QBSet);\\n\\n\\t\\tif ($reset === true)\\n\\t\\t{\\n\\t\\t\\t$this->resetWrite();\\n\\t\\t}\\n\\n\\t\\treturn $this->compileFinalQuery($sql);\\n\\t}\", \"output\": \"Get UPDATE query string\\n\\nCompiles an update query and returns the sql\\n\\n@param boolean $reset TRUE: reset QB values; FALSE: leave QB values alone\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getCompiledDelete(bool $reset = true): string\\n\\t{\\n\\t\\t$table = $this->QBFrom[0];\\n\\n\\t\\t$sql = $this->delete($table, '', $reset, true);\\n\\n\\t\\treturn $this->compileFinalQuery($sql);\\n\\t}\", \"output\": \"Get DELETE query string\\n\\nCompiles a delete query string and returns the sql\\n\\n@param boolean $reset TRUE: reset QB values; FALSE: leave QB values alone\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function decrement(string $column, int $value = 1)\\n\\t{\\n\\t\\t$column = $this->db->protectIdentifiers($column);\\n\\n\\t\\t$sql = $this->_update($this->QBFrom[0], [$column => \\\"{$column}-{$value}\\\"]);\\n\\n\\t\\treturn $this->db->query($sql, $this->binds, false);\\n\\t}\", \"output\": \"Decrements a numeric column by the specified value.\\n\\n@param string  $column\\n@param integer $value\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function compileSelect($select_override = false): string\\n\\t{\\n\\t\\t// Write the \\\"select\\\" portion of the query\\n\\t\\tif ($select_override !== false)\\n\\t\\t{\\n\\t\\t\\t$sql = $select_override;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t$sql = ( ! $this->QBDistinct) ? 'SELECT ' : 'SELECT DISTINCT ';\\n\\n\\t\\t\\tif (empty($this->QBSelect))\\n\\t\\t\\t{\\n\\t\\t\\t\\t$sql .= '*';\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t// Cycle through the \\\"select\\\" portion of the query and prep each column name.\\n\\t\\t\\t\\t// The reason we protect identifiers here rather than in the select() function\\n\\t\\t\\t\\t// is because until the user calls the from() function we don't know if there are aliases\\n\\t\\t\\t\\tforeach ($this->QBSelect as $key => $val)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$no_escape            = $this->QBNoEscape[$key] ?? null;\\n\\t\\t\\t\\t\\t$this->QBSelect[$key] = $this->db->protectIdentifiers($val, false, $no_escape);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t$sql .= implode(', ', $this->QBSelect);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Write the \\\"FROM\\\" portion of the query\\n\\t\\tif (! empty($this->QBFrom))\\n\\t\\t{\\n\\t\\t\\t$sql .= \\\"\\\\nFROM \\\" . $this->_fromTables();\\n\\t\\t}\\n\\n\\t\\t// Write the \\\"JOIN\\\" portion of the query\\n\\t\\tif (! empty($this->QBJoin))\\n\\t\\t{\\n\\t\\t\\t$sql .= \\\"\\\\n\\\" . implode(\\\"\\\\n\\\", $this->QBJoin);\\n\\t\\t}\\n\\n\\t\\t$sql .= $this->compileWhereHaving('QBWhere')\\n\\t\\t\\t\\t. $this->compileGroupBy()\\n\\t\\t\\t\\t. $this->compileWhereHaving('QBHaving')\\n\\t\\t\\t\\t. $this->compileOrderBy(); // ORDER BY\\n\\t\\t// LIMIT\\n\\t\\tif ($this->QBLimit)\\n\\t\\t{\\n\\t\\t\\treturn $this->_limit($sql . \\\"\\\\n\\\");\\n\\t\\t}\\n\\n\\t\\treturn $sql;\\n\\t}\", \"output\": \"Compile the SELECT statement\\n\\nGenerates a query string based on which functions were used.\\nShould not be called directly.\\n\\n@param mixed $select_override\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function compileWhereHaving(string $qb_key): string\\n\\t{\\n\\t\\tif (! empty($this->$qb_key))\\n\\t\\t{\\n\\t\\t\\tfor ($i = 0, $c = count($this->$qb_key); $i < $c; $i ++)\\n\\t\\t\\t{\\n\\t\\t\\t\\t// Is this condition already compiled?\\n\\t\\t\\t\\tif (is_string($this->{$qb_key}[$i]))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telseif ($this->{$qb_key}[$i]['escape'] === false)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$this->{$qb_key}[$i] = $this->{$qb_key}[$i]['condition'];\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Split multiple conditions\\n\\t\\t\\t\\t$conditions = preg_split(\\n\\t\\t\\t\\t\\t\\t'/((?:^|\\\\s+)AND\\\\s+|(?:^|\\\\s+)OR\\\\s+)/i', $this->{$qb_key}[$i]['condition'], -1, PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\tfor ($ci = 0, $cc = count($conditions); $ci < $cc; $ci ++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (($op = $this->getOperator($conditions[$ci])) === false\\n\\t\\t\\t\\t\\t\\t\\t|| ! preg_match('/^(\\\\(?)(.*)(' . preg_quote($op, '/') . ')\\\\s*(.*(?<!\\\\)))?(\\\\)?)$/i', $conditions[$ci], $matches)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// $matches = array(\\n\\t\\t\\t\\t\\t//\\t0 => '(test <= foo)',\\t/* the whole thing */\\n\\t\\t\\t\\t\\t//\\t1 => '(',\\t\\t/* optional */\\n\\t\\t\\t\\t\\t//\\t2 => 'test',\\t\\t/* the field name */\\n\\t\\t\\t\\t\\t//\\t3 => ' <= ',\\t\\t/* $op */\\n\\t\\t\\t\\t\\t//\\t4 => 'foo',\\t\\t/* optional, if $op is e.g. 'IS NULL' */\\n\\t\\t\\t\\t\\t//\\t5 => ')'\\t\\t/* optional */\\n\\t\\t\\t\\t\\t// );\\n\\n\\t\\t\\t\\t\\tif (! empty($matches[4]))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t$matches[4] = ' ' . $matches[4];\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t$conditions[$ci] = $matches[1] . $this->db->protectIdentifiers(trim($matches[2]))\\n\\t\\t\\t\\t\\t\\t\\t. ' ' . trim($matches[3]) . $matches[4] . $matches[5];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t$this->{$qb_key}[$i] = implode('', $conditions);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ($qb_key === 'QBHaving' ? \\\"\\\\nHAVING \\\" : \\\"\\\\nWHERE \\\")\\n\\t\\t\\t\\t\\t. implode(\\\"\\\\n\\\", $this->$qb_key);\\n\\t\\t}\\n\\n\\t\\treturn '';\\n\\t}\", \"output\": \"Compile WHERE, HAVING statements\\n\\nEscapes identifiers in WHERE and HAVING statements at execution time.\\n\\nRequired so that aliases are tracked properly, regardless of whether\\nwhere(), orWhere(), having(), orHaving are called prior to from(),\\njoin() and prefixTable is added only if needed.\\n\\n@param string $qb_key 'QBWhere' or 'QBHaving'\\n\\n@return string    SQL statement\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function compileGroupBy(): string\\n\\t{\\n\\t\\tif (! empty($this->QBGroupBy))\\n\\t\\t{\\n\\t\\t\\tfor ($i = 0, $c = count($this->QBGroupBy); $i < $c; $i ++)\\n\\t\\t\\t{\\n\\t\\t\\t\\t// Is it already compiled?\\n\\t\\t\\t\\tif (is_string($this->QBGroupBy[$i]))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t$this->QBGroupBy[$i] = ($this->QBGroupBy[$i]['escape'] === false ||\\n\\t\\t\\t\\t\\t\\t$this->isLiteral($this->QBGroupBy[$i]['field'])) ? $this->QBGroupBy[$i]['field'] : $this->db->protectIdentifiers($this->QBGroupBy[$i]['field']);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn \\\"\\\\nGROUP BY \\\" . implode(', ', $this->QBGroupBy);\\n\\t\\t}\\n\\n\\t\\treturn '';\\n\\t}\", \"output\": \"Compile GROUP BY\\n\\nEscapes identifiers in GROUP BY statements at execution time.\\n\\nRequired so that aliases are tracked properly, regardless of whether\\ngroupBy() is called prior to from(), join() and prefixTable is added\\nonly if needed.\\n\\n@return string    SQL statement\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function compileOrderBy(): string\\n\\t{\\n\\t\\tif (is_array($this->QBOrderBy) && ! empty($this->QBOrderBy))\\n\\t\\t{\\n\\t\\t\\tfor ($i = 0, $c = count($this->QBOrderBy); $i < $c; $i ++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif ($this->QBOrderBy[$i]['escape'] !== false && ! $this->isLiteral($this->QBOrderBy[$i]['field']))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$this->QBOrderBy[$i]['field'] = $this->db->protectIdentifiers($this->QBOrderBy[$i]['field']);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t$this->QBOrderBy[$i] = $this->QBOrderBy[$i]['field'] . $this->QBOrderBy[$i]['direction'];\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn $this->QBOrderBy = \\\"\\\\nORDER BY \\\" . implode(', ', $this->QBOrderBy);\\n\\t\\t}\\n\\t\\telseif (is_string($this->QBOrderBy))\\n\\t\\t{\\n\\t\\t\\treturn $this->QBOrderBy;\\n\\t\\t}\\n\\n\\t\\treturn '';\\n\\t}\", \"output\": \"Compile ORDER BY\\n\\nEscapes identifiers in ORDER BY statements at execution time.\\n\\nRequired so that aliases are tracked properly, regardless of whether\\norderBy() is called prior to from(), join() and prefixTable is added\\nonly if needed.\\n\\n@return string    SQL statement\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function getOperator(string $str, bool $list = false)\\n\\t{\\n\\t\\tstatic $_operators;\\n\\n\\t\\tif (empty($_operators))\\n\\t\\t{\\n\\t\\t\\t$_les       = ($this->db->likeEscapeStr !== '') ? '\\\\s+' . preg_quote(trim(sprintf($this->db->likeEscapeStr, $this->db->likeEscapeChar)), '/') : '';\\n\\t\\t\\t$_operators = [\\n\\t\\t\\t\\t'\\\\s*(?:<|>|!)?=\\\\s*', // =, <=, >=, !=\\n\\t\\t\\t\\t'\\\\s*<>?\\\\s*', // <, <>\\n\\t\\t\\t\\t'\\\\s*>\\\\s*', // >\\n\\t\\t\\t\\t'\\\\s+IS NULL', // IS NULL\\n\\t\\t\\t\\t'\\\\s+IS NOT NULL', // IS NOT NULL\\n\\t\\t\\t\\t'\\\\s+EXISTS\\\\s*\\\\(.*\\\\)', // EXISTS(sql)\\n\\t\\t\\t\\t'\\\\s+NOT EXISTS\\\\s*\\\\(.*\\\\)', // NOT EXISTS(sql)\\n\\t\\t\\t\\t'\\\\s+BETWEEN\\\\s+', // BETWEEN value AND value\\n\\t\\t\\t\\t'\\\\s+IN\\\\s*\\\\(.*\\\\)', // IN(list)\\n\\t\\t\\t\\t'\\\\s+NOT IN\\\\s*\\\\(.*\\\\)', // NOT IN (list)\\n\\t\\t\\t\\t'\\\\s+LIKE\\\\s+\\\\S.*(' . $_les . ')?', // LIKE 'expr'[ ESCAPE '%s']\\n\\t\\t\\t\\t'\\\\s+NOT LIKE\\\\s+\\\\S.*(' . $_les . ')?', // NOT LIKE 'expr'[ ESCAPE '%s']\\n\\t\\t\\t];\\n\\t\\t}\\n\\n\\t\\treturn preg_match_all('/' . implode('|', $_operators) . '/i', $str, $match) ? ($list ? $match[0] : $match[0][count($match[0]) - 1]) : false;\\n\\t}\", \"output\": \"Returns the SQL string operator\\n\\n@param string  $str\\n@param boolean $list\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function renderTimeline(array $collectors, $startTime, int $segmentCount, int $segmentDuration, array &$styles): string\\n\\t{\\n\\t\\t$displayTime = $segmentCount * $segmentDuration;\\n\\t\\t$rows = $this->collectTimelineData($collectors);\\n\\t\\t$output = '';\\n\\t\\t$styleCount = 0;\\n\\n\\t\\tforeach ($rows as $row)\\n\\t\\t{\\n\\t\\t\\t$output .= '<tr>';\\n\\t\\t\\t$output .= \\\"<td>{$row['name']}</td>\\\";\\n\\t\\t\\t$output .= \\\"<td>{$row['component']}</td>\\\";\\n\\t\\t\\t$output .= \\\"<td class='debug-bar-alignRight'>\\\" . number_format($row['duration'] * 1000, 2) . ' ms</td>';\\n\\t\\t\\t$output .= \\\"<td class='debug-bar-noverflow' colspan='{$segmentCount}'>\\\";\\n\\n\\t\\t\\t$offset = ((($row['start'] - $startTime) * 1000) / $displayTime) * 100;\\n\\t\\t\\t$length = (($row['duration'] * 1000) / $displayTime) * 100;\\n\\n\\t\\t\\t$styles['debug-bar-timeline-' . $styleCount] = \\\"left: {$offset}%; width: {$length}%;\\\";\\n\\t\\t\\t$output .= \\\"<span class='timer debug-bar-timeline-{$styleCount}' title='\\\" . number_format($length, 2) . \\\"%'></span>\\\";\\n\\t\\t\\t$output .= '</td>';\\n\\t\\t\\t$output .= '</tr>';\\n\\n\\t\\t\\t$styleCount++;\\n\\t\\t}\\n\\n\\t\\treturn $output;\\n\\t}\", \"output\": \"Called within the view to display the timeline itself.\\n\\n@param array   $collectors\\n@param float   $startTime\\n@param integer $segmentCount\\n@param integer $segmentDuration\\n@param array   $styles\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function collectTimelineData($collectors): array\\n\\t{\\n\\t\\t$data = [];\\n\\n\\t\\t// Collect it\\n\\t\\tforeach ($collectors as $collector)\\n\\t\\t{\\n\\t\\t\\tif (! $collector['hasTimelineData'])\\n\\t\\t\\t{\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$data = array_merge($data, $collector['timelineData']);\\n\\t\\t}\\n\\n\\t\\t// Sort it\\n\\n\\t\\treturn $data;\\n\\t}\", \"output\": \"Returns a sorted array of timeline data arrays from the collectors.\\n\\n@param array $collectors\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function collectVarData(): array\\n\\t{\\n\\t\\t$data = [];\\n\\n\\t\\tforeach ($this->collectors as $collector)\\n\\t\\t{\\n\\t\\t\\tif (! $collector->hasVarData())\\n\\t\\t\\t{\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$data = array_merge($data, $collector->getVarData());\\n\\t\\t}\\n\\n\\t\\treturn $data;\\n\\t}\", \"output\": \"Returns an array of data from all of the modules\\nthat should be displayed in the 'Vars' tab.\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function roundTo(float $number, int $increments = 5): float\\n\\t{\\n\\t\\t$increments = 1 / $increments;\\n\\n\\t\\treturn (ceil($number * $increments) / $increments);\\n\\t}\", \"output\": \"Rounds a number to the nearest incremental value.\\n\\n@param float   $number\\n@param integer $increments\\n\\n@return float\"}"}
{"text": "{\"input\": \"Summarize the following code: public function copy(string $targetPath, string $targetName = null, int $perms = 0644): bool\\n\\t{\\n\\t\\t$targetPath = rtrim($targetPath, '/ ') . '/';\\n\\n\\t\\t$targetName = is_null($targetName) ? $this->getFilename() : $targetName;\\n\\n\\t\\tif (empty($targetName))\\n\\t\\t{\\n\\t\\t\\tthrow ImageException::forInvalidFile($targetName);\\n\\t\\t}\\n\\n\\t\\tif (! is_dir($targetPath))\\n\\t\\t{\\n\\t\\t\\tmkdir($targetName, 0755, true);\\n\\t\\t}\\n\\n\\t\\tif (! copy($this->getPathname(), \\\"{$targetPath}{$targetName}\\\"))\\n\\t\\t{\\n\\t\\t\\tthrow ImageException::forCopyError($targetPath);\\n\\t\\t}\\n\\n\\t\\tchmod(\\\"{$targetPath}/{$targetName}\\\", $perms);\\n\\n\\t\\treturn true;\\n\\t}\", \"output\": \"Makes a copy of itself to the new location. If no filename is provided\\nit will use the existing filename.\\n\\n@param string      $targetPath The directory to store the file in\\n@param string|null $targetName The new name of the copied file.\\n@param integer     $perms      File permissions to be applied after copy.\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getProperties(bool $return = false)\\n\\t{\\n\\t\\t$path = $this->getPathname();\\n\\n\\t\\t$vals  = getimagesize($path);\\n\\t\\t$types = [\\n\\t\\t\\t1 => 'gif',\\n\\t\\t\\t2 => 'jpeg',\\n\\t\\t\\t3 => 'png',\\n\\t\\t];\\n\\n\\t\\t$mime = 'image/' . ($types[$vals[2]] ?? 'jpg');\\n\\n\\t\\tif ($return === true)\\n\\t\\t{\\n\\t\\t\\treturn [\\n\\t\\t\\t\\t'width'      => $vals[0],\\n\\t\\t\\t\\t'height'     => $vals[1],\\n\\t\\t\\t\\t'image_type' => $vals[2],\\n\\t\\t\\t\\t'size_str'   => $vals[3],\\n\\t\\t\\t\\t'mime_type'  => $mime,\\n\\t\\t\\t];\\n\\t\\t}\\n\\n\\t\\t$this->origWidth  = $vals[0];\\n\\t\\t$this->origHeight = $vals[1];\\n\\t\\t$this->imageType  = $vals[2];\\n\\t\\t$this->sizeStr    = $vals[3];\\n\\t\\t$this->mime       = $mime;\\n\\n\\t\\treturn true;\\n\\t}\", \"output\": \"Get image properties\\n\\nA helper function that gets info about the file\\n\\n@param boolean $return\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function releaseLock(): bool\\n\\t{\\n\\t\\tif (! $this->lock)\\n\\t\\t{\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tif ($this->platform === 'mysql')\\n\\t\\t{\\n\\t\\t\\tif ($this->db->query(\\\"SELECT RELEASE_LOCK('{$this->lock}') AS ci_session_lock\\\")->getRow()->ci_session_lock)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$this->lock = false;\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn $this->fail();\\n\\t\\t}\\n\\t\\telseif ($this->platform === 'postgre')\\n\\t\\t{\\n\\t\\t\\tif ($this->db->simpleQuery(\\\"SELECT pg_advisory_unlock({$this->lock})\\\"))\\n\\t\\t\\t{\\n\\t\\t\\t\\t$this->lock = false;\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn $this->fail();\\n\\t\\t}\\n\\n\\t\\t// Unsupported DB? Let the parent handle the simple version.\\n\\t\\treturn parent::releaseLock();\\n\\t}\", \"output\": \"Releases the lock, if any.\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: public function attachHoneypot(ResponseInterface $response)\\n\\t{\\n\\t\\t$prep_field = $this->prepareTemplate($this->config->template);\\n\\n\\t\\t$body = $response->getBody();\\n\\t\\t$body = str_ireplace('</form>', $prep_field, $body);\\n\\t\\t$response->setBody($body);\\n\\t}\", \"output\": \"Attaches Honeypot template to response.\\n\\n@param \\\\CodeIgniter\\\\HTTP\\\\ResponseInterface $response\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function prepareTemplate(string $template): string\\n\\t{\\n\\t\\t$template = str_ireplace('{label}', $this->config->label, $template);\\n\\t\\t$template = str_ireplace('{name}', $this->config->name, $template);\\n\\n\\t\\tif ($this->config->hidden)\\n\\t\\t{\\n\\t\\t\\t$template = '<div style=\\\"display:none\\\">' . $template . '</div>';\\n\\t\\t}\\n\\t\\treturn $template;\\n\\t}\", \"output\": \"Prepares the template by adding label\\ncontent and field name.\\n\\n@param  string $template\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function fetchObject(string $className = 'stdClass')\\n\\t{\\n\\t\\t// No native support for fetching rows as objects\\n\\t\\tif (($row = $this->fetchAssoc()) === false)\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\telseif ($className === 'stdClass')\\n\\t\\t{\\n\\t\\t\\treturn (object) $row;\\n\\t\\t}\\n\\n\\t\\t$classObj = new $className();\\n\\t\\t$classSet = \\\\Closure::bind(function ($key, $value) {\\n\\t\\t\\t$this->$key = $value;\\n\\t\\t}, $classObj, $className\\n\\t\\t);\\n\\t\\tforeach (array_keys($row) as $key)\\n\\t\\t{\\n\\t\\t\\t$classSet($key, $row[$key]);\\n\\t\\t}\\n\\t\\treturn $classObj;\\n\\t}\", \"output\": \"Returns the result set as an object.\\n\\nOverridden by child classes.\\n\\n@param string $className\\n\\n@return object|boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: public function makeColumns($array = [], $columnLimit = 0)\\n\\t{\\n\\t\\tif (! is_array($array) || count($array) === 0 || ! is_int($columnLimit))\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// Turn off the auto-heading feature since it's doubtful we\\n\\t\\t// will want headings from a one-dimensional array\\n\\t\\t$this->autoHeading = false;\\n\\n\\t\\tif ($columnLimit === 0)\\n\\t\\t{\\n\\t\\t\\treturn $array;\\n\\t\\t}\\n\\n\\t\\t$new = [];\\n\\t\\tdo\\n\\t\\t{\\n\\t\\t\\t$temp = array_splice($array, 0, $columnLimit);\\n\\n\\t\\t\\tif (count($temp) < $columnLimit)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor ($i = count($temp); $i < $columnLimit; $i ++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$temp[] = '&nbsp;';\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t$new[] = $temp;\\n\\t\\t}\\n\\t\\twhile (count($array) > 0);\\n\\n\\t\\treturn $new;\\n\\t}\", \"output\": \"Set columns. Takes a one-dimensional array as input and creates\\na multi-dimensional array with a depth equal to the number of\\ncolumns. This allows a single array with many elements to be\\ndisplayed in a table that has a fixed column count.\\n\\n@param  array   $array\\n@param  integer $columnLimit\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: public function clear()\\n\\t{\\n\\t\\t$this->rows        = [];\\n\\t\\t$this->heading     = [];\\n\\t\\t$this->footing     = [];\\n\\t\\t$this->autoHeading = true;\\n\\t\\t$this->caption     = null;\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Clears the table arrays.  Useful if multiple tables are being generated\\n\\n@return Table\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function _setFromDBResult($object)\\n\\t{\\n\\t\\t// First generate the headings from the table column names\\n\\t\\tif ($this->autoHeading === true && empty($this->heading))\\n\\t\\t{\\n\\t\\t\\t$this->heading = $this->_prepArgs($object->getFieldNames());\\n\\t\\t}\\n\\n\\t\\tforeach ($object->getResultArray() as $row)\\n\\t\\t{\\n\\t\\t\\t$this->rows[] = $this->_prepArgs($row);\\n\\t\\t}\\n\\t}\", \"output\": \"Set table data from a database result object\\n\\n@param  BaseResult $object Database result object\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function _setFromArray($data)\\n\\t{\\n\\t\\tif ($this->autoHeading === true && empty($this->heading))\\n\\t\\t{\\n\\t\\t\\t$this->heading = $this->_prepArgs(array_shift($data));\\n\\t\\t}\\n\\n\\t\\tforeach ($data as &$row)\\n\\t\\t{\\n\\t\\t\\t$this->rows[] = $this->_prepArgs($row);\\n\\t\\t}\\n\\t}\", \"output\": \"Set table data from an array\\n\\n@param  array $data\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function setPath(string $path): string\\n\\t{\\n\\t\\tif (! is_dir($path))\\n\\t\\t{\\n\\t\\t\\tmkdir($path, 0777, true);\\n\\t\\t\\t//create the index.html file\\n\\t\\t\\tif (! is_file($path . 'index.html'))\\n\\t\\t\\t{\\n\\t\\t\\t\\t$file = fopen($path . 'index.html', 'x+');\\n\\t\\t\\t\\tfclose($file);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn $path;\\n\\t}\", \"output\": \"create file target path if\\nthe set path does not exist\\n\\n@param string $path\\n\\n@return string The path set or created.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getErrorString(): string\\n\\t{\\n\\t\\t$errors = [\\n\\t\\t\\tUPLOAD_ERR_OK         => lang('HTTP.uploadErrOk'),\\n\\t\\t\\tUPLOAD_ERR_INI_SIZE   => lang('HTTP.uploadErrIniSize'),\\n\\t\\t\\tUPLOAD_ERR_FORM_SIZE  => lang('HTTP.uploadErrFormSize'),\\n\\t\\t\\tUPLOAD_ERR_PARTIAL    => lang('HTTP.uploadErrPartial'),\\n\\t\\t\\tUPLOAD_ERR_NO_FILE    => lang('HTTP.uploadErrNoFile'),\\n\\t\\t\\tUPLOAD_ERR_CANT_WRITE => lang('HTTP.uploadErrCantWrite'),\\n\\t\\t\\tUPLOAD_ERR_NO_TMP_DIR => lang('HTTP.uploadErrNoTmpDir'),\\n\\t\\t\\tUPLOAD_ERR_EXTENSION  => lang('HTTP.uploadErrExtension'),\\n\\t\\t];\\n\\n\\t\\t$error = is_null($this->error) ? UPLOAD_ERR_OK : $this->error;\\n\\n\\t\\treturn sprintf($errors[$error] ?? lang('HTTP.uploadErrUnknown'), $this->getName());\\n\\t}\", \"output\": \"Get error string\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function store(string $folderName = null, string $fileName = null): string\\n\\t{\\n\\t\\t$folderName = $folderName ?? date('Ymd');\\n\\t\\t$fileName   = $fileName ?? $this->getRandomName();\\n\\n\\t\\t// Move the uploaded file to a new location.\\n\\t\\treturn ($this->move(WRITEPATH . 'uploads/' . $folderName, $fileName)) ?\\n\\t\\t\\t\\t$folderName . DIRECTORY_SEPARATOR . $this->name : null;\\n\\t}\", \"output\": \"Save the uploaded file to a new location.\\n\\nBy default, upload files are saved in writable/uploads directory. The YYYYMMDD folder\\nand random file name will be created.\\n\\n@param  string $folderName the folder name to writable/uploads directory.\\n@param  string $fileName   the name to rename the file to.\\n@return string file full path\"}"}
{"text": "{\"input\": \"Summarize the following code: public function max_size(string $blank = null, string $params, array $data): bool\\n\\t{\\n\\t\\t// Grab the file name off the top of the $params\\n\\t\\t// after we split it.\\n\\t\\t$params = explode(',', $params);\\n\\t\\t$name   = array_shift($params);\\n\\n\\t\\t$file = $this->request->getFile($name);\\n\\n\\t\\tif (is_null($file))\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn $params[0] >= $file->getSize() / 1024;\\n\\t}\", \"output\": \"Verifies if the file's size in Kilobytes is no larger than the parameter.\\n\\n@param string|null $blank\\n@param string      $params\\n@param array       $data\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: public function is_image(string $blank = null, string $params, array $data): bool\\n\\t{\\n\\t\\t// Grab the file name off the top of the $params\\n\\t\\t// after we split it.\\n\\t\\t$params = explode(',', $params);\\n\\t\\t$name   = array_shift($params);\\n\\n\\t\\t$file = $this->request->getFile($name);\\n\\n\\t\\tif (is_null($file))\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// We know that our mimes list always has the first mime\\n\\t\\t// start with `image` even when then are multiple accepted types.\\n\\t\\t$type = \\\\Config\\\\Mimes::guessTypeFromExtension($file->getExtension());\\n\\n\\t\\treturn mb_strpos($type, 'image') === 0;\\n\\t}\", \"output\": \"Uses the mime config file to determine if a file is considered an \\\"image\\\",\\nwhich for our purposes basically means that it's a raster image or svg.\\n\\n@param string|null $blank\\n@param string      $params\\n@param array       $data\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: public function mime_in(string $blank = null, string $params, array $data): bool\\n\\t{\\n\\t\\t// Grab the file name off the top of the $params\\n\\t\\t// after we split it.\\n\\t\\t$params = explode(',', $params);\\n\\t\\t$name   = array_shift($params);\\n\\n\\t\\t$file = $this->request->getFile($name);\\n\\n\\t\\tif (is_null($file))\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\treturn in_array($file->getMimeType(), $params);\\n\\t}\", \"output\": \"Checks to see if an uploaded file's mime type matches one in the parameter.\\n\\n@param string|null $blank\\n@param string      $params\\n@param array       $data\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: public function max_dims(string $blank = null, string $params, array $data): bool\\n\\t{\\n\\t\\t// Grab the file name off the top of the $params\\n\\t\\t// after we split it.\\n\\t\\t$params = explode(',', $params);\\n\\t\\t$name   = array_shift($params);\\n\\n\\t\\t$file = $this->request->getFile($name);\\n\\n\\t\\tif (is_null($file))\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// Get Parameter sizes\\n\\t\\t$allowedWidth  = $params[0] ?? 0;\\n\\t\\t$allowedHeight = $params[1] ?? 0;\\n\\n\\t\\t// Get uploaded image size\\n\\t\\t$info       = getimagesize($file->getTempName());\\n\\t\\t$fileWidth  = $info[0];\\n\\t\\t$fileHeight = $info[1];\\n\\n\\t\\treturn $fileWidth <= $allowedWidth && $fileHeight <= $allowedHeight;\\n\\t}\", \"output\": \"Checks an uploaded file to verify that the dimensions are within\\na specified allowable dimension.\\n\\n@param string|null $blank\\n@param string      $params\\n@param array       $data\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: public function fetchGlobal($method, $index = null, $filter = null, $flags = null)\\n\\t{\\n\\t\\t$method = strtolower($method);\\n\\n\\t\\tif (! isset($this->globals[$method]))\\n\\t\\t{\\n\\t\\t\\t$this->populateGlobals($method);\\n\\t\\t}\\n\\n\\t\\t// Null filters cause null values to return.\\n\\t\\tif (is_null($filter))\\n\\t\\t{\\n\\t\\t\\t$filter = FILTER_DEFAULT;\\n\\t\\t}\\n\\n\\t\\t// Return all values when $index is null\\n\\t\\tif (is_null($index))\\n\\t\\t{\\n\\t\\t\\t$values = [];\\n\\t\\t\\tforeach ($this->globals[$method] as $key => $value)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$values[$key] = is_array($value)\\n\\t\\t\\t\\t\\t? $this->fetchGlobal($method, $key, $filter, $flags)\\n\\t\\t\\t\\t\\t: filter_var($value, $filter, $flags);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn $values;\\n\\t\\t}\\n\\n\\t\\t// allow fetching multiple keys at once\\n\\t\\tif (is_array($index))\\n\\t\\t{\\n\\t\\t\\t$output = [];\\n\\n\\t\\t\\tforeach ($index as $key)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$output[$key] = $this->fetchGlobal($method, $key, $filter, $flags);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn $output;\\n\\t\\t}\\n\\n\\t\\t// Does the index contain array notation?\\n\\t\\tif (($count = preg_match_all('/(?:^[^\\\\[]+)|\\\\[[^]]*\\\\]/', $index, $matches)) > 1)\\n\\t\\t{\\n\\t\\t\\t$value = $this->globals[$method];\\n\\t\\t\\tfor ($i = 0; $i < $count; $i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$key = trim($matches[0][$i], '[]');\\n\\n\\t\\t\\t\\tif ($key === '') // Empty notation will return the value as array\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (isset($value[$key]))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$value = $value[$key];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (! isset($value))\\n\\t\\t{\\n\\t\\t\\t$value = $this->globals[$method][$index] ?? null;\\n\\t\\t}\\n\\n\\t\\t// Cannot filter these types of data automatically...\\n\\t\\tif (is_array($value) || is_object($value) || is_null($value))\\n\\t\\t{\\n\\t\\t\\treturn $value;\\n\\t\\t}\\n\\n\\t\\treturn filter_var($value, $filter, $flags);\\n\\t}\", \"output\": \"Fetches one or more items from a global, like cookies, get, post, etc.\\nCan optionally filter the input when you retrieve it by passing in\\na filter.\\n\\nIf $type is an array, it must conform to the input allowed by the\\nfilter_input_array method.\\n\\nhttp://php.net/manual/en/filter.filters.sanitize.php\\n\\n@param string            $method Input filter constant\\n@param string|array|null $index\\n@param integer|null      $filter Filter constant\\n@param mixed             $flags\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function populateGlobals(string $method)\\n\\t{\\n\\t\\tif (! isset($this->globals[$method]))\\n\\t\\t{\\n\\t\\t\\t$this->globals[$method] = [];\\n\\t\\t}\\n\\n\\t\\t// Don't populate ENV as it might contain\\n\\t\\t// sensitive data that we don't want to get logged.\\n\\t\\tswitch($method)\\n\\t\\t{\\n\\t\\t\\tcase 'get':\\n\\t\\t\\t\\t$this->globals['get'] = $_GET;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 'post':\\n\\t\\t\\t\\t$this->globals['post'] = $_POST;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 'request':\\n\\t\\t\\t\\t$this->globals['request'] = $_REQUEST;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 'cookie':\\n\\t\\t\\t\\t$this->globals['cookie'] = $_COOKIE;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 'server':\\n\\t\\t\\t\\t$this->globals['server'] = $_SERVER;\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\", \"output\": \"Saves a copy of the current state of one of several PHP globals\\nso we can retrieve them later.\\n\\n@param string $method\"}"}
{"text": "{\"input\": \"Summarize the following code: public function run(array $params = [])\\n\\t{\\n\\t\\t$runner = Services::migrations();\\n\\n\\t\\t// Get the version number\\n\\t\\t$version = array_shift($params);\\n\\n\\t\\tif (is_null($version))\\n\\t\\t{\\n\\t\\t\\t$version = CLI::prompt(lang('Migrations.version'));\\n\\t\\t}\\n\\n\\t\\tif (is_null($version))\\n\\t\\t{\\n\\t\\t\\tCLI::error(lang('Migrations.invalidVersion'));\\n\\t\\t\\texit();\\n\\t\\t}\\n\\n\\t\\tCLI::write(sprintf(lang('Migrations.toVersionPH'), $version), 'yellow');\\n\\n\\t\\t$namespace = $params['-n'] ?? CLI::getOption('n');\\n\\t\\t$group     = $params['-g'] ?? CLI::getOption('g');\\n\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\t$runner->version($version, $namespace, $group);\\n\\t\\t\\tCLI::write('Done');\\n\\t\\t}\\n\\t\\tcatch (\\\\Exception $e)\\n\\t\\t{\\n\\t\\t\\t$this->showError($e);\\n\\t\\t}\\n\\t}\", \"output\": \"Migrates the database up or down to get to the specified version.\\n\\n@param array $params\"}"}
{"text": "{\"input\": \"Summarize the following code: public function fromTable(string $table)\\n\\t{\\n\\t\\t$this->prefixedTableName = $table;\\n\\n\\t\\t// Remove the prefix, if any, since it's\\n\\t\\t// already been added by the time we get here...\\n\\t\\t$prefix = $this->db->DBPrefix;\\n\\t\\tif (! empty($prefix))\\n\\t\\t{\\n\\t\\t\\tif (strpos($table, $prefix) === 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$table = substr($table, strlen($prefix));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (! $this->db->tableExists($this->prefixedTableName))\\n\\t\\t{\\n\\t\\t\\tthrow DataException::forTableNotFound($this->prefixedTableName);\\n\\t\\t}\\n\\n\\t\\t$this->tableName = $table;\\n\\n\\t\\t$this->fields = $this->formatFields($this->db->getFieldData($table));\\n\\n\\t\\t$this->keys = array_merge($this->keys, $this->formatKeys($this->db->getIndexData($table)));\\n\\n\\t\\t$this->foreignKeys = $this->db->getForeignKeyData($table);\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Reads an existing database table and\\ncollects all of the information needed to\\nrecreate this table.\\n\\n@param string $table\\n\\n@return \\\\CodeIgniter\\\\Database\\\\SQLite3\\\\Table\"}"}
{"text": "{\"input\": \"Summarize the following code: public function run(): bool\\n\\t{\\n\\t\\t$this->db->query('PRAGMA foreign_keys = OFF');\\n\\n\\t\\t$this->db->transStart();\\n\\n\\t\\t$this->forge->renameTable($this->tableName, \\\"temp_{$this->tableName}\\\");\\n\\n\\t\\t$this->forge->reset();\\n\\n\\t\\t$this->createTable();\\n\\n\\t\\t$this->copyData();\\n\\n\\t\\t$this->forge->dropTable(\\\"temp_{$this->tableName}\\\");\\n\\n\\t\\t$success = $this->db->transComplete();\\n\\n\\t\\t$this->db->query('PRAGMA foreign_keys = ON');\\n\\n\\t\\treturn $success;\\n\\t}\", \"output\": \"Called after `fromTable` and any actions, like `dropColumn`, etc,\\nto finalize the action. It creates a temp table, creates the new\\ntable with modifications, and copies the data over to the new table.\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: public function modifyColumn(array $field)\\n\\t{\\n\\t\\t$field = $field[0];\\n\\n\\t\\t$oldName = $field['name'];\\n\\t\\tunset($field['name']);\\n\\n\\t\\t$this->fields[$oldName] = $field;\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Modifies a field, including changing data type,\\nrenaming, etc.\\n\\n@param array $field\\n\\n@return \\\\CodeIgniter\\\\Database\\\\SQLite3\\\\Table\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function createTable()\\n\\t{\\n\\t\\t$this->dropIndexes();\\n\\t\\t$this->db->resetDataCache();\\n\\n\\t\\t// Handle any modified columns.\\n\\t\\t$fields = [];\\n\\t\\tforeach ($this->fields as $name => $field)\\n\\t\\t{\\n\\t\\t\\tif (isset($field['new_name']))\\n\\t\\t\\t{\\n\\t\\t\\t\\t$fields[$field['new_name']] = $field;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$fields[$name] = $field;\\n\\t\\t}\\n\\n\\t\\t$this->forge->addField($fields);\\n\\n\\t\\t// Unique/Index keys\\n\\t\\tif (is_array($this->keys))\\n\\t\\t{\\n\\t\\t\\tforeach ($this->keys as $key)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch ($key['type'])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcase 'primary':\\n\\t\\t\\t\\t\\t\\t$this->forge->addPrimaryKey($key['fields']);\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase 'unique':\\n\\t\\t\\t\\t\\t\\t$this->forge->addUniqueKey($key['fields']);\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase 'index':\\n\\t\\t\\t\\t\\t\\t$this->forge->addKey($key['fields']);\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Foreign Keys\\n\\n\\t\\treturn $this->forge->createTable($this->tableName);\\n\\t}\", \"output\": \"Creates the new table based on our current fields.\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function copyData()\\n\\t{\\n\\t\\t$exFields  = [];\\n\\t\\t$newFields = [];\\n\\n\\t\\tforeach ($this->fields as $name => $details)\\n\\t\\t{\\n\\t\\t\\t// Are we modifying the column?\\n\\t\\t\\tif (isset($details['new_name']))\\n\\t\\t\\t{\\n\\t\\t\\t\\t$newFields[] = $details['new_name'];\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t$newFields[] = $name;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$exFields[] = $name;\\n\\t\\t}\\n\\n\\t\\t$exFields  = implode(', ', $exFields);\\n\\t\\t$newFields = implode(', ', $newFields);\\n\\n\\t\\t$this->db->query(\\\"INSERT INTO {$this->prefixedTableName}({$newFields}) SELECT {$exFields} FROM {$this->db->DBPrefix}temp_{$this->tableName}\\\");\\n\\t}\", \"output\": \"Copies data from our old table to the new one,\\ntaking care map data correctly based on any columns\\nthat have been renamed.\\n\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function formatFields($fields)\\n\\t{\\n\\t\\tif (! is_array($fields))\\n\\t\\t{\\n\\t\\t\\treturn $fields;\\n\\t\\t}\\n\\n\\t\\t$return = [];\\n\\n\\t\\tforeach ($fields as $field)\\n\\t\\t{\\n\\t\\t\\t$return[$field->name] = [\\n\\t\\t\\t\\t'type'     => $field->type,\\n\\t\\t\\t\\t'default'  => $field->default,\\n\\t\\t\\t\\t'nullable' => $field->nullable,\\n\\t\\t\\t];\\n\\n\\t\\t\\tif ($field->primary_key)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$this->keys[$field->name] = [\\n\\t\\t\\t\\t\\t'fields' => [$field->name],\\n\\t\\t\\t\\t\\t'type'   => 'primary',\\n\\t\\t\\t\\t];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $return;\\n\\t}\", \"output\": \"Converts fields retrieved from the database to\\nthe format needed for creating fields with Forge.\\n\\n@param array|boolean $fields\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function formatKeys($keys)\\n\\t{\\n\\t\\tif (! is_array($keys))\\n\\t\\t{\\n\\t\\t\\treturn $keys;\\n\\t\\t}\\n\\n\\t\\t$return = [];\\n\\n\\t\\tforeach ($keys as $name => $key)\\n\\t\\t{\\n\\t\\t\\t$return[$name] = [\\n\\t\\t\\t\\t'fields' => $key->fields,\\n\\t\\t\\t\\t'type'   => 'index',\\n\\t\\t\\t];\\n\\t\\t}\\n\\n\\t\\treturn $return;\\n\\t}\", \"output\": \"Converts keys retrieved from the database to\\nthe format needed to create later.\\n\\n@param mixed $keys\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function dropIndexes()\\n\\t{\\n\\t\\tif (! is_array($this->keys) || ! count($this->keys))\\n\\t\\t{\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tforeach ($this->keys as $name => $key)\\n\\t\\t{\\n\\t\\t\\tif ($key['type'] === 'primary' || $key['type'] === 'unique')\\n\\t\\t\\t{\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$this->db->query(\\\"DROP INDEX IF EXISTS '{$name}'\\\");\\n\\t\\t}\\n\\t}\", \"output\": \"Attempts to drop all indexes and constraints\\nfrom the database for this table.\\n\\n@return null|void\"}"}
{"text": "{\"input\": \"Summarize the following code: public function CSRFSetCookie(RequestInterface $request)\\n\\t{\\n\\t\\t$expire        = time() + $this->CSRFExpire;\\n\\t\\t$secure_cookie = (bool) $this->cookieSecure;\\n\\n\\t\\tif ($secure_cookie && ! $request->isSecure())\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tsetcookie(\\n\\t\\t\\t\\t$this->CSRFCookieName, $this->CSRFHash, $expire, $this->cookiePath, $this->cookieDomain, $secure_cookie, true                // Enforce HTTP only cookie for security\\n\\t\\t);\\n\\n\\t\\tlog_message('info', 'CSRF cookie sent');\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"CSRF Set Cookie\\n\\n@codeCoverageIgnore\\n\\n@param RequestInterface|\\\\CodeIgniter\\\\HTTP\\\\IncomingRequest $request\\n\\n@return Security|false\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function CSRFSetHash(): string\\n\\t{\\n\\t\\tif ($this->CSRFHash === null)\\n\\t\\t{\\n\\t\\t\\t// If the cookie exists we will use its value.\\n\\t\\t\\t// We don't necessarily want to regenerate it with\\n\\t\\t\\t// each page load since a page could contain embedded\\n\\t\\t\\t// sub-pages causing this feature to fail\\n\\t\\t\\tif (isset($_COOKIE[$this->CSRFCookieName]) && is_string($_COOKIE[$this->CSRFCookieName]) && preg_match('#^[0-9a-f]{32}$#iS', $_COOKIE[$this->CSRFCookieName]) === 1\\n\\t\\t\\t)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn $this->CSRFHash = $_COOKIE[$this->CSRFCookieName];\\n\\t\\t\\t}\\n\\n\\t\\t\\t$rand           = random_bytes(16);\\n\\t\\t\\t$this->CSRFHash = bin2hex($rand);\\n\\t\\t}\\n\\n\\t\\treturn $this->CSRFHash;\\n\\t}\", \"output\": \"Sets the CSRF Hash and cookie.\\n\\n@return string\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function now($timezone = null, string $locale = null)\\n\\t{\\n\\t\\treturn new Time(null, $timezone, $locale);\\n\\t}\", \"output\": \"Returns a new Time instance with the timezone set.\\n\\n@param string|DateTimeZone|null $timezone\\n@param string|null              $locale\\n\\n@return \\\\CodeIgniter\\\\I18n\\\\Time\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function parse(string $datetime, $timezone = null, string $locale = null)\\n\\t{\\n\\t\\treturn new Time($datetime, $timezone, $locale);\\n\\t}\", \"output\": \"Returns a new Time instance while parsing a datetime string.\\n\\nExample:\\n$time = Time::parse('first day of December 2008');\\n\\n@param string      $datetime\\n@param string|null $timezone\\n@param string|null $locale\\n\\n@return \\\\CodeIgniter\\\\I18n\\\\Time\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function today($timezone = null, string $locale = null)\\n\\t{\\n\\t\\treturn new Time(date('Y-m-d 00:00:00'), $timezone, $locale);\\n\\t}\", \"output\": \"Return a new time with the time set to midnight.\\n\\n@param null        $timezone\\n@param string|null $locale\\n\\n@return \\\\CodeIgniter\\\\I18n\\\\Time\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function yesterday($timezone = null, string $locale = null)\\n\\t{\\n\\t\\treturn new Time(date('Y-m-d 00:00:00', strtotime('-1 day')), $timezone, $locale);\\n\\t}\", \"output\": \"Returns an instance set to midnight yesterday morning.\\n\\n@param null        $timezone\\n@param string|null $locale\\n\\n@return \\\\CodeIgniter\\\\I18n\\\\Time\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function tomorrow($timezone = null, string $locale = null)\\n\\t{\\n\\t\\treturn new Time(date('Y-m-d 00:00:00', strtotime('+1 day')), $timezone, $locale);\\n\\t}\", \"output\": \"Returns an instance set to midnight tomorrow morning.\\n\\n@param null        $timezone\\n@param string|null $locale\\n\\n@return \\\\CodeIgniter\\\\I18n\\\\Time\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function createFromDate(int $year = null, int $month = null, int $day = null, $timezone = null, string $locale = null)\\n\\t{\\n\\t\\treturn static::create($year, $month, $day, null, null, null, $timezone, $locale);\\n\\t}\", \"output\": \"Returns a new instance based on the year, month and day. If any of those three\\nare left empty, will default to the current value.\\n\\n@param integer|null $year\\n@param integer|null $month\\n@param integer|null $day\\n@param null         $timezone\\n@param string       $locale\\n\\n@return \\\\CodeIgniter\\\\I18n\\\\Time\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function createFromTime(int $hour = null, int $minutes = null, int $seconds = null, $timezone = null, string $locale = null)\\n\\t{\\n\\t\\treturn static::create(null, null, null, $hour, $minutes, $seconds, $timezone, $locale);\\n\\t}\", \"output\": \"Returns a new instance with the date set to today, and the time set to the values passed in.\\n\\n@param integer|null $hour\\n@param integer|null $minutes\\n@param integer|null $seconds\\n@param null         $timezone\\n@param string|null  $locale\\n\\n@return \\\\CodeIgniter\\\\I18n\\\\Time\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function create(int $year = null, int $month = null, int $day = null, int $hour = null, int $minutes = null, int $seconds = null, $timezone = null, string $locale = null)\\n\\t{\\n\\t\\t$year    = is_null($year) ? date('Y') : $year;\\n\\t\\t$month   = is_null($month) ? date('m') : $month;\\n\\t\\t$day     = is_null($day) ? date('d') : $day;\\n\\t\\t$hour    = empty($hour) ? 0 : $hour;\\n\\t\\t$minutes = empty($minutes) ? 0 : $minutes;\\n\\t\\t$seconds = empty($seconds) ? 0 : $seconds;\\n\\n\\t\\treturn new Time(date('Y-m-d H:i:s', strtotime(\\\"{$year}-{$month}-{$day} {$hour}:{$minutes}:{$seconds}\\\")), $timezone, $locale);\\n\\t}\", \"output\": \"Returns a new instance with the date time values individually set.\\n\\n@param integer|null $year\\n@param integer|null $month\\n@param integer|null $day\\n@param integer|null $hour\\n@param integer|null $minutes\\n@param integer|null $seconds\\n@param null         $timezone\\n@param string|null  $locale\\n\\n@return \\\\CodeIgniter\\\\I18n\\\\Time\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function createFromFormat($format, $datetime, $timeZone = null)\\n\\t{\\n\\t\\t$date = parent::createFromFormat($format, $datetime);\\n\\n\\t\\treturn new Time($date->format('Y-m-d H:i:s'), $timeZone);\\n\\t}\", \"output\": \"Provides a replacement for DateTime's own createFromFormat function, that provides\\nmore flexible timeZone handling\\n\\n@param string                $format\\n@param string                $datetime\\n@param DateTimeZone|string   $timeZone\\n\\n@return \\\\CodeIgniter\\\\I18n\\\\Time\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function createFromTimestamp(int $timestamp, $timeZone = null, string $locale = null)\\n\\t{\\n\\t\\treturn new Time(date('Y-m-d H:i:s', $timestamp), $timeZone, $locale);\\n\\t}\", \"output\": \"Returns a new instance with the datetime set based on the provided UNIX timestamp.\\n\\n@param integer      $timestamp\\n@param DateTimeZone $timeZone\\n@param string|null  $locale\\n\\n@return \\\\CodeIgniter\\\\I18n\\\\Time\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function instance(DateTime $dateTime, string $locale = null)\\n\\t{\\n\\t\\t$date     = $dateTime->format('Y-m-d H:i:s');\\n\\t\\t$timezone = $dateTime->getTimezone();\\n\\n\\t\\treturn new Time($date, $timezone, $locale);\\n\\t}\", \"output\": \"Takes an instance of DateTime and returns an instance of Time with it's same values.\\n\\n@param \\\\DateTime   $dateTime\\n@param string|null $locale\\n\\n@return \\\\CodeIgniter\\\\I18n\\\\Time\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public function toDateTime()\\n\\t{\\n\\t\\t$dateTime = new DateTime(null, $this->getTimezone());\\n\\t\\t$dateTime->setTimestamp(parent::getTimestamp());\\n\\n\\t\\treturn $dateTime;\\n\\t}\", \"output\": \"Converts the current instance to a mutable DateTime object.\\n\\n@return \\\\DateTime\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getAge()\\n\\t{\\n\\t\\t$now  = Time::now()->getTimestamp();\\n\\t\\t$time = $this->getTimestamp();\\n\\n\\t\\t// future dates have no age\\n\\t\\treturn max(0, date('Y', $now) - date('Y', $time));\\n\\t}\", \"output\": \"Returns the age in years from the \\\"current\\\" date and 'now'\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getDst(): bool\\n\\t{\\n\\t\\t// grab the transactions that would affect today\\n\\t\\t$start       = strtotime('-1 year', $this->getTimestamp());\\n\\t\\t$end         = strtotime('+2 year', $start);\\n\\t\\t$transitions = $this->timezone->getTransitions($start, $end);\\n\\n\\t\\t$daylightSaving = false;\\n\\t\\tforeach ($transitions as $transition)\\n\\t\\t{\\n\\t\\t\\tif ($transition['time'] > $this->format('U'))\\n\\t\\t\\t{\\n\\t\\t\\t\\t$daylightSaving = (bool) $transition['isdst'] ?? $daylightSaving;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn $daylightSaving;\\n\\t}\", \"output\": \"Are we in daylight savings time currently?\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setMonth($value)\\n\\t{\\n\\t\\tif (is_numeric($value) && $value < 1 || $value > 12)\\n\\t\\t{\\n\\t\\t\\tthrow I18nException::forInvalidMonth($value);\\n\\t\\t}\\n\\n\\t\\tif (is_string($value) && ! is_numeric($value))\\n\\t\\t{\\n\\t\\t\\t$value = date('m', strtotime(\\\"{$value} 1 2017\\\"));\\n\\t\\t}\\n\\n\\t\\treturn $this->setValue('month', $value);\\n\\t}\", \"output\": \"Sets the month of the year.\\n\\n@param $value\\n\\n@return \\\\CodeIgniter\\\\I18n\\\\Time\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setDay($value)\\n\\t{\\n\\t\\tif ($value < 1 || $value > 31)\\n\\t\\t{\\n\\t\\t\\tthrow I18nException::forInvalidDay($value);\\n\\t\\t}\\n\\n\\t\\t$date    = $this->getYear() . '-' . $this->getMonth();\\n\\t\\t$lastDay = date('t', strtotime($date));\\n\\t\\tif ($value > $lastDay)\\n\\t\\t{\\n\\t\\t\\tthrow I18nException::forInvalidOverDay($lastDay, $value);\\n\\t\\t}\\n\\n\\t\\treturn $this->setValue('day', $value);\\n\\t}\", \"output\": \"Sets the day of the month.\\n\\n@param $value\\n\\n@return \\\\CodeIgniter\\\\I18n\\\\Time\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setMinute($value)\\n\\t{\\n\\t\\tif ($value < 0 || $value > 59)\\n\\t\\t{\\n\\t\\t\\tthrow I18nException::forInvalidMinutes($value);\\n\\t\\t}\\n\\n\\t\\treturn $this->setValue('minute', $value);\\n\\t}\", \"output\": \"Sets the minute of the hour\\n\\n@param $value\\n\\n@return \\\\CodeIgniter\\\\I18n\\\\Time\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setSecond($value)\\n\\t{\\n\\t\\tif ($value < 0 || $value > 59)\\n\\t\\t{\\n\\t\\t\\tthrow I18nException::forInvalidSeconds($value);\\n\\t\\t}\\n\\n\\t\\treturn $this->setValue('second', $value);\\n\\t}\", \"output\": \"Sets the second of the minute.\\n\\n@param $value\\n\\n@return \\\\CodeIgniter\\\\I18n\\\\Time\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function setValue(string $name, $value)\\n\\t{\\n\\t\\tlist($year, $month, $day, $hour, $minute, $second) = explode('-', $this->format('Y-n-j-G-i-s'));\\n\\t\\t$$name                                             = $value;\\n\\n\\t\\treturn Time::create($year, $month, $day, $hour, $minute, $second, $this->getTimezoneName(), $this->locale);\\n\\t}\", \"output\": \"Helper method to do the heavy lifting of the 'setX' methods.\\n\\n@param string $name\\n@param $value\\n\\n@return \\\\CodeIgniter\\\\I18n\\\\Time\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setTimestamp($timestamp)\\n\\t{\\n\\t\\t$time = date('Y-m-d H:i:s', $timestamp);\\n\\n\\t\\treturn Time::parse($time, $this->timezone, $this->locale);\\n\\t}\", \"output\": \"Returns a new instance with the date set to the new timestamp.\\n\\n@param integer $timestamp\\n\\n@return \\\\CodeIgniter\\\\I18n\\\\Time\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public function equals($testTime, string $timezone = null): bool\\n\\t{\\n\\t\\t$testTime = $this->getUTCObject($testTime, $timezone);\\n\\n\\t\\t$ourTime = $this->toDateTime()\\n\\t\\t\\t\\t->setTimezone(new DateTimeZone('UTC'))\\n\\t\\t\\t\\t->format('Y-m-d H:i:s');\\n\\n\\t\\treturn $testTime->format('Y-m-d H:i:s') === $ourTime;\\n\\t}\", \"output\": \"Determines if the datetime passed in is equal to the current instance.\\nEqual in this case means that they represent the same moment in time,\\nand are not required to be in the same timezone, as both times are\\nconverted to UTC and compared that way.\\n\\n@param Time|DateTime|string $testTime\\n@param string|null          $timezone\\n\\n@return boolean\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public function sameAs($testTime, string $timezone = null): bool\\n\\t{\\n\\t\\tif ($testTime instanceof DateTime)\\n\\t\\t{\\n\\t\\t\\t$testTime = $testTime->format('Y-m-d H:i:s');\\n\\t\\t}\\n\\t\\telse if (is_string($testTime))\\n\\t\\t{\\n\\t\\t\\t$timezone = $timezone ?: $this->timezone;\\n\\t\\t\\t$timezone = $timezone instanceof DateTimeZone ? $timezone : new DateTimeZone($timezone);\\n\\t\\t\\t$testTime = new DateTime($testTime, $timezone);\\n\\t\\t\\t$testTime = $testTime->format('Y-m-d H:i:s');\\n\\t\\t}\\n\\n\\t\\t$ourTime = $this->toDateTimeString();\\n\\n\\t\\treturn $testTime === $ourTime;\\n\\t}\", \"output\": \"Ensures that the times are identical, taking timezone into account.\\n\\n@param Time|DateTime|string $testTime\\n@param string|null          $timezone\\n\\n@return boolean\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getUTCObject($time, string $timezone = null)\\n\\t{\\n\\t\\tif ($time instanceof Time)\\n\\t\\t{\\n\\t\\t\\t$time = $time->toDateTime()\\n\\t\\t\\t\\t\\t->setTimezone(new DateTimeZone('UTC'));\\n\\t\\t}\\n\\t\\telse if ($time instanceof DateTime)\\n\\t\\t{\\n\\t\\t\\t$time = $time->setTimezone(new DateTimeZone('UTC'));\\n\\t\\t}\\n\\t\\telse if (is_string($time))\\n\\t\\t{\\n\\t\\t\\t$timezone = $timezone ?: $this->timezone;\\n\\t\\t\\t$timezone = $timezone instanceof DateTimeZone ? $timezone : new DateTimeZone($timezone);\\n\\t\\t\\t$time     = new DateTime($time, $timezone);\\n\\t\\t\\t$time     = $time->setTimezone(new DateTimeZone('UTC'));\\n\\t\\t}\\n\\n\\t\\treturn $time;\\n\\t}\", \"output\": \"Returns a Time instance with the timezone converted to UTC.\\n\\n@param $time\\n@param string|null $timezone\\n\\n@return \\\\DateTime|static\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function jsMatcher($matches)\\n    {\\n        $chr = $matches[0];\\n        if (strlen($chr) == 1) {\\n            return sprintf('\\\\\\\\x%02X', ord($chr));\\n        }\\n        $chr = $this->convertEncoding($chr, 'UTF-16BE', 'UTF-8');\\n        $hex = strtoupper(bin2hex($chr));\\n        if (strlen($hex) <= 4) {\\n            return sprintf('\\\\\\\\u%04s', $hex);\\n        }\\n        $highSurrogate = substr($hex, 0, 4);\\n        $lowSurrogate = substr($hex, 4, 4);\\n        return sprintf('\\\\\\\\u%04s\\\\\\\\u%04s', $highSurrogate, $lowSurrogate);\\n    }\", \"output\": \"Callback function for preg_replace_callback that applies Javascript\\nescaping to all matches.\\n\\n@param array $matches\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function cssMatcher($matches)\\n    {\\n        $chr = $matches[0];\\n        if (strlen($chr) == 1) {\\n            $ord = ord($chr);\\n        } else {\\n            $chr = $this->convertEncoding($chr, 'UTF-32BE', 'UTF-8');\\n            $ord = hexdec(bin2hex($chr));\\n        }\\n        return sprintf('\\\\\\\\%X ', $ord);\\n    }\", \"output\": \"Callback function for preg_replace_callback that applies CSS\\nescaping to all matches.\\n\\n@param array $matches\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function toUtf8($string)\\n    {\\n        if ($this->getEncoding() === 'utf-8') {\\n            $result = $string;\\n        } else {\\n            $result = $this->convertEncoding($string, 'UTF-8', $this->getEncoding());\\n        }\\n\\n        if (! $this->isUtf8($result)) {\\n            throw new Exception\\\\RuntimeException(\\n                sprintf('String to be escaped was not valid UTF-8 or could not be converted: %s', $result)\\n            );\\n        }\\n\\n        return $result;\\n    }\", \"output\": \"Converts a string to UTF-8 from the base encoding. The base encoding is set via this\\nclass' constructor.\\n\\n@param string $string\\n@throws Exception\\\\RuntimeException\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function fromUtf8($string)\\n    {\\n        if ($this->getEncoding() === 'utf-8') {\\n            return $string;\\n        }\\n\\n        return $this->convertEncoding($string, $this->getEncoding(), 'UTF-8');\\n    }\", \"output\": \"Converts a string from UTF-8 to the base encoding. The base encoding is set via this\\nclass' constructor.\\n@param string $string\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getFile(string $name)\\n\\t{\\n\\t\\t$this->populateFiles();\\n\\n\\t\\tif ($this->hasFile($name))\\n\\t\\t{\\n\\t\\t\\tif (strpos($name, '.') !== false)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$name         = explode('.', $name);\\n\\t\\t\\t\\t$uploadedFile = $this->getValueDotNotationSyntax($name, $this->files);\\n\\t\\t\\t\\treturn ($uploadedFile instanceof UploadedFile) ?\\n\\t\\t\\t\\t\\t $uploadedFile : null;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (array_key_exists($name, $this->files))\\n\\t\\t\\t{\\n\\t\\t\\t\\t$uploadedFile = $this->files[$name];\\n\\t\\t\\t\\treturn  ($uploadedFile instanceof UploadedFile) ?\\n\\t\\t\\t\\t\\t$uploadedFile : null;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn null;\\n\\t}\", \"output\": \"Attempts to get a single file from the collection of uploaded files.\\n\\n@param string $name\\n\\n@return UploadedFile|null\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function createFileObject(array $array)\\n\\t{\\n\\t\\tif (! isset($array['name']))\\n\\t\\t{\\n\\t\\t\\t$output = [];\\n\\n\\t\\t\\tforeach ($array as $key => $values)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (! is_array($values))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t$output[$key] = $this->createFileObject($values);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn $output;\\n\\t\\t}\\n\\n\\t\\treturn new UploadedFile(\\n\\t\\t\\t\\t$array['tmp_name'] ?? null, $array['name'] ?? null, $array['type'] ?? null, $array['size'] ?? null, $array['error'] ?? null\\n\\t\\t);\\n\\t}\", \"output\": \"Given a file array, will create UploadedFile instances. Will\\nloop over an array and create objects for each.\\n\\n@param array $array\\n\\n@return array|UploadedFile\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function getValueDotNotationSyntax(array $index, array $value)\\n\\t{\\n\\t\\tif (is_array($index) && ! empty($index))\\n\\t\\t{\\n\\t\\t\\t$current_index = array_shift($index);\\n\\t\\t}\\n\\t\\tif (is_array($index) && $index && is_array($value[$current_index]) && $value[$current_index])\\n\\t\\t{\\n\\t\\t\\treturn $this->getValueDotNotationSyntax($index, $value[$current_index]);\\n\\t\\t}\\n\\n\\t\\treturn (isset($value[$current_index])) ? $value[$current_index] : null;\\n\\t}\", \"output\": \"Navigate through a array looking for a particular index\\n\\n@param array $index The index sequence we are navigating down\\n@param array $value The portion of the array to process\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setBinary(string $binary)\\n\\t{\\n\\t\\tif ($this->file !== null)\\n\\t\\t{\\n\\t\\t\\tthrow DownloadException::forCannotSetBinary();\\n\\t\\t}\\n\\n\\t\\t$this->binary = $binary;\\n\\t}\", \"output\": \"set download for binary string.\\n\\n@param string $binary\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setFilePath(string $filepath)\\n\\t{\\n\\t\\tif ($this->binary !== null)\\n\\t\\t{\\n\\t\\t\\tthrow DownloadException::forCannotSetFilePath($filepath);\\n\\t\\t}\\n\\n\\t\\t$this->file = new File($filepath, true);\\n\\t}\", \"output\": \"set download for file.\\n\\n@param string $filepath\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getContentLength() : int\\n\\t{\\n\\t\\tif (is_string($this->binary))\\n\\t\\t{\\n\\t\\t\\treturn strlen($this->binary);\\n\\t\\t}\\n\\t\\telseif ($this->file instanceof File)\\n\\t\\t{\\n\\t\\t\\treturn $this->file->getSize();\\n\\t\\t}\\n\\n\\t\\treturn 0;\\n\\t}\", \"output\": \"get content length.\\n\\n@return integer\"}"}
{"text": "{\"input\": \"Summarize the following code: private function setContentTypeByMimeType()\\n\\t{\\n\\t\\t$mime    = null;\\n\\t\\t$charset = '';\\n\\n\\t\\tif ($this->setMime === true)\\n\\t\\t{\\n\\t\\t\\tif (($last_dot_position = strrpos($this->filename, '.')) !== false)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$mime    = Mimes::guessTypeFromExtension(substr($this->filename, $last_dot_position + 1));\\n\\t\\t\\t\\t$charset = $this->charset;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (! is_string($mime))\\n\\t\\t{\\n\\t\\t\\t// Set the default MIME type to send\\n\\t\\t\\t$mime    = 'application/octet-stream';\\n\\t\\t\\t$charset = '';\\n\\t\\t}\\n\\n\\t\\t$this->setContentType($mime, $charset);\\n\\t}\", \"output\": \"Set content type by guessing mime type from file extension\"}"}
{"text": "{\"input\": \"Summarize the following code: private function getDownloadFileName(): string\\n\\t{\\n\\t\\t$filename  = $this->filename;\\n\\t\\t$x         = explode('.', $this->filename);\\n\\t\\t$extension = end($x);\\n\\n\\t\\t/* It was reported that browsers on Android 2.1 (and possibly older as well)\\n\\t\\t * need to have the filename extension upper-cased in order to be able to\\n\\t\\t * download it.\\n\\t\\t *\\n\\t\\t * Reference: http://digiblog.de/2011/04/19/android-and-the-download-file-headers/\\n\\t\\t */\\n\\t\\t// @todo: depend super global\\n\\t\\tif (count($x) !== 1 && isset($_SERVER['HTTP_USER_AGENT'])\\n\\t\\t\\t\\t&& preg_match('/Android\\\\s(1|2\\\\.[01])/', $_SERVER['HTTP_USER_AGENT']))\\n\\t\\t{\\n\\t\\t\\t$x[count($x) - 1] = strtoupper($extension);\\n\\t\\t\\t$filename         = implode('.', $x);\\n\\t\\t}\\n\\n\\t\\treturn $filename;\\n\\t}\", \"output\": \"get download filename.\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: private function getContentDisposition() : string\\n\\t{\\n\\t\\t$download_filename = $this->getDownloadFileName();\\n\\n\\t\\t$utf8_filename = $download_filename;\\n\\n\\t\\tif (strtoupper($this->charset) !== 'UTF-8')\\n\\t\\t{\\n\\t\\t\\t$utf8_filename = mb_convert_encoding($download_filename, 'UTF-8', $this->charset);\\n\\t\\t}\\n\\n\\t\\t$result = sprintf('attachment; filename=\\\"%s\\\"', $download_filename);\\n\\n\\t\\tif (isset($utf8_filename))\\n\\t\\t{\\n\\t\\t\\t$result .= '; filename*=UTF-8\\\\'\\\\'' . rawurlencode($utf8_filename);\\n\\t\\t}\\n\\n\\t\\treturn $result;\\n\\t}\", \"output\": \"get Content-Disposition Header string.\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function buildHeaders()\\n\\t{\\n\\t\\tif (! $this->hasHeader('Content-Type'))\\n\\t\\t{\\n\\t\\t\\t$this->setContentTypeByMimeType();\\n\\t\\t}\\n\\n\\t\\t$this->setHeader('Content-Disposition', $this->getContentDisposition());\\n\\t\\t$this->setHeader('Expires-Disposition', '0');\\n\\t\\t$this->setHeader('Content-Transfer-Encoding', 'binary');\\n\\t\\t$this->setHeader('Content-Length', (string)$this->getContentLength());\\n\\t\\t$this->noCache();\\n\\t}\", \"output\": \"set header for file download.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function sendBody()\\n\\t{\\n\\t\\tif ($this->binary !== null)\\n\\t\\t{\\n\\t\\t\\treturn $this->sendBodyByBinary();\\n\\t\\t}\\n\\t\\telseif ($this->file !== null)\\n\\t\\t{\\n\\t\\t\\treturn $this->sendBodyByFilePath();\\n\\t\\t}\\n\\n\\t\\tthrow DownloadException::forNotFoundDownloadSource();\\n\\t}\", \"output\": \"output download file text.\\n\\n@throws DownloadException\\n\\n@return DownloadResponse\"}"}
{"text": "{\"input\": \"Summarize the following code: private function sendBodyByFilePath()\\n\\t{\\n\\t\\t$spl_file_object = $this->file->openFile('rb');\\n\\n\\t\\t// Flush 1MB chunks of data\\n\\t\\twhile (! $spl_file_object->eof() && ($data = $spl_file_object->fread(1048576)) !== false)\\n\\t\\t{\\n\\t\\t\\techo $data;\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"output download text by file.\\n\\n@return DownloadResponse\"}"}
{"text": "{\"input\": \"Summarize the following code: public function _remap($method, ...$params)\\n\\t{\\n\\t\\t// The first param is usually empty, so scrap it.\\n\\t\\tif (empty($params[0]))\\n\\t\\t{\\n\\t\\t\\tarray_shift($params);\\n\\t\\t}\\n\\n\\t\\t$this->index($params);\\n\\t}\", \"output\": \"We map all un-routed CLI methods through this function\\nso we have the chance to look for a Command first.\\n\\n@param string $method\\n@param array  ...$params\\n\\n@throws \\\\ReflectionException\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function runCommand(string $command, array $params)\\n\\t{\\n\\t\\tif (! isset($this->commands[$command]))\\n\\t\\t{\\n\\t\\t\\tCLI::error(lang('CLI.commandNotFound', [$command]));\\n\\t\\t\\tCLI::newLine();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// The file would have already been loaded during the\\n\\t\\t// createCommandList function...\\n\\t\\t$className = $this->commands[$command]['class'];\\n\\t\\t$class     = new $className($this->logger, $this);\\n\\n\\t\\treturn $class->run($params);\\n\\t}\", \"output\": \"Actually runs the command.\\n\\n@param string $command\\n@param array  $params\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function createCommandList()\\n\\t{\\n\\t\\t$files = Services::locator()->listFiles('Commands/');\\n\\n\\t\\t// If no matching command files were found, bail\\n\\t\\tif (empty($files))\\n\\t\\t{\\n\\t\\t\\t// This should never happen in unit testing.\\n\\t\\t\\t// if it does, we have far bigger problems!\\n\\t\\t\\t// @codeCoverageIgnoreStart\\n\\t\\t\\treturn;\\n\\t\\t\\t// @codeCoverageIgnoreEnd\\n\\t\\t}\\n\\n\\t\\t// Loop over each file checking to see if a command with that\\n\\t\\t// alias exists in the class. If so, return it. Otherwise, try the next.\\n\\t\\tforeach ($files as $file)\\n\\t\\t{\\n\\t\\t\\t$className = Services::locator()->findQualifiedNameFromPath($file);\\n\\t\\t\\tif (empty($className) || ! class_exists($className))\\n\\t\\t\\t{\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$class = new \\\\ReflectionClass($className);\\n\\n\\t\\t\\tif (! $class->isInstantiable() || ! $class->isSubclassOf(BaseCommand::class))\\n\\t\\t\\t{\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$class = new $className($this->logger, $this);\\n\\n\\t\\t\\t// Store it!\\n\\t\\t\\tif ($class->group !== null)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$this->commands[$class->name] = [\\n\\t\\t\\t\\t\\t'class'       => $className,\\n\\t\\t\\t\\t\\t'file'        => $file,\\n\\t\\t\\t\\t\\t'group'       => $class->group,\\n\\t\\t\\t\\t\\t'description' => $class->description,\\n\\t\\t\\t\\t];\\n\\t\\t\\t}\\n\\n\\t\\t\\t$class = null;\\n\\t\\t\\tunset($class);\\n\\t\\t}\\n\\n\\t\\tasort($this->commands);\\n\\t}\", \"output\": \"Scans all Commands directories and prepares a list\\nof each command with it's group and file.\\n\\n@throws \\\\ReflectionException\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function connect($group = null, bool $getShared = true)\\n\\t{\\n\\t\\t// If a DB connection is passed in, just pass it back\\n\\t\\tif ($group instanceof BaseConnection)\\n\\t\\t{\\n\\t\\t\\treturn $group;\\n\\t\\t}\\n\\n\\t\\tif (is_array($group))\\n\\t\\t{\\n\\t\\t\\t$config = $group;\\n\\t\\t\\t$group  = 'custom-' . md5(json_encode($config));\\n\\t\\t}\\n\\n\\t\\t$config = $config ?? new \\\\Config\\\\Database();\\n\\n\\t\\tif (empty($group))\\n\\t\\t{\\n\\t\\t\\t$group = ENVIRONMENT === 'testing' ? 'tests' : $config->defaultGroup;\\n\\t\\t}\\n\\n\\t\\tif (is_string($group) && ! isset($config->$group) && strpos($group, 'custom-') !== 0)\\n\\t\\t{\\n\\t\\t\\tthrow new \\\\InvalidArgumentException($group . ' is not a valid database connection group.');\\n\\t\\t}\\n\\n\\t\\tif ($getShared && isset(static::$instances[$group]))\\n\\t\\t{\\n\\t\\t\\treturn static::$instances[$group];\\n\\t\\t}\\n\\n\\t\\tstatic::ensureFactory();\\n\\n\\t\\tif (isset($config->$group))\\n\\t\\t{\\n\\t\\t\\t$config = $config->$group;\\n\\t\\t}\\n\\n\\t\\t$connection = static::$factory->load($config, $group);\\n\\n\\t\\tstatic::$instances[$group] = & $connection;\\n\\n\\t\\treturn $connection;\\n\\t}\", \"output\": \"Creates the default\\n\\n@param string|array $group     The name of the connection group to use,\\nor an array of configuration settings.\\n@param boolean      $getShared Whether to return a shared instance of the connection.\\n\\n@return BaseConnection\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function seeder(string $group = null)\\n\\t{\\n\\t\\t$config = config('Database');\\n\\n\\t\\treturn new Seeder($config, static::connect($group));\\n\\t}\", \"output\": \"Returns a new instance of the Database Seeder.\\n\\n@param string|null $group\\n\\n@return Seeder\"}"}
{"text": "{\"input\": \"Summarize the following code: private function isAllNamespace(array $params): bool\\n\\t{\\n\\t\\tif (array_search('-all', $params) !== false)\\n\\t\\t{\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\treturn ! is_null(CLI::getOption('all'));\\n\\t}\", \"output\": \"To migrate all namespaces to the latest migration\\n\\nDemo:\\n1. command line: php spark migrate:latest -all\\n2. command file: $this->call('migrate:latest', ['-g' => 'test','-all']);\\n\\n@param  array $params\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: public function add(string $name, \\\\Closure $closure)\\n\\t{\\n\\t\\t$name = strtolower($name);\\n\\n\\t\\t$this->tests[$name] = $closure;\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Adds a test to run.\\n\\nTests are simply closures that the user can define any sequence of\\nthings to happen during the test.\\n\\n@param string    $name\\n@param \\\\Closure  $closure\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: public function run(int $iterations = 1000, bool $output = true)\\n\\t{\\n\\t\\tforeach ($this->tests as $name => $test)\\n\\t\\t{\\n\\t\\t\\t// clear memory before start\\n\\t\\t\\tgc_collect_cycles();\\n\\n\\t\\t\\t$start     = microtime(true);\\n\\t\\t\\t$start_mem = $max_memory = memory_get_usage(true);\\n\\n\\t\\t\\tfor ($i = 0; $i < $iterations; $i ++)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$result = $test();\\n\\n\\t\\t\\t\\t$max_memory = max($max_memory, memory_get_usage(true));\\n\\n\\t\\t\\t\\tunset($result);\\n\\t\\t\\t}\\n\\n\\t\\t\\t$this->results[$name] = [\\n\\t\\t\\t\\t'time'   => microtime(true) - $start,\\n\\t\\t\\t\\t'memory' => $max_memory - $start_mem,\\n\\t\\t\\t\\t'n'      => $iterations,\\n\\t\\t\\t];\\n\\t\\t}\\n\\n\\t\\tif ($output)\\n\\t\\t{\\n\\t\\t\\treturn $this->getReport();\\n\\t\\t}\\n\\n\\t\\treturn null;\\n\\t}\", \"output\": \"Runs through all of the tests that have been added, recording\\ntime to execute the desired number of iterations, and the approximate\\nmemory usage used during those iterations.\\n\\n@param integer $iterations\\n@param boolean $output\\n\\n@return string|null\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getReport(): string\\n\\t{\\n\\t\\tif (empty($this->results))\\n\\t\\t{\\n\\t\\t\\treturn 'No results to display.';\\n\\t\\t}\\n\\n\\t\\thelper('number');\\n\\n\\t\\t// Template\\n\\t\\t$tpl = '<table>\\n\\t\\t\\t<thead>\\n\\t\\t\\t\\t<tr>\\n\\t\\t\\t\\t\\t<td>Test</td>\\n\\t\\t\\t\\t\\t<td>Time</td>\\n\\t\\t\\t\\t\\t<td>Memory</td>\\n\\t\\t\\t\\t</tr>\\n\\t\\t\\t</thead>\\n\\t\\t\\t<tbody>\\n\\t\\t\\t\\t{rows}\\n\\t\\t\\t</tbody>\\n\\t\\t</table>';\\n\\n\\t\\t$rows = '';\\n\\n\\t\\tforeach ($this->results as $name => $result)\\n\\t\\t{\\n\\t\\t\\t$memory = number_to_size($result['memory'], 4);\\n\\n\\t\\t\\t$rows .= \\\"<tr>\\n\\t\\t\\t\\t<td>{$name}</td>\\n\\t\\t\\t\\t<td>\\\" . number_format($result['time'], 4) . \\\"</td>\\n\\t\\t\\t\\t<td>{$memory}</td>\\n\\t\\t\\t</tr>\\\";\\n\\t\\t}\\n\\n\\t\\t$tpl = str_replace('{rows}', $rows, $tpl);\\n\\n\\t\\treturn $tpl . '<br/>';\\n\\t}\", \"output\": \"Get results.\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setQuery(string $sql, $binds = null, bool $setEscape = true)\\n\\t{\\n\\t\\t$this->originalQueryString = $sql;\\n\\n\\t\\tif (! is_null($binds))\\n\\t\\t{\\n\\t\\t\\tif (! is_array($binds))\\n\\t\\t\\t{\\n\\t\\t\\t\\t$binds = [$binds];\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ($setEscape)\\n\\t\\t\\t{\\n\\t\\t\\t\\tarray_walk($binds, function (&$item) {\\n\\t\\t\\t\\t\\t$item = [\\n\\t\\t\\t\\t\\t\\t$item,\\n\\t\\t\\t\\t\\t\\ttrue,\\n\\t\\t\\t\\t\\t];\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\t$this->binds = $binds;\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Sets the raw query string to use for this statement.\\n\\n@param string  $sql\\n@param mixed   $binds\\n@param boolean $setEscape\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getQuery(): string\\n\\t{\\n\\t\\tif (empty($this->finalQueryString))\\n\\t\\t{\\n\\t\\t\\t$this->finalQueryString = $this->originalQueryString;\\n\\t\\t}\\n\\n\\t\\t$this->compileBinds();\\n\\n\\t\\treturn $this->finalQueryString;\\n\\t}\", \"output\": \"Returns the final, processed query string after binding, etal\\nhas been performed.\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getStartTime(bool $returnRaw = false, int $decimals = 6): string\\n\\t{\\n\\t\\tif ($returnRaw)\\n\\t\\t{\\n\\t\\t\\treturn $this->startTime;\\n\\t\\t}\\n\\n\\t\\treturn number_format($this->startTime, $decimals);\\n\\t}\", \"output\": \"Returns the start time in seconds with microseconds.\\n\\n@param boolean $returnRaw\\n@param integer $decimals\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getDuration(int $decimals = 6): string\\n\\t{\\n\\t\\treturn number_format(($this->endTime - $this->startTime), $decimals);\\n\\t}\", \"output\": \"Returns the duration of this query during execution, or null if\\nthe query has not been executed yet.\\n\\n@param integer $decimals The accuracy of the returned time.\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setError(int $code, string $error)\\n\\t{\\n\\t\\t$this->errorCode   = $code;\\n\\t\\t$this->errorString = $error;\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Stores the error description that happened for this query.\\n\\n@param integer $code\\n@param string  $error\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: public function swapPrefix(string $orig, string $swap)\\n\\t{\\n\\t\\t$sql = empty($this->finalQueryString) ? $this->originalQueryString : $this->finalQueryString;\\n\\n\\t\\t$this->finalQueryString = preg_replace('/(\\\\W)' . $orig . '(\\\\S+?)/', '\\\\\\\\1' . $swap . '\\\\\\\\2', $sql);\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Swaps out one table prefix for a new one.\\n\\n@param string $orig\\n@param string $swap\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function compileBinds()\\n\\t{\\n\\t\\t$sql = $this->finalQueryString;\\n\\n\\t\\t$hasNamedBinds = strpos($sql, ':') !== false;\\n\\n\\t\\tif (empty($this->binds) || empty($this->bindMarker) ||\\n\\t\\t\\t\\t(strpos($sql, $this->bindMarker) === false &&\\n\\t\\t\\t\\t$hasNamedBinds === false)\\n\\t\\t)\\n\\t\\t{\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (! is_array($this->binds))\\n\\t\\t{\\n\\t\\t\\t$binds     = [$this->binds];\\n\\t\\t\\t$bindCount = 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t$binds     = $this->binds;\\n\\t\\t\\t$bindCount = count($binds);\\n\\t\\t}\\n\\n\\t\\t// Reverse the binds so that duplicate named binds\\n\\t\\t// will be processed prior to the original binds.\\n\\t\\tif (! is_numeric(key(array_slice($binds, 0, 1))))\\n\\t\\t{\\n\\t\\t\\t$binds = array_reverse($binds);\\n\\t\\t}\\n\\n\\t\\t// We'll need marker length later\\n\\t\\t$ml = strlen($this->bindMarker);\\n\\n\\t\\tif ($hasNamedBinds)\\n\\t\\t{\\n\\t\\t\\t$sql = $this->matchNamedBinds($sql, $binds);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t$sql = $this->matchSimpleBinds($sql, $binds, $bindCount, $ml);\\n\\t\\t}\\n\\n\\t\\t$this->finalQueryString = $sql;\\n\\t}\", \"output\": \"Escapes and inserts any binds into the finalQueryString object.\\n\\n@return null|void\"}"}
{"text": "{\"input\": \"Summarize the following code: public function addNamespace($namespace, string $path = null)\\n\\t{\\n\\t\\tif (is_array($namespace))\\n\\t\\t{\\n\\t\\t\\tforeach ($namespace as $prefix => $path)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$prefix = trim($prefix, '\\\\\\\\');\\n\\n\\t\\t\\t\\tif (is_array($path))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tforeach ($path as $dir)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t$this->prefixes[$prefix][] = rtrim($dir, '/') . '/';\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t$this->prefixes[$prefix][] = rtrim($path, '/') . '/';\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t$this->prefixes[trim($namespace, '\\\\\\\\')][] = rtrim($path, '/') . '/';\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Registers namespaces with the autoloader.\\n\\n@param array|string $namespace\\n@param string       $path\\n\\n@return Autoloader\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getNamespace(string $prefix = null)\\n\\t{\\n\\t\\tif ($prefix === null)\\n\\t\\t{\\n\\t\\t\\treturn $this->prefixes;\\n\\t\\t}\\n\\n\\t\\treturn $this->prefixes[trim($prefix, '\\\\\\\\')] ?? [];\\n\\t}\", \"output\": \"Get namespaces with prefixes as keys and paths as values.\\n\\nIf a prefix param is set, returns only paths to the given prefix.\\n\\n@var string|null $prefix\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function requireFile(string $file)\\n\\t{\\n\\t\\t$file = $this->sanitizeFilename($file);\\n\\n\\t\\tif (is_file($file))\\n\\t\\t{\\n\\t\\t\\trequire_once $file;\\n\\n\\t\\t\\treturn $file;\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\", \"output\": \"A central way to require a file is loaded. Split out primarily\\nfor testing purposes.\\n\\n@param string $file\\n\\n@return string|false The filename on success, false if the file is not loaded\"}"}
{"text": "{\"input\": \"Summarize the following code: public function sanitizeFilename(string $filename): string\\n\\t{\\n\\t\\t// Only allow characters deemed safe for POSIX portable filenames.\\n\\t\\t// Plus the forward slash for directory separators since this might\\n\\t\\t// be a path.\\n\\t\\t// http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html#tag_03_278\\n\\t\\t// Modified to allow backslash and colons for on Windows machines.\\n\\t\\t$filename = preg_replace('/[^a-zA-Z0-9\\\\s\\\\/\\\\-\\\\_\\\\.\\\\:\\\\\\\\\\\\\\\\]/', '', $filename);\\n\\n\\t\\t// Clean up our filename edges.\\n\\t\\t$filename = trim($filename, '.-_');\\n\\n\\t\\treturn $filename;\\n\\t}\", \"output\": \"Sanitizes a filename, replacing spaces with dashes.\\n\\nRemoves special characters that are illegal in filenames on certain\\noperating systems and special characters requiring special escaping\\nto manipulate at the command line. Replaces spaces and consecutive\\ndashes with a single dash. Trim period, dash and underscore from beginning\\nand end of filename.\\n\\n@param string $filename\\n\\n@return string       The sanitized filename\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function discoverComposerNamespaces()\\n\\t{\\n\\t\\tif (! is_file(COMPOSER_PATH))\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t$composer = include COMPOSER_PATH;\\n\\n\\t\\t$paths = $composer->getPrefixesPsr4();\\n\\t\\tunset($composer);\\n\\n\\t\\t// Get rid of CodeIgniter so we don't have duplicates\\n\\t\\tif (isset($paths['CodeIgniter\\\\\\\\']))\\n\\t\\t{\\n\\t\\t\\tunset($paths['CodeIgniter\\\\\\\\']);\\n\\t\\t}\\n\\n\\t\\t// Composer stores paths with trailng slash. We don't.\\n\\t\\t$newPaths = [];\\n\\t\\tforeach ($paths as $key => $value)\\n\\t\\t{\\n\\t\\t\\t$newPaths[rtrim($key, '\\\\\\\\ ')] = $value;\\n\\t\\t}\\n\\n\\t\\t$this->prefixes = array_merge($this->prefixes, $newPaths);\\n\\t}\", \"output\": \"Locates all PSR4 compatible namespaces from Composer.\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function date_modify($value, string $adjustment): string\\n\\t{\\n\\t\\t$value = static::date($value, 'Y-m-d H:i:s');\\n\\n\\t\\treturn strtotime($adjustment, strtotime($value));\\n\\t}\", \"output\": \"Given a string or DateTime object, will return the date modified\\nby the given value. Returns the value as a unix timestamp\\n\\nExample:\\nmy_date|date_modify(+1 day)\\n\\n@param $value\\n@param string $adjustment\\n\\n@return   string\\n@internal param string $format\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function excerpt(string $value, string $phrase, int $radius = 100): string\\n\\t{\\n\\t\\thelper('text');\\n\\n\\t\\treturn excerpt($value, $phrase, $radius);\\n\\t}\", \"output\": \"Returns an excerpt of the given string.\\n\\n@param string  $value\\n@param string  $phrase\\n@param integer $radius\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function sanitizeValue(string $value): string\\n\\t{\\n\\t\\tif (! $value)\\n\\t\\t{\\n\\t\\t\\treturn $value;\\n\\t\\t}\\n\\n\\t\\t// Does it begin with a quote?\\n\\t\\tif (strpbrk($value[0], '\\\"\\\\'') !== false)\\n\\t\\t{\\n\\t\\t\\t// value starts with a quote\\n\\t\\t\\t$quote        = $value[0];\\n\\t\\t\\t$regexPattern = sprintf(\\n\\t\\t\\t\\t\\t'/^\\n\\t\\t\\t\\t\\t%1$s          # match a quote at the start of the value\\n\\t\\t\\t\\t\\t(             # capturing sub-pattern used\\n\\t\\t\\t\\t\\t\\t\\t\\t  (?:          # we do not need to capture this\\n\\t\\t\\t\\t\\t\\t\\t\\t   [^%1$s\\\\\\\\\\\\\\\\] # any character other than a quote or backslash\\n\\t\\t\\t\\t\\t\\t\\t\\t   |\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\   # or two backslashes together\\n\\t\\t\\t\\t\\t\\t\\t\\t   |\\\\\\\\\\\\\\\\%1$s   # or an escaped quote e.g \\\\\\\"\\n\\t\\t\\t\\t\\t\\t\\t\\t  )*           # as many characters that match the previous rules\\n\\t\\t\\t\\t\\t)             # end of the capturing sub-pattern\\n\\t\\t\\t\\t\\t%1$s          # and the closing quote\\n\\t\\t\\t\\t\\t.*$           # and discard any string after the closing quote\\n\\t\\t\\t\\t\\t/mx', $quote\\n\\t\\t\\t);\\n\\t\\t\\t$value        = preg_replace($regexPattern, '$1', $value);\\n\\t\\t\\t$value        = str_replace(\\\"\\\\\\\\$quote\\\", $quote, $value);\\n\\t\\t\\t$value        = str_replace('\\\\\\\\\\\\\\\\', '\\\\\\\\', $value);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t$parts = explode(' #', $value, 2);\\n\\n\\t\\t\\t$value = trim($parts[0]);\\n\\n\\t\\t\\t// Unquoted values cannot contain whitespace\\n\\t\\t\\tif (preg_match('/\\\\s+/', $value) > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tthrow new \\\\InvalidArgumentException('.env values containing spaces must be surrounded by quotes.');\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $value;\\n\\t}\", \"output\": \"Strips quotes from the environment variable value.\\n\\nThis was borrowed from the excellent phpdotenv with very few changes.\\nhttps://github.com/vlucas/phpdotenv\\n\\n@param string $value\\n\\n@return string\\n@throws \\\\InvalidArgumentException\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function resolveNestedVariables(string $value): string\\n\\t{\\n\\t\\tif (strpos($value, '$') !== false)\\n\\t\\t{\\n\\t\\t\\t$loader = $this;\\n\\n\\t\\t\\t$value = preg_replace_callback(\\n\\t\\t\\t\\t'/\\\\${([a-zA-Z0-9_]+)}/',\\n\\t\\t\\t\\tfunction ($matchedPatterns) use ($loader) {\\n\\t\\t\\t\\t\\t$nestedVariable = $loader->getVariable($matchedPatterns[1]);\\n\\n\\t\\t\\t\\t\\tif (is_null($nestedVariable))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturn $matchedPatterns[0];\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn $nestedVariable;\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t$value\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\treturn $value;\\n\\t}\", \"output\": \"Resolve the nested variables.\\n\\nLook for ${varname} patterns in the variable value and replace with an existing\\nenvironment variable.\\n\\nThis was borrowed from the excellent phpdotenv with very few changes.\\nhttps://github.com/vlucas/phpdotenv\\n\\n@param $value\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setDatabase(string $databaseName): bool\\n\\t{\\n\\t\\tif ($databaseName === '')\\n\\t\\t{\\n\\t\\t\\t$databaseName = $this->database;\\n\\t\\t}\\n\\n\\t\\tif (empty($this->connID))\\n\\t\\t{\\n\\t\\t\\t$this->initialize();\\n\\t\\t}\\n\\n\\t\\tif ($this->connID->select_db($databaseName))\\n\\t\\t{\\n\\t\\t\\t$this->database = $databaseName;\\n\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\", \"output\": \"Select a specific database table to use.\\n\\n@param string $databaseName\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function prepQuery(string $sql): string\\n\\t{\\n\\t\\t// mysqli_affected_rows() returns 0 for \\\"DELETE FROM TABLE\\\" queries. This hack\\n\\t\\t// modifies the query so that it a proper number of affected rows is returned.\\n\\t\\tif ($this->deleteHack === true && preg_match('/^\\\\s*DELETE\\\\s+FROM\\\\s+(\\\\S+)\\\\s*$/i', $sql))\\n\\t\\t{\\n\\t\\t\\treturn trim($sql) . ' WHERE 1=1';\\n\\t\\t}\\n\\n\\t\\treturn $sql;\\n\\t}\", \"output\": \"Prep the query\\n\\nIf needed, each database adapter can prep the query string\\n\\n@param string $sql an SQL query\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function error(): array\\n\\t{\\n\\t\\tif (! empty($this->mysqli->connect_errno))\\n\\t\\t{\\n\\t\\t\\treturn [\\n\\t\\t\\t\\t'code'    => $this->mysqli->connect_errno,\\n\\t\\t\\t\\t'message' => $this->mysqli->connect_error,\\n\\t\\t\\t];\\n\\t\\t}\\n\\n\\t\\treturn [\\n\\t\\t\\t'code'    => $this->connID->errno,\\n\\t\\t\\t'message' => $this->connID->error,\\n\\t\\t];\\n\\t}\", \"output\": \"Returns the last error code and message.\\n\\nMust return an array with keys 'code' and 'message':\\n\\nreturn ['code' => null, 'message' => null);\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: public function execute(string $sql)\\n\\t{\\n\\t\\treturn $this->isWriteType($sql)\\n\\t\\t\\t? $this->connID->exec($sql)\\n\\t\\t\\t: $this->connID->query($sql);\\n\\t}\", \"output\": \"Execute the query\\n\\n@param string $sql\\n\\n@return mixed    \\\\SQLite3Result object or bool\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getFieldNames(string $table)\\n\\t{\\n\\t\\t// Is there a cached result?\\n\\t\\tif (isset($this->dataCache['field_names'][$table]))\\n\\t\\t{\\n\\t\\t\\treturn $this->dataCache['field_names'][$table];\\n\\t\\t}\\n\\n\\t\\tif (empty($this->connID))\\n\\t\\t{\\n\\t\\t\\t$this->initialize();\\n\\t\\t}\\n\\n\\t\\tif (false === ($sql = $this->_listColumns($table)))\\n\\t\\t{\\n\\t\\t\\tif ($this->DBDebug)\\n\\t\\t\\t{\\n\\t\\t\\t\\tthrow new DatabaseException(lang('Database.featureUnavailable'));\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t$query                                  = $this->query($sql);\\n\\t\\t$this->dataCache['field_names'][$table] = [];\\n\\n\\t\\tforeach ($query->getResultArray() as $row)\\n\\t\\t{\\n\\t\\t\\t// Do we know from where to get the column's name?\\n\\t\\t\\tif (! isset($key))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (isset($row['column_name']))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$key = 'column_name';\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telseif (isset($row['COLUMN_NAME']))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$key = 'COLUMN_NAME';\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telseif (isset($row['name']))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$key = 'name';\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t// We have no other choice but to just get the first element's key.\\n\\t\\t\\t\\t\\t$key = key($row);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t$this->dataCache['field_names'][$table][] = $row[$key];\\n\\t\\t}\\n\\n\\t\\treturn $this->dataCache['field_names'][$table];\\n\\t}\", \"output\": \"Fetch Field Names\\n\\n@param string $table Table name\\n\\n@return array|false\\n@throws DatabaseException\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function cache(Cache $config = null, bool $getShared = true)\\n\\t{\\n\\t\\tif ($getShared)\\n\\t\\t{\\n\\t\\t\\treturn static::getSharedInstance('cache', $config);\\n\\t\\t}\\n\\n\\t\\tif (! is_object($config))\\n\\t\\t{\\n\\t\\t\\t$config = new Cache();\\n\\t\\t}\\n\\n\\t\\treturn CacheFactory::getHandler($config);\\n\\t}\", \"output\": \"The cache class provides a simple way to store and retrieve\\ncomplex data for later.\\n\\n@param \\\\Config\\\\Cache $config\\n@param boolean       $getShared\\n\\n@return \\\\CodeIgniter\\\\Cache\\\\CacheInterface\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function clirequest(App $config = null, bool $getShared = true)\\n\\t{\\n\\t\\tif ($getShared)\\n\\t\\t{\\n\\t\\t\\treturn static::getSharedInstance('clirequest', $config);\\n\\t\\t}\\n\\n\\t\\tif (! is_object($config))\\n\\t\\t{\\n\\t\\t\\t$config = config(App::class);\\n\\t\\t}\\n\\n\\t\\treturn new CLIRequest($config);\\n\\t}\", \"output\": \"The CLI Request class provides for ways to interact with\\na command line request.\\n\\n@param \\\\Config\\\\App $config\\n@param boolean     $getShared\\n\\n@return \\\\CodeIgniter\\\\HTTP\\\\CLIRequest\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function honeypot(BaseConfig $config = null, bool $getShared = true)\\n\\t{\\n\\t\\tif ($getShared)\\n\\t\\t{\\n\\t\\t\\treturn static::getSharedInstance('honeypot', $config);\\n\\t\\t}\\n\\n\\t\\tif (is_null($config))\\n\\t\\t{\\n\\t\\t\\t$config = new \\\\Config\\\\Honeypot();\\n\\t\\t}\\n\\n\\t\\treturn new Honeypot($config);\\n\\t}\", \"output\": \"The Honeypot provides a secret input on forms that bots should NOT\\nfill in, providing an additional safeguard when accepting user input.\\n\\n@param \\\\CodeIgniter\\\\Config\\\\BaseConfig|null $config\\n@param boolean                             $getShared\\n\\n@return \\\\CodeIgniter\\\\Honeypot\\\\Honeypot|mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function language(string $locale = null, bool $getShared = true)\\n\\t{\\n\\t\\tif ($getShared)\\n\\t\\t{\\n\\t\\t\\treturn static::getSharedInstance('language', $locale)\\n\\t\\t\\t\\t\\t   ->setLocale($locale);\\n\\t\\t}\\n\\n\\t\\t$locale = ! empty($locale)\\n\\t\\t\\t? $locale\\n\\t\\t\\t: static::request()\\n\\t\\t\\t\\t  ->getLocale();\\n\\n\\t\\treturn new Language($locale);\\n\\t}\", \"output\": \"Responsible for loading the language string translations.\\n\\n@param string  $locale\\n@param boolean $getShared\\n\\n@return \\\\CodeIgniter\\\\Language\\\\Language\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function logger(bool $getShared = true)\\n\\t{\\n\\t\\tif ($getShared)\\n\\t\\t{\\n\\t\\t\\treturn static::getSharedInstance('logger');\\n\\t\\t}\\n\\n\\t\\treturn new \\\\CodeIgniter\\\\Log\\\\Logger(new Logger());\\n\\t}\", \"output\": \"The Logger class is a PSR-3 compatible Logging class that supports\\nmultiple handlers that process the actual logging.\\n\\n@param boolean $getShared\\n\\n@return \\\\CodeIgniter\\\\Log\\\\Logger\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function negotiator(RequestInterface $request = null, bool $getShared = true)\\n\\t{\\n\\t\\tif ($getShared)\\n\\t\\t{\\n\\t\\t\\treturn static::getSharedInstance('negotiator', $request);\\n\\t\\t}\\n\\n\\t\\tif (is_null($request))\\n\\t\\t{\\n\\t\\t\\t$request = static::request();\\n\\t\\t}\\n\\n\\t\\treturn new Negotiate($request);\\n\\t}\", \"output\": \"The Negotiate class provides the content negotiation features for\\nworking the request to determine correct language, encoding, charset,\\nand more.\\n\\n@param \\\\CodeIgniter\\\\HTTP\\\\RequestInterface $request\\n@param boolean                            $getShared\\n\\n@return \\\\CodeIgniter\\\\HTTP\\\\Negotiate\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function parser(string $viewPath = null, $config = null, bool $getShared = true)\\n\\t{\\n\\t\\tif ($getShared)\\n\\t\\t{\\n\\t\\t\\treturn static::getSharedInstance('parser', $viewPath, $config);\\n\\t\\t}\\n\\n\\t\\tif (is_null($config))\\n\\t\\t{\\n\\t\\t\\t$config = new \\\\Config\\\\View();\\n\\t\\t}\\n\\n\\t\\tif (is_null($viewPath))\\n\\t\\t{\\n\\t\\t\\t$paths    = config('Paths');\\n\\t\\t\\t$viewPath = $paths->viewDirectory;\\n\\t\\t}\\n\\n\\t\\treturn new Parser($config, $viewPath, static::locator(true), CI_DEBUG, static::logger(true));\\n\\t}\", \"output\": \"The Parser is a simple template parser.\\n\\n@param string  $viewPath\\n@param mixed   $config\\n@param boolean $getShared\\n\\n@return \\\\CodeIgniter\\\\View\\\\Parser\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function request(App $config = null, bool $getShared = true)\\n\\t{\\n\\t\\tif ($getShared)\\n\\t\\t{\\n\\t\\t\\treturn static::getSharedInstance('request', $config);\\n\\t\\t}\\n\\n\\t\\tif (! is_object($config))\\n\\t\\t{\\n\\t\\t\\t$config = config(App::class);\\n\\t\\t}\\n\\n\\t\\treturn new IncomingRequest(\\n\\t\\t\\t$config,\\n\\t\\t\\tnew URI(),\\n\\t\\t\\t'php://input',\\n\\t\\t\\tnew UserAgent()\\n\\t\\t);\\n\\t}\", \"output\": \"The Request class models an HTTP request.\\n\\n@param \\\\Config\\\\App $config\\n@param boolean     $getShared\\n\\n@return \\\\CodeIgniter\\\\HTTP\\\\IncomingRequest\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function response(App $config = null, bool $getShared = true)\\n\\t{\\n\\t\\tif ($getShared)\\n\\t\\t{\\n\\t\\t\\treturn static::getSharedInstance('response', $config);\\n\\t\\t}\\n\\n\\t\\tif (! is_object($config))\\n\\t\\t{\\n\\t\\t\\t$config = config(App::class);\\n\\t\\t}\\n\\n\\t\\treturn new Response($config);\\n\\t}\", \"output\": \"The Response class models an HTTP response.\\n\\n@param \\\\Config\\\\App $config\\n@param boolean     $getShared\\n\\n@return \\\\CodeIgniter\\\\HTTP\\\\Response\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function redirectResponse(App $config = null, bool $getShared = true)\\n\\t{\\n\\t\\tif ($getShared)\\n\\t\\t{\\n\\t\\t\\treturn static::getSharedInstance('redirectResponse', $config);\\n\\t\\t}\\n\\n\\t\\tif (! is_object($config))\\n\\t\\t{\\n\\t\\t\\t$config = config(App::class);\\n\\t\\t}\\n\\n\\t\\t$response = new RedirectResponse($config);\\n\\t\\t$response->setProtocolVersion(static::request()\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  ->getProtocolVersion());\\n\\n\\t\\treturn $response;\\n\\t}\", \"output\": \"The Redirect class provides nice way of working with redirects.\\n\\n@param \\\\Config\\\\App $config\\n@param boolean     $getShared\\n\\n@return \\\\CodeIgniter\\\\HTTP\\\\Response\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function router(RouteCollectionInterface $routes = null, bool $getShared = true)\\n\\t{\\n\\t\\tif ($getShared)\\n\\t\\t{\\n\\t\\t\\treturn static::getSharedInstance('router', $routes);\\n\\t\\t}\\n\\n\\t\\tif (empty($routes))\\n\\t\\t{\\n\\t\\t\\t$routes = static::routes(true);\\n\\t\\t}\\n\\n\\t\\treturn new Router($routes);\\n\\t}\", \"output\": \"The Router class uses a RouteCollection's array of routes, and determines\\nthe correct Controller and Method to execute.\\n\\n@param \\\\CodeIgniter\\\\Router\\\\RouteCollectionInterface $routes\\n@param boolean                                      $getShared\\n\\n@return \\\\CodeIgniter\\\\Router\\\\Router\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function security(App $config = null, bool $getShared = true)\\n\\t{\\n\\t\\tif ($getShared)\\n\\t\\t{\\n\\t\\t\\treturn static::getSharedInstance('security', $config);\\n\\t\\t}\\n\\n\\t\\tif (! is_object($config))\\n\\t\\t{\\n\\t\\t\\t$config = config(App::class);\\n\\t\\t}\\n\\n\\t\\treturn new Security($config);\\n\\t}\", \"output\": \"The Security class provides a few handy tools for keeping the site\\nsecure, most notably the CSRF protection tools.\\n\\n@param \\\\Config\\\\App $config\\n@param boolean     $getShared\\n\\n@return \\\\CodeIgniter\\\\Security\\\\Security\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function uri(string $uri = null, bool $getShared = true)\\n\\t{\\n\\t\\tif ($getShared)\\n\\t\\t{\\n\\t\\t\\treturn static::getSharedInstance('uri', $uri);\\n\\t\\t}\\n\\n\\t\\treturn new URI($uri);\\n\\t}\", \"output\": \"The URI class provides a way to model and manipulate URIs.\\n\\n@param string  $uri\\n@param boolean $getShared\\n\\n@return \\\\CodeIgniter\\\\HTTP\\\\URI\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function validation(\\\\Config\\\\Validation $config = null, bool $getShared = true)\\n\\t{\\n\\t\\tif ($getShared)\\n\\t\\t{\\n\\t\\t\\treturn static::getSharedInstance('validation', $config);\\n\\t\\t}\\n\\n\\t\\tif (is_null($config))\\n\\t\\t{\\n\\t\\t\\t$config = config('Validation');\\n\\t\\t}\\n\\n\\t\\treturn new Validation($config, static::renderer());\\n\\t}\", \"output\": \"The Validation class provides tools for validating input data.\\n\\n@param \\\\Config\\\\Validation $config\\n@param boolean            $getShared\\n\\n@return \\\\CodeIgniter\\\\Validation\\\\Validation\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function describeCommands(array $commands = [])\\n\\t{\\n\\t\\tksort($commands);\\n\\n\\t\\t// Sort into buckets by group\\n\\t\\t$sorted         = [];\\n\\t\\t$maxTitleLength = 0;\\n\\n\\t\\tforeach ($commands as $title => $command)\\n\\t\\t{\\n\\t\\t\\tif (! isset($sorted[$command['group']]))\\n\\t\\t\\t{\\n\\t\\t\\t\\t$sorted[$command['group']] = [];\\n\\t\\t\\t}\\n\\n\\t\\t\\t$sorted[$command['group']][$title] = $command;\\n\\n\\t\\t\\t$maxTitleLength = max($maxTitleLength, strlen($title));\\n\\t\\t}\\n\\n\\t\\tksort($sorted);\\n\\n\\t\\t// Display it all...\\n\\t\\tforeach ($sorted as $group => $items)\\n\\t\\t{\\n\\t\\t\\tCLI::newLine();\\n\\t\\t\\tCLI::write($group);\\n\\n\\t\\t\\tforeach ($items as $title => $item)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$title = $this->padTitle($title, $maxTitleLength, 2, 2);\\n\\n\\t\\t\\t\\t$out = CLI::color($title, 'yellow');\\n\\n\\t\\t\\t\\tif (isset($item['description']))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$out .= CLI::wrap($item['description'], 125, strlen($title));\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tCLI::write($out);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\", \"output\": \"Displays the commands on the CLI.\\n\\n@param array $commands\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function padTitle(string $item, int $max, int $extra = 2, int $indent = 0): string\\n\\t{\\n\\t\\t$max += $extra + $indent;\\n\\n\\t\\t$item = str_repeat(' ', $indent) . $item;\\n\\t\\t$item = str_pad($item, $max);\\n\\n\\t\\treturn $item;\\n\\t}\", \"output\": \"Pads our string out so that all titles are the same length to nicely line up descriptions.\\n\\n@param string  $item\\n@param integer $max\\n@param integer $extra  // How many extra spaces to add at the end\\n@param integer $indent\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getXMLFromResult(ResultInterface $query, array $params = []): string\\n\\t{\\n\\t\\t// Set our default values\\n\\t\\tforeach (['root' => 'root', 'element' => 'element', 'newline' => \\\"\\\\n\\\", 'tab' => \\\"\\\\t\\\"] as $key => $val)\\n\\t\\t{\\n\\t\\t\\tif (! isset($params[$key]))\\n\\t\\t\\t{\\n\\t\\t\\t\\t$params[$key] = $val;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Create variables for convenience\\n\\t\\textract($params);\\n\\n\\t\\t// Load the xml helper\\n\\t\\thelper('xml');\\n\\t\\t// Generate the result\\n\\t\\t$xml = '<' . $root . '>' . $newline;\\n\\t\\twhile ($row = $query->getUnbufferedRow())\\n\\t\\t{\\n\\t\\t\\t$xml .= $tab . '<' . $element . '>' . $newline;\\n\\t\\t\\tforeach ($row as $key => $val)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$val = (!empty($val)) ? xml_convert($val) : '';\\n\\t\\t\\t\\t$xml .= $tab . $tab . '<' . $key . '>' . $val . '</' . $key . '>' . $newline;\\n\\t\\t\\t}\\n\\t\\t\\t$xml .= $tab . '</' . $element . '>' . $newline;\\n\\t\\t}\\n\\n\\t\\treturn $xml . '</' . $root . '>' . $newline;\\n\\t}\", \"output\": \"Generate XML data from a query result object\\n\\n@param ResultInterface $query  Query result object\\n@param array           $params Any preferences\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function call(string $command, array $params = [])\\n\\t{\\n\\t\\t// The CommandRunner will grab the first element\\n\\t\\t// for the command name.\\n\\t\\tarray_unshift($params, $command);\\n\\n\\t\\treturn $this->commands->index($params);\\n\\t}\", \"output\": \"Can be used by a command to run other commands.\\n\\n@param string $command\\n@param array  $params\\n\\n@return mixed\\n@throws \\\\ReflectionException\"}"}
{"text": "{\"input\": \"Summarize the following code: public function call(string $class)\\n\\t{\\n\\t\\tif (empty($class))\\n\\t\\t{\\n\\t\\t\\tthrow new \\\\InvalidArgumentException('No Seeder was specified.');\\n\\t\\t}\\n\\n\\t\\t$path = str_replace('.php', '', $class) . '.php';\\n\\n\\t\\t// If we have namespaced class, simply try to load it.\\n\\t\\tif (strpos($class, '\\\\\\\\') !== false)\\n\\t\\t{\\n\\t\\t\\t$seeder = new $class($this->config);\\n\\t\\t}\\n\\t\\t// Otherwise, try to load the class manually.\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t$path = $this->seedPath . $path;\\n\\n\\t\\t\\tif (! is_file($path))\\n\\t\\t\\t{\\n\\t\\t\\t\\tthrow new \\\\InvalidArgumentException('The specified Seeder is not a valid file: ' . $path);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Assume the class has the correct namespace\\n\\t\\t\\t$class = APP_NAMESPACE . '\\\\Database\\\\Seeds\\\\\\\\' . $class;\\n\\n\\t\\t\\tif (! class_exists($class, false))\\n\\t\\t\\t{\\n\\t\\t\\t\\trequire_once $path;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$seeder = new $class($this->config);\\n\\t\\t}\\n\\n\\t\\t$seeder->run();\\n\\n\\t\\tunset($seeder);\\n\\n\\t\\tif (is_cli() && ! $this->silent)\\n\\t\\t{\\n\\t\\t\\tCLI::write(\\\"Seeded: {$class}\\\", 'green');\\n\\t\\t}\\n\\t}\", \"output\": \"Loads the specified seeder and runs it.\\n\\n@param string $class\\n\\n@throws \\\\InvalidArgumentException\"}"}
{"text": "{\"input\": \"Summarize the following code: public function less_than_equal_to(string $str = null, string $max): bool\\n\\t{\\n\\t\\treturn is_numeric($str) ? ($str <= $max) : false;\\n\\t}\", \"output\": \"Equal to or Less than\\n\\n@param string $str\\n@param string $max\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: public function required_without($str = null, string $fields, array $data): bool\\n\\t{\\n\\t\\t$fields = explode(',', $fields);\\n\\n\\t\\t// If the field is present we can safely assume that\\n\\t\\t// the field is here, no matter whether the corresponding\\n\\t\\t// search field is present or not.\\n\\t\\t$present = $this->required($str ?? '');\\n\\n\\t\\tif ($present)\\n\\t\\t{\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\t// Still here? Then we fail this test if\\n\\t\\t// any of the fields are not present in $data\\n\\t\\tforeach ($fields as $field)\\n\\t\\t{\\n\\t\\t\\tif (! array_key_exists($field, $data))\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\", \"output\": \"The field is required when all of the other fields are present\\nin the data but not required.\\n\\nExample (field is required when the id or email field is missing):\\n\\nrequired_without[id,email]\\n\\n@param $str\\n@param string $fields\\n@param array  $data\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function validateRequest(array $segments): array\\n\\t{\\n\\t\\t$segments = array_filter($segments);\\n\\t\\t$segments = array_values($segments);\\n\\n\\t\\t$c                  = count($segments);\\n\\t\\t$directory_override = isset($this->directory);\\n\\n\\t\\t// Loop through our segments and return as soon as a controller\\n\\t\\t// is found or when such a directory doesn't exist\\n\\t\\twhile ($c -- > 0)\\n\\t\\t{\\n\\t\\t\\t$test = $this->directory . ucfirst($this->translateURIDashes === true ? str_replace('-', '_', $segments[0]) : $segments[0]\\n\\t\\t\\t);\\n\\n\\t\\t\\tif (! is_file(APPPATH . 'Controllers/' . $test . '.php') && $directory_override === false && is_dir(APPPATH . 'Controllers/' . $this->directory . ucfirst($segments[0])))\\n\\t\\t\\t{\\n\\t\\t\\t\\t$this->setDirectory(array_shift($segments), true);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn $segments;\\n\\t\\t}\\n\\n\\t\\t// This means that all segments were actually directories\\n\\t\\treturn $segments;\\n\\t}\", \"output\": \"Attempts to validate the URI request and determine the controller path.\\n\\n@param array $segments URI segments\\n\\n@return array URI segments\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function setDirectory(string $dir = null, bool $append = false)\\n\\t{\\n\\t\\t$dir = ucfirst($dir);\\n\\n\\t\\tif ($append !== true || empty($this->directory))\\n\\t\\t{\\n\\t\\t\\t$this->directory = str_replace('.', '', trim($dir, '/')) . '/';\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t$this->directory .= str_replace('.', '', trim($dir, '/')) . '/';\\n\\t\\t}\\n\\t}\", \"output\": \"Sets the sub-directory that the controller is in.\\n\\n@param string|null   $dir\\n@param boolean|false $append\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function setRequest(array $segments = [])\\n\\t{\\n\\t\\t// If we don't have any segments - try the default controller;\\n\\t\\tif (empty($segments))\\n\\t\\t{\\n\\t\\t\\t$this->setDefaultController();\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tlist($controller, $method) = array_pad(explode('::', $segments[0]), 2, null);\\n\\n\\t\\t$this->controller = $controller;\\n\\n\\t\\t// $this->method already contains the default method name,\\n\\t\\t// so don't overwrite it with emptiness.\\n\\t\\tif (! empty($method))\\n\\t\\t{\\n\\t\\t\\t$this->method = $method;\\n\\t\\t}\\n\\n\\t\\tarray_shift($segments);\\n\\n\\t\\t$this->params = $segments;\\n\\t}\", \"output\": \"Set request route\\n\\nTakes an array of URI segments as input and sets the class/method\\nto be called.\\n\\n@param array $segments URI segments\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function setDefaultController()\\n\\t{\\n\\t\\tif (empty($this->controller))\\n\\t\\t{\\n\\t\\t\\tthrow RouterException::forMissingDefaultRoute();\\n\\t\\t}\\n\\n\\t\\t// Is the method being specified?\\n\\t\\tif (sscanf($this->controller, '%[^/]/%s', $class, $this->method) !== 2)\\n\\t\\t{\\n\\t\\t\\t$this->method = 'index';\\n\\t\\t}\\n\\n\\t\\tif (! is_file(APPPATH . 'Controllers/' . $this->directory . ucfirst($class) . '.php'))\\n\\t\\t{\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t$this->controller = ucfirst($class);\\n\\n\\t\\tlog_message('info', 'Used the default controller.');\\n\\t}\", \"output\": \"Sets the default controller based on the info set in the RouteCollection.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getSize(string $unit = 'b')\\n\\t{\\n\\t\\tif (is_null($this->size))\\n\\t\\t{\\n\\t\\t\\t$this->size = filesize($this->getPathname());\\n\\t\\t}\\n\\n\\t\\tswitch (strtolower($unit))\\n\\t\\t{\\n\\t\\t\\tcase 'kb':\\n\\t\\t\\t\\treturn number_format($this->size / 1024, 3);\\n\\t\\t\\tcase 'mb':\\n\\t\\t\\t\\treturn number_format(($this->size / 1024) / 1024, 3);\\n\\t\\t}\\n\\n\\t\\treturn (int) $this->size;\\n\\t}\", \"output\": \"Retrieve the file size.\\n\\nImplementations SHOULD return the value stored in the \\\"size\\\" key of\\nthe file in the $_FILES array if available, as PHP calculates this based\\non the actual size transmitted.\\n\\n@param string $unit The unit to return:\\n- b   Bytes\\n- kb  Kilobytes\\n- mb  Megabytes\\n\\n@return integer|null The file size in bytes or null if unknown.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function move(string $targetPath, string $name = null, bool $overwrite = false)\\n\\t{\\n\\t\\t$targetPath  = rtrim($targetPath, '/') . '/';\\n\\t\\t$name        = $name ?? $this->getBaseName();\\n\\t\\t$destination = $overwrite ? $targetPath . $name : $this->getDestination($targetPath . $name);\\n\\n\\t\\t$oldName = empty($this->getRealPath()) ? $this->getPath() : $this->getRealPath();\\n\\n\\t\\tif (! @rename($oldName, $destination))\\n\\t\\t{\\n\\t\\t\\t$error = error_get_last();\\n\\t\\t\\tthrow FileException::forUnableToMove($this->getBasename(), $targetPath, strip_tags($error['message']));\\n\\t\\t}\\n\\n\\t\\t@chmod($targetPath, 0777 & ~umask());\\n\\n\\t\\treturn new File($destination);\\n\\t}\", \"output\": \"Moves a file to a new location.\\n\\n@param string      $targetPath\\n@param string|null $name\\n@param boolean     $overwrite\\n\\n@return \\\\CodeIgniter\\\\Files\\\\File\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getDestination(string $destination, string $delimiter = '_', int $i = 0): string\\n\\t{\\n\\t\\twhile (is_file($destination))\\n\\t\\t{\\n\\t\\t\\t$info = pathinfo($destination);\\n\\t\\t\\tif (strpos($info['filename'], $delimiter) !== false)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$parts = explode($delimiter, $info['filename']);\\n\\t\\t\\t\\tif (is_numeric(end($parts)))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$i = end($parts);\\n\\t\\t\\t\\t\\tarray_pop($parts);\\n\\t\\t\\t\\t\\tarray_push($parts, ++ $i);\\n\\t\\t\\t\\t\\t$destination = $info['dirname'] . '/' . implode($delimiter, $parts) . '.' . $info['extension'];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$destination = $info['dirname'] . '/' . $info['filename'] . $delimiter . ++ $i . '.' . $info['extension'];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t$destination = $info['dirname'] . '/' . $info['filename'] . $delimiter . ++ $i . '.' . $info['extension'];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn $destination;\\n\\t}\", \"output\": \"Returns the destination path for the move operation where overwriting is not expected.\\n\\nFirst, it checks whether the delimiter is present in the filename, if it is, then it checks whether the\\nlast element is an integer as there may be cases that the delimiter may be present in the filename.\\nFor the all other cases, it appends an integer starting from zero before the file's extension.\\n\\n@param string  $destination\\n@param string  $delimiter\\n@param integer $i\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function collect(Query $query)\\n\\t{\\n\\t\\t$config = config('Toolbar');\\n\\n\\t\\t// Provide default in case it's not set\\n\\t\\t$max = $config->maxQueries ?: 100;\\n\\n\\t\\tif (count(static::$queries) < $max)\\n\\t\\t{\\n\\t\\t\\tstatic::$queries[] = $query;\\n\\t\\t}\\n\\t}\", \"output\": \"The static method used during Events to collect\\ndata.\\n\\n@param \\\\CodeIgniter\\\\Database\\\\Query $query\\n\\n@internal param $ array \\\\CodeIgniter\\\\Database\\\\Query\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function formatTimelineData(): array\\n\\t{\\n\\t\\t$data = [];\\n\\n\\t\\tforeach ($this->connections as $alias => $connection)\\n\\t\\t{\\n\\t\\t\\t// Connection Time\\n\\t\\t\\t$data[] = [\\n\\t\\t\\t\\t'name'      => 'Connecting to Database: \\\"' . $alias . '\\\"',\\n\\t\\t\\t\\t'component' => 'Database',\\n\\t\\t\\t\\t'start'     => $connection->getConnectStart(),\\n\\t\\t\\t\\t'duration'  => $connection->getConnectDuration(),\\n\\t\\t\\t];\\n\\t\\t}\\n\\n\\t\\tforeach (static::$queries as $query)\\n\\t\\t{\\n\\t\\t\\t$data[] = [\\n\\t\\t\\t\\t'name'      => 'Query',\\n\\t\\t\\t\\t'component' => 'Database',\\n\\t\\t\\t\\t'start'     => $query->getStartTime(true),\\n\\t\\t\\t\\t'duration'  => $query->getDuration(),\\n\\t\\t\\t];\\n\\t\\t}\\n\\n\\t\\treturn $data;\\n\\t}\", \"output\": \"Returns timeline data formatted for the toolbar.\\n\\n@return array The formatted data or an empty array.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function locateFile(string $file, string $folder = null, string $ext = 'php')\\n\\t{\\n\\t\\t$file = $this->ensureExt($file, $ext);\\n\\n\\t\\t// Clears the folder name if it is at the beginning of the filename\\n\\t\\tif (! empty($folder) && ($pos = strpos($file, $folder)) === 0)\\n\\t\\t{\\n\\t\\t\\t$file = substr($file, strlen($folder . '/'));\\n\\t\\t}\\n\\n\\t\\t// Is not namespaced? Try the application folder.\\n\\t\\tif (strpos($file, '\\\\\\\\') === false)\\n\\t\\t{\\n\\t\\t\\treturn $this->legacyLocate($file, $folder);\\n\\t\\t}\\n\\n\\t\\t// Standardize slashes to handle nested directories.\\n\\t\\t$file = strtr($file, '/', '\\\\\\\\');\\n\\n\\t\\t$segments = explode('\\\\\\\\', $file);\\n\\n\\t\\t// The first segment will be empty if a slash started the filename.\\n\\t\\tif (empty($segments[0]))\\n\\t\\t{\\n\\t\\t\\tunset($segments[0]);\\n\\t\\t}\\n\\n\\t\\t$path     = '';\\n\\t\\t$prefix   = '';\\n\\t\\t$filename = '';\\n\\n\\t\\t// Namespaces always comes with arrays of paths\\n\\t\\t$namespaces = $this->autoloader->getNamespace();\\n\\n\\t\\twhile (! empty($segments))\\n\\t\\t{\\n\\t\\t\\t$prefix .= empty($prefix)\\n\\t\\t\\t\\t? ucfirst(array_shift($segments))\\n\\t\\t\\t\\t: '\\\\\\\\' . ucfirst(array_shift($segments));\\n\\n\\t\\t\\tif (empty($namespaces[$prefix]))\\n\\t\\t\\t{\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\t$path = $this->getNamespaces($prefix);\\n\\n\\t\\t\\t$filename = implode('/', $segments);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\t// IF we have a folder name, then the calling function\\n\\t\\t// expects this file to be within that folder, like 'Views',\\n\\t\\t// or 'libraries'.\\n\\t\\tif (! empty($folder) && strpos($path . $filename, '/' . $folder . '/') === false)\\n\\t\\t{\\n\\t\\t\\t$filename = $folder . '/' . $filename;\\n\\t\\t}\\n\\n\\t\\t$path .= $filename;\\n\\n\\t\\treturn is_file($path) ? $path : false;\\n\\t}\", \"output\": \"Attempts to locate a file by examining the name for a namespace\\nand looking through the PSR-4 namespaced files that we know about.\\n\\n@param string $file   The namespaced file to locate\\n@param string $folder The folder within the namespace that we should look for the file.\\n@param string $ext    The file extension the file should have.\\n\\n@return string|false The path to the file, or false if not found.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getClassname(string $file) : string\\n\\t{\\n\\t\\t$php        = file_get_contents($file);\\n\\t\\t$tokens     = token_get_all($php);\\n\\t\\t$count      = count($tokens);\\n\\t\\t$dlm        = false;\\n\\t\\t$namespace  = '';\\n\\t\\t$class_name = '';\\n\\n\\t\\tfor ($i = 2; $i < $count; $i++)\\n\\t\\t{\\n\\t\\t\\tif ((isset($tokens[$i - 2][1]) && ($tokens[$i - 2][1] === 'phpnamespace' || $tokens[$i - 2][1] === 'namespace')) || ($dlm && $tokens[$i - 1][0] === T_NS_SEPARATOR && $tokens[$i][0] === T_STRING))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (! $dlm)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$namespace = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (isset($tokens[$i][1]))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$namespace = $namespace ? $namespace . '\\\\\\\\' . $tokens[$i][1] : $tokens[$i][1];\\n\\t\\t\\t\\t\\t$dlm       = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telseif ($dlm && ($tokens[$i][0] !== T_NS_SEPARATOR) && ($tokens[$i][0] !== T_STRING))\\n\\t\\t\\t{\\n\\t\\t\\t\\t$dlm = false;\\n\\t\\t\\t}\\n\\t\\t\\tif (($tokens[$i - 2][0] === T_CLASS || (isset($tokens[$i - 2][1]) && $tokens[$i - 2][1] === 'phpclass'))\\n\\t\\t\\t\\t&& $tokens[$i - 1][0] === T_WHITESPACE\\n\\t\\t\\t\\t&& $tokens[$i][0] === T_STRING)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$class_name = $tokens[$i][1];\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (empty( $class_name ))\\n\\t\\t{\\n\\t\\t\\treturn '';\\n\\t\\t}\\n\\n\\t\\treturn $namespace . '\\\\\\\\' . $class_name;\\n\\t}\", \"output\": \"Examines a file and returns the fully qualified domain name.\\n\\n@param string $file\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function search(string $path, string $ext = 'php'): array\\n\\t{\\n\\t\\t$path = $this->ensureExt($path, $ext);\\n\\n\\t\\t$foundPaths = [];\\n\\n\\t\\tforeach ($this->getNamespaces() as $namespace)\\n\\t\\t{\\n\\t\\t\\tif (is_file($namespace['path'] . $path))\\n\\t\\t\\t{\\n\\t\\t\\t\\t$foundPaths[] = $namespace['path'] . $path;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Remove any duplicates\\n\\t\\t$foundPaths = array_unique($foundPaths);\\n\\n\\t\\treturn $foundPaths;\\n\\t}\", \"output\": \"Searches through all of the defined namespaces looking for a file.\\nReturns an array of all found locations for the defined file.\\n\\nExample:\\n\\n$locator->search('Config/Routes.php');\\n// Assuming PSR4 namespaces include foo and bar, might return:\\n[\\n'app/Modules/foo/Config/Routes.php',\\n'app/Modules/bar/Config/Routes.php',\\n]\\n\\n@param string $path\\n@param string $ext\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function ensureExt(string $path, string $ext): string\\n\\t{\\n\\t\\tif ($ext)\\n\\t\\t{\\n\\t\\t\\t$ext = '.' . $ext;\\n\\n\\t\\t\\tif (substr($path, -strlen($ext)) !== $ext)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$path .= $ext;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $path;\\n\\t}\", \"output\": \"Ensures a extension is at the end of a filename\\n\\n@param string $path\\n@param string $ext\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function findQualifiedNameFromPath(string $path)\\n\\t{\\n\\t\\t$path = realpath($path);\\n\\n\\t\\tif (! $path)\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tforeach ($this->getNamespaces() as $namespace)\\n\\t\\t{\\n\\t\\t\\t$namespace['path'] = realpath($namespace['path']);\\n\\n\\t\\t\\tif (empty($namespace['path']))\\n\\t\\t\\t{\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (mb_strpos($path, $namespace['path']) === 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\t$className = '\\\\\\\\' . $namespace['prefix'] . '\\\\\\\\' .\\n\\t\\t\\t\\t\\t\\tltrim(str_replace('/', '\\\\\\\\', mb_substr(\\n\\t\\t\\t\\t\\t\\t\\t$path, mb_strlen($namespace['path']))\\n\\t\\t\\t\\t\\t\\t), '\\\\\\\\');\\n\\t\\t\\t\\t// Remove the file extension (.php)\\n\\t\\t\\t\\t$className = mb_substr($className, 0, -4);\\n\\n\\t\\t\\t\\treturn $className;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\", \"output\": \"Find the qualified name of a file according to\\nthe namespace of the first matched namespace path.\\n\\n@param string $path\\n\\n@return string|false The qualified name or false if the path is not found\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function legacyLocate(string $file, string $folder = null)\\n\\t{\\n\\t\\t$paths = [\\n\\t\\t\\tAPPPATH,\\n\\t\\t\\tSYSTEMPATH,\\n\\t\\t];\\n\\n\\t\\tforeach ($paths as $path)\\n\\t\\t{\\n\\t\\t\\t$path .= empty($folder) ? $file : $folder . '/' . $file;\\n\\n\\t\\t\\tif (is_file($path))\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn $path;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\", \"output\": \"Checks the application folder to see if the file can be found.\\nOnly for use with filenames that DO NOT include namespacing.\\n\\n@param string      $file\\n@param string|null $folder\\n\\n@return string|false The path to the file, or false if not found.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function renderString(string $view, array $options = null, bool $saveData = null): string\\n\\t{\\n\\t\\t$start = microtime(true);\\n\\t\\tif (is_null($saveData))\\n\\t\\t{\\n\\t\\t\\t$saveData = $this->config->saveData;\\n\\t\\t}\\n\\n\\t\\textract($this->data);\\n\\n\\t\\tif (! $saveData)\\n\\t\\t{\\n\\t\\t\\t$this->data = [];\\n\\t\\t}\\n\\n\\t\\tob_start();\\n\\t\\t$incoming = '?>' . $view;\\n\\t\\teval($incoming);\\n\\t\\t$output = ob_get_contents();\\n\\t\\t@ob_end_clean();\\n\\n\\t\\t$this->logPerformance($start, microtime(true), $this->excerpt($view));\\n\\n\\t\\treturn $output;\\n\\t}\", \"output\": \"Builds the output based upon a string and any\\ndata that has already been set.\\nCache does not apply, because there is no \\\"key\\\".\\n\\n@param string  $view     The view contents\\n@param array   $options  Reserved for 3rd-party uses since\\nit might be needed to pass additional info\\nto other template engines.\\n@param boolean $saveData If true, will save data for use with any other calls,\\nif false, will clean the data after displaying the view,\\nif not specified, use the config setting.\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setData(array $data = [], string $context = null): RendererInterface\\n\\t{\\n\\t\\tif (! empty($context))\\n\\t\\t{\\n\\t\\t\\t$data = \\\\esc($data, $context);\\n\\t\\t}\\n\\n\\t\\t$this->data = array_merge($this->data, $data);\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Sets several pieces of view data at once.\\n\\n@param array  $data\\n@param string $context The context to escape it for: html, css, js, url\\nIf null, no escaping will happen\\n\\n@return RendererInterface\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setVar(string $name, $value = null, string $context = null): RendererInterface\\n\\t{\\n\\t\\tif (! empty($context))\\n\\t\\t{\\n\\t\\t\\t$value = \\\\esc($value, $context);\\n\\t\\t}\\n\\n\\t\\t$this->data[$name] = $value;\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Sets a single piece of view data.\\n\\n@param string $name\\n@param mixed  $value\\n@param string $context The context to escape it for: html, css, js, url\\nIf null, no escaping will happen\\n\\n@return RendererInterface\"}"}
{"text": "{\"input\": \"Summarize the following code: public function renderSection(string $sectionName)\\n\\t{\\n\\t\\tif (! isset($this->sections[$sectionName]))\\n\\t\\t{\\n\\t\\t\\techo '';\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tforeach ($this->sections[$sectionName] as $contents)\\n\\t\\t{\\n\\t\\t\\techo $contents;\\n\\t\\t}\\n\\t}\", \"output\": \"Renders a section's contents.\\n\\n@param string $sectionName\"}"}
{"text": "{\"input\": \"Summarize the following code: public function include(string $view, array $options = null, $saveData = null): string\\n\\t{\\n\\t\\treturn $this->render($view, $options, $saveData);\\n\\t}\", \"output\": \"Used within layout views to include additional views.\\n\\n@param string     $view\\n@param array|null $options\\n@param null       $saveData\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function logPerformance(float $start, float $end, string $view)\\n\\t{\\n\\t\\tif (! $this->debug)\\n\\t\\t{\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t$this->performanceData[] = [\\n\\t\\t\\t'start' => $start,\\n\\t\\t\\t'end'   => $end,\\n\\t\\t\\t'view'  => $view,\\n\\t\\t];\\n\\t}\", \"output\": \"Logs performance data for rendering a view.\\n\\n@param float  $start\\n@param float  $end\\n@param string $view\"}"}
{"text": "{\"input\": \"Summarize the following code: public function withFile(string $path)\\n\\t{\\n\\t\\t// Clear out the old resource so that\\n\\t\\t// it doesn't try to use a previous image\\n\\t\\t$this->resource = null;\\n\\n\\t\\t$this->image = new Image($path, true);\\n\\n\\t\\t$this->image->getProperties(false);\\n\\t\\t$this->width  = $this->image->origWidth;\\n\\t\\t$this->height = $this->image->origHeight;\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Sets another image for this handler to work on.\\nKeeps us from needing to continually instantiate the handler.\\n\\n@param string $path\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function ensureResource()\\n\\t{\\n\\t\\tif ($this->resource === null)\\n\\t\\t{\\n\\t\\t\\t$path = $this->image->getPathname();\\n\\t\\t\\t// if valid image type, make corresponding image resource\\n\\t\\t\\tswitch ($this->image->imageType)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcase IMAGETYPE_GIF:\\n\\t\\t\\t\\t\\t$this->resource = imagecreatefromgif($path);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase IMAGETYPE_JPEG:\\n\\t\\t\\t\\t\\t$this->resource = imagecreatefromjpeg($path);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase IMAGETYPE_PNG:\\n\\t\\t\\t\\t\\t$this->resource = imagecreatefrompng($path);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\", \"output\": \"Make the image resource object if needed\"}"}
{"text": "{\"input\": \"Summarize the following code: public function resize(int $width, int $height, bool $maintainRatio = false, string $masterDim = 'auto')\\n\\t{\\n\\t\\t// If the target width/height match the source, then we have nothing to do here.\\n\\t\\tif ($this->image->origWidth === $width && $this->image->origHeight === $height)\\n\\t\\t{\\n\\t\\t\\treturn $this;\\n\\t\\t}\\n\\n\\t\\t$this->width  = $width;\\n\\t\\t$this->height = $height;\\n\\n\\t\\tif ($maintainRatio)\\n\\t\\t{\\n\\t\\t\\t$this->masterDim = $masterDim;\\n\\t\\t\\t$this->reproportion();\\n\\t\\t}\\n\\n\\t\\treturn $this->_resize($maintainRatio);\\n\\t}\", \"output\": \"Resize the image\\n\\n@param integer $width\\n@param integer $height\\n@param boolean $maintainRatio If true, will get the closest match possible while keeping aspect ratio true.\\n@param string  $masterDim\\n\\n@return BaseHandler\"}"}
{"text": "{\"input\": \"Summarize the following code: public function rotate(float $angle)\\n\\t{\\n\\t\\t// Allowed rotation values\\n\\t\\t$degs = [\\n\\t\\t\\t90,\\n\\t\\t\\t180,\\n\\t\\t\\t270,\\n\\t\\t];\\n\\n\\t\\tif ($angle === '' || ! in_array($angle, $degs))\\n\\t\\t{\\n\\t\\t\\tthrow ImageException::forMissingAngle();\\n\\t\\t}\\n\\n\\t\\t// cast angle as an int, for our use\\n\\t\\t$angle = (int) $angle;\\n\\n\\t\\t// Reassign the width and height\\n\\t\\tif ($angle === 90 || $angle === 270)\\n\\t\\t{\\n\\t\\t\\t$temp         = $this->height;\\n\\t\\t\\t$this->width  = $this->height;\\n\\t\\t\\t$this->height = $temp;\\n\\t\\t}\\n\\n\\t\\t// Call the Handler-specific version.\\n\\t\\t$this->_rotate($angle);\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Rotates the image on the current canvas.\\n\\n@param float $angle\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public function flip(string $dir = 'vertical')\\n\\t{\\n\\t\\t$dir = strtolower($dir);\\n\\n\\t\\tif ($dir !== 'vertical' && $dir !== 'horizontal')\\n\\t\\t{\\n\\t\\t\\tthrow ImageException::forInvalidDirection($dir);\\n\\t\\t}\\n\\n\\t\\treturn $this->_flip($dir);\\n\\t}\", \"output\": \"Flips an image either horizontally or vertically.\\n\\n@param string $dir Either 'vertical' or 'horizontal'\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: public function text(string $text, array $options = [])\\n\\t{\\n\\t\\t$options                = array_merge($this->textDefaults, $options);\\n\\t\\t$options['color']       = trim($options['color'], '# ');\\n\\t\\t$options['shadowColor'] = trim($options['shadowColor'], '# ');\\n\\n\\t\\t$this->_text($text, $options);\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Overlays a string of text over the image.\\n\\nValid options:\\n\\n- color         Text Color (hex number)\\n- shadowColor   Color of the shadow (hex number)\\n- hAlign        Horizontal alignment: left, center, right\\n- vAlign        Vertical alignment: top, middle, bottom\\n- hOffset\\n- vOffset\\n- fontPath\\n- fontSize\\n- shadowOffset\\n\\n@param string $text\\n@param array  $options\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: public function reorient(bool $silent = false)\\n\\t{\\n\\t\\t$orientation = $this->getEXIF('Orientation', $silent);\\n\\n\\t\\tswitch ($orientation)\\n\\t\\t{\\n\\t\\t\\tcase 2:\\n\\t\\t\\t\\treturn $this->flip('horizontal');\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 3:\\n\\t\\t\\t\\treturn $this->rotate(180);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 4:\\n\\t\\t\\t\\treturn $this->rotate(180)\\n\\t\\t\\t\\t\\t\\t\\t\\t->flip('horizontal');\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 5:\\n\\t\\t\\t\\treturn $this->rotate(270)\\n\\t\\t\\t\\t\\t\\t\\t\\t->flip('horizontal');\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 6:\\n\\t\\t\\t\\treturn $this->rotate(270);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 7:\\n\\t\\t\\t\\treturn $this->rotate(90)\\n\\t\\t\\t\\t\\t\\t\\t\\t->flip('horizontal');\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 8:\\n\\t\\t\\t\\treturn $this->rotate(90);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\treturn $this;\\n\\t\\t}\\n\\t}\", \"output\": \"Reads the EXIF information from the image and modifies the orientation\\nso that displays correctly in the browser. This is especially an issue\\nwith images taken by smartphones who always store the image up-right,\\nbut set the orientation flag to display it correctly.\\n\\n@param boolean $silent If true, will ignore exceptions when PHP doesn't support EXIF.\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getEXIF(string $key = null, bool $silent = false)\\n\\t{\\n\\t\\tif (! function_exists('exif_read_data'))\\n\\t\\t{\\n\\t\\t\\tif ($silent)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t$exif = exif_read_data($this->image->getPathname());\\n\\t\\tif (! is_null($key) && is_array($exif))\\n\\t\\t{\\n\\t\\t\\t$exif = $exif[$key] ?? false;\\n\\t\\t}\\n\\n\\t\\treturn $exif;\\n\\t}\", \"output\": \"Retrieve the EXIF information from the image, if possible. Returns\\nan array of the information, or null if nothing can be found.\\n\\n@param string|null $key    If specified, will only return this piece of EXIF data.\\n\\n@param boolean     $silent If true, will not throw our own exceptions.\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public function fit(int $width, int $height = null, string $position = 'center')\\n\\t{\\n\\t\\t$origWidth  = $this->image->origWidth;\\n\\t\\t$origHeight = $this->image->origHeight;\\n\\n\\t\\tlist($cropWidth, $cropHeight) = $this->calcAspectRatio($width, $height, $origWidth, $origHeight);\\n\\n\\t\\tif (is_null($height))\\n\\t\\t{\\n\\t\\t\\t$height = ceil(($width / $cropWidth) * $cropHeight);\\n\\t\\t}\\n\\n\\t\\tlist($x, $y) = $this->calcCropCoords($width, $height, $origWidth, $origHeight, $position);\\n\\n\\t\\treturn $this->crop($cropWidth, $cropHeight, $x, $y)\\n\\t\\t\\t\\t\\t\\t->resize($width, $height);\\n\\t}\", \"output\": \"Combine cropping and resizing into a single command.\\n\\nSupported positions:\\n- top-left\\n- top\\n- top-right\\n- left\\n- center\\n- right\\n- bottom-left\\n- bottom\\n- bottom-right\\n\\n@param integer $width\\n@param integer $height\\n@param string  $position\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: public function run(array $params)\\n\\t{\\n\\t\\t// Valid PHP Version?\\n\\t\\tif (phpversion() < $this->minPHPVersion)\\n\\t\\t{\\n\\t\\t\\tdie('Your PHP version must be ' . $this->minPHPVersion .\\n\\t\\t\\t\\t' or higher to run CodeIgniter. Current version: ' . phpversion());\\n\\t\\t}\\n\\n\\t\\t// Collect any user-supplied options and apply them.\\n\\t\\t$php  = CLI::getOption('php') ?? PHP_BINARY;\\n\\t\\t$host = CLI::getOption('host') ?? 'localhost';\\n\\t\\t$port = CLI::getOption('port') ?? '8080';\\n\\n\\t\\t// Get the party started.\\n\\t\\tCLI::write('CodeIgniter development server started on http://' . $host . ':' . $port, 'green');\\n\\t\\tCLI::write('Press Control-C to stop.');\\n\\n\\t\\t// Set the Front Controller path as Document Root.\\n\\t\\t$docroot = escapeshellarg(FCPATH);\\n\\n\\t\\t// Mimic Apache's mod_rewrite functionality with user settings.\\n\\t\\t$rewrite = escapeshellarg(__DIR__ . '/rewrite.php');\\n\\n\\t\\t// Call PHP's built-in webserver, making sure to set our\\n\\t\\t// base path to the public folder, and to use the rewrite file\\n\\t\\t// to ensure our environment is set and it simulates basic mod_rewrite.\\n\\t\\tpassthru($php . ' -S ' . $host . ':' . $port . ' -t ' . $docroot . ' ' . $rewrite);\\n\\t}\", \"output\": \"Run the server\\n\\n@param array $params Parameters\\n\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: public function renderString(string $template, array $options = null, bool $saveData = null): string\\n\\t{\\n\\t\\t$start = microtime(true);\\n\\t\\tif (is_null($saveData))\\n\\t\\t{\\n\\t\\t\\t$saveData = $this->config->saveData;\\n\\t\\t}\\n\\n\\t\\t$output = $this->parse($template, $this->data, $options);\\n\\n\\t\\t$this->logPerformance($start, microtime(true), $this->excerpt($template));\\n\\n\\t\\tif (! $saveData)\\n\\t\\t{\\n\\t\\t\\t$this->data = [];\\n\\t\\t}\\n\\t\\treturn $output;\\n\\t}\", \"output\": \"Parse a String\\n\\nParses pseudo-variables contained in the specified string,\\nreplacing them with any data that has already been set.\\n\\n@param string  $template\\n@param array   $options\\n@param boolean $saveData\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function parsePair(string $variable, array $data, string $template): array\\n\\t{\\n\\t\\t// Holds the replacement patterns and contents\\n\\t\\t// that will be used within a preg_replace in parse()\\n\\t\\t$replace = [];\\n\\n\\t\\t// Find all matches of space-flexible versions of {tag}{/tag} so we\\n\\t\\t// have something to loop over.\\n\\t\\tpreg_match_all(\\n\\t\\t\\t\\t'#' . $this->leftDelimiter . '\\\\s*' . preg_quote($variable) . '\\\\s*' . $this->rightDelimiter . '(.+?)' .\\n\\t\\t\\t\\t$this->leftDelimiter . '\\\\s*' . '/' . preg_quote($variable) . '\\\\s*' . $this->rightDelimiter . '#s', $template, $matches, PREG_SET_ORDER\\n\\t\\t);\\n\\n\\t\\t/*\\n\\t\\t * Each match looks like:\\n\\t\\t *\\n\\t\\t * $match[0] {tag}...{/tag}\\n\\t\\t * $match[1] Contents inside the tag\\n\\t\\t */\\n\\t\\tforeach ($matches as $match)\\n\\t\\t{\\n\\t\\t\\t// Loop over each piece of $data, replacing\\n\\t\\t\\t// it's contents so that we know what to replace in parse()\\n\\t\\t\\t$str = '';  // holds the new contents for this tag pair.\\n\\t\\t\\tforeach ($data as $row)\\n\\t\\t\\t{\\n\\t\\t\\t\\t// Objects that have a `toArray()` method should be\\n\\t\\t\\t\\t// converted with that method (i.e. Entities)\\n\\t\\t\\t\\tif (is_object($row) && method_exists($row, 'toArray'))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$row = $row->toArray();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Otherwise, cast as an array and it will grab public properties.\\n\\t\\t\\t\\telse if (is_object($row))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$row = (array)$row;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t$temp  = [];\\n\\t\\t\\t\\t$pairs = [];\\n\\t\\t\\t\\t$out   = $match[1];\\n\\t\\t\\t\\tforeach ($row as $key => $val)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t// For nested data, send us back through this method...\\n\\t\\t\\t\\t\\tif (is_array($val))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t$pair = $this->parsePair($key, $val, $match[1]);\\n\\n\\t\\t\\t\\t\\t\\tif (! empty($pair))\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t$pairs[array_keys( $pair )[0]] = true;\\n\\t\\t\\t\\t\\t\\t\\t$temp                          = array_merge($temp, $pair);\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if (is_object($val))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t$val = 'Class: ' . get_class($val);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if (is_resource($val))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t$val = 'Resource';\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t$temp['#' . $this->leftDelimiter . '!?\\\\s*' . preg_quote($key) . '\\\\s*\\\\|*\\\\s*([|\\\\w<>=\\\\(\\\\),:_\\\\-\\\\s\\\\+]+)*\\\\s*!?' . $this->rightDelimiter . '#s'] = $val;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Now replace our placeholders with the new content.\\n\\t\\t\\t\\tforeach ($temp as $pattern => $content)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$out = $this->replaceSingle($pattern, $content, $out, ! isset( $pairs[$pattern] ) );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t$str .= $out;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$replace['#' . $match[0] . '#s'] = $str;\\n\\t\\t}\\n\\n\\t\\treturn $replace;\\n\\t}\", \"output\": \"Parse a tag pair\\n\\nParses tag pairs: {some_tag} string... {/some_tag}\\n\\n@param  string $variable\\n@param  array  $data\\n@param  string $template\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function extractNoparse(string $template): string\\n\\t{\\n\\t\\t$pattern = '/\\\\{\\\\s*noparse\\\\s*\\\\}(.*?)\\\\{\\\\s*\\\\/noparse\\\\s*\\\\}/ms';\\n\\n\\t\\t/*\\n\\t\\t * $matches[][0] is the raw match\\n\\t\\t * $matches[][1] is the contents\\n\\t\\t */\\n\\t\\tif (preg_match_all($pattern, $template, $matches, PREG_SET_ORDER))\\n\\t\\t{\\n\\t\\t\\tforeach ($matches as $match)\\n\\t\\t\\t{\\n\\t\\t\\t\\t// Create a hash of the contents to insert in its place.\\n\\t\\t\\t\\t$hash                       = md5($match[1]);\\n\\t\\t\\t\\t$this->noparseBlocks[$hash] = $match[1];\\n\\t\\t\\t\\t$template                   = str_replace($match[0], \\\"noparse_{$hash}\\\", $template);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $template;\\n\\t}\", \"output\": \"Extracts noparse blocks, inserting a hash in its place so that\\nthose blocks of the page are not touched by parsing.\\n\\n@param string $template\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function insertNoparse(string $template): string\\n\\t{\\n\\t\\tforeach ($this->noparseBlocks as $hash => $replace)\\n\\t\\t{\\n\\t\\t\\t$template = str_replace(\\\"noparse_{$hash}\\\", $replace, $template);\\n\\t\\t\\tunset($this->noparseBlocks[$hash]);\\n\\t\\t}\\n\\n\\t\\treturn $template;\\n\\t}\", \"output\": \"Re-inserts the noparsed contents back into the template.\\n\\n@param string $template\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function parseConditionals(string $template): string\\n\\t{\\n\\t\\t$pattern = '/\\\\{\\\\s*(if|elseif)\\\\s*((?:\\\\()?(.*?)(?:\\\\))?)\\\\s*\\\\}/ms';\\n\\n\\t\\t/**\\n\\t\\t * For each match:\\n\\t\\t * [0] = raw match `{if var}`\\n\\t\\t * [1] = conditional `if`\\n\\t\\t * [2] = condition `do === true`\\n\\t\\t * [3] = same as [2]\\n\\t\\t */\\n\\t\\tpreg_match_all($pattern, $template, $matches, PREG_SET_ORDER);\\n\\n\\t\\tforeach ($matches as $match)\\n\\t\\t{\\n\\t\\t\\t// Build the string to replace the `if` statement with.\\n\\t\\t\\t$condition = $match[2];\\n\\n\\t\\t\\t$statement = $match[1] === 'elseif' ? '<?php elseif (' . $condition . '): ?>' : '<?php if (' . $condition . '): ?>';\\n\\t\\t\\t$template  = str_replace($match[0], $statement, $template);\\n\\t\\t}\\n\\n\\t\\t$template = preg_replace('/\\\\{\\\\s*else\\\\s*\\\\}/ms', '<?php else: ?>', $template);\\n\\t\\t$template = preg_replace('/\\\\{\\\\s*endif\\\\s*\\\\}/ms', '<?php endif; ?>', $template);\\n\\n\\t\\t// Parse the PHP itself, or insert an error so they can debug\\n\\t\\tob_start();\\n\\t\\textract($this->data);\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\teval('?>' . $template . '<?php ');\\n\\t\\t}\\n\\t\\tcatch (\\\\ParseError $e)\\n\\t\\t{\\n\\t\\t\\tob_end_clean();\\n\\t\\t\\tthrow ViewException::forTagSyntaxError(str_replace(['?>', '<?php '], '', $template));\\n\\t\\t}\\n\\t\\treturn ob_get_clean();\\n\\t}\", \"output\": \"Parses any conditionals in the code, removing blocks that don't\\npass so we don't try to parse it later.\\n\\nValid conditionals:\\n- if\\n- elseif\\n- else\\n\\n@param string $template\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setDelimiters($leftDelimiter = '{', $rightDelimiter = '}'): RendererInterface\\n\\t{\\n\\t\\t$this->leftDelimiter  = $leftDelimiter;\\n\\t\\t$this->rightDelimiter = $rightDelimiter;\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Over-ride the substitution field delimiters.\\n\\n@param  string $leftDelimiter\\n@param  string $rightDelimiter\\n@return RendererInterface\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function replaceSingle($pattern, $content, $template, bool $escape = false): string\\n\\t{\\n\\t\\t// Any dollar signs in the pattern will be mis-interpreted, so slash them\\n\\t\\t$pattern = addcslashes($pattern, '$');\\n\\n\\t\\t// Replace the content in the template\\n\\t\\t$template = preg_replace_callback($pattern, function ($matches) use ($content, $escape) {\\n\\t\\t\\t// Check for {! !} syntax to not-escape this one.\\n\\t\\t\\tif (strpos($matches[0], '{!') === 0 && substr($matches[0], -2) === '!}')\\n\\t\\t\\t{\\n\\t\\t\\t\\t$escape = false;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn $this->prepareReplacement($matches, $content, $escape);\\n\\t\\t}, $template);\\n\\n\\t\\treturn $template;\\n\\t}\", \"output\": \"Handles replacing a pseudo-variable with the actual content. Will double-check\\nfor escaping brackets.\\n\\n@param $pattern\\n@param $content\\n@param $template\\n@param boolean  $escape\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function shouldAddEscaping(string $key)\\n\\t{\\n\\t\\t$escape = false;\\n\\n\\t\\t$key = trim(str_replace(['{', '}'], '', $key));\\n\\n\\t\\t// If the key has a context stored (from setData)\\n\\t\\t// we need to respect that.\\n\\t\\tif (array_key_exists($key, $this->dataContexts))\\n\\t\\t{\\n\\t\\t\\tif ($this->dataContexts[$key] !== 'raw')\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn $this->dataContexts[$key];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// No pipes, then we know we need to escape\\n\\t\\telseif (strpos($key, '|') === false)\\n\\t\\t{\\n\\t\\t\\t$escape = 'html';\\n\\t\\t}\\n\\t\\t// If there's a `noescape` then we're definitely false.\\n\\t\\telseif (strpos($key, 'noescape') !== false)\\n\\t\\t{\\n\\t\\t\\t$escape = false;\\n\\t\\t}\\n\\t\\t// If no `esc` filter is found, then we'll need to add one.\\n\\t\\telseif (! preg_match('/\\\\s+esc/', $key))\\n\\t\\t{\\n\\t\\t\\t$escape = 'html';\\n\\t\\t}\\n\\n\\t\\treturn $escape;\\n\\t}\", \"output\": \"Checks the placeholder the view provided to see if we need to provide any autoescaping.\\n\\n@param string $key\\n\\n@return false|string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function addPlugin(string $alias, callable $callback, bool $isPair = false)\\n\\t{\\n\\t\\t$this->plugins[$alias] = $isPair ? [$callback] : $callback;\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Makes a new plugin available during the parsing of the template.\\n\\n@param string   $alias\\n@param callable $callback\\n\\n@param boolean  $isPair\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function createImage(string $path = '', string $imageType = '')\\n\\t{\\n\\t\\tif ($this->resource !== null)\\n\\t\\t{\\n\\t\\t\\treturn $this->resource;\\n\\t\\t}\\n\\n\\t\\tif ($path === '')\\n\\t\\t{\\n\\t\\t\\t$path = $this->image->getPathname();\\n\\t\\t}\\n\\n\\t\\tif ($imageType === '')\\n\\t\\t{\\n\\t\\t\\t$imageType = $this->image->imageType;\\n\\t\\t}\\n\\n\\t\\tswitch ($imageType)\\n\\t\\t{\\n\\t\\t\\tcase IMAGETYPE_GIF:\\n\\t\\t\\t\\tif (! function_exists('imagecreatefromgif'))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tthrow ImageException::forInvalidImageCreate(lang('images.gifNotSupported'));\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn imagecreatefromgif($path);\\n\\t\\t\\tcase IMAGETYPE_JPEG:\\n\\t\\t\\t\\tif (! function_exists('imagecreatefromjpeg'))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tthrow ImageException::forInvalidImageCreate(lang('images.jpgNotSupported'));\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn imagecreatefromjpeg($path);\\n\\t\\t\\tcase IMAGETYPE_PNG:\\n\\t\\t\\t\\tif (! function_exists('imagecreatefrompng'))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tthrow ImageException::forInvalidImageCreate(lang('images.pngNotSupported'));\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn imagecreatefrompng($path);\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tthrow ImageException::forInvalidImageCreate('Ima');\\n\\t\\t}\\n\\t}\", \"output\": \"Create Image Resource\\n\\nThis simply creates an image resource handle\\nbased on the type of image being processed\\n\\n@param string    $path\\n@param string    $imageType\\n\\n@return resource|boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getHeader(string $name)\\n\\t{\\n\\t\\t$orig_name = $this->getHeaderName($name);\\n\\n\\t\\tif (! isset($this->headers[$orig_name]))\\n\\t\\t{\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\treturn $this->headers[$orig_name];\\n\\t}\", \"output\": \"Returns a single header object. If multiple headers with the same\\nname exist, then will return an array of header objects.\\n\\n@param string $name\\n\\n@return array|\\\\CodeIgniter\\\\HTTP\\\\Header\"}"}
{"text": "{\"input\": \"Summarize the following code: public function hasHeader(string $name): bool\\n\\t{\\n\\t\\t$orig_name = $this->getHeaderName($name);\\n\\n\\t\\treturn isset($this->headers[$orig_name]);\\n\\t}\", \"output\": \"Determines whether a header exists.\\n\\n@param string    $name\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setHeader(string $name, $value)\\n\\t{\\n\\t\\tif (! isset($this->headers[$name]))\\n\\t\\t{\\n\\t\\t\\t$this->headers[$name] = new Header($name, $value);\\n\\n\\t\\t\\t$this->headerMap[strtolower($name)] = $name;\\n\\n\\t\\t\\treturn $this;\\n\\t\\t}\\n\\n\\t\\tif (! is_array($this->headers[$name]))\\n\\t\\t{\\n\\t\\t\\t$this->headers[$name] = [$this->headers[$name]];\\n\\t\\t}\\n\\n\\t\\tif (isset($this->headers[$name]))\\n\\t\\t{\\n\\t\\t\\t$this->headers[$name] = new Header($name, $value);\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Sets a header and it's value.\\n\\n@param string            $name\\n@param array|null|string $value\\n\\n@return Message|Response\"}"}
{"text": "{\"input\": \"Summarize the following code: public function removeHeader(string $name)\\n\\t{\\n\\t\\t$orig_name = $this->getHeaderName($name);\\n\\n\\t\\tunset($this->headers[$orig_name]);\\n\\t\\tunset($this->headerMap[strtolower($name)]);\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Removes a header from the list of headers we track.\\n\\n@param string $name\\n\\n@return Message\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setProtocolVersion(string $version)\\n\\t{\\n\\t\\tif (! is_numeric($version))\\n\\t\\t{\\n\\t\\t\\t$version = substr($version, strpos($version, '/') + 1);\\n\\t\\t}\\n\\n\\t\\tif (! in_array($version, $this->validProtocolVersions))\\n\\t\\t{\\n\\t\\t\\tthrow HTTPException::forInvalidHTTPProtocol(implode(', ', $this->validProtocolVersions));\\n\\t\\t}\\n\\n\\t\\t$this->protocolVersion = $version;\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Sets the HTTP protocol version.\\n\\n@param string $version\\n\\n@return Message\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function getHeaderName(string $name): string\\n\\t{\\n\\t\\t$lower_name = strtolower($name);\\n\\n\\t\\treturn $this->headerMap[$lower_name] ?? $name;\\n\\t}\", \"output\": \"Takes a header name in any case, and returns the\\nnormal-case version of the header.\\n\\n@param string $name\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function configureSessionIDRegex()\\n\\t{\\n\\t\\t$bitsPerCharacter = (int)ini_get('session.sid_bits_per_character');\\n\\t\\t$SIDLength        = (int)ini_get('session.sid_length');\\n\\n\\t\\tif (($bits = $SIDLength * $bitsPerCharacter) < 160)\\n\\t\\t{\\n\\t\\t\\t// Add as many more characters as necessary to reach at least 160 bits\\n\\t\\t\\t$SIDLength += (int)ceil((160 % $bits) / $bitsPerCharacter);\\n\\t\\t\\tini_set('session.sid_length', $SIDLength);\\n\\t\\t}\\n\\n\\t\\t// Yes, 4,5,6 are the only known possible values as of 2016-10-27\\n\\t\\tswitch ($bitsPerCharacter)\\n\\t\\t{\\n\\t\\t\\tcase 4:\\n\\t\\t\\t\\t$this->sessionIDRegex = '[0-9a-f]';\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 5:\\n\\t\\t\\t\\t$this->sessionIDRegex = '[0-9a-v]';\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 6:\\n\\t\\t\\t\\t$this->sessionIDRegex = '[0-9a-zA-Z,-]';\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\t$this->sessionIDRegex .= '{' . $SIDLength . '}';\\n\\t}\", \"output\": \"Configure Session ID regular expression\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getReason(): string\\n\\t{\\n\\t\\tif (empty($this->reason))\\n\\t\\t{\\n\\t\\t\\treturn ! empty($this->statusCode) ? static::$statusCodes[$this->statusCode] : '';\\n\\t\\t}\\n\\n\\t\\treturn $this->reason;\\n\\t}\", \"output\": \"Gets the response response phrase associated with the status code.\\n\\n@see http://tools.ietf.org/html/rfc7231#section-6\\n@see http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setLink(PagerInterface $pager)\\n\\t{\\n\\t\\t$links = '';\\n\\n\\t\\tif ($previous = $pager->getPreviousPageURI())\\n\\t\\t{\\n\\t\\t\\t$links .= '<' . $pager->getPageURI($pager->getFirstPage()) . '>; rel=\\\"first\\\",';\\n\\t\\t\\t$links .= '<' . $previous . '>; rel=\\\"prev\\\"';\\n\\t\\t}\\n\\n\\t\\tif (($next = $pager->getNextPageURI()) && $previous)\\n\\t\\t{\\n\\t\\t\\t$links .= ',';\\n\\t\\t}\\n\\n\\t\\tif ($next)\\n\\t\\t{\\n\\t\\t\\t$links .= '<' . $next . '>; rel=\\\"next\\\",';\\n\\t\\t\\t$links .= '<' . $pager->getPageURI($pager->getLastPage()) . '>; rel=\\\"last\\\"';\\n\\t\\t}\\n\\n\\t\\t$this->setHeader('Link', $links);\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Set the Link Header\\n\\n@param \\\\CodeIgniter\\\\Pager\\\\PagerInterface $pager\\n\\n@see http://tools.ietf.org/html/rfc5988\\n\\n@return Response\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setContentType(string $mime, string $charset = 'UTF-8')\\n\\t{\\n\\t\\t// add charset attribute if not already there and provided as parm\\n\\t\\tif ((strpos($mime, 'charset=') < 1) && ! empty($charset))\\n\\t\\t{\\n\\t\\t\\t$mime .= '; charset=' . $charset;\\n\\t\\t}\\n\\n\\t\\t$this->removeHeader('Content-Type'); // replace existing content type\\n\\t\\t$this->setHeader('Content-Type', $mime);\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Sets the Content Type header for this response with the mime type\\nand, optionally, the charset.\\n\\n@param string $mime\\n@param string $charset\\n\\n@return Response\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getJSON()\\n\\t{\\n\\t\\t$body = $this->body;\\n\\n\\t\\tif ($this->bodyFormat !== 'json')\\n\\t\\t{\\n\\t\\t\\t/**\\n\\t\\t\\t * @var Format $config\\n\\t\\t\\t */\\n\\t\\t\\t$config    = config(Format::class);\\n\\t\\t\\t$formatter = $config->getFormatter('application/json');\\n\\n\\t\\t\\t$body = $formatter->format($body);\\n\\t\\t}\\n\\n\\t\\treturn $body ?: null;\\n\\t}\", \"output\": \"Returns the current body, converted to JSON is it isn't already.\\n\\n@return mixed|string\\n\\n@throws \\\\InvalidArgumentException If the body property is not array.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getXML()\\n\\t{\\n\\t\\t$body = $this->body;\\n\\n\\t\\tif ($this->bodyFormat !== 'xml')\\n\\t\\t{\\n\\t\\t\\t/**\\n\\t\\t\\t * @var Format $config\\n\\t\\t\\t */\\n\\t\\t\\t$config    = config(Format::class);\\n\\t\\t\\t$formatter = $config->getFormatter('application/xml');\\n\\n\\t\\t\\t$body = $formatter->format($body);\\n\\t\\t}\\n\\n\\t\\treturn $body;\\n\\t}\", \"output\": \"Retrieves the current body into XML and returns it.\\n\\n@return mixed|string\\n@throws \\\\InvalidArgumentException If the body property is not array.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function formatBody($body, string $format)\\n\\t{\\n\\t\\t$mime = \\\"application/{$format}\\\";\\n\\t\\t$this->setContentType($mime);\\n\\t\\t$this->bodyFormat = $format;\\n\\n\\t\\t// Nothing much to do for a string...\\n\\t\\tif (! is_string($body))\\n\\t\\t{\\n\\t\\t\\t/**\\n\\t\\t\\t * @var Format $config\\n\\t\\t\\t */\\n\\t\\t\\t$config    = config(Format::class);\\n\\t\\t\\t$formatter = $config->getFormatter($mime);\\n\\n\\t\\t\\t$body = $formatter->format($body);\\n\\t\\t}\\n\\n\\t\\treturn $body;\\n\\t}\", \"output\": \"Handles conversion of the of the data into the appropriate format,\\nand sets the correct Content-Type header for our response.\\n\\n@param string|array $body\\n@param string       $format Valid: json, xml\\n\\n@return mixed\\n@throws \\\\InvalidArgumentException If the body property is not string or array.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setCache(array $options = [])\\n\\t{\\n\\t\\tif (empty($options))\\n\\t\\t{\\n\\t\\t\\treturn $this;\\n\\t\\t}\\n\\n\\t\\t$this->removeHeader('Cache-Control');\\n\\t\\t$this->removeHeader('ETag');\\n\\n\\t\\t// ETag\\n\\t\\tif (isset($options['etag']))\\n\\t\\t{\\n\\t\\t\\t$this->setHeader('ETag', $options['etag']);\\n\\t\\t\\tunset($options['etag']);\\n\\t\\t}\\n\\n\\t\\t// Last Modified\\n\\t\\tif (isset($options['last-modified']))\\n\\t\\t{\\n\\t\\t\\t$this->setLastModified($options['last-modified']);\\n\\n\\t\\t\\tunset($options['last-modified']);\\n\\t\\t}\\n\\n\\t\\t$this->setHeader('Cache-control', $options);\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"A shortcut method that allows the developer to set all of the\\ncache-control headers in one method call.\\n\\nThe options array is used to provide the cache-control directives\\nfor the header. It might look something like:\\n\\n$options = [\\n'max-age'  => 300,\\n's-maxage' => 900\\n'etag'     => 'abcde',\\n];\\n\\nTypical options are:\\n- etag\\n- last-modified\\n- max-age\\n- s-maxage\\n- private\\n- public\\n- must-revalidate\\n- proxy-revalidate\\n- no-transform\\n\\n@param array $options\\n\\n@return Response\"}"}
{"text": "{\"input\": \"Summarize the following code: public function send()\\n\\t{\\n\\t\\t// If we're enforcing a Content Security Policy,\\n\\t\\t// we need to give it a chance to build out it's headers.\\n\\t\\tif ($this->CSPEnabled === true)\\n\\t\\t{\\n\\t\\t\\t$this->CSP->finalize($this);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t$this->body = str_replace(['{csp-style-nonce}', '{csp-script-nonce}'], '', $this->body);\\n\\t\\t}\\n\\n\\t\\t$this->sendHeaders();\\n\\t\\t$this->sendBody();\\n\\t\\t$this->sendCookies();\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Sends the output to the browser.\\n\\n@return Response\"}"}
{"text": "{\"input\": \"Summarize the following code: public function sendHeaders()\\n\\t{\\n\\t\\t// Have the headers already been sent?\\n\\t\\tif ($this->pretend || headers_sent())\\n\\t\\t{\\n\\t\\t\\treturn $this;\\n\\t\\t}\\n\\n\\t\\t// Per spec, MUST be sent with each request, if possible.\\n\\t\\t// http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html\\n\\t\\tif (! isset($this->headers['Date']))\\n\\t\\t{\\n\\t\\t\\t$this->setDate(\\\\DateTime::createFromFormat('U', time()));\\n\\t\\t}\\n\\n\\t\\t// HTTP Status\\n\\t\\theader(sprintf('HTTP/%s %s %s', $this->protocolVersion, $this->statusCode, $this->reason), true, $this->statusCode);\\n\\n\\t\\t// Send all of our headers\\n\\t\\tforeach ($this->getHeaders() as $name => $values)\\n\\t\\t{\\n\\t\\t\\theader($name . ': ' . $this->getHeaderLine($name), false, $this->statusCode);\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Sends the headers of this HTTP request to the browser.\\n\\n@return Response\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setCookie(\\n\\t\\t$name,\\n\\t\\t$value = '',\\n\\t\\t$expire = '',\\n\\t\\t$domain = '',\\n\\t\\t$path = '/',\\n\\t\\t$prefix = '',\\n\\t\\t$secure = false,\\n\\t\\t$httponly = false\\n\\t)\\n\\t{\\n\\t\\tif (is_array($name))\\n\\t\\t{\\n\\t\\t\\t// always leave 'name' in last place, as the loop will break otherwise, due to $$item\\n\\t\\t\\tforeach (['value', 'expire', 'domain', 'path', 'prefix', 'secure', 'httponly', 'name'] as $item)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (isset($name[$item]))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$$item = $name[$item];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ($prefix === '' && $this->cookiePrefix !== '')\\n\\t\\t{\\n\\t\\t\\t$prefix = $this->cookiePrefix;\\n\\t\\t}\\n\\n\\t\\tif ($domain === '' && $this->cookieDomain !== '')\\n\\t\\t{\\n\\t\\t\\t$domain = $this->cookieDomain;\\n\\t\\t}\\n\\n\\t\\tif ($path === '/' && $this->cookiePath !== '/')\\n\\t\\t{\\n\\t\\t\\t$path = $this->cookiePath;\\n\\t\\t}\\n\\n\\t\\tif ($secure === false && $this->cookieSecure === true)\\n\\t\\t{\\n\\t\\t\\t$secure = $this->cookieSecure;\\n\\t\\t}\\n\\n\\t\\tif ($httponly === false && $this->cookieHTTPOnly !== false)\\n\\t\\t{\\n\\t\\t\\t$httponly = $this->cookieHTTPOnly;\\n\\t\\t}\\n\\n\\t\\tif (! is_numeric($expire))\\n\\t\\t{\\n\\t\\t\\t$expire = time() - 86500;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t$expire = ($expire > 0) ? time() + $expire : 0;\\n\\t\\t}\\n\\n\\t\\t$this->cookies[] = [\\n\\t\\t\\t'name'     => $prefix . $name,\\n\\t\\t\\t'value'    => $value,\\n\\t\\t\\t'expires'  => $expire,\\n\\t\\t\\t'path'     => $path,\\n\\t\\t\\t'domain'   => $domain,\\n\\t\\t\\t'secure'   => $secure,\\n\\t\\t\\t'httponly' => $httponly,\\n\\t\\t];\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Set a cookie\\n\\nAccepts an arbitrary number of binds (up to 7) or an associative\\narray in the first parameter containing all the values.\\n\\n@param string|array  $name     Cookie name or array containing binds\\n@param string        $value    Cookie value\\n@param string        $expire   Cookie expiration time in seconds\\n@param string        $domain   Cookie domain (e.g.: '.yourdomain.com')\\n@param string        $path     Cookie path (default: '/')\\n@param string        $prefix   Cookie name prefix\\n@param boolean|false $secure   Whether to only transfer cookies via SSL\\n@param boolean|false $httponly Whether only make the cookie accessible via HTTP (no javascript)\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: public function hasCookie(string $name, string $value = null, string $prefix = ''): bool\\n\\t{\\n\\t\\tif ($prefix === '' && $this->cookiePrefix !== '')\\n\\t\\t{\\n\\t\\t\\t$prefix = $this->cookiePrefix;\\n\\t\\t}\\n\\n\\t\\t$name = $prefix . $name;\\n\\n\\t\\tforeach ($this->cookies as $cookie)\\n\\t\\t{\\n\\t\\t\\tif ($cookie['name'] !== $name)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ($value === null)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn $cookie['value'] === $value;\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\", \"output\": \"Checks to see if the Response has a specified cookie or not.\\n\\n@param string      $name\\n@param string|null $value\\n@param string      $prefix\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getCookie(string $name = null, string $prefix = '')\\n\\t{\\n\\t\\t// if no name given, return them all\\n\\t\\tif (empty($name))\\n\\t\\t{\\n\\t\\t\\treturn $this->cookies;\\n\\t\\t}\\n\\n\\t\\tif ($prefix === '' && $this->cookiePrefix !== '')\\n\\t\\t{\\n\\t\\t\\t$prefix = $this->cookiePrefix;\\n\\t\\t}\\n\\n\\t\\t$name = $prefix . $name;\\n\\n\\t\\tforeach ($this->cookies as $cookie)\\n\\t\\t{\\n\\t\\t\\tif ($cookie['name'] === $name)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn $cookie;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn null;\\n\\t}\", \"output\": \"Returns the cookie\\n\\n@param string|null $name\\n@param string      $prefix\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public function deleteCookie(string $name = '', string $domain = '', string $path = '/', string $prefix = '')\\n\\t{\\n\\t\\tif (empty($name))\\n\\t\\t{\\n\\t\\t\\treturn $this;\\n\\t\\t}\\n\\n\\t\\tif ($prefix === '' && $this->cookiePrefix !== '')\\n\\t\\t{\\n\\t\\t\\t$prefix = $this->cookiePrefix;\\n\\t\\t}\\n\\n\\t\\t$name = $prefix . $name;\\n\\n\\t\\tforeach ($this->cookies as &$cookie)\\n\\t\\t{\\n\\t\\t\\tif ($cookie['name'] === $name)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (! empty($domain) && $cookie['domain'] !== $domain)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (! empty($path) && $cookie['path'] !== $path)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t$cookie['value']   = '';\\n\\t\\t\\t\\t$cookie['expires'] = '';\\n\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $this;\\n\\t}\", \"output\": \"Sets a cookie to be deleted when the response is sent.\\n\\n@param string $name\\n@param string $domain\\n@param string $path\\n@param string $prefix\\n\\n@return $this\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function sendCookies()\\n\\t{\\n\\t\\tif ($this->pretend)\\n\\t\\t{\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tforeach ($this->cookies as $params)\\n\\t\\t{\\n\\t\\t\\t// PHP cannot unpack array with string keys\\n\\t\\t\\t$params = array_values($params);\\n\\n\\t\\t\\tsetcookie(...$params);\\n\\t\\t}\\n\\t}\", \"output\": \"Actually sets the cookies.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function download(string $filename = '', $data = '', bool $setMime = false)\\n\\t{\\n\\t\\tif ($filename === '' || $data === '')\\n\\t\\t{\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\t$filepath = '';\\n\\t\\tif ($data === null)\\n\\t\\t{\\n\\t\\t\\t$filepath = $filename;\\n\\t\\t\\t$filename = explode('/', str_replace(DIRECTORY_SEPARATOR, '/', $filename));\\n\\t\\t\\t$filename = end($filename);\\n\\t\\t}\\n\\n\\t\\t$response = new DownloadResponse($filename, $setMime);\\n\\n\\t\\tif ($filepath !== '')\\n\\t\\t{\\n\\t\\t\\t$response->setFilePath($filepath);\\n\\t\\t}\\n\\t\\telseif ($data !== null)\\n\\t\\t{\\n\\t\\t\\t$response->setBinary($data);\\n\\t\\t}\\n\\n\\t\\treturn $response;\\n\\t}\", \"output\": \"Force a download.\\n\\nGenerates the headers that force a download to happen. And\\nsends the file to the browser.\\n\\n@param string        $filename The path to the file to send\\n@param string|null   $data     The data to be downloaded\\n@param boolean       $setMime  Whether to try and send the actual MIME type\\n\\n@return \\\\CodeIgniter\\\\HTTP\\\\DownloadResponse|null\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function get(string $name, bool $getShared = true)\\n\\t{\\n\\t\\t$class = $name;\\n\\t\\tif (($pos = strrpos($name, '\\\\\\\\')) !== false)\\n\\t\\t{\\n\\t\\t\\t$class = substr($name, $pos + 1);\\n\\t\\t}\\n\\n\\t\\tif (! $getShared)\\n\\t\\t{\\n\\t\\t\\treturn self::createClass($name);\\n\\t\\t}\\n\\n\\t\\tif (! isset( self::$instances[$class] ))\\n\\t\\t{\\n\\t\\t\\tself::$instances[$class] = self::createClass($name);\\n\\t\\t}\\n\\t\\treturn self::$instances[$class];\\n\\t}\", \"output\": \"Create new configuration instances or return\\na shared instance\\n\\n@param string  $name      Configuration name\\n@param boolean $getShared Use shared instance\\n\\n@return mixed|null\"}"}
{"text": "{\"input\": \"Summarize the following code: private static function createClass(string $name)\\n\\t{\\n\\t\\tif (class_exists($name))\\n\\t\\t{\\n\\t\\t\\treturn new $name();\\n\\t\\t}\\n\\n\\t\\t$locator = Services::locator();\\n\\t\\t$file    = $locator->locateFile($name, 'Config');\\n\\n\\t\\tif (empty($file))\\n\\t\\t{\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\t$name = $locator->getClassname($file);\\n\\n\\t\\tif (empty($name))\\n\\t\\t{\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\treturn new $name();\\n\\t}\", \"output\": \"Find configuration class and create instance\\n\\n@param string $name Classname\\n\\n@return mixed|null\"}"}
{"text": "{\"input\": \"Summarize the following code: protected static function getSharedInstance(string $key, ...$params)\\n\\t{\\n\\t\\t// Returns mock if exists\\n\\t\\tif (isset(static::$mocks[$key]))\\n\\t\\t{\\n\\t\\t\\treturn static::$mocks[$key];\\n\\t\\t}\\n\\n\\t\\tif (! isset(static::$instances[$key]))\\n\\t\\t{\\n\\t\\t\\t// Make sure $getShared is false\\n\\t\\t\\tarray_push($params, false);\\n\\n\\t\\t\\tstatic::$instances[$key] = static::$key(...$params);\\n\\t\\t}\\n\\n\\t\\treturn static::$instances[$key];\\n\\t}\", \"output\": \"Returns a shared instance of any of the class' services.\\n\\n$key must be a name matching a service.\\n\\n@param string $key\\n@param array  ...$params\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function autoloader(bool $getShared = true)\\n\\t{\\n\\t\\tif ($getShared)\\n\\t\\t{\\n\\t\\t\\tif (empty(static::$instances['autoloader']))\\n\\t\\t\\t{\\n\\t\\t\\t\\tstatic::$instances['autoloader'] = new Autoloader();\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn static::$instances['autoloader'];\\n\\t\\t}\\n\\n\\t\\treturn new Autoloader();\\n\\t}\", \"output\": \"The Autoloader class is the central class that handles our\\nspl_autoload_register method, and helper methods.\\n\\n@param boolean $getShared\\n\\n@return \\\\CodeIgniter\\\\Autoloader\\\\Autoloader\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function locator(bool $getShared = true)\\n\\t{\\n\\t\\tif ($getShared)\\n\\t\\t{\\n\\t\\t\\tif (empty(static::$instances['locator']))\\n\\t\\t\\t{\\n\\t\\t\\t\\tstatic::$instances['locator'] = new FileLocator(\\n\\t\\t\\t\\t\\tstatic::autoloader()\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn static::$instances['locator'];\\n\\t\\t}\\n\\n\\t\\treturn new FileLocator(static::autoloader());\\n\\t}\", \"output\": \"The file locator provides utility methods for looking for non-classes\\nwithin namespaced folders, as well as convenience methods for\\nloading 'helpers', and 'libraries'.\\n\\n@param boolean $getShared\\n\\n@return \\\\CodeIgniter\\\\Autoloader\\\\FileLocator\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function reset(bool $init_autoloader = false)\\n\\t{\\n\\t\\tstatic::$mocks = [];\\n\\n\\t\\tstatic::$instances = [];\\n\\n\\t\\tif ($init_autoloader)\\n\\t\\t{\\n\\t\\t\\tstatic::autoloader()->initialize(new Autoload(), new Modules());\\n\\t\\t}\\n\\t}\", \"output\": \"Reset shared instances and mocks for testing.\\n\\n@param boolean $init_autoloader Initializes autoloader instance\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function injectMock(string $name, $mock)\\n\\t{\\n\\t\\t$name                 = strtolower($name);\\n\\t\\tstatic::$mocks[$name] = $mock;\\n\\t}\", \"output\": \"Inject mock object for testing.\\n\\n@param string $name\\n@param $mock\"}"}
{"text": "{\"input\": \"Summarize the following code: protected static function discoverServices(string $name, array $arguments)\\n\\t{\\n\\t\\tif (! static::$discovered)\\n\\t\\t{\\n\\t\\t\\t$config = config('Modules');\\n\\n\\t\\t\\tif ($config->shouldDiscover('services'))\\n\\t\\t\\t{\\n\\t\\t\\t\\t$locator = static::locator();\\n\\t\\t\\t\\t$files   = $locator->search('Config/Services');\\n\\n\\t\\t\\t\\tif (empty($files))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t// no files at all found - this would be really, really bad\\n\\t\\t\\t\\t\\treturn null;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Get instances of all service classes and cache them locally.\\n\\t\\t\\t\\tforeach ($files as $file)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$classname = $locator->getClassname($file);\\n\\n\\t\\t\\t\\t\\tif (! in_array($classname, ['CodeIgniter\\\\\\\\Config\\\\\\\\Services']))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tstatic::$services[] = new $classname();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tstatic::$discovered = true;\\n\\t\\t}\\n\\n\\t\\tif (! static::$services)\\n\\t\\t{\\n\\t\\t\\t// we found stuff, but no services - this would be really bad\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\t// Try to find the desired service method\\n\\t\\tforeach (static::$services as $class)\\n\\t\\t{\\n\\t\\t\\tif (method_exists(get_class($class), $name))\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn $class::$name(...$arguments);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn null;\\n\\t}\", \"output\": \"Will scan all psr4 namespaces registered with system to look\\nfor new Config\\\\Services files. Caches a copy of each one, then\\nlooks for the service method in each, returning an instance of\\nthe service, if available.\\n\\n@param string $name\\n@param array  $arguments\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function input(string $prefix = null): string\\n\\t{\\n\\t\\tif (static::$readline_support)\\n\\t\\t{\\n\\t\\t\\treturn readline($prefix);\\n\\t\\t}\\n\\n\\t\\techo $prefix;\\n\\n\\t\\treturn fgets(STDIN);\\n\\t}\", \"output\": \"Get input from the shell, using readline or the standard STDIN\\n\\nNamed options must be in the following formats:\\nphp index.php user -v --v -name=John --name=John\\n\\n@param  string $prefix\\n@return string\\n\\n@codeCoverageIgnore\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function prompt(string $field, $options = null, string $validation = null): string\\n\\t{\\n\\t\\t$extra_output = '';\\n\\t\\t$default      = '';\\n\\n\\t\\tif (is_string($options))\\n\\t\\t{\\n\\t\\t\\t$extra_output = ' [' . static::color($options, 'white') . ']';\\n\\t\\t\\t$default      = $options;\\n\\t\\t}\\n\\n\\t\\tif (is_array($options) && $options)\\n\\t\\t{\\n\\t\\t\\t$opts                 = $options;\\n\\t\\t\\t$extra_output_default = static::color($opts[0], 'white');\\n\\n\\t\\t\\tunset($opts[0]);\\n\\n\\t\\t\\tif (empty($opts))\\n\\t\\t\\t{\\n\\t\\t\\t\\t$extra_output = $extra_output_default;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t$extra_output = ' [' . $extra_output_default . ', ' . implode(', ', $opts) . ']';\\n\\t\\t\\t\\t$validation  .= '|in_list[' . implode(',', $options) . ']';\\n\\t\\t\\t\\t$validation   = trim($validation, '|');\\n\\t\\t\\t}\\n\\n\\t\\t\\t$default = $options[0];\\n\\t\\t}\\n\\n\\t\\tfwrite(STDOUT, $field . $extra_output . ': ');\\n\\n\\t\\t// Read the input from keyboard.\\n\\t\\t$input = trim(static::input()) ?: $default;\\n\\n\\t\\tif (isset($validation))\\n\\t\\t{\\n\\t\\t\\twhile (! static::validate($field, $input, $validation))\\n\\t\\t\\t{\\n\\t\\t\\t\\t$input = static::prompt($field, $options, $validation);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn empty($input) ? '' : $input;\\n\\t}\", \"output\": \"Asks the user for input.\\n\\nUsage:\\n\\n// Takes any input\\n$color = CLI::prompt('What is your favorite color?');\\n\\n// Takes any input, but offers default\\n$color = CLI::prompt('What is your favourite color?', 'white');\\n\\n// Will validate options with the in_list rule and accept only if one of the list\\n$color = CLI::prompt('What is your favourite color?', array('red','blue'));\\n\\n// Do not provide options but requires a valid email\\n$email = CLI::prompt('What is your email?', null, 'required|valid_email');\\n\\n@param string       $field      Output \\\"field\\\" question\\n@param string|array $options    String to a default value, array to a list of options (the first option will be the default value)\\n@param string       $validation Validation rules\\n\\n@return             string                   The user input\\n@codeCoverageIgnore\"}"}
{"text": "{\"input\": \"Summarize the following code: protected static function validate(string $field, string $value, string $rules): bool\\n\\t{\\n\\t\\t$validation = \\\\Config\\\\Services::validation(null, false);\\n\\t\\t$validation->setRule($field, null, $rules);\\n\\t\\t$validation->run([$field => $value]);\\n\\n\\t\\tif ($validation->hasError($field))\\n\\t\\t{\\n\\t\\t\\tstatic::error($validation->getError($field));\\n\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\", \"output\": \"Validate one prompt \\\"field\\\" at a time\\n\\n@param string $field Prompt \\\"field\\\" output\\n@param string $value Input value\\n@param string $rules Validation rules\\n\\n@return             boolean\\n@codeCoverageIgnore\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function print(string $text = '', string $foreground = null, string $background = null)\\n\\t{\\n\\t\\tif ($foreground || $background)\\n\\t\\t{\\n\\t\\t\\t$text = static::color($text, $foreground, $background);\\n\\t\\t}\\n\\n\\t\\tstatic::$lastWrite = null;\\n\\n\\t\\tfwrite(STDOUT, $text);\\n\\t}\", \"output\": \"Outputs a string to the CLI without any surrounding newlines.\\nUseful for showing repeating elements on a single line.\\n\\n@param string      $text\\n@param string|null $foreground\\n@param string|null $background\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function error(string $text, string $foreground = 'light_red', string $background = null)\\n\\t{\\n\\t\\tif ($foreground || $background)\\n\\t\\t{\\n\\t\\t\\t$text = static::color($text, $foreground, $background);\\n\\t\\t}\\n\\n\\t\\tfwrite(STDERR, $text . PHP_EOL);\\n\\t}\", \"output\": \"Outputs an error to the CLI using STDERR instead of STDOUT\\n\\n@param string|array $text       The text to output, or array of errors\\n@param string       $foreground\\n@param string       $background\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function wait(int $seconds, bool $countdown = false)\\n\\t{\\n\\t\\tif ($countdown === true)\\n\\t\\t{\\n\\t\\t\\t$time = $seconds;\\n\\n\\t\\t\\twhile ($time > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfwrite(STDOUT, $time . '... ');\\n\\t\\t\\t\\tsleep(1);\\n\\t\\t\\t\\t$time --;\\n\\t\\t\\t}\\n\\t\\t\\tstatic::write();\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif ($seconds > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsleep($seconds);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t// this chunk cannot be tested because of keyboard input\\n\\t\\t\\t\\t// @codeCoverageIgnoreStart\\n\\t\\t\\t\\tstatic::write(static::$wait_msg);\\n\\t\\t\\t\\tstatic::input();\\n\\t\\t\\t\\t// @codeCoverageIgnoreEnd\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\", \"output\": \"Waits a certain number of seconds, optionally showing a wait message and\\nwaiting for a key press.\\n\\n@param integer $seconds   Number of seconds\\n@param boolean $countdown Show a countdown or not\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function color(string $text, string $foreground, string $background = null, string $format = null): string\\n\\t{\\n\\t\\tif (static::isWindows() && ! isset($_SERVER['ANSICON']))\\n\\t\\t{\\n\\t\\t\\t// @codeCoverageIgnoreStart\\n\\t\\t\\treturn $text;\\n\\t\\t\\t// @codeCoverageIgnoreEnd\\n\\t\\t}\\n\\n\\t\\tif (! array_key_exists($foreground, static::$foreground_colors))\\n\\t\\t{\\n\\t\\t\\tthrow CLIException::forInvalidColor('foreground', $foreground);\\n\\t\\t}\\n\\n\\t\\tif ($background !== null && ! array_key_exists($background, static::$background_colors))\\n\\t\\t{\\n\\t\\t\\tthrow CLIException::forInvalidColor('background', $background);\\n\\t\\t}\\n\\n\\t\\t$string = \\\"\\\\033[\\\" . static::$foreground_colors[$foreground] . 'm';\\n\\n\\t\\tif ($background !== null)\\n\\t\\t{\\n\\t\\t\\t$string .= \\\"\\\\033[\\\" . static::$background_colors[$background] . 'm';\\n\\t\\t}\\n\\n\\t\\tif ($format === 'underline')\\n\\t\\t{\\n\\t\\t\\t$string .= \\\"\\\\033[4m\\\";\\n\\t\\t}\\n\\n\\t\\t$string .= $text . \\\"\\\\033[0m\\\";\\n\\n\\t\\treturn $string;\\n\\t}\", \"output\": \"Returns the given text with the correct color codes for a foreground and\\noptionally a background color.\\n\\n@param string $text       The text to color\\n@param string $foreground The foreground color\\n@param string $background The background color\\n@param string $format     Other formatting to apply. Currently only 'underline' is understood\\n\\n@return string    The color coded string\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function wrap(string $string = null, int $max = 0, int $pad_left = 0): string\\n\\t{\\n\\t\\tif (empty($string))\\n\\t\\t{\\n\\t\\t\\treturn '';\\n\\t\\t}\\n\\n\\t\\tif ($max === 0)\\n\\t\\t{\\n\\t\\t\\t$max = CLI::getWidth();\\n\\t\\t}\\n\\n\\t\\tif (CLI::getWidth() < $max)\\n\\t\\t{\\n\\t\\t\\t$max = CLI::getWidth();\\n\\t\\t}\\n\\n\\t\\t$max = $max - $pad_left;\\n\\n\\t\\t$lines = wordwrap($string, $max);\\n\\n\\t\\tif ($pad_left > 0)\\n\\t\\t{\\n\\t\\t\\t$lines = explode(PHP_EOL, $lines);\\n\\n\\t\\t\\t$first = true;\\n\\n\\t\\t\\tarray_walk($lines, function (&$line, $index) use ($pad_left, &$first) {\\n\\t\\t\\t\\tif (! $first)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$line = str_repeat(' ', $pad_left) . $line;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$first = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\t$lines = implode(PHP_EOL, $lines);\\n\\t\\t}\\n\\n\\t\\treturn $lines;\\n\\t}\", \"output\": \"Takes a string and writes it to the command line, wrapping to a maximum\\nwidth. If no maximum width is specified, will wrap to the window's max\\nwidth.\\n\\nIf an int is passed into $pad_left, then all strings after the first\\nwill padded with that many spaces to the left. Useful when printing\\nshort descriptions that need to start on an existing line.\\n\\n@param string  $string\\n@param integer $max\\n@param integer $pad_left\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function getOption(string $name)\\n\\t{\\n\\t\\tif (! array_key_exists($name, static::$options))\\n\\t\\t{\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\t// If the option didn't have a value, simply return TRUE\\n\\t\\t// so they know it was set, otherwise return the actual value.\\n\\t\\t$val = static::$options[$name] === null ? true : static::$options[$name];\\n\\n\\t\\treturn $val;\\n\\t}\", \"output\": \"Gets a single command-line option. Returns TRUE if the option\\nexists, but doesn't have a value, and is simply acting as a flag.\\n\\n@param string $name\\n\\n@return boolean|mixed|null\"}"}
{"text": "{\"input\": \"Summarize the following code: public function respond($data = null, int $status = null, string $message = '')\\n\\t{\\n\\t\\t// If data is null and status code not provided, exit and bail\\n\\t\\tif ($data === null && $status === null)\\n\\t\\t{\\n\\t\\t\\t$status = 404;\\n\\n\\t\\t\\t// Create the output var here in case of $this->response([]);\\n\\t\\t\\t$output = null;\\n\\t\\t} // If data is null but status provided, keep the output empty.\\n\\t\\telseif ($data === null && is_numeric($status))\\n\\t\\t{\\n\\t\\t\\t$output = null;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t$status = empty($status) ? 200 : $status;\\n\\t\\t\\t$output = $this->format($data);\\n\\t\\t}\\n\\n\\t\\treturn $this->response->setBody($output)\\n\\t\\t\\t\\t\\t\\t->setStatusCode($status, $message);\\n\\t}\", \"output\": \"Provides a single, simple method to return an API response, formatted\\nto match the requested format, with proper content-type and status code.\\n\\n@param array|string|null $data\\n@param integer           $status\\n@param string            $message\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public function fail($messages, int $status = 400, string $code = null, string $customMessage = '')\\n\\t{\\n\\t\\tif (! is_array($messages))\\n\\t\\t{\\n\\t\\t\\t$messages = ['error' => $messages];\\n\\t\\t}\\n\\n\\t\\t$response = [\\n\\t\\t\\t'status'   => $status,\\n\\t\\t\\t'error'    => $code === null ? $status : $code,\\n\\t\\t\\t'messages' => $messages,\\n\\t\\t];\\n\\n\\t\\treturn $this->respond($response, $status, $customMessage);\\n\\t}\", \"output\": \"Used for generic failures that no custom methods exist for.\\n\\n@param string|array $messages\\n@param integer|null $status        HTTP status code\\n@param string|null  $code          Custom, API-specific, error code\\n@param string       $customMessage\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public function respondCreated($data = null, string $message = '')\\n\\t{\\n\\t\\treturn $this->respond($data, $this->codes['created'], $message);\\n\\t}\", \"output\": \"Used after successfully creating a new resource.\\n\\n@param mixed  $data    Data.\\n@param string $message Message.\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public function failUnauthorized(string $description = 'Unauthorized', string $code = null, string $message = '')\\n\\t{\\n\\t\\treturn $this->fail($description, $this->codes['unauthorized'], $code, $message);\\n\\t}\", \"output\": \"Used when the client is either didn't send authorization information,\\nor had bad authorization credentials. User is encouraged to try again\\nwith the proper information.\\n\\n@param string $description\\n@param string $code\\n@param string $message\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public function failServerError(string $description = 'Internal Server Error', string $code = null, string $message = ''): Response\\n\\t{\\n\\t\\treturn $this->fail($description, $this->codes['server_error'], $code, $message);\\n\\t}\", \"output\": \"Used when there is a server error.\\n\\n@param string      $description The error message to show the user.\\n@param string|null $code        A custom, API-specific, error code.\\n@param string      $message     A custom \\\"reason\\\" message to return.\\n\\n@return Response The value of the Response's send() method.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function before(RequestInterface $request)\\n\\t{\\n\\t\\tif ($request->isCLI())\\n\\t\\t{\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t$security = Services::security();\\n\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\t$security->CSRFVerify($request);\\n\\t\\t}\\n\\t\\tcatch (SecurityException $e)\\n\\t\\t{\\n\\t\\t\\tif (config('App')->CSRFRedirect && ! $request->isAJAX())\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn redirect()->back()->with('error', $e->getMessage());\\n\\t\\t\\t}\\n\\n\\t\\t\\tthrow $e;\\n\\t\\t}\\n\\t}\", \"output\": \"Do whatever processing this filter needs to do.\\nBy default it should not return anything during\\nnormal execution. However, when an abnormal state\\nis found, it should return an instance of\\nCodeIgniter\\\\HTTP\\\\Response. If it does, script\\nexecution will end and that Response will be\\nsent back to the client, allowing for error pages,\\nredirects, etc.\\n\\n@param RequestInterface|\\\\CodeIgniter\\\\HTTP\\\\IncomingRequest $request\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function initialize()\\n\\t{\\n\\t\\t// Don't overwrite anything....\\n\\t\\tif (static::$initialized)\\n\\t\\t{\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t$config = config('Modules');\\n\\n\\t\\t$files = [APPPATH . 'Config/Events.php'];\\n\\n\\t\\tif ($config->shouldDiscover('events'))\\n\\t\\t{\\n\\t\\t\\t$locator = Services::locator();\\n\\t\\t\\t$files   = $locator->search('Config/Events.php');\\n\\t\\t}\\n\\n\\t\\tstatic::$files = $files;\\n\\n\\t\\tforeach (static::$files as $file)\\n\\t\\t{\\n\\t\\t\\tif (is_file($file))\\n\\t\\t\\t{\\n\\t\\t\\t\\tinclude $file;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tstatic::$initialized = true;\\n\\t}\", \"output\": \"Ensures that we have a events file ready.\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function listeners($event_name): array\\n\\t{\\n\\t\\tif (! isset(static::$listeners[$event_name]))\\n\\t\\t{\\n\\t\\t\\treturn [];\\n\\t\\t}\\n\\n\\t\\t// The list is not sorted\\n\\t\\tif (! static::$listeners[$event_name][0])\\n\\t\\t{\\n\\t\\t\\t// Sort it!\\n\\t\\t\\tarray_multisort(static::$listeners[$event_name][1], SORT_NUMERIC, static::$listeners[$event_name][2]);\\n\\n\\t\\t\\t// Mark it as sorted already!\\n\\t\\t\\tstatic::$listeners[$event_name][0] = true;\\n\\t\\t}\\n\\n\\t\\treturn static::$listeners[$event_name][2];\\n\\t}\", \"output\": \"Returns an array of listeners for a single event. They are\\nsorted by priority.\\n\\nIf the listener could not be found, returns FALSE, or TRUE if\\nit was removed.\\n\\n@param $event_name\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function removeListener($event_name, callable $listener): bool\\n\\t{\\n\\t\\tif (! isset(static::$listeners[$event_name]))\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tforeach (static::$listeners[$event_name][2] as $index => $check)\\n\\t\\t{\\n\\t\\t\\tif ($check === $listener)\\n\\t\\t\\t{\\n\\t\\t\\t\\tunset(static::$listeners[$event_name][1][$index]);\\n\\t\\t\\t\\tunset(static::$listeners[$event_name][2][$index]);\\n\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\", \"output\": \"Removes a single listener from an event.\\n\\nIf the listener couldn't be found, returns FALSE, else TRUE if\\nit was removed.\\n\\n@param $event_name\\n@param callable   $listener\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: public function isReferral(): bool\\n\\t{\\n\\t\\tif (! isset($this->referrer))\\n\\t\\t{\\n\\t\\t\\tif (empty($_SERVER['HTTP_REFERER']))\\n\\t\\t\\t{\\n\\t\\t\\t\\t$this->referrer = false;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t$referer_host = @parse_url($_SERVER['HTTP_REFERER'], PHP_URL_HOST);\\n\\t\\t\\t\\t$own_host     = parse_url(\\\\base_url(), PHP_URL_HOST);\\n\\n\\t\\t\\t\\t$this->referrer = ($referer_host && $referer_host !== $own_host);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $this->referrer;\\n\\t}\", \"output\": \"Is this a referral from another site?\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function setPlatform(): bool\\n\\t{\\n\\t\\tif (is_array($this->config->platforms) && $this->config->platforms)\\n\\t\\t{\\n\\t\\t\\tforeach ($this->config->platforms as $key => $val)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (preg_match('|' . preg_quote($key) . '|i', $this->agent))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$this->platform = $val;\\n\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t$this->platform = 'Unknown Platform';\\n\\n\\t\\treturn false;\\n\\t}\", \"output\": \"Set the Platform\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function setBrowser(): bool\\n\\t{\\n\\t\\tif (is_array($this->config->browsers) && $this->config->browsers)\\n\\t\\t{\\n\\t\\t\\tforeach ($this->config->browsers as $key => $val)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (preg_match('|' . $key . '.*?([0-9\\\\.]+)|i', $this->agent, $match))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$this->isBrowser = true;\\n\\t\\t\\t\\t\\t$this->version   = $match[1];\\n\\t\\t\\t\\t\\t$this->browser   = $val;\\n\\t\\t\\t\\t\\t$this->setMobile();\\n\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\", \"output\": \"Set the Browser\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function setRobot(): bool\\n\\t{\\n\\t\\tif (is_array($this->config->robots) && $this->config->robots)\\n\\t\\t{\\n\\t\\t\\tforeach ($this->config->robots as $key => $val)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (preg_match('|' . preg_quote($key) . '|i', $this->agent))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$this->isRobot = true;\\n\\t\\t\\t\\t\\t$this->robot   = $val;\\n\\t\\t\\t\\t\\t$this->setMobile();\\n\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\", \"output\": \"Set the Robot\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function setMobile(): bool\\n\\t{\\n\\t\\tif (is_array($this->config->mobiles) && $this->config->mobiles)\\n\\t\\t{\\n\\t\\t\\tforeach ($this->config->mobiles as $key => $val)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (false !== (stripos($this->agent, $key)))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t$this->isMobile = true;\\n\\t\\t\\t\\t\\t$this->mobile   = $val;\\n\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\", \"output\": \"Set the Mobile Device\\n\\n@return boolean\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function _attributeType(array &$attributes)\\n\\t{\\n\\t\\t// Reset field lengths for data types that don't support it\\n\\t\\tif (isset($attributes['CONSTRAINT']) && stripos($attributes['TYPE'], 'int') !== false)\\n\\t\\t{\\n\\t\\t\\t$attributes['CONSTRAINT'] = null;\\n\\t\\t}\\n\\n\\t\\tswitch (strtoupper($attributes['TYPE']))\\n\\t\\t{\\n\\t\\t\\tcase 'TINYINT':\\n\\t\\t\\t\\t$attributes['TYPE']     = 'SMALLINT';\\n\\t\\t\\t\\t$attributes['UNSIGNED'] = false;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 'MEDIUMINT':\\n\\t\\t\\t\\t$attributes['TYPE']     = 'INTEGER';\\n\\t\\t\\t\\t$attributes['UNSIGNED'] = false;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 'DATETIME':\\n\\t\\t\\t\\t$attributes['TYPE'] = 'TIMESTAMP';\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\", \"output\": \"Field attribute TYPE\\n\\nPerforms a data type mapping between different databases.\\n\\n@param array &$attributes\\n\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: private function initializeConfig()\\n    {\\n        if (!is_dir($this->vbot->config['path'])) {\\n            mkdir($this->vbot->config['path'], 0755, true);\\n        }\\n\\n        $this->vbot->config['storage'] = $this->vbot->config['storage'] ?: 'collection';\\n\\n        $this->vbot->config['path'] = realpath($this->vbot->config['path']);\\n    }\", \"output\": \"initialize config.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function show($text)\\n    {\\n        if (!array_get($this->config, 'qrcode', true)) {\\n            return false;\\n        }\\n        $output = new ConsoleOutput();\\n        static::initQrcodeStyle($output);\\n\\n        $pxMap[0] = Console::isWin() ? '<whitec>mm</whitec>' : '<whitec>  </whitec>';\\n        $pxMap[1] = '<blackc>  </blackc>';\\n\\n        $text = QrCodeConsole::text($text);\\n\\n        $length = strlen($text[0]);\\n\\n        $output->write(\\\"\\\\n\\\");\\n        foreach ($text as $line) {\\n            $output->write($pxMap[0]);\\n            for ($i = 0; $i < $length; $i++) {\\n                $type = substr($line, $i, 1);\\n                $output->write($pxMap[$type]);\\n            }\\n            $output->writeln($pxMap[0]);\\n        }\\n    }\", \"output\": \"show qrCode on console.\\n\\n@param $text\\n\\n@return bool\"}"}
{"text": "{\"input\": \"Summarize the following code: private static function initQrcodeStyle(OutputInterface $output)\\n    {\\n        $style = new OutputFormatterStyle('black', 'black', ['bold']);\\n        $output->getFormatter()->setStyle('blackc', $style);\\n        $style = new OutputFormatterStyle('white', 'white', ['bold']);\\n        $output->getFormatter()->setStyle('whitec', $style);\\n    }\", \"output\": \"init qrCode style.\\n\\n@param OutputInterface $output\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function formatContent($content)\\n    {\\n        $content = self::emojiHandle($content);\\n        $content = self::replaceBr($content);\\n\\n        return self::htmlDecode($content);\\n    }\", \"output\": \"format XML for Content.\\n\\n@param $content\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: private function heartbeat($time)\\n    {\\n        if (time() - $time > 1800) {\\n            Text::send('filehelper', 'heart beat '.Carbon::now()->toDateTimeString());\\n\\n            return time();\\n        }\\n\\n        return $time;\\n    }\", \"output\": \"make a heartbeat every 30 minutes.\\n\\n@param $time\\n\\n@return int\"}"}
{"text": "{\"input\": \"Summarize the following code: public function handleCheckSync($retCode, $selector, $test = false)\\n    {\\n        if (in_array($retCode, [1100, 1101, 1102, 1205])) { // \\u5fae\\u4fe1\\u5ba2\\u6237\\u7aef\\u4e0a\\u767b\\u51fa\\u6216\\u8005\\u5176\\u4ed6\\u8bbe\\u5907\\u767b\\u5f55\\n\\n            $this->vbot->console->log('vbot exit normally.');\\n            $this->vbot->cache->forget('session.'.$this->vbot->config['session']);\\n\\n            return false;\\n        } elseif ($retCode != 0) {\\n            $this->vbot->needActivateObserver->trigger();\\n        } else {\\n            if (!$test) {\\n                $this->handleMessage($selector);\\n            }\\n\\n            return true;\\n        }\\n    }\", \"output\": \"handle a sync from wechat.\\n\\n@param $retCode\\n@param $selector\\n@param bool $test\\n\\n@return bool\"}"}
{"text": "{\"input\": \"Summarize the following code: private function log($message)\\n    {\\n        if ($this->vbot->messageLog && ($message['ModContactList'] || $message['AddMsgList'])) {\\n            $this->vbot->messageLog->info(json_encode($message));\\n        }\\n    }\", \"output\": \"log the message.\\n\\n@param $message\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function getUuid()\\n    {\\n        $content = $this->vbot->http->get('https://login.weixin.qq.com/jslogin', ['query' => [\\n            'appid' => 'wx782c26e4c19acffb',\\n            'fun'   => 'new',\\n            'lang'  => 'zh_CN',\\n            '_'     => time(),\\n        ]]);\\n\\n        preg_match('/window.QRLogin.code = (\\\\d+); window.QRLogin.uuid = \\\\\\\"(\\\\S+?)\\\\\\\"/', $content, $matches);\\n\\n        if (!$matches) {\\n            throw new FetchUuidException('fetch uuid failed.');\\n        }\\n\\n        $this->vbot->config['server.uuid'] = $matches[2];\\n    }\", \"output\": \"get uuid.\\n\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public function showQrCode()\\n    {\\n        $url = 'https://login.weixin.qq.com/l/'.$this->vbot->config['server.uuid'];\\n\\n        $this->vbot->qrCodeObserver->trigger($url);\\n\\n        $this->vbot->qrCode->show($url);\\n    }\", \"output\": \"show a login qrCode.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function waitForLogin()\\n    {\\n        $retryTime = 10;\\n        $tip = 1;\\n\\n        $this->vbot->console->log('please scan the qrCode with wechat.');\\n        while ($retryTime > 0) {\\n            $url = sprintf('https://login.weixin.qq.com/cgi-bin/mmwebwx-bin/login?tip=%s&uuid=%s&_=%s', $tip, $this->vbot->config['server.uuid'], time());\\n\\n            $content = $this->vbot->http->get($url, ['timeout' => 35]);\\n\\n            preg_match('/window.code=(\\\\d+);/', $content, $matches);\\n\\n            $code = $matches[1];\\n            switch ($code) {\\n                case '201':\\n                    $this->vbot->console->log('please confirm login in wechat.');\\n                    $tip = 0;\\n                    break;\\n                case '200':\\n                    preg_match('/window.redirect_uri=\\\"(https:\\\\/\\\\/(\\\\S+?)\\\\/\\\\S+?)\\\";/', $content, $matches);\\n\\n                    $this->vbot->config['server.uri.redirect'] = $matches[1].'&fun=new';\\n                    $url = 'https://%s/cgi-bin/mmwebwx-bin';\\n                    $this->vbot->config['server.uri.file'] = sprintf($url, 'file.'.$matches[2]);\\n                    $this->vbot->config['server.uri.push'] = sprintf($url, 'webpush.'.$matches[2]);\\n                    $this->vbot->config['server.uri.base'] = sprintf($url, $matches[2]);\\n\\n                    return;\\n                case '408':\\n                    $tip = 1;\\n                    $retryTime -= 1;\\n                    sleep(1);\\n                    break;\\n                default:\\n                    $tip = 1;\\n                    $retryTime -= 1;\\n                    sleep(1);\\n                    break;\\n            }\\n        }\\n\\n        $this->vbot->console->log('login time out!', Console::ERROR);\\n\\n        throw new LoginTimeoutException('Login time out.');\\n    }\", \"output\": \"waiting user to login.\\n\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: private function getLogin()\\n    {\\n        $content = $this->vbot->http->get($this->vbot->config['server.uri.redirect']);\\n\\n        $data = (array) simplexml_load_string($content, 'SimpleXMLElement', LIBXML_NOCDATA);\\n\\n        $this->vbot->config['server.skey'] = $data['skey'];\\n        $this->vbot->config['server.sid'] = $data['wxsid'];\\n        $this->vbot->config['server.uin'] = $data['wxuin'];\\n        $this->vbot->config['server.passTicket'] = $data['pass_ticket'];\\n\\n        if (in_array('', [$data['wxsid'], $data['wxuin'], $data['pass_ticket']])) {\\n            throw new LoginFailedException('Login failed.');\\n        }\\n\\n        $this->vbot->config['server.deviceId'] = 'e'.substr(mt_rand().mt_rand(), 1, 15);\\n\\n        $this->vbot->config['server.baseRequest'] = [\\n            'Uin'      => $data['wxuin'],\\n            'Sid'      => $data['wxsid'],\\n            'Skey'     => $data['skey'],\\n            'DeviceID' => $this->vbot->config['server.deviceId'],\\n        ];\\n\\n        $this->saveServer();\\n    }\", \"output\": \"login wechat.\\n\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: private function saveServer()\\n    {\\n        $this->vbot->cache->forever('session.'.$this->vbot->config['session'], json_encode($this->vbot->config['server']));\\n    }\", \"output\": \"store config to cache.\"}"}
{"text": "{\"input\": \"Summarize the following code: private function beforeInitSuccess()\\n    {\\n        $this->vbot->console->log('current session: '.$this->vbot->config['session']);\\n        $this->vbot->console->log('init begin.');\\n    }\", \"output\": \"before init success.\"}"}
{"text": "{\"input\": \"Summarize the following code: private function afterInitSuccess($content)\\n    {\\n        $this->vbot->log->info('response:'.json_encode($content));\\n        $this->vbot->console->log('init success.');\\n        $this->vbot->loginSuccessObserver->trigger();\\n        $this->vbot->console->log('init contacts begin.');\\n    }\", \"output\": \"after init success.\\n\\n@param $content\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function statusNotify()\\n    {\\n        $url = sprintf($this->vbot->config['server.uri.base'].'/webwxstatusnotify?lang=zh_CN&pass_ticket=%s', $this->vbot->config['server.passTicket']);\\n\\n        $this->vbot->http->json($url, [\\n            'BaseRequest'  => $this->vbot->config['server.baseRequest'],\\n            'Code'         => 3,\\n            'FromUserName' => $this->vbot->myself->username,\\n            'ToUserName'   => $this->vbot->myself->username,\\n            'ClientMsgId'  => time(),\\n        ]);\\n    }\", \"output\": \"open wechat status notify.\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function download($message, $callback = null)\\n    {\\n        if (!$callback) {\\n            static::autoDownload($message['raw'], true);\\n\\n            return true;\\n        }\\n\\n        if ($callback && !is_callable($callback)) {\\n            throw new ArgumentException();\\n        }\\n\\n        call_user_func_array($callback, [static::getResource($message['raw'])]);\\n\\n        return true;\\n    }\", \"output\": \"download multimedia.\\n\\n@param $message\\n@param null $callback\\n\\n@throws ArgumentException\\n\\n@return bool\"}"}
{"text": "{\"input\": \"Summarize the following code: private static function getResource($message)\\n    {\\n        $url = static::getDownloadUrl($message);\\n\\n        $content = vbot('http')->get($url, static::getDownloadOption($message));\\n\\n        if (!$content) {\\n            vbot('console')->log('download file failed.', Console::WARNING);\\n        } else {\\n            return $content;\\n        }\\n    }\", \"output\": \"get a resource through api.\\n\\n@param $message\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: protected static function autoDownload($message, $force = false)\\n    {\\n        $isDownload = vbot('config')['download.'.static::TYPE];\\n\\n        if ($isDownload || $force) {\\n            $resource = static::getResource($message);\\n\\n            if ($resource) {\\n                File::saveTo(vbot('config')['user_path'].static::TYPE.DIRECTORY_SEPARATOR.\\n                    static::fileName($message), $resource);\\n            }\\n        }\\n    }\", \"output\": \"download resource to a default path.\\n\\n@param $message\\n@param bool $force\"}"}
{"text": "{\"input\": \"Summarize the following code: public function checkSync()\\n    {\\n        $content = $this->vbot->http->get($this->vbot->config['server.uri.push'].'/synccheck', ['timeout' => 35, 'query' => [\\n            'r'        => time(),\\n            'sid'      => $this->vbot->config['server.sid'],\\n            'uin'      => $this->vbot->config['server.uin'],\\n            'skey'     => $this->vbot->config['server.skey'],\\n            'deviceid' => $this->vbot->config['server.deviceId'],\\n            'synckey'  => $this->vbot->config['server.syncKeyStr'],\\n            '_'        => time(),\\n        ]]);\\n\\n        if (!$content) {\\n            $this->vbot->console->log('checkSync no response');\\n\\n            return false;\\n        }\\n\\n        return preg_match('/window.synccheck=\\\\{retcode:\\\"(\\\\d+)\\\",selector:\\\"(\\\\d+)\\\"\\\\}/', $content, $matches) ?\\n            [$matches[1], $matches[2]] : false;\\n    }\", \"output\": \"check if got a new message.\\n\\n@return array|bool\"}"}
{"text": "{\"input\": \"Summarize the following code: public function sync()\\n    {\\n        $url = sprintf($this->vbot->config['server.uri.base'].'/webwxsync?sid=%s&skey=%s&lang=zh_CN&pass_ticket=%s',\\n            $this->vbot->config['server.sid'],\\n            $this->vbot->config['server.skey'],\\n            $this->vbot->config['server.passTicket']\\n        );\\n\\n        $result = $this->vbot->http->json($url, [\\n            'BaseRequest' => $this->vbot->config['server.baseRequest'],\\n            'SyncKey'     => $this->vbot->config['server.syncKey'],\\n            'rr'          => ~time(),\\n        ], true);\\n\\n        if ($result && $result['BaseResponse']['Ret'] == 0) {\\n            $this->generateSyncKey($result);\\n        }\\n\\n        return $result;\\n    }\", \"output\": \"get a message.\\n\\n@throws WebSyncException\\n\\n@return mixed|string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function generateSyncKey($result)\\n    {\\n        $this->vbot->config['server.syncKey'] = $result['SyncKey'];\\n\\n        $syncKey = [];\\n\\n        if (is_array($this->vbot->config['server.syncKey.List'])) {\\n            foreach ($this->vbot->config['server.syncKey.List'] as $item) {\\n                $syncKey[] = $item['Key'].'_'.$item['Val'];\\n            }\\n        }\\n\\n        $this->vbot->config['server.syncKeyStr'] = implode('|', $syncKey);\\n    }\", \"output\": \"generate a sync key.\\n\\n@param $result\"}"}
{"text": "{\"input\": \"Summarize the following code: public function log($str, $level = 'INFO', $log = false)\\n    {\\n        if ($this->isOutput()) {\\n            if ($log && in_array($level, array_keys(Logger::getLevels()))) {\\n                $this->vbot->log->log($level, $str);\\n            }\\n            echo '['.Carbon::now()->toDateTimeString().']'.\\\"[{$level}] \\\".$str.PHP_EOL;\\n        }\\n    }\", \"output\": \"print in terminal.\\n\\n@param $str\\n@param string $level\\n@param bool   $log\"}"}
{"text": "{\"input\": \"Summarize the following code: public function message($str)\\n    {\\n        if (array_get($this->config, 'message', true)) {\\n            $this->log($str, self::MESSAGE);\\n        }\\n    }\", \"output\": \"print message.\\n\\n@param $str\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function send($username, $word)\\n    {\\n        if (!$word || !$username) {\\n            return false;\\n        }\\n\\n        return static::sendMsg([\\n            'Type'         => 1,\\n            'Content'      => $word,\\n            'FromUserName' => vbot('myself')->username,\\n            'ToUserName'   => $username,\\n            'LocalID'      => time() * 1e4,\\n            'ClientMsgId'  => time() * 1e4,\\n        ]);\\n    }\", \"output\": \"send a text message.\\n\\n@param $word string\\n@param $username string\\n\\n@return bool|mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public function fetchAllContacts($seq = 0)\\n    {\\n        $url = sprintf($this->vbot->config['server.uri.base'].'/webwxgetcontact?pass_ticket=%s&skey=%s&r=%s&seq=%s',\\n            $this->vbot->config['server.passTicket'],\\n            $this->vbot->config['server.skey'],\\n            time(),\\n            $seq\\n        );\\n\\n        $result = $this->vbot->http->json($url, [], true, ['timeout' => 60]);\\n\\n        if (isset($result['MemberList']) && $result['MemberList']) {\\n            $this->store($result['MemberList']);\\n        }\\n\\n        if (isset($result['Seq']) && $result['Seq'] != 0) {\\n            $this->fetchAllContacts($result['Seq']);\\n        }\\n    }\", \"output\": \"fetch all contacts through api.\\n\\n@param $seq\"}"}
{"text": "{\"input\": \"Summarize the following code: public function store($memberList)\\n    {\\n        foreach ($memberList as $contact) {\\n            if (in_array($contact['UserName'], static::SPECIAL_USERS)) {\\n                $this->vbot->specials->put($contact['UserName'], $contact);\\n            } elseif ($this->vbot->officials->isOfficial($contact['VerifyFlag'])) {\\n                $this->vbot->officials->put($contact['UserName'], $contact);\\n            } elseif (strstr($contact['UserName'], '@@') !== false) {\\n                $this->vbot->groups->put($contact['UserName'], $contact);\\n            } else {\\n                $this->vbot->friends->put($contact['UserName'], $contact);\\n            }\\n        }\\n    }\", \"output\": \"create and save contacts to collections.\\n\\n@param $memberList\"}"}
{"text": "{\"input\": \"Summarize the following code: public function fetchGroupMembers()\\n    {\\n        $url = sprintf($this->vbot->config['server.uri.base'].'/webwxbatchgetcontact?type=ex&r=%s&pass_ticket=%s',\\n            time(), $this->vbot->config['server.passTicket']\\n        );\\n\\n        $list = [];\\n        $this->vbot->groups->each(function ($item, $key) use (&$list) {\\n            $list[] = ['UserName' => $key, 'EncryChatRoomId' => ''];\\n        });\\n\\n        $content = $this->vbot->http->json($url, [\\n            'BaseRequest' => $this->vbot->config['server.baseRequest'],\\n            'Count'       => $this->vbot->groups->count(),\\n            'List'        => $list,\\n        ], true, ['timeout' => 60]);\\n\\n        $this->storeMembers($content);\\n    }\", \"output\": \"fetch group members.\"}"}
{"text": "{\"input\": \"Summarize the following code: private function storeMembers($array)\\n    {\\n        if (isset($array['ContactList']) && $array['ContactList']) {\\n            foreach ($array['ContactList'] as $group) {\\n                $groupAccount = $this->vbot->groups->get($group['UserName']);\\n                $groupAccount['MemberList'] = $group['MemberList'];\\n                $groupAccount['ChatRoomId'] = $group['EncryChatRoomId'];\\n                $this->vbot->groups->put($group['UserName'], $groupAccount);\\n                foreach ($group['MemberList'] as $member) {\\n                    $this->vbot->members->put($member['UserName'], $member);\\n                }\\n            }\\n        }\\n    }\", \"output\": \"store group members.\\n\\n@param $array\"}"}
{"text": "{\"input\": \"Summarize the following code: public function report(Exception $e)\\n    {\\n        if ($this->shouldntReport($e)) {\\n            return true;\\n        }\\n\\n        if ($this->handler) {\\n            call_user_func_array($this->handler, [$e]);\\n        }\\n    }\", \"output\": \"report while exception.\\n\\n@param Exception $e\\n\\n@throws Exception\\n\\n@return bool\"}"}
{"text": "{\"input\": \"Summarize the following code: private function throwFatalException(Throwable $e)\\n    {\\n        foreach ($this->fatalException as $exception) {\\n            if ($e instanceof $exception) {\\n                throw $e;\\n            }\\n        }\\n    }\", \"output\": \"Exception that make vbot couldn 't work.\\n\\n@param Throwable $e\\n\\n@throws Throwable\"}"}
{"text": "{\"input\": \"Summarize the following code: private function validateKey($key): void\\n    {\\n        if (! is_resource($key)) {\\n            throw new InvalidArgumentException(\\n                'It was not possible to parse your key, reason: ' . openssl_error_string()\\n            );\\n        }\\n\\n        $details = openssl_pkey_get_details($key);\\n        assert(is_array($details));\\n\\n        if (! isset($details['key']) || $details['type'] !== $this->getKeyType()) {\\n            throw new InvalidArgumentException('This key is not compatible with this signer');\\n        }\\n    }\", \"output\": \"Raises an exception when the key type is not the expected type\\n\\n@param resource|bool $key\\n\\n@throws InvalidArgumentException\"}"}
{"text": "{\"input\": \"Summarize the following code: private function splitJwt(string $jwt): array\\n    {\\n        $data = explode('.', $jwt);\\n\\n        if (count($data) !== 3) {\\n            throw new InvalidArgumentException('The JWT string must have two dots');\\n        }\\n\\n        return $data;\\n    }\", \"output\": \"Splits the JWT string into an array\\n\\n@return string[]\\n\\n@throws InvalidArgumentException When JWT doesn't have all parts.\"}"}
{"text": "{\"input\": \"Summarize the following code: private function parseHeader(string $data): array\\n    {\\n        $header = $this->decoder->jsonDecode($this->decoder->base64UrlDecode($data));\\n\\n        if (! is_array($header)) {\\n            throw new InvalidArgumentException('Headers must be an array');\\n        }\\n\\n        if (isset($header['enc'])) {\\n            throw new InvalidArgumentException('Encryption is not supported yet');\\n        }\\n\\n        if (! isset($header['typ'])) {\\n            throw new InvalidArgumentException('The header \\\"typ\\\" must be present');\\n        }\\n\\n        return $header;\\n    }\", \"output\": \"Parses the header from a string\\n\\n@return mixed[]\\n\\n@throws InvalidArgumentException When an invalid header is informed.\"}"}
{"text": "{\"input\": \"Summarize the following code: private function parseClaims(string $data): array\\n    {\\n        $claims = $this->decoder->jsonDecode($this->decoder->base64UrlDecode($data));\\n\\n        if (! is_array($claims)) {\\n            throw new InvalidArgumentException('Claims must be an array');\\n        }\\n\\n        if (isset($claims[RegisteredClaims::AUDIENCE])) {\\n            $claims[RegisteredClaims::AUDIENCE] = (array) $claims[RegisteredClaims::AUDIENCE];\\n        }\\n\\n        foreach (array_intersect(RegisteredClaims::DATE_CLAIMS, array_keys($claims)) as $claim) {\\n            $claims[$claim] = $this->convertDate((string) $claims[$claim]);\\n        }\\n\\n        return $claims;\\n    }\", \"output\": \"Parses the claim set from a string\\n\\n@return mixed[]\\n\\n@throws InvalidArgumentException When an invalid claim set is informed.\"}"}
{"text": "{\"input\": \"Summarize the following code: private function parseSignature(array $header, string $data): Signature\\n    {\\n        if ($data === '' || ! isset($header['alg']) || $header['alg'] === 'none') {\\n            return Signature::fromEmptyData();\\n        }\\n\\n        $hash = $this->decoder->base64UrlDecode($data);\\n\\n        return new Signature($hash, $data);\\n    }\", \"output\": \"Returns the signature from given data\\n\\n@param mixed[] $header\"}"}
{"text": "{\"input\": \"Summarize the following code: public function negotiateLanguage()\\n    {\\n        $matches = $this->getMatchesFromAcceptedLanguages();\\n        foreach ($matches as $key => $q) {\\n\\n            $key = ($this->configRepository->get('laravellocalization.localesMapping')[$key]) ?? $key;\\n\\n            if (!empty($this->supportedLanguages[$key])) {\\n                return $key;\\n            }\\n\\n            if ($this->use_intl) {\\n                $key = Locale::canonicalize($key);\\n            }\\n\\n            // Search for acceptable locale by 'regional' => 'af_ZA' or 'lang' => 'af-ZA' match.\\n            foreach ( $this->supportedLanguages as $key_supported => $locale ) {\\n                if ( (isset($locale['regional']) && $locale['regional'] == $key) || (isset($locale['lang']) && $locale['lang'] == $key) ) {\\n                    return $key_supported;\\n                }\\n            }\\n        }\\n        // If any (i.e. \\\"*\\\") is acceptable, return the first supported format\\n        if (isset($matches['*'])) {\\n            reset($this->supportedLanguages);\\n\\n            return key($this->supportedLanguages);\\n        }\\n\\n        if ($this->use_intl && !empty($_SERVER['HTTP_ACCEPT_LANGUAGE'])) {\\n            $http_accept_language = Locale::acceptFromHttp($_SERVER['HTTP_ACCEPT_LANGUAGE']);\\n\\n            if (!empty($this->supportedLanguages[$http_accept_language])) {\\n                return $http_accept_language;\\n            }\\n        }\\n\\n        if ($this->request->server('REMOTE_HOST')) {\\n            $remote_host = explode('.', $this->request->server('REMOTE_HOST'));\\n            $lang = strtolower(end($remote_host));\\n\\n            if (!empty($this->supportedLanguages[$lang])) {\\n                return $lang;\\n            }\\n        }\\n\\n        return $this->defaultLocale;\\n    }\", \"output\": \"Negotiates language with the user's browser through the Accept-Language\\nHTTP header or the user's host address.  Language codes are generally in\\nthe form \\\"ll\\\" for a language spoken in only one country, or \\\"ll-CC\\\" for a\\nlanguage spoken in a particular country.  For example, U.S. English is\\n\\\"en-US\\\", while British English is \\\"en-UK\\\".  Portuguese as spoken in\\nPortugal is \\\"pt-PT\\\", while Brazilian Portuguese is \\\"pt-BR\\\".\\n\\nThis function is based on negotiateLanguage from Pear HTTP2\\nhttp://pear.php.net/package/HTTP2/\\n\\nQuality factors in the Accept-Language: header are supported, e.g.:\\nAccept-Language: en-UK;q=0.7, en-US;q=0.6, no, dk;q=0.8\\n\\n@return string The negotiated language result or app.locale.\"}"}
{"text": "{\"input\": \"Summarize the following code: private function getMatchesFromAcceptedLanguages()\\n    {\\n        $matches = [];\\n\\n        if ($acceptLanguages = $this->request->header('Accept-Language')) {\\n            $acceptLanguages = explode(',', $acceptLanguages);\\n\\n            $generic_matches = [];\\n            foreach ($acceptLanguages as $option) {\\n                $option = array_map('trim', explode(';', $option));\\n                $l = $option[0];\\n                if (isset($option[1])) {\\n                    $q = (float) str_replace('q=', '', $option[1]);\\n                } else {\\n                    $q = null;\\n                    // Assign default low weight for generic values\\n                    if ($l == '*/*') {\\n                        $q = 0.01;\\n                    } elseif (substr($l, -1) == '*') {\\n                        $q = 0.02;\\n                    }\\n                }\\n                // Unweighted values, get high weight by their position in the\\n                // list\\n                $q = $q ?? 1000 - \\\\count($matches);\\n                $matches[$l] = $q;\\n\\n                //If for some reason the Accept-Language header only sends language with country\\n                //we should make the language without country an accepted option, with a value\\n                //less than it's parent.\\n                $l_ops = explode('-', $l);\\n                array_pop($l_ops);\\n                while (!empty($l_ops)) {\\n                    //The new generic option needs to be slightly less important than it's base\\n                    $q -= 0.001;\\n                    $op = implode('-', $l_ops);\\n                    if (empty($generic_matches[$op]) || $generic_matches[$op] > $q) {\\n                        $generic_matches[$op] = $q;\\n                    }\\n                    array_pop($l_ops);\\n                }\\n            }\\n            $matches = array_merge($generic_matches, $matches);\\n\\n            arsort($matches, SORT_NUMERIC);\\n        }\\n\\n        return $matches;\\n    }\", \"output\": \"Return all the accepted languages from the browser.\\n\\n@return array Matches from the header field Accept-Languages\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function cacheRoutesPerLocale()\\n    {\\n        // Store the default routes cache,\\n        // this way the Application will detect that routes are cached.\\n        $allLocales = $this->getSupportedLocales();\\n\\n        array_push($allLocales, null);\\n\\n        foreach ($allLocales as $locale) {\\n\\n            $routes = $this->getFreshApplicationRoutes($locale);\\n\\n            if (count($routes) == 0) {\\n                $this->error(\\\"Your application doesn't have any routes.\\\");\\n                return;\\n            }\\n\\n            foreach ($routes as $route) {\\n                $route->prepareForSerialization();\\n            }\\n\\n            $this->files->put(\\n                $this->makeLocaleRoutesPath($locale), $this->buildRouteCacheFile($routes)\\n            );\\n        }\\n    }\", \"output\": \"Cache the routes separately for each locale.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function buildRouteCacheFile(RouteCollection $routes)\\n    {\\n        $stub = $this->files->get(\\n            realpath(\\n                __DIR__\\n                . DIRECTORY_SEPARATOR . '..'\\n                . DIRECTORY_SEPARATOR . '..'\\n                . DIRECTORY_SEPARATOR . '..'\\n                . DIRECTORY_SEPARATOR . 'stubs'\\n                . DIRECTORY_SEPARATOR . 'routes.stub'\\n            )\\n        );\\n\\n        return str_replace(\\n            [\\n                '{{routes}}',\\n                '{{translatedRoutes}}',\\n            ],\\n            [\\n                base64_encode(serialize($routes)),\\n                $this->getLaravelLocalization()->getSerializedTranslatedRoutes(),\\n            ],\\n            $stub\\n        );\\n    }\", \"output\": \"Build the route cache file.\\n\\n@param  \\\\Illuminate\\\\Routing\\\\RouteCollection $routes\\n@return string\\n@throws \\\\Illuminate\\\\Contracts\\\\Filesystem\\\\FileNotFoundException\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function registerBindings()\\n    {\\n        $this->app->singleton(LaravelLocalization::class, function () {\\n            return new LaravelLocalization();\\n        });\\n\\n        $this->app->alias(LaravelLocalization::class, 'laravellocalization');\\n    }\", \"output\": \"Registers app bindings and aliases.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function registerCommands()\\n    {\\n        $this->app->singleton('laravellocalizationroutecache.cache', Commands\\\\RouteTranslationsCacheCommand::class);\\n        $this->app->singleton('laravellocalizationroutecache.clear', Commands\\\\RouteTranslationsClearCommand::class);\\n        $this->app->singleton('laravellocalizationroutecache.list', Commands\\\\RouteTranslationsListCommand::class);\\n\\n        $this->commands([\\n            'laravellocalizationroutecache.cache',\\n            'laravellocalizationroutecache.clear',\\n            'laravellocalizationroutecache.list',\\n        ]);\\n    }\", \"output\": \"Registers route caching commands.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setLocale($locale = null)\\n    {\\n        if (empty($locale) || !\\\\is_string($locale)) {\\n            // If the locale has not been passed through the function\\n            // it tries to get it from the first segment of the url\\n            $locale = $this->request->segment(1);\\n\\n            // If the locale is determined by env, use that\\n            // Note that this is how per-locale route caching is performed.\\n            if ( ! $locale) {\\n                $locale = $this->getForcedLocale();\\n            }\\n        }\\n\\n        if (!empty($this->supportedLocales[$locale])) {\\n            $this->currentLocale = $locale;\\n        } else {\\n            // if the first segment/locale passed is not valid\\n            // the system would ask which locale have to take\\n            // it could be taken by the browser\\n            // depending on your configuration\\n\\n            $locale = null;\\n\\n            // if we reached this point and hideDefaultLocaleInURL is true\\n            // we have to assume we are routing to a defaultLocale route.\\n            if ($this->hideDefaultLocaleInURL()) {\\n                $this->currentLocale = $this->defaultLocale;\\n            }\\n            // but if hideDefaultLocaleInURL is false, we have\\n            // to retrieve it from the browser...\\n            else {\\n                $this->currentLocale = $this->getCurrentLocale();\\n            }\\n        }\\n\\n        $this->app->setLocale($this->currentLocale);\\n\\n        // Regional locale such as de_DE, so formatLocalized works in Carbon\\n        $regional = $this->getCurrentLocaleRegional();\\n        $suffix = $this->configRepository->get('laravellocalization.utf8suffix');\\n        if ($regional) {\\n            setlocale(LC_TIME, $regional . $suffix);\\n            setlocale(LC_MONETARY, $regional . $suffix);\\n        }\\n\\n        return $locale;\\n    }\", \"output\": \"Set and return current locale.\\n\\n@param string $locale Locale to set the App to (optional)\\n\\n@return string Returns locale (if route has any) or null (if route does not have a locale)\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getURLFromRouteNameTranslated($locale, $transKeyName, $attributes = [], $forceDefaultLocation = false)\\n    {\\n        if (!$this->checkLocaleInSupportedLocales($locale)) {\\n            throw new UnsupportedLocaleException('Locale \\\\''.$locale.'\\\\' is not in the list of supported locales.');\\n        }\\n\\n        if (!\\\\is_string($locale)) {\\n            $locale = $this->getDefaultLocale();\\n        }\\n\\n        $route = '';\\n\\n        if ($forceDefaultLocation || !($locale === $this->defaultLocale && $this->hideDefaultLocaleInURL())) {\\n            $route = '/'.$locale;\\n        }\\n        if (\\\\is_string($locale) && $this->translator->has($transKeyName, $locale)) {\\n            $translation = $this->translator->trans($transKeyName, [], $locale);\\n            $route .= '/'.$translation;\\n\\n            $route = $this->substituteAttributesInRoute($attributes, $route);\\n        }\\n\\n        if (empty($route)) {\\n            // This locale does not have any key for this route name\\n            return false;\\n        }\\n\\n        return rtrim($this->createUrlFromUri($route), '/');\\n    }\", \"output\": \"Returns an URL adapted to the route name and the locale given.\\n\\n\\n@param string|bool $locale       Locale to adapt\\n@param string      $transKeyName Translation key name of the url to adapt\\n@param array       $attributes   Attributes for the route (only needed if transKeyName needs them)\\n@param bool        $forceDefaultLocation Force to show default location even hideDefaultLocaleInURL set as TRUE\\n\\n@throws SupportedLocalesNotDefined\\n@throws UnsupportedLocaleException\\n\\n@return string|false URL translated\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getSupportedLocales()\\n    {\\n        if (!empty($this->supportedLocales)) {\\n            return $this->supportedLocales;\\n        }\\n\\n        $locales = $this->configRepository->get('laravellocalization.supportedLocales');\\n\\n        if (empty($locales) || !\\\\is_array($locales)) {\\n            throw new SupportedLocalesNotDefined();\\n        }\\n\\n        $this->supportedLocales = $locales;\\n\\n        return $locales;\\n    }\", \"output\": \"Return an array of all supported Locales.\\n\\n@throws SupportedLocalesNotDefined\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getLocalesOrder()\\n    {\\n        $locales = $this->getSupportedLocales();\\n\\n        $order = $this->configRepository->get('laravellocalization.localesOrder');\\n\\n        uksort($locales, function ($a, $b) use ($order) {\\n            $pos_a = array_search($a, $order);\\n            $pos_b = array_search($b, $order);\\n            return $pos_a - $pos_b;\\n        });\\n\\n        return $locales;\\n    }\", \"output\": \"Return an array of all supported Locales but in the order the user\\nhas specified in the config file. Useful for the language selector.\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getCurrentLocaleDirection()\\n    {\\n        if (!empty($this->supportedLocales[$this->getCurrentLocale()]['dir'])) {\\n            return $this->supportedLocales[$this->getCurrentLocale()]['dir'];\\n        }\\n\\n        switch ($this->getCurrentLocaleScript()) {\\n            // Other (historic) RTL scripts exist, but this list contains the only ones in current use.\\n            case 'Arab':\\n            case 'Hebr':\\n            case 'Mong':\\n            case 'Tfng':\\n            case 'Thaa':\\n            return 'rtl';\\n            default:\\n            return 'ltr';\\n        }\\n    }\", \"output\": \"Returns current locale direction.\\n\\n@return string current locale direction\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getCurrentLocale()\\n    {\\n        if ($this->currentLocale) {\\n            return $this->currentLocale;\\n        }\\n\\n        if ($this->useAcceptLanguageHeader() && !$this->app->runningInConsole()) {\\n            $negotiator = new LanguageNegotiator($this->defaultLocale, $this->getSupportedLocales(), $this->request);\\n\\n            return $negotiator->negotiateLanguage();\\n        }\\n\\n        // or get application default language\\n        return $this->configRepository->get('app.locale');\\n    }\", \"output\": \"Returns current language.\\n\\n@return string current language\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getCurrentLocaleRegional()\\n    {\\n        // need to check if it exists, since 'regional' has been added\\n        // after version 1.0.11 and existing users will not have it\\n        if (isset($this->supportedLocales[$this->getCurrentLocale()]['regional'])) {\\n            return $this->supportedLocales[$this->getCurrentLocale()]['regional'];\\n        } else {\\n            return;\\n        }\\n    }\", \"output\": \"Returns current regional.\\n\\n@return string current regional\"}"}
{"text": "{\"input\": \"Summarize the following code: public function checkLocaleInSupportedLocales($locale)\\n    {\\n        $locales = $this->getSupportedLocales();\\n        if ($locale !== false && empty($locales[$locale])) {\\n            return false;\\n        }\\n\\n        return true;\\n    }\", \"output\": \"Check if Locale exists on the supported locales array.\\n\\n@param string|bool $locale string|bool Locale to be checked\\n\\n@throws SupportedLocalesNotDefined\\n\\n@return bool is the locale supported?\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getRouteNameFromAPath($path)\\n    {\\n        $attributes = $this->extractAttributes($path);\\n\\n        $path = parse_url($path)['path'];\\n        $path = trim(str_replace('/'.$this->currentLocale.'/', '', $path), \\\"/\\\");\\n\\n        foreach ($this->translatedRoutes as $route) {\\n            if (trim($this->substituteAttributesInRoute($attributes, $this->translator->trans($route)), '/') === $path) {\\n                return $route;\\n            }\\n        }\\n\\n        return false;\\n    }\", \"output\": \"Returns the translation key for a given path.\\n\\n@param string $path Path to get the key translated\\n\\n@return string|false Key for translation, false if not exist\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function findTranslatedRouteByPath($path, $url_locale)\\n    {\\n        // check if this url is a translated url\\n        foreach ($this->translatedRoutes as $translatedRoute) {\\n            if ($this->translator->trans($translatedRoute, [], $url_locale) == rawurldecode($path)) {\\n                return $translatedRoute;\\n            }\\n        }\\n\\n        return false;\\n    }\", \"output\": \"Returns the translated route for the path and the url given.\\n\\n@param string $path       Path to check if it is a translated route\\n@param string $url_locale Language to check if the path exists\\n\\n@return string|false Key for translation, false if not exist\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function findTranslatedRouteByUrl($url, $attributes, $locale)\\n    {\\n        if (empty($url)) {\\n            return false;\\n        }\\n\\n        if (isset($this->cachedTranslatedRoutesByUrl[$locale][$url])) {\\n            return $this->cachedTranslatedRoutesByUrl[$locale][$url];\\n        }\\n\\n        // check if this url is a translated url\\n        foreach ($this->translatedRoutes as $translatedRoute) {\\n            $routeName = $this->getURLFromRouteNameTranslated($locale, $translatedRoute, $attributes);\\n\\n            // We can ignore extra url parts and compare only their url_path (ignore arguments that are not attributes)\\n            if (parse_url($this->getNonLocalizedURL($routeName), PHP_URL_PATH) == parse_url($this->getNonLocalizedURL($url), PHP_URL_PATH)) {\\n                $this->cachedTranslatedRoutesByUrl[$locale][$url] = $translatedRoute;\\n\\n                return $translatedRoute;\\n            }\\n        }\\n\\n        return false;\\n    }\", \"output\": \"Returns the translated route for an url and the attributes given and a locale.\\n\\n\\n@param string|false|null $url        Url to check if it is a translated route\\n@param array             $attributes Attributes to check if the url exists in the translated routes array\\n@param string            $locale     Language to check if the url exists\\n\\n@throws SupportedLocalesNotDefined\\n@throws UnsupportedLocaleException\\n\\n@return string|false Key for translation, false if not exist\"}"}
{"text": "{\"input\": \"Summarize the following code: public function createUrlFromUri($uri)\\n    {\\n        $uri = ltrim($uri, '/');\\n\\n        if (empty($this->baseUrl)) {\\n            return app('url')->to($uri);\\n        }\\n\\n        return $this->baseUrl.$uri;\\n    }\", \"output\": \"Create an url from the uri.\\n\\n@param string $uri Uri\\n\\n@return string Url for the given uri\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function normalizeAttributes($attributes)\\n     {\\n         if (array_key_exists('data', $attributes) && \\\\is_array($attributes['data']) && ! \\\\count($attributes['data'])) {\\n             $attributes['data'] = null;\\n             return $attributes;\\n         }\\n         return $attributes;\\n     }\", \"output\": \"Normalize attributes gotten from request parameters.\\n\\n@param      array  $attributes  The attributes\\n@return     array  The normalized attributes\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function loadCachedRoutes()\\n    {\\n        $localization = $this->getLaravelLocalization();\\n\\n        $localization->setLocale();\\n\\n        $locale = $localization->getCurrentLocale();\\n\\n        $localeKeys = $localization->getSupportedLanguagesKeys();\\n\\n        // First, try to load the routes specifically cached for this locale\\n        // if they do not exist, write a warning to the log and load the default\\n        // routes instead. Note that this is guaranteed to exist, because the\\n        // 'cached routes' check in the Application checks its existence.\\n\\n        $path = $this->makeLocaleRoutesPath($locale, $localeKeys);\\n\\n        if ( ! file_exists($path)) {\\n\\n            Log::warning(\\\"Routes cached, but no cached routes found for locale '{$locale}'!\\\");\\n\\n            $path = $this->getDefaultCachedRoutePath();\\n        }\\n\\n        $this->app->booted(function () use ($path) {\\n            require $path;\\n        });\\n    }\", \"output\": \"Load the cached routes for the application.\\n\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function makeLocaleRoutesPath($locale, $localeKeys)\\n    {\\n        $path = $this->getDefaultCachedRoutePath();\\n\\n        $localeSegment = request()->segment(1);\\n        if ( ! $localeSegment || ! in_array($localeSegment, $localeKeys)) {\\n            return $path;\\n        }\\n\\n        return substr($path, 0, -4) . '_' . $locale . '.php';\\n    }\", \"output\": \"Returns the path to the cached routes file for a given locale.\\n\\n@param string   $locale\\n@param string[] $localeKeys\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function encodeMessageSet(array $messages, int $compression = self::COMPRESSION_NONE): string\\n    {\\n        $data = '';\\n        $next = 0;\\n\\n        foreach ($messages as $message) {\\n            $encodedMessage = $this->encodeMessage($message);\\n\\n            $data .= self::pack(self::BIT_B64, (string) $next)\\n                   . self::encodeString($encodedMessage, self::PACK_INT32);\\n\\n            ++$next;\\n        }\\n\\n        if ($compression === self::COMPRESSION_NONE) {\\n            return $data;\\n        }\\n\\n        return self::pack(self::BIT_B64, '0')\\n             . self::encodeString($this->encodeMessage($data, $compression), self::PACK_INT32);\\n    }\", \"output\": \"encode message set\\nN.B., MessageSets are not preceded by an int32 like other array elements\\nin the protocol.\\n\\n@param string[]|string[][] $messages\\n\\n@throws NotSupported\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function encodeProducePartition(array $values, int $compression): string\\n    {\\n        if (! isset($values['partition_id'])) {\\n            throw new ProtocolException('given produce data invalid. `partition_id` is undefined.');\\n        }\\n\\n        if (! isset($values['messages']) || empty($values['messages'])) {\\n            throw new ProtocolException('given produce data invalid. `messages` is undefined.');\\n        }\\n\\n        $data  = self::pack(self::BIT_B32, (string) $values['partition_id']);\\n        $data .= self::encodeString(\\n            $this->encodeMessageSet((array) $values['messages'], $compression),\\n            self::PACK_INT32\\n        );\\n\\n        return $data;\\n    }\", \"output\": \"encode signal part\\n\\n@param mixed[] $values\\n\\n@throws NotSupported\\n@throws ProtocolException\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function encodeProduceTopic(array $values, int $compression): string\\n    {\\n        if (! isset($values['topic_name'])) {\\n            throw new ProtocolException('given produce data invalid. `topic_name` is undefined.');\\n        }\\n\\n        if (! isset($values['partitions']) || empty($values['partitions'])) {\\n            throw new ProtocolException('given produce data invalid. `partitions` is undefined.');\\n        }\\n\\n        $topic      = self::encodeString($values['topic_name'], self::PACK_INT16);\\n        $partitions = self::encodeArray($values['partitions'], [$this, 'encodeProducePartition'], $compression);\\n\\n        return $topic . $partitions;\\n    }\", \"output\": \"encode signal topic\\n\\n@param mixed[] $values\\n\\n@throws NotSupported\\n@throws ProtocolException\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function produceTopicPair(string $data, int $version): array\\n    {\\n        $offset    = 0;\\n        $topicInfo = $this->decodeString($data, self::BIT_B16);\\n        $offset   += $topicInfo['length'];\\n        $ret       = $this->decodeArray(substr($data, $offset), [$this, 'producePartitionPair'], $version);\\n        $offset   += $ret['length'];\\n\\n        return [\\n            'length' => $offset,\\n            'data'   => [\\n                'topicName'  => $topicInfo['data'],\\n                'partitions' => $ret['data'],\\n            ],\\n        ];\\n    }\", \"output\": \"decode produce topic pair response\\n\\n@return mixed[]\\n\\n@throws ProtocolException\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function producePartitionPair(string $data, int $version): array\\n    {\\n        $offset          = 0;\\n        $partitionId     = self::unpack(self::BIT_B32, substr($data, $offset, 4));\\n        $offset         += 4;\\n        $errorCode       = self::unpack(self::BIT_B16_SIGNED, substr($data, $offset, 2));\\n        $offset         += 2;\\n        $partitionOffset = self::unpack(self::BIT_B64, substr($data, $offset, 8));\\n        $offset         += 8;\\n        $timestamp       = 0;\\n\\n        if ($version === self::API_VERSION2) {\\n            $timestamp = self::unpack(self::BIT_B64, substr($data, $offset, 8));\\n            $offset   += 8;\\n        }\\n\\n        return [\\n            'length' => $offset,\\n            'data'   => [\\n                'partition' => $partitionId,\\n                'errorCode' => $errorCode,\\n                'offset'    => $offset,\\n                'timestamp' => $timestamp,\\n            ],\\n        ];\\n    }\", \"output\": \"decode produce partition pair response\\n\\n@return mixed[]\\n\\n@throws ProtocolException\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function decodeMessageSet(string $data): ?array\\n    {\\n        if (strlen($data) <= 12) {\\n            return null;\\n        }\\n\\n        $offset      = 0;\\n        $roffset     = self::unpack(self::BIT_B64, substr($data, $offset, 8));\\n        $offset     += 8;\\n        $messageSize = self::unpack(self::BIT_B32, substr($data, $offset, 4));\\n        $offset     += 4;\\n        $ret         = $this->decodeMessage(substr($data, $offset), $messageSize);\\n\\n        if ($ret === null) {\\n            return null;\\n        }\\n\\n        $offset += $ret['length'];\\n\\n        return [\\n            'length' => $offset,\\n            'data'   => [\\n                'offset'  => $roffset,\\n                'size'    => $messageSize,\\n                'message' => $ret['data'],\\n            ],\\n        ];\\n    }\", \"output\": \"decode message set\\nN.B., MessageSets are not preceded by an int32 like other array elements\\nin the protocol.\\n\\n@return mixed[]|null\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function decodeMessage(string $data, int $messageSize): ?array\\n    {\\n        if ($messageSize === 0 || strlen($data) < $messageSize) {\\n            return null;\\n        }\\n\\n        $offset  = 0;\\n        $crc     = self::unpack(self::BIT_B32, substr($data, $offset, 4));\\n        $offset += 4;\\n\\n        $magic = self::unpack(self::BIT_B8, substr($data, $offset, 1));\\n        ++$offset;\\n\\n        $attr = self::unpack(self::BIT_B8, substr($data, $offset, 1));\\n        ++$offset;\\n\\n        $timestamp  = 0;\\n        $backOffset = $offset;\\n\\n        try { // try unpack message format v1, falling back to v0 if it fails\\n            if ($magic >= self::MESSAGE_MAGIC_VERSION1) {\\n                $timestamp = self::unpack(self::BIT_B64, substr($data, $offset, 8));\\n                $offset   += 8;\\n            }\\n\\n            $keyRet  = $this->decodeString(substr($data, $offset), self::BIT_B32);\\n            $offset += $keyRet['length'];\\n\\n            $valueRet = $this->decodeString((string) substr($data, $offset), self::BIT_B32, $attr & Produce::COMPRESSION_CODEC_MASK);\\n            $offset  += $valueRet['length'];\\n\\n            if ($offset !== $messageSize) {\\n                throw new Exception(\\n                    'pack message fail, message len:' . $messageSize . ' , data unpack offset :' . $offset\\n                );\\n            }\\n        } catch (Exception $e) { // try unpack message format v0\\n            $offset    = $backOffset;\\n            $timestamp = 0;\\n            $keyRet    = $this->decodeString(substr($data, $offset), self::BIT_B32);\\n            $offset   += $keyRet['length'];\\n\\n            $valueRet = $this->decodeString(substr($data, $offset), self::BIT_B32);\\n            $offset  += $valueRet['length'];\\n        }\\n\\n        return [\\n            'length' => $offset,\\n            'data'   => [\\n                'crc'       => $crc,\\n                'magic'     => $magic,\\n                'attr'      => $attr,\\n                'timestamp' => $timestamp,\\n                'key'       => $keyRet['data'],\\n                'value'     => $valueRet['data'],\\n            ],\\n        ];\\n    }\", \"output\": \"decode message\\nN.B., MessageSets are not preceded by an int32 like other array elements\\nin the protocol.\\n\\n@return mixed[]|null\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function createSocket(string $remoteSocket, $context, ?int &$errno, ?string &$errstr)\\n    {\\n        return stream_socket_client(\\n            $remoteSocket,\\n            $errno,\\n            $errstr,\\n            $this->sendTimeoutSec + ($this->sendTimeoutUsec / 1000000),\\n            STREAM_CLIENT_CONNECT,\\n            $context\\n        );\\n    }\", \"output\": \"Encapsulation of stream_socket_client\\n\\nBecause `stream_socket_client` in stream wrapper mock no effect, if don't create this function will never be testable\\n\\n@codeCoverageIgnore\\n\\n@param resource $context\\n\\n@return resource\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function select(array $sockets, int $timeoutSec, int $timeoutUsec, bool $isRead = true)\\n    {\\n        $null = null;\\n\\n        if ($isRead) {\\n            return @stream_select($sockets, $null, $null, $timeoutSec, $timeoutUsec);\\n        }\\n\\n        return @stream_select($null, $sockets, $null, $timeoutSec, $timeoutUsec);\\n    }\", \"output\": \"Encapsulation of stream_select\\n\\nBecause `stream_select` in stream wrapper mock no effect, if don't create this function will never be testable\\n\\n@codeCoverageIgnore\\n\\n@param resource[] $sockets\\n\\n@return int|bool\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function unpack(string $type, string $bytes)\\n    {\\n        self::checkLen($type, $bytes);\\n\\n        if ($type === self::BIT_B64) {\\n            $set    = unpack($type, $bytes);\\n            $result = ($set[1] & 0xFFFFFFFF) << 32 | ($set[2] & 0xFFFFFFFF);\\n        } elseif ($type === self::BIT_B16_SIGNED) {\\n            // According to PHP docs: 's' = signed short (always 16 bit, machine byte order)\\n            // So lets unpack it..\\n            $set = unpack($type, $bytes);\\n\\n            // But if our system is little endian\\n            if (self::isSystemLittleEndian()) {\\n                // We need to flip the endianess because coming from kafka it is big endian\\n                $set = self::convertSignedShortFromLittleEndianToBigEndian($set);\\n            }\\n            $result = $set;\\n        } else {\\n            $result = unpack($type, $bytes);\\n        }\\n\\n        return is_array($result) ? array_shift($result) : $result;\\n    }\", \"output\": \"Unpack a bit integer as big endian long\\n\\n@return mixed\\n@throws ProtocolException\"}"}
{"text": "{\"input\": \"Summarize the following code: protected static function checkLen(string $type, string $bytes): void\\n    {\\n        $expectedLength = 0;\\n\\n        switch ($type) {\\n            case self::BIT_B64:\\n                $expectedLength = 8;\\n                break;\\n            case self::BIT_B32:\\n                $expectedLength = 4;\\n                break;\\n            case self::BIT_B16:\\n                $expectedLength = 2;\\n                break;\\n            case self::BIT_B16_SIGNED:\\n                $expectedLength = 2;\\n                break;\\n            case self::BIT_B8:\\n                $expectedLength = 1;\\n                break;\\n        }\\n\\n        $length = strlen($bytes);\\n\\n        if ($length !== $expectedLength) {\\n            throw new ProtocolException('unpack failed. string(raw) length is ' . $length . ' , TO ' . $type);\\n        }\\n    }\", \"output\": \"check unpack bit is valid\\n\\n@throws ProtocolException\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function isSystemLittleEndian(): bool\\n    {\\n        // If we don't know if our system is big endian or not yet...\\n        if (self::$isLittleEndianSystem === null) {\\n            [$endianTest] = array_values(unpack('L1L', pack('V', 1)));\\n\\n            self::$isLittleEndianSystem = (int) $endianTest === 1;\\n        }\\n\\n        return self::$isLittleEndianSystem;\\n    }\", \"output\": \"Determines if the computer currently running this code is big endian or little endian.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getApiVersion(int $apikey): int\\n    {\\n        switch ($apikey) {\\n            case self::METADATA_REQUEST:\\n                return self::API_VERSION0;\\n            case self::PRODUCE_REQUEST:\\n                if (version_compare($this->version, '0.10.0') >= 0) {\\n                    return self::API_VERSION2;\\n                }\\n\\n                if (version_compare($this->version, '0.9.0') >= 0) {\\n                    return self::API_VERSION1;\\n                }\\n\\n                return self::API_VERSION0;\\n            case self::FETCH_REQUEST:\\n                if (version_compare($this->version, '0.10.0') >= 0) {\\n                    return self::API_VERSION2;\\n                }\\n\\n                if (version_compare($this->version, '0.9.0') >= 0) {\\n                    return self::API_VERSION1;\\n                }\\n\\n                return self::API_VERSION0;\\n            case self::OFFSET_REQUEST:\\n//                TODO: make it compatible with V1 of OFFSET_REQUEST\\n//                if (version_compare($this->version, '0.10.1.0') >= 0) {\\n//                    return self::API_VERSION1;\\n//                } else {\\n//                    return self::API_VERSION0;\\n//                }\\n                return self::API_VERSION0;\\n            case self::GROUP_COORDINATOR_REQUEST:\\n                return self::API_VERSION0;\\n            case self::OFFSET_COMMIT_REQUEST:\\n                if (version_compare($this->version, '0.9.0') >= 0) {\\n                    return self::API_VERSION2;\\n                }\\n\\n                if (version_compare($this->version, '0.8.2') >= 0) {\\n                    return self::API_VERSION1;\\n                }\\n\\n                return self::API_VERSION0; // supported in 0.8.1 or later\\n            case self::OFFSET_FETCH_REQUEST:\\n                if (version_compare($this->version, '0.8.2') >= 0) {\\n                    return self::API_VERSION1; // Offset Fetch Request v1 will fetch offset from Kafka\\n                }\\n\\n                return self::API_VERSION0;//Offset Fetch Request v0 will fetch offset from zookeeper\\n            case self::JOIN_GROUP_REQUEST:\\n                if (version_compare($this->version, '0.10.1.0') >= 0) {\\n                    return self::API_VERSION1;\\n                }\\n\\n                return self::API_VERSION0; // supported in 0.9.0.0 and greater\\n            case self::SYNC_GROUP_REQUEST:\\n                return self::API_VERSION0;\\n            case self::HEART_BEAT_REQUEST:\\n                return self::API_VERSION0;\\n            case self::LEAVE_GROUP_REQUEST:\\n                return self::API_VERSION0;\\n            case self::LIST_GROUPS_REQUEST:\\n                return self::API_VERSION0;\\n            case self::DESCRIBE_GROUPS_REQUEST:\\n                return self::API_VERSION0;\\n        }\\n\\n        // default\\n        return self::API_VERSION0;\\n    }\", \"output\": \"Get kafka api version according to specify kafka broker version\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function getApiText(int $apikey): string\\n    {\\n        $apis = [\\n            self::PRODUCE_REQUEST           => 'ProduceRequest',\\n            self::FETCH_REQUEST             => 'FetchRequest',\\n            self::OFFSET_REQUEST            => 'OffsetRequest',\\n            self::METADATA_REQUEST          => 'MetadataRequest',\\n            self::OFFSET_COMMIT_REQUEST     => 'OffsetCommitRequest',\\n            self::OFFSET_FETCH_REQUEST      => 'OffsetFetchRequest',\\n            self::GROUP_COORDINATOR_REQUEST => 'GroupCoordinatorRequest',\\n            self::JOIN_GROUP_REQUEST        => 'JoinGroupRequest',\\n            self::HEART_BEAT_REQUEST        => 'HeartbeatRequest',\\n            self::LEAVE_GROUP_REQUEST       => 'LeaveGroupRequest',\\n            self::SYNC_GROUP_REQUEST        => 'SyncGroupRequest',\\n            self::DESCRIBE_GROUPS_REQUEST   => 'DescribeGroupsRequest',\\n            self::LIST_GROUPS_REQUEST       => 'ListGroupsRequest',\\n            self::SASL_HAND_SHAKE_REQUEST   => 'SaslHandShakeRequest',\\n            self::API_VERSIONS_REQUEST      => 'ApiVersionsRequest',\\n        ];\\n\\n        return $apis[$apikey] ?? 'Unknown message';\\n    }\", \"output\": \"Get kafka api text\"}"}
{"text": "{\"input\": \"Summarize the following code: public function before($methods, $pattern, $fn)\\n    {\\n        $pattern = $this->baseRoute . '/' . trim($pattern, '/');\\n        $pattern = $this->baseRoute ? rtrim($pattern, '/') : $pattern;\\n\\n        foreach (explode('|', $methods) as $method) {\\n            $this->beforeRoutes[$method][] = [\\n                'pattern' => $pattern,\\n                'fn' => $fn,\\n            ];\\n        }\\n    }\", \"output\": \"Store a before middleware route and a handling function to be executed when accessed using one of the specified methods.\\n\\n@param string          $methods Allowed methods, | delimited\\n@param string          $pattern A route pattern such as /about/system\\n@param object|callable $fn      The handling function to be executed\"}"}
{"text": "{\"input\": \"Summarize the following code: public function match($methods, $pattern, $fn)\\n    {\\n        $pattern = $this->baseRoute . '/' . trim($pattern, '/');\\n        $pattern = $this->baseRoute ? rtrim($pattern, '/') : $pattern;\\n\\n        foreach (explode('|', $methods) as $method) {\\n            $this->afterRoutes[$method][] = [\\n                'pattern' => $pattern,\\n                'fn' => $fn,\\n            ];\\n        }\\n    }\", \"output\": \"Store a route and a handling function to be executed when accessed using one of the specified methods.\\n\\n@param string          $methods Allowed methods, | delimited\\n@param string          $pattern A route pattern such as /about/system\\n@param object|callable $fn      The handling function to be executed\"}"}
{"text": "{\"input\": \"Summarize the following code: public function mount($baseRoute, $fn)\\n    {\\n        // Track current base route\\n        $curBaseRoute = $this->baseRoute;\\n\\n        // Build new base route string\\n        $this->baseRoute .= $baseRoute;\\n\\n        // Call the callable\\n        call_user_func($fn);\\n\\n        // Restore original base route\\n        $this->baseRoute = $curBaseRoute;\\n    }\", \"output\": \"Mounts a collection of callbacks onto a base route.\\n\\n@param string   $baseRoute The route sub pattern to mount the callbacks on\\n@param callable $fn        The callback method\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getRequestMethod()\\n    {\\n        // Take the method as found in $_SERVER\\n        $method = $_SERVER['REQUEST_METHOD'];\\n\\n        // If it's a HEAD request override it to being GET and prevent any output, as per HTTP Specification\\n        // @url http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.4\\n        if ($_SERVER['REQUEST_METHOD'] == 'HEAD') {\\n            ob_start();\\n            $method = 'GET';\\n        }\\n\\n        // If it's a POST request, check for a method override header\\n        elseif ($_SERVER['REQUEST_METHOD'] == 'POST') {\\n            $headers = $this->getRequestHeaders();\\n            if (isset($headers['X-HTTP-Method-Override']) && in_array($headers['X-HTTP-Method-Override'], ['PUT', 'DELETE', 'PATCH'])) {\\n                $method = $headers['X-HTTP-Method-Override'];\\n            }\\n        }\\n\\n        return $method;\\n    }\", \"output\": \"Get the request method used, taking overrides into account.\\n\\n@return string The Request method to handle\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getBasePath()\\n    {\\n        // Check if server base path is defined, if not define it.\\n        if ($this->serverBasePath === null) {\\n            $this->serverBasePath = implode('/', array_slice(explode('/', $_SERVER['SCRIPT_NAME']), 0, -1)) . '/';\\n        }\\n\\n        return $this->serverBasePath;\\n    }\", \"output\": \"Return server base Path, and define it if isn't defined.\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function map($pattern, $callback, $pass_route = false) {\\n        $url = $pattern;\\n        $methods = array('*');\\n\\n        if (strpos($pattern, ' ') !== false) {\\n            list($method, $url) = explode(' ', trim($pattern), 2);\\n\\n            $methods = explode('|', $method);\\n        }\\n\\n        $this->routes[] = new Route($url, $callback, $methods, $pass_route);\\n    }\", \"output\": \"Maps a URL pattern to a callback function.\\n\\n@param string $pattern URL pattern to match\\n@param callback $callback Callback function\\n@param boolean $pass_route Pass the matching route object to the callback\"}"}
{"text": "{\"input\": \"Summarize the following code: public function route(Request $request) {\\n        $url_decoded = urldecode( $request->url );\\n        while ($route = $this->current()) {\\n            if ($route !== false && $route->matchMethod($request->method) && $route->matchUrl($url_decoded, $this->case_sensitive)) {\\n                return $route;\\n            }\\n            $this->next();\\n        }\\n\\n        return false;\\n    }\", \"output\": \"Routes the current request.\\n\\n@param Request $request Request object\\n@return Route|bool Matching route or false if no match\"}"}
{"text": "{\"input\": \"Summarize the following code: public function current() {\\n        return isset($this->routes[$this->index]) ? $this->routes[$this->index] : false;\\n    }\", \"output\": \"Gets the current route.\\n\\n@return Route\"}"}
{"text": "{\"input\": \"Summarize the following code: public function matchUrl($url, $case_sensitive = false) {\\n        // Wildcard or exact match\\n        if ($this->pattern === '*' || $this->pattern === $url) {\\n            return true;\\n        }\\n\\n        $ids = array();\\n        $last_char = substr($this->pattern, -1);\\n\\n        // Get splat\\n        if ($last_char === '*') {\\n            $n = 0;\\n            $len = strlen($url);\\n            $count = substr_count($this->pattern, '/');\\n\\n            for ($i = 0; $i < $len; $i++) {\\n                if ($url[$i] == '/') $n++;\\n                if ($n == $count) break;\\n            }\\n\\n            $this->splat = (string)substr($url, $i+1);\\n        }\\n\\n        // Build the regex for matching\\n        $regex = str_replace(array(')','/*'), array(')?','(/?|/.*?)'), $this->pattern);\\n\\n        $regex = preg_replace_callback(\\n            '#@([\\\\w]+)(:([^/\\\\(\\\\)]*))?#',\\n            function($matches) use (&$ids) {\\n                $ids[$matches[1]] = null;\\n                if (isset($matches[3])) {\\n                    return '(?P<'.$matches[1].'>'.$matches[3].')';\\n                }\\n                return '(?P<'.$matches[1].'>[^/\\\\?]+)';\\n            },\\n            $regex\\n        );\\n\\n        // Fix trailing slash\\n        if ($last_char === '/') {\\n            $regex .= '?';\\n        }\\n        // Allow trailing slash\\n        else {\\n            $regex .= '/?';\\n        }\\n\\n        // Attempt to match route and named parameters\\n        if (preg_match('#^'.$regex.'(?:\\\\?.*)?$#'.(($case_sensitive) ? '' : 'i'), $url, $matches)) {\\n            foreach ($ids as $k => $v) {\\n                $this->params[$k] = (array_key_exists($k, $matches)) ? urldecode($matches[$k]) : null;\\n            }\\n\\n            $this->regex = $regex;\\n\\n            return true;\\n        }\\n\\n        return false;\\n    }\", \"output\": \"Checks if a URL matches the route pattern. Also parses named parameters in the URL.\\n\\n@param string $url Requested URL\\n@param boolean $case_sensitive Case sensitive matching\\n@return boolean Match status\"}"}
{"text": "{\"input\": \"Summarize the following code: public function run($name, array $params = array()) {\\n        $output = '';\\n\\n        // Run pre-filters\\n        if (!empty($this->filters[$name]['before'])) {\\n            $this->filter($this->filters[$name]['before'], $params, $output);\\n        }\\n\\n        // Run requested method\\n        $output = $this->execute($this->get($name), $params);\\n\\n        // Run post-filters\\n        if (!empty($this->filters[$name]['after'])) {\\n            $this->filter($this->filters[$name]['after'], $params, $output);\\n        }\\n\\n        return $output;\\n    }\", \"output\": \"Dispatches an event.\\n\\n@param string $name Event name\\n@param array $params Callback parameters\\n@return string Output of callback\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public function get($name) {\\n        return isset($this->events[$name]) ? $this->events[$name] : null;\\n    }\", \"output\": \"Gets an assigned callback.\\n\\n@param string $name Event name\\n@return callback $callback Callback function\"}"}
{"text": "{\"input\": \"Summarize the following code: public function clear($name = null) {\\n        if ($name !== null) {\\n            unset($this->events[$name]);\\n            unset($this->filters[$name]);\\n        }\\n        else {\\n            $this->events = array();\\n            $this->filters = array();\\n        }\\n    }\", \"output\": \"Clears an event. If no name is given,\\nall events are removed.\\n\\n@param string $name Event name\"}"}
{"text": "{\"input\": \"Summarize the following code: public function filter($filters, &$params, &$output) {\\n        $args = array(&$params, &$output);\\n        foreach ($filters as $callback) {\\n            $continue = $this->execute($callback, $args);\\n            if ($continue === false) break;\\n        }\\n    }\", \"output\": \"Executes a chain of method filters.\\n\\n@param array $filters Chain of filters\\n@param array $params Method parameters\\n@param mixed $output Method output\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function execute($callback, array &$params = array()) {\\n        if (is_callable($callback)) {\\n            return is_array($callback) ?\\n                self::invokeMethod($callback, $params) :\\n                self::callFunction($callback, $params);\\n        }\\n        else {\\n            throw new \\\\Exception('Invalid callback specified.');\\n        }\\n    }\", \"output\": \"Executes a callback function.\\n\\n@param callback $callback Callback function\\n@param array $params Function parameters\\n@return mixed Function results\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function callFunction($func, array &$params = array()) {\\n        // Call static method\\n        if (is_string($func) && strpos($func, '::') !== false) {\\n            return call_user_func_array($func, $params);\\n        }\\n\\n        switch (count($params)) {\\n            case 0:\\n                return $func();\\n            case 1:\\n                return $func($params[0]);\\n            case 2:\\n                return $func($params[0], $params[1]);\\n            case 3:\\n                return $func($params[0], $params[1], $params[2]);\\n            case 4:\\n                return $func($params[0], $params[1], $params[2], $params[3]);\\n            case 5:\\n                return $func($params[0], $params[1], $params[2], $params[3], $params[4]);\\n            default:\\n                return call_user_func_array($func, $params);\\n        }\\n    }\", \"output\": \"Calls a function.\\n\\n@param string $func Name of function to call\\n@param array $params Function parameters\\n@return mixed Function results\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function invokeMethod($func, array &$params = array()) {\\n        list($class, $method) = $func;\\n\\n        $instance = is_object($class);\\n\\t\\t\\n        switch (count($params)) {\\n            case 0:\\n                return ($instance) ?\\n                    $class->$method() :\\n                    $class::$method();\\n            case 1:\\n                return ($instance) ?\\n                    $class->$method($params[0]) :\\n                    $class::$method($params[0]);\\n            case 2:\\n                return ($instance) ?\\n                    $class->$method($params[0], $params[1]) :\\n                    $class::$method($params[0], $params[1]);\\n            case 3:\\n                return ($instance) ?\\n                    $class->$method($params[0], $params[1], $params[2]) :\\n                    $class::$method($params[0], $params[1], $params[2]);\\n            case 4:\\n                return ($instance) ?\\n                    $class->$method($params[0], $params[1], $params[2], $params[3]) :\\n                    $class::$method($params[0], $params[1], $params[2], $params[3]);\\n            case 5:\\n                return ($instance) ?\\n                    $class->$method($params[0], $params[1], $params[2], $params[3], $params[4]) :\\n                    $class::$method($params[0], $params[1], $params[2], $params[3], $params[4]);\\n            default:\\n                return call_user_func_array($func, $params);\\n        }\\n    }\", \"output\": \"Invokes a method.\\n\\n@param mixed $func Class method\\n@param array $params Class method parameters\\n@return mixed Function results\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function getBody() {\\n        static $body;\\n\\n        if (!is_null($body)) {\\n            return $body;\\n        }\\n\\n        $method = self::getMethod();\\n\\n        if ($method == 'POST' || $method == 'PUT' || $method == 'PATCH') {\\n            $body = file_get_contents('php://input');\\n        }\\n\\n        return $body;\\n    }\", \"output\": \"Gets the body of the request.\\n\\n@return string Raw HTTP request body\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function getMethod() {\\n        $method = self::getVar('REQUEST_METHOD', 'GET');\\n\\n        if (isset($_SERVER['HTTP_X_HTTP_METHOD_OVERRIDE'])) {\\n            $method = $_SERVER['HTTP_X_HTTP_METHOD_OVERRIDE'];\\n        }\\n        elseif (isset($_REQUEST['_method'])) {\\n            $method = $_REQUEST['_method'];\\n        }\\n\\n        return strtoupper($method);\\n    }\", \"output\": \"Gets the request method.\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function getProxyIpAddress() {\\n        static $forwarded = array(\\n            'HTTP_CLIENT_IP',\\n            'HTTP_X_FORWARDED_FOR',\\n            'HTTP_X_FORWARDED',\\n            'HTTP_X_CLUSTER_CLIENT_IP',\\n            'HTTP_FORWARDED_FOR',\\n            'HTTP_FORWARDED'\\n        );\\n\\n        $flags = \\\\FILTER_FLAG_NO_PRIV_RANGE | \\\\FILTER_FLAG_NO_RES_RANGE;\\n\\n        foreach ($forwarded as $key) {\\n            if (array_key_exists($key, $_SERVER)) {\\n                sscanf($_SERVER[$key], '%[^,]', $ip);\\n                if (filter_var($ip, \\\\FILTER_VALIDATE_IP, $flags) !== false) {\\n                    return $ip;\\n                }\\n            }\\n        }\\n\\n        return '';\\n    }\", \"output\": \"Gets the real remote IP address.\\n\\n@return string IP address\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function parseQuery($url) {\\n        $params = array();\\n\\n        $args = parse_url($url);\\n        if (isset($args['query'])) {\\n            parse_str($args['query'], $params);\\n        }\\n\\n        return $params;\\n    }\", \"output\": \"Parse query parameters from a URL.\\n\\n@param string $url URL string\\n@return array Query parameters\"}"}
{"text": "{\"input\": \"Summarize the following code: public function status($code = null) {\\n        if ($code === null) {\\n            return $this->status;\\n        }\\n\\n        if (array_key_exists($code, self::$codes)) {\\n            $this->status = $code;\\n        }\\n        else {\\n            throw new \\\\Exception('Invalid status code.');\\n        }\\n\\n        return $this;\\n    }\", \"output\": \"Sets the HTTP status of the response.\\n\\n@param int $code HTTP status code.\\n@return object|int Self reference\\n@throws \\\\Exception If invalid status code\"}"}
{"text": "{\"input\": \"Summarize the following code: public function header($name, $value = null) {\\n        if (is_array($name)) {\\n            foreach ($name as $k => $v) {\\n                $this->headers[$k] = $v;\\n            }\\n        }\\n        else {\\n            $this->headers[$name] = $value;\\n        }\\n\\n        return $this;\\n    }\", \"output\": \"Adds a header to the response.\\n\\n@param string|array $name Header name or array of names and values\\n@param string $value Header value\\n@return object Self reference\"}"}
{"text": "{\"input\": \"Summarize the following code: public function cache($expires) {\\n        if ($expires === false) {\\n            $this->headers['Expires'] = 'Mon, 26 Jul 1997 05:00:00 GMT';\\n            $this->headers['Cache-Control'] = array(\\n                'no-store, no-cache, must-revalidate',\\n                'post-check=0, pre-check=0',\\n                'max-age=0'\\n            );\\n            $this->headers['Pragma'] = 'no-cache';\\n        }\\n        else {\\n            $expires = is_int($expires) ? $expires : strtotime($expires);\\n            $this->headers['Expires'] = gmdate('D, d M Y H:i:s', $expires) . ' GMT';\\n            $this->headers['Cache-Control'] = 'max-age='.($expires - time());\\n            if (isset($this->headers['Pragma']) && $this->headers['Pragma'] == 'no-cache'){\\n                unset($this->headers['Pragma']);\\n            }\\n        }\\n        return $this;\\n    }\", \"output\": \"Sets caching headers for the response.\\n\\n@param int|string $expires Expiration time\\n@return object Self reference\"}"}
{"text": "{\"input\": \"Summarize the following code: public function send() {\\n        if (ob_get_length() > 0) {\\n            ob_end_clean();\\n        }\\n\\n        if (!headers_sent()) {\\n            $this->sendHeaders();\\n        }\\n\\n        echo $this->body;\\n\\n        $this->sent = true;\\n    }\", \"output\": \"Sends a HTTP response.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function init() {\\n        static $initialized = false;\\n        $self = $this;\\n\\n        if ($initialized) {\\n            $this->vars = array();\\n            $this->loader->reset();\\n            $this->dispatcher->reset();\\n        }\\n\\n        // Register default components\\n        $this->loader->register('request', '\\\\flight\\\\net\\\\Request');\\n        $this->loader->register('response', '\\\\flight\\\\net\\\\Response');\\n        $this->loader->register('router', '\\\\flight\\\\net\\\\Router');\\n        $this->loader->register('view', '\\\\flight\\\\template\\\\View', array(), function($view) use ($self) {\\n            $view->path = $self->get('flight.views.path');\\n            $view->extension = $self->get('flight.views.extension');\\n        });\\n\\n        // Register framework methods\\n        $methods = array(\\n            'start','stop','route','halt','error','notFound',\\n            'render','redirect','etag','lastModified','json','jsonp'\\n        );\\n        foreach ($methods as $name) {\\n            $this->dispatcher->set($name, array($this, '_'.$name));\\n        }\\n\\n        // Default configuration settings\\n        $this->set('flight.base_url', null);\\n        $this->set('flight.case_sensitive', false);\\n        $this->set('flight.handle_errors', true);\\n        $this->set('flight.log_errors', false);\\n        $this->set('flight.views.path', './views');\\n        $this->set('flight.views.extension', '.php');\\n\\n        // Startup configuration\\n        $this->before('start', function() use ($self) {\\n            // Enable error handling\\n            if ($self->get('flight.handle_errors')) {\\n                set_error_handler(array($self, 'handleError'));\\n                set_exception_handler(array($self, 'handleException'));\\n            }\\n\\n            // Set case-sensitivity\\n            $self->router()->case_sensitive = $self->get('flight.case_sensitive');\\n        });\\n\\n        $initialized = true;\\n    }\", \"output\": \"Initializes the framework.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function handleError($errno, $errstr, $errfile, $errline) {\\n        if ($errno & error_reporting()) {\\n            throw new \\\\ErrorException($errstr, $errno, 0, $errfile, $errline);\\n        }\\n    }\", \"output\": \"Custom error handler. Converts errors into exceptions.\\n\\n@param int $errno Error number\\n@param int $errstr Error string\\n@param int $errfile Error file name\\n@param int $errline Error file line number\\n@throws \\\\ErrorException\"}"}
{"text": "{\"input\": \"Summarize the following code: public function handleException($e) {\\n        if ($this->get('flight.log_errors')) {\\n            error_log($e->getMessage());\\n        }\\n\\n        $this->error($e);\\n    }\", \"output\": \"Custom exception handler. Logs exceptions.\\n\\n@param \\\\Exception $e Thrown exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public function map($name, $callback) {\\n        if (method_exists($this, $name)) {\\n            throw new \\\\Exception('Cannot override an existing framework method.');\\n        }\\n\\n        $this->dispatcher->set($name, $callback);\\n    }\", \"output\": \"Maps a callback to a framework method.\\n\\n@param string $name Method name\\n@param callback $callback Callback function\\n@throws \\\\Exception If trying to map over a framework method\"}"}
{"text": "{\"input\": \"Summarize the following code: public function register($name, $class, array $params = array(), $callback = null) {\\n        if (method_exists($this, $name)) {\\n            throw new \\\\Exception('Cannot override an existing framework method.');\\n        }\\n\\n        $this->loader->register($name, $class, $params, $callback);\\n    }\", \"output\": \"Registers a class to a framework method.\\n\\n@param string $name Method name\\n@param string $class Class name\\n@param array $params Class initialization parameters\\n@param callback $callback Function to call after object instantiation\\n@throws \\\\Exception If trying to map over a framework method\"}"}
{"text": "{\"input\": \"Summarize the following code: public function get($key = null) {\\n        if ($key === null) return $this->vars;\\n\\n        return isset($this->vars[$key]) ? $this->vars[$key] : null;\\n    }\", \"output\": \"Gets a variable.\\n\\n@param string $key Key\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public function clear($key = null) {\\n        if (is_null($key)) {\\n            $this->vars = array();\\n        }\\n        else {\\n            unset($this->vars[$key]);\\n        }\\n    }\", \"output\": \"Unsets a variable. If no key is passed in, clear all variables.\\n\\n@param string $key Key\"}"}
{"text": "{\"input\": \"Summarize the following code: public function _start() {\\n        $dispatched = false;\\n        $self = $this;\\n        $request = $this->request();\\n        $response = $this->response();\\n        $router = $this->router();\\n\\n        // Allow filters to run\\n        $this->after('start', function() use ($self) {\\n            $self->stop();\\n        });\\n\\n        // Flush any existing output\\n        if (ob_get_length() > 0) {\\n            $response->write(ob_get_clean());\\n        }\\n\\n        // Enable output buffering\\n        ob_start();\\n\\n        // Route the request\\n        while ($route = $router->route($request)) {\\n            $params = array_values($route->params);\\n\\n            // Add route info to the parameter list\\n            if ($route->pass) {\\n                $params[] = $route;\\n            }\\n\\n            // Call route handler\\n            $continue = $this->dispatcher->execute(\\n                $route->callback,\\n                $params\\n            );\\n\\n            $dispatched = true;\\n\\n            if (!$continue) break;\\n\\n            $router->next();\\n\\n            $dispatched = false;\\n        }\\n\\n        if (!$dispatched) {\\n            $this->notFound();\\n        }\\n    }\", \"output\": \"Starts the framework.\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public function _stop($code = null) {\\n        $response = $this->response();\\n\\n        if (!$response->sent()) {\\n            if ($code !== null) {\\n                $response->status($code);\\n            }\\n\\n            $response->write(ob_get_clean());\\n\\n            $response->send();\\n        }\\n    }\", \"output\": \"Stops the framework and outputs the current response.\\n\\n@param int $code HTTP status code\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public function _route($pattern, $callback, $pass_route = false) {\\n        $this->router()->map($pattern, $callback, $pass_route);\\n    }\", \"output\": \"Routes a URL to a callback function.\\n\\n@param string $pattern URL pattern to match\\n@param callback $callback Callback function\\n@param boolean $pass_route Pass the matching route object to the callback\"}"}
{"text": "{\"input\": \"Summarize the following code: public function _halt($code = 200, $message = '') {\\n        $this->response()\\n            ->clear()\\n            ->status($code)\\n            ->write($message)\\n            ->send();\\n        exit();\\n    }\", \"output\": \"Stops processing and returns a given response.\\n\\n@param int $code HTTP status code\\n@param string $message Response message\"}"}
{"text": "{\"input\": \"Summarize the following code: public function _redirect($url, $code = 303) {\\n        $base = $this->get('flight.base_url');\\n\\n        if ($base === null) {\\n            $base = $this->request()->base;\\n        }\\n\\n        // Append base url to redirect url\\n        if ($base != '/' && strpos($url, '://') === false) {\\n            $url = $base . preg_replace('#/+#', '/', '/' . $url);\\n        }\\n\\n        $this->response()\\n            ->clear()\\n            ->status($code)\\n            ->header('Location', $url)\\n            ->send();\\n    }\", \"output\": \"Redirects the current request to another URL.\\n\\n@param string $url URL\\n@param int $code HTTP status code\"}"}
{"text": "{\"input\": \"Summarize the following code: public function _json(\\n        $data,\\n        $code = 200,\\n        $encode = true,\\n        $charset = 'utf-8',\\n        $option = 0\\n    ) {\\n        $json = ($encode) ? json_encode($data, $option) : $data;\\n\\n        $this->response()\\n            ->status($code)\\n            ->header('Content-Type', 'application/json; charset='.$charset)\\n            ->write($json)\\n            ->send();\\n    }\", \"output\": \"Sends a JSON response.\\n\\n@param mixed $data JSON data\\n@param int $code HTTP status code\\n@param bool $encode Whether to perform JSON encoding\\n@param string $charset Charset\\n@param int $option Bitmask Json constant such as JSON_HEX_QUOT\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public function _jsonp(\\n        $data,\\n        $param = 'jsonp',\\n        $code = 200,\\n        $encode = true,\\n        $charset = 'utf-8',\\n        $option = 0\\n    ) {\\n        $json = ($encode) ? json_encode($data, $option) : $data;\\n\\n        $callback = $this->request()->query[$param];\\n\\n        $this->response()\\n            ->status($code)\\n            ->header('Content-Type', 'application/javascript; charset='.$charset)\\n            ->write($callback.'('.$json.');')\\n            ->send();\\n    }\", \"output\": \"Sends a JSONP response.\\n\\n@param mixed $data JSON data\\n@param string $param Query parameter that specifies the callback name.\\n@param int $code HTTP status code\\n@param bool $encode Whether to perform JSON encoding\\n@param string $charset Charset\\n@param int $option Bitmask Json constant such as JSON_HEX_QUOT\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public function _etag($id, $type = 'strong') {\\n        $id = (($type === 'weak') ? 'W/' : '').$id;\\n\\n        $this->response()->header('ETag', $id);\\n\\n        if (isset($_SERVER['HTTP_IF_NONE_MATCH']) &&\\n            $_SERVER['HTTP_IF_NONE_MATCH'] === $id) {\\n            $this->halt(304);\\n        }\\n    }\", \"output\": \"Handles ETag HTTP caching.\\n\\n@param string $id ETag identifier\\n@param string $type ETag type\"}"}
{"text": "{\"input\": \"Summarize the following code: public function _lastModified($time) {\\n        $this->response()->header('Last-Modified', gmdate('D, d M Y H:i:s \\\\G\\\\M\\\\T', $time));\\n\\n        if (isset($_SERVER['HTTP_IF_MODIFIED_SINCE']) &&\\n            strtotime($_SERVER['HTTP_IF_MODIFIED_SINCE']) === $time) {\\n            $this->halt(304);\\n        }\\n    }\", \"output\": \"Handles last modified HTTP caching.\\n\\n@param int $time Unix timestamp\"}"}
{"text": "{\"input\": \"Summarize the following code: public function register($name, $class, array $params = array(), $callback = null) {\\n        unset($this->instances[$name]);\\n\\n        $this->classes[$name] = array($class, $params, $callback);\\n    }\", \"output\": \"Registers a class.\\n\\n@param string $name Registry name\\n@param string|callable $class Class name or function to instantiate class\\n@param array $params Class initialization parameters\\n@param callback $callback Function to call after object instantiation\"}"}
{"text": "{\"input\": \"Summarize the following code: public function load($name, $shared = true) {\\n        $obj = null;\\n\\n        if (isset($this->classes[$name])) {\\n            list($class, $params, $callback) = $this->classes[$name];\\n\\n            $exists = isset($this->instances[$name]);\\n\\n            if ($shared) {\\n                $obj = ($exists) ?\\n                    $this->getInstance($name) :\\n                    $this->newInstance($class, $params);\\n                \\n                if (!$exists) {\\n                    $this->instances[$name] = $obj;\\n                }\\n            }\\n            else {\\n                $obj = $this->newInstance($class, $params);\\n            }\\n\\n            if ($callback && (!$shared || !$exists)) {\\n                $ref = array(&$obj);\\n                call_user_func_array($callback, $ref);\\n            }\\n        }\\n\\n        return $obj;\\n    }\", \"output\": \"Loads a registered class.\\n\\n@param string $name Method name\\n@param bool $shared Shared instance\\n@return object Class instance\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getInstance($name) {\\n        return isset($this->instances[$name]) ? $this->instances[$name] : null;\\n    }\", \"output\": \"Gets a single instance of a class.\\n\\n@param string $name Instance name\\n@return object Class instance\"}"}
{"text": "{\"input\": \"Summarize the following code: public function newInstance($class, array $params = array()) {\\n        if (is_callable($class)) {\\n            return call_user_func_array($class, $params);\\n        }\\n\\n        switch (count($params)) {\\n            case 0:\\n                return new $class();\\n            case 1:\\n                return new $class($params[0]);\\n            case 2:\\n                return new $class($params[0], $params[1]);\\n            case 3:\\n                return new $class($params[0], $params[1], $params[2]);\\n            case 4:\\n                return new $class($params[0], $params[1], $params[2], $params[3]);\\n            case 5:\\n                return new $class($params[0], $params[1], $params[2], $params[3], $params[4]);\\n            default:\\n                try {\\n                    $refClass = new \\\\ReflectionClass($class);\\n                    return $refClass->newInstanceArgs($params);\\n                } catch (\\\\ReflectionException $e) {\\n                    throw new \\\\Exception(\\\"Cannot instantiate {$class}\\\", 0, $e);\\n                }\\n        }\\n    }\", \"output\": \"Gets a new instance of a class.\\n\\n@param string|callable $class Class name or callback function to instantiate class\\n@param array $params Class initialization parameters\\n@return object Class instance\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function loadClass($class) {\\n        $class_file = str_replace(array('\\\\\\\\', '_'), '/', $class).'.php';\\n\\n        foreach (self::$dirs as $dir) {\\n            $file = $dir.'/'.$class_file;\\n            if (file_exists($file)) {\\n                require $file;\\n                return;\\n            }\\n        }\\n    }\", \"output\": \"Autoloads classes.\\n\\n@param string $class Class name\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function addDirectory($dir) {\\n        if (is_array($dir) || is_object($dir)) {\\n            foreach ($dir as $value) {\\n                self::addDirectory($value);\\n            }\\n        }\\n        else if (is_string($dir)) {\\n            if (!in_array($dir, self::$dirs)) self::$dirs[] = $dir;\\n        }\\n    }\", \"output\": \"Adds a directory for autoloading classes.\\n\\n@param mixed $dir Directory path\"}"}
{"text": "{\"input\": \"Summarize the following code: public function fetch($file, $data = null) {\\n        ob_start();\\n\\n        $this->render($file, $data);\\n        $output = ob_get_clean();\\n\\n        return $output;\\n    }\", \"output\": \"Gets the output of a template.\\n\\n@param string $file Template file\\n@param array $data Template data\\n@return string Output of template\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getTemplate($file) {\\n        $ext = $this->extension;\\n\\n        if (!empty($ext) && (substr($file, -1 * strlen($ext)) != $ext)) {\\n            $file .= $ext;\\n        }\\n\\n        if ((substr($file, 0, 1) == '/')) {\\n            return $file;\\n        }\\n        \\n        return $this->path.'/'.$file;\\n    }\", \"output\": \"Gets the full path to a template file.\\n\\n@param string $file Template file\\n@return string Template file location\"}"}
{"text": "{\"input\": \"Summarize the following code: public function isCyclic(Graph $graph)\\n    {\\n        // prepare stack\\n        $recursionStack = [];\\n        foreach ($graph->all() as $node) {\\n            $recursionStack[$node->getKey()] = false;\\n        }\\n\\n        // start analysis\\n        $isCyclic = false;\\n        foreach ($graph->getEdges() as $edge) {\\n            if ($r = $this->detectCycle($edge->getFrom(), $recursionStack)) {\\n                $edge->cyclic = true;\\n                $isCyclic = true;\\n            }\\n\\n            $recursionStack[$node->getKey()] = false;\\n        }\\n\\n        $graph->resetVisits();\\n\\n        return $isCyclic;\\n    }\", \"output\": \"Check if graph contains cycle\\n\\nEach node in cycle is flagged with the \\\"cyclic\\\" attribute\\n\\n@param Graph $graph\\n@return bool\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getAverageHeightOfGraph()\\n    {\\n        $ns = [];\\n        foreach ($this->graph->getRootNodes() as $node) {\\n            array_push($ns, $this->getLongestBranch($node));\\n        }\\n        return round(array_sum($ns) / max(1, sizeof($ns)), 2);\\n    }\", \"output\": \"Get average height of graph\\n\\n@return float\"}"}
{"text": "{\"input\": \"Summarize the following code: private function collapseArray(array $arr)\\n    {\\n        $iterator = new RecursiveIteratorIterator(new RecursiveArrayIterator($arr));\\n        $result = [];\\n        foreach ($iterator as $leafValue) {\\n            $keys = [];\\n            foreach (range(0, $iterator->getDepth()) as $depth) {\\n                $keys[] = $iterator->getSubIterator($depth)->key();\\n            }\\n            $result[join('-', $keys)] = $leafValue;\\n        }\\n\\n        return $result;\\n    }\", \"output\": \"Collapses array into a one-dimensional one by imploding nested keys with '-'\\n\\n@param array $arr\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: public function fetch(array $paths)\\n    {\\n        $files = array();\\n        foreach ($paths as $path) {\\n            if (is_dir($path)) {\\n                $path = rtrim($path, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR;\\n                $directory = new RecursiveDirectoryIterator($path, $this->flags);\\n                $iterator = new RecursiveIteratorIterator($directory);\\n\\n                $filterRegex = sprintf(\\n                    '`^%s%s%s$`',\\n                    preg_quote($path, '`'),\\n                    !empty($this->excludedDirs) ? '((?!' . implode('|', array_map('preg_quote', $this->excludedDirs)) . ').)+' : '.+',\\n                    '\\\\.(' . implode('|', $this->extensions) . ')'\\n                );\\n\\n                $filteredIterator = new RegexIterator(\\n                    $iterator,\\n                    $filterRegex,\\n                    \\\\RecursiveRegexIterator::GET_MATCH\\n                );\\n\\n                foreach ($filteredIterator as $file) {\\n                    $files[] = $file[0];\\n                }\\n            } elseif (is_file($path)) {\\n                $files[] = $path;\\n            }\\n        }\\n        return $files;\\n    }\", \"output\": \"Find files in path\\n\\n@param array $paths\\n@return array\\n@internal param string $path\"}"}
{"text": "{\"input\": \"Summarize the following code: private function traverse(TreeNode $node)\\n    {\\n        if ($node->visited) {\\n            return 0;\\n        }\\n        $node->visited = true;\\n\\n        foreach ($node->getAdjacents() as $adjacent) {\\n            $this->traverse($adjacent);\\n        }\\n\\n        return 1;\\n    }\", \"output\": \"Traverse node, and return 1 if node has not been visited yet\\n\\n@param TreeNode $node\\n@return int\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getRootNodes()\\n    {\\n        $roots = [];\\n        foreach ($this->all() as $node) {\\n\\n            $isRoot = true;\\n\\n            foreach ($node->getEdges() as $edge) {\\n                if ($edge->getTo() == $node) {\\n                    $isRoot = false;\\n                }\\n            }\\n\\n\\n            if ($isRoot) {\\n                array_push($roots, $node);\\n            }\\n        }\\n\\n        return $roots;\\n    }\", \"output\": \"Get the list of all root nodes\\n\\nwe can have array of roots : graph can be a \\\"forest\\\"\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function getComposerLockInstalled($rootPackageRequirements)\\n    {\\n        $rawInstalled = [[]];\\n\\n        // Find composer.lock file\\n        $finder = new Finder(['lock'], $this->config->get('exclude'));\\n        $files = $finder->fetch($this->config->get('files'));\\n\\n        // List all composer.lock found in the project.\\n        foreach ($files as $filename) {\\n            if (false === \\\\strpos($filename, 'composer.lock')) {\\n                continue;\\n            }\\n            $composerLockJson = (object)\\\\json_decode(\\\\file_get_contents($filename));\\n\\n            if (!isset($composerLockJson->packages)) {\\n                continue;\\n            }\\n\\n            $installed = [];\\n            foreach ($composerLockJson->packages as $package) {\\n                if (!\\\\in_array($package->name, $rootPackageRequirements, true)) {\\n                    continue;\\n                }\\n\\n                $installed[$package->name] = \\\\preg_replace('#[^.\\\\d]#', '', $package->version);\\n            }\\n\\n            $rawInstalled[] = $installed;\\n        }\\n\\n        return \\\\call_user_func_array('array_merge', $rawInstalled);\\n    }\", \"output\": \"Returns the installed packages from the composer.lock file.\\n@param array $rootPackageRequirements List of requirements to match installed packages only with requirements.\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: public function advance()\\n    {\\n        $this->current++;\\n\\n        if ($this->hasAnsi()) {\\n            $percent = round($this->current / $this->max * 100);\\n            $this->output->write(\\\"\\\\x0D\\\");\\n            $this->output->write(\\\"\\\\x1B[2K\\\");\\n            $this->output->write(sprintf('... %s%% ...', $percent));\\n        } else {\\n            $this->output->write('.');\\n        }\\n    }\", \"output\": \"Advance progress bar\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function hasAnsi()\\n    {\\n        if (DIRECTORY_SEPARATOR === '\\\\\\\\') {\\n            return\\n                0 >= version_compare('10.0.10586',\\n                    PHP_WINDOWS_VERSION_MAJOR . '.' . PHP_WINDOWS_VERSION_MINOR . '.' . PHP_WINDOWS_VERSION_BUILD)\\n                || false !== getenv('ANSICON')\\n                || 'ON' === getenv('ConEmuANSI')\\n                || 'xterm' === getenv('TERM');\\n        }\\n\\n        return function_exists('posix_isatty') && @posix_isatty($this->stream);\\n    }\", \"output\": \"Detects ANSI support\\n\\n@return bool\"}"}
{"text": "{\"input\": \"Summarize the following code: public function process_no_parameters( $stackPtr, $group_name, $matched_content ) {\\n\\n\\t\\t$target_param = $this->target_functions[ $matched_content ];\\n\\n\\t\\tif ( 1 !== $target_param ) {\\n\\t\\t\\t// Only process the no param case as fixable if the text domain is expected to be the first parameter.\\n\\t\\t\\t$this->phpcsFile->addWarning( 'Missing $domain arg and preceding argument(s)', $stackPtr, 'MissingArgs' );\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t$opener = $this->phpcsFile->findNext( Tokens::$emptyTokens, ( $stackPtr + 1 ), null, true );\\n\\t\\tif ( \\\\T_OPEN_PARENTHESIS !== $this->tokens[ $opener ]['code']\\n\\t\\t\\t|| isset( $this->tokens[ $opener ]['parenthesis_closer'] ) === false\\n\\t\\t) {\\n\\t\\t\\t// Parse error or live coding.\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t$fix = $this->phpcsFile->addFixableError( 'Missing $domain arg', $stackPtr, 'MissingArgDomain' );\\n\\t\\tif ( true === $fix ) {\\n\\t\\t\\t$closer      = $this->tokens[ $opener ]['parenthesis_closer'];\\n\\t\\t\\t$replacement = \\\" '{$this->new_text_domain}' \\\";\\n\\n\\t\\t\\tif ( $this->tokens[ $opener ]['line'] !== $this->tokens[ $closer ]['line'] ) {\\n\\t\\t\\t\\t$replacement = trim( $replacement );\\n\\t\\t\\t\\t$addBefore   = ( $closer - 1 );\\n\\t\\t\\t\\tif ( \\\\T_WHITESPACE === $this->tokens[ ( $closer - 1 ) ]['code']\\n\\t\\t\\t\\t\\t&& $this->tokens[ $closer - 1 ]['line'] === $this->tokens[ $closer ]['line']\\n\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\tif ( isset( $this->tokens[ ( $closer - 1 ) ]['orig_content'] ) ) {\\n\\t\\t\\t\\t\\t\\t$replacement = $this->tokens[ ( $closer - 1 ) ]['orig_content']\\n\\t\\t\\t\\t\\t\\t\\t. \\\"\\\\t\\\"\\n\\t\\t\\t\\t\\t\\t\\t. $replacement;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t$replacement = $this->tokens[ ( $closer - 1 ) ]['content']\\n\\t\\t\\t\\t\\t\\t\\t. str_repeat( ' ', $this->tab_width )\\n\\t\\t\\t\\t\\t\\t\\t. $replacement;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t--$addBefore;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// We don't know whether the code uses tabs or spaces, so presume WPCS, i.e. tabs.\\n\\t\\t\\t\\t\\t$replacement = \\\"\\\\t\\\" . $replacement;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t$replacement = $this->phpcsFile->eolChar . $replacement;\\n\\n\\t\\t\\t\\t$this->phpcsFile->fixer->addContentBefore( $addBefore, $replacement );\\n\\n\\t\\t\\t} elseif ( \\\\T_WHITESPACE === $this->tokens[ ( $closer - 1 ) ]['code'] ) {\\n\\t\\t\\t\\t$this->phpcsFile->fixer->replaceToken( ( $closer - 1 ), $replacement );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t$this->phpcsFile->fixer->addContentBefore( $closer, $replacement );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\", \"output\": \"Process the function if no parameters were found.\\n\\n@since 1.2.0\\n\\n@param int    $stackPtr        The position of the current token in the stack.\\n@param array  $group_name      The name of the group which was matched.\\n@param string $matched_content The token content (function name) which was matched.\\n\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: public function process( File $phpcsFile, $stackPtr ) {\\n\\t\\t$this->init( $phpcsFile );\\n\\t\\treturn $this->process_token( $stackPtr );\\n\\t}\", \"output\": \"Set sniff properties and hand off to child class for processing of the token.\\n\\n@since 0.11.0\\n\\n@param \\\\PHP_CodeSniffer\\\\Files\\\\File $phpcsFile The file being scanned.\\n@param int                         $stackPtr  The position of the current token\\nin the stack passed in $tokens.\\n\\n@return int|void Integer stack pointer to skip forward or void to continue\\nnormal file processing.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function init( File $phpcsFile ) {\\n\\t\\t$this->phpcsFile = $phpcsFile;\\n\\t\\t$this->tokens    = $phpcsFile->getTokens();\\n\\t}\", \"output\": \"Initialize the class for the current process.\\n\\nThis method must be called by child classes before using many of the methods\\nbelow.\\n\\n@since 0.4.0\\n\\n@param \\\\PHP_CodeSniffer\\\\Files\\\\File $phpcsFile The file currently being processed.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function addFixableMessage( $message, $stackPtr, $is_error = true, $code = 'Found', $data = array(), $severity = 0 ) {\\n\\t\\treturn $this->throwMessage( $message, $stackPtr, $is_error, $code, $data, $severity, true );\\n\\t}\", \"output\": \"Add a fixable PHPCS message to the output stack as either a warning or an error.\\n\\n@since 0.11.0\\n\\n@param string $message   The message.\\n@param int    $stackPtr  The position of the token the message relates to.\\n@param bool   $is_error  Optional. Whether to report the message as an 'error' or 'warning'.\\nDefaults to true (error).\\n@param string $code      Optional error code for the message. Defaults to 'Found'.\\n@param array  $data      Optional input for the data replacements.\\n@param int    $severity  Optional. Severity level. Defaults to 0 which will translate to\\nthe PHPCS default severity level.\\n@return bool\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function merge_custom_array( $custom, $base = array(), $flip = true ) {\\n\\t\\tif ( true === $flip ) {\\n\\t\\t\\t$base = array_filter( $base );\\n\\t\\t}\\n\\n\\t\\tif ( empty( $custom ) || ! \\\\is_array( $custom ) ) {\\n\\t\\t\\treturn $base;\\n\\t\\t}\\n\\n\\t\\tif ( true === $flip ) {\\n\\t\\t\\t$custom = array_fill_keys( $custom, false );\\n\\t\\t}\\n\\n\\t\\tif ( empty( $base ) ) {\\n\\t\\t\\treturn $custom;\\n\\t\\t}\\n\\n\\t\\treturn array_merge( $base, $custom );\\n\\t}\", \"output\": \"Merge a pre-set array with a ruleset provided array.\\n\\n- By default flips custom lists to allow for using `isset()` instead\\nof `in_array()`.\\n- When `$flip` is true:\\n* Presumes the base array is in a `'value' => true` format.\\n* Any custom items will be given the value `false` to be able to\\ndistinguish them from pre-set (base array) values.\\n* Will filter previously added custom items out from the base array\\nbefore merging/returning to allow for resetting to the base array.\\n\\n{@internal Function is static as it doesn't use any of the properties or others\\nmethods anyway and this way the `WordPress.NamingConventions.ValidVariableName` sniff\\nwhich extends an upstream sniff can also use it.}}\\n\\n@since 0.11.0\\n@since 2.0.0  No longer supports custom array properties which were incorrectly\\npassed as a string.\\n\\n@param array $custom Custom list as provided via a ruleset.\\n@param array $base   Optional. Base list. Defaults to an empty array.\\nExpects `value => true` format when `$flip` is true.\\n@param bool  $flip   Optional. Whether or not to flip the custom list.\\nDefaults to true.\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function get_last_ptr_on_line( $stackPtr ) {\\n\\n\\t\\t$tokens      = $this->tokens;\\n\\t\\t$currentLine = $tokens[ $stackPtr ]['line'];\\n\\t\\t$nextPtr     = ( $stackPtr + 1 );\\n\\n\\t\\twhile ( isset( $tokens[ $nextPtr ] ) && $tokens[ $nextPtr ]['line'] === $currentLine ) {\\n\\t\\t\\t$nextPtr++;\\n\\t\\t\\t// Do nothing, we just want the last token of the line.\\n\\t\\t}\\n\\n\\t\\t// We've made it to the next line, back up one to the last in the previous line.\\n\\t\\t// We do this for micro-optimization of the above loop.\\n\\t\\t$lastPtr = ( $nextPtr - 1 );\\n\\n\\t\\treturn $lastPtr;\\n\\t}\", \"output\": \"Get the last pointer in a line.\\n\\n@since 0.4.0\\n\\n@param integer $stackPtr The position of the current token in the stack passed\\nin $tokens.\\n\\n@return integer Position of the last pointer on that line.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function is_assignment( $stackPtr ) {\\n\\n\\t\\tstatic $valid = array(\\n\\t\\t\\t\\\\T_VARIABLE             => true,\\n\\t\\t\\t\\\\T_CLOSE_SQUARE_BRACKET => true,\\n\\t\\t);\\n\\n\\t\\t// Must be a variable, constant or closing square bracket (see below).\\n\\t\\tif ( ! isset( $valid[ $this->tokens[ $stackPtr ]['code'] ] ) ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t$next_non_empty = $this->phpcsFile->findNext(\\n\\t\\t\\tTokens::$emptyTokens,\\n\\t\\t\\t( $stackPtr + 1 ),\\n\\t\\t\\tnull,\\n\\t\\t\\ttrue,\\n\\t\\t\\tnull,\\n\\t\\t\\ttrue\\n\\t\\t);\\n\\n\\t\\t// No token found.\\n\\t\\tif ( false === $next_non_empty ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// If the next token is an assignment, that's all we need to know.\\n\\t\\tif ( isset( Tokens::$assignmentTokens[ $this->tokens[ $next_non_empty ]['code'] ] ) ) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\t// Check if this is an array assignment, e.g., `$var['key'] = 'val';` .\\n\\t\\tif ( \\\\T_OPEN_SQUARE_BRACKET === $this->tokens[ $next_non_empty ]['code']\\n\\t\\t\\t&& isset( $this->tokens[ $next_non_empty ]['bracket_closer'] )\\n\\t\\t) {\\n\\t\\t\\treturn $this->is_assignment( $this->tokens[ $next_non_empty ]['bracket_closer'] );\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\", \"output\": \"Check if this variable is being assigned a value.\\n\\nE.g., $var = 'foo';\\n\\nAlso handles array assignments to arbitrary depth:\\n\\n$array['key'][ $foo ][ something() ] = $bar;\\n\\n@since 0.5.0\\n\\n@param int $stackPtr The index of the token in the stack. This must point to\\neither a T_VARIABLE or T_CLOSE_SQUARE_BRACKET token.\\n\\n@return bool Whether the token is a variable being assigned a value.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function is_token_namespaced( $stackPtr ) {\\n\\t\\t$prev = $this->phpcsFile->findPrevious( Tokens::$emptyTokens, ( $stackPtr - 1 ), null, true, null, true );\\n\\n\\t\\tif ( false === $prev ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tif ( \\\\T_NS_SEPARATOR !== $this->tokens[ $prev ]['code'] ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t$before_prev = $this->phpcsFile->findPrevious( Tokens::$emptyTokens, ( $prev - 1 ), null, true, null, true );\\n\\t\\tif ( false === $before_prev ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tif ( \\\\T_STRING !== $this->tokens[ $before_prev ]['code']\\n\\t\\t\\t&& \\\\T_NAMESPACE !== $this->tokens[ $before_prev ]['code']\\n\\t\\t) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\", \"output\": \"Check if a particular token is prefixed with a namespace.\\n\\n@internal This will give a false positive if the file is not namespaced and the token is prefixed\\nwith `namespace\\\\`.\\n\\n@since 2.1.0\\n\\n@param int $stackPtr The index of the token in the stack.\\n\\n@return bool\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function is_only_sanitized( $stackPtr ) {\\n\\n\\t\\t// If it isn't being sanitized at all.\\n\\t\\tif ( ! $this->is_sanitized( $stackPtr ) ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// If this isn't set, we know the value must have only been casted, because\\n\\t\\t// is_sanitized() would have returned false otherwise.\\n\\t\\tif ( ! isset( $this->tokens[ $stackPtr ]['nested_parenthesis'] ) ) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\t// At this point we're expecting the value to have not been casted. If it\\n\\t\\t// was, it wasn't *only* casted, because it's also in a function.\\n\\t\\tif ( $this->is_safe_casted( $stackPtr ) ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// The only parentheses should belong to the sanitizing function. If there's\\n\\t\\t// more than one set, this isn't *only* sanitization.\\n\\t\\treturn ( \\\\count( $this->tokens[ $stackPtr ]['nested_parenthesis'] ) === 1 );\\n\\t}\", \"output\": \"Check if something is only being sanitized.\\n\\n@since 0.5.0\\n\\n@param int $stackPtr The index of the token in the stack.\\n\\n@return bool Whether the token is only within a sanitization.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function is_safe_casted( $stackPtr ) {\\n\\n\\t\\t// Get the last non-empty token.\\n\\t\\t$prev = $this->phpcsFile->findPrevious(\\n\\t\\t\\tTokens::$emptyTokens,\\n\\t\\t\\t( $stackPtr - 1 ),\\n\\t\\t\\tnull,\\n\\t\\t\\ttrue\\n\\t\\t);\\n\\n\\t\\tif ( false === $prev ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// Check if it is a safe cast.\\n\\t\\treturn isset( $this->safe_casts[ $this->tokens[ $prev ]['code'] ] );\\n\\t}\", \"output\": \"Check if something is being casted to a safe value.\\n\\n@since 0.5.0\\n\\n@param int $stackPtr The index of the token in the stack.\\n\\n@return bool Whether the token being casted.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function get_array_access_keys( $stackPtr, $all = true ) {\\n\\n\\t\\t$keys = array();\\n\\n\\t\\tif ( \\\\T_VARIABLE !== $this->tokens[ $stackPtr ]['code'] ) {\\n\\t\\t\\treturn $keys;\\n\\t\\t}\\n\\n\\t\\t$current = $stackPtr;\\n\\n\\t\\tdo {\\n\\t\\t\\t// Find the next non-empty token.\\n\\t\\t\\t$open_bracket = $this->phpcsFile->findNext(\\n\\t\\t\\t\\tTokens::$emptyTokens,\\n\\t\\t\\t\\t( $current + 1 ),\\n\\t\\t\\t\\tnull,\\n\\t\\t\\t\\ttrue\\n\\t\\t\\t);\\n\\n\\t\\t\\t// If it isn't a bracket, this isn't an array-access.\\n\\t\\t\\tif ( false === $open_bracket\\n\\t\\t\\t\\t|| \\\\T_OPEN_SQUARE_BRACKET !== $this->tokens[ $open_bracket ]['code']\\n\\t\\t\\t\\t|| ! isset( $this->tokens[ $open_bracket ]['bracket_closer'] )\\n\\t\\t\\t) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$key = $this->phpcsFile->getTokensAsString(\\n\\t\\t\\t\\t( $open_bracket + 1 ),\\n\\t\\t\\t\\t( $this->tokens[ $open_bracket ]['bracket_closer'] - $open_bracket - 1 )\\n\\t\\t\\t);\\n\\n\\t\\t\\t$keys[]  = trim( $key );\\n\\t\\t\\t$current = $this->tokens[ $open_bracket ]['bracket_closer'];\\n\\t\\t} while ( isset( $this->tokens[ $current ] ) && true === $all );\\n\\n\\t\\treturn $keys;\\n\\t}\", \"output\": \"Get the index keys of an array variable.\\n\\nE.g., \\\"bar\\\" and \\\"baz\\\" in $foo['bar']['baz'].\\n\\n@since 2.1.0\\n\\n@param int  $stackPtr The index of the variable token in the stack.\\n@param bool $all      Whether to get all keys or only the first.\\nDefaults to `true`(= all).\\n\\n@return array An array of index keys whose value is being accessed.\\nor an empty array if this is not array access.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function get_array_access_key( $stackPtr ) {\\n\\n\\t\\t$keys = $this->get_array_access_keys( $stackPtr, false );\\n\\n\\t\\tif ( isset( $keys[0] ) ) {\\n\\t\\t\\treturn $keys[0];\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\", \"output\": \"Get the index key of an array variable.\\n\\nE.g., \\\"bar\\\" in $foo['bar'].\\n\\n@since 0.5.0\\n@since 2.1.0 Now uses get_array_access_keys() under the hood.\\n\\n@param int $stackPtr The index of the token in the stack.\\n\\n@return string|false The array index key whose value is being accessed.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function is_comparison( $stackPtr, $include_coalesce = true ) {\\n\\n\\t\\t$comparisonTokens = Tokens::$comparisonTokens;\\n\\t\\tif ( false === $include_coalesce ) {\\n\\t\\t\\tunset( $comparisonTokens[ \\\\T_COALESCE ] );\\n\\t\\t}\\n\\n\\t\\t// We first check if this is a switch statement (switch ( $var )).\\n\\t\\tif ( isset( $this->tokens[ $stackPtr ]['nested_parenthesis'] ) ) {\\n\\t\\t\\t$nested_parenthesis = $this->tokens[ $stackPtr ]['nested_parenthesis'];\\n\\t\\t\\t$close_parenthesis  = end( $nested_parenthesis );\\n\\n\\t\\t\\tif (\\n\\t\\t\\t\\tisset( $this->tokens[ $close_parenthesis ]['parenthesis_owner'] )\\n\\t\\t\\t\\t&& \\\\T_SWITCH === $this->tokens[ $this->tokens[ $close_parenthesis ]['parenthesis_owner'] ]['code']\\n\\t\\t\\t) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Find the previous non-empty token. We check before the var first because\\n\\t\\t// yoda conditions are usually expected.\\n\\t\\t$previous_token = $this->phpcsFile->findPrevious(\\n\\t\\t\\tTokens::$emptyTokens,\\n\\t\\t\\t( $stackPtr - 1 ),\\n\\t\\t\\tnull,\\n\\t\\t\\ttrue\\n\\t\\t);\\n\\n\\t\\tif ( isset( $comparisonTokens[ $this->tokens[ $previous_token ]['code'] ] ) ) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\t// Maybe the comparison operator is after this.\\n\\t\\t$next_token = $this->phpcsFile->findNext(\\n\\t\\t\\tTokens::$emptyTokens,\\n\\t\\t\\t( $stackPtr + 1 ),\\n\\t\\t\\tnull,\\n\\t\\t\\ttrue\\n\\t\\t);\\n\\n\\t\\t// This might be an opening square bracket in the case of arrays ($var['a']).\\n\\t\\twhile ( false !== $next_token && \\\\T_OPEN_SQUARE_BRACKET === $this->tokens[ $next_token ]['code'] ) {\\n\\n\\t\\t\\t$next_token = $this->phpcsFile->findNext(\\n\\t\\t\\t\\tTokens::$emptyTokens,\\n\\t\\t\\t\\t( $this->tokens[ $next_token ]['bracket_closer'] + 1 ),\\n\\t\\t\\t\\tnull,\\n\\t\\t\\t\\ttrue\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\tif ( false !== $next_token && isset( $comparisonTokens[ $this->tokens[ $next_token ]['code'] ] ) ) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\", \"output\": \"Check whether a variable is being compared to another value.\\n\\nE.g., $var === 'foo', 1 <= $var, etc.\\n\\nAlso recognizes `switch ( $var )`.\\n\\n@since 0.5.0\\n@since 2.1.0 Added the $include_coalesce parameter.\\n\\n@param int  $stackPtr         The index of this token in the stack.\\n@param bool $include_coalesce Optional. Whether or not to regard the null\\ncoalesce operator - ?? - as a comparison operator.\\nDefaults to true.\\nNull coalesce is a special comparison operator in this\\nsense as it doesn't compare a variable to whatever is\\non the other side of the comparison operator.\\n\\n@return bool Whether this is a comparison.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function is_in_array_comparison( $stackPtr ) {\\n\\t\\t$function_ptr = $this->is_in_function_call( $stackPtr, $this->arrayCompareFunctions, true, true );\\n\\t\\tif ( false === $function_ptr ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t$function_name = $this->tokens[ $function_ptr ]['content'];\\n\\t\\tif ( true === $this->arrayCompareFunctions[ $function_name ] ) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tif ( $this->get_function_call_parameter_count( $function_ptr ) >= $this->arrayCompareFunctions[ $function_name ] ) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\", \"output\": \"Check if a token is inside of an array-value comparison function.\\n\\n@since 2.1.0\\n\\n@param int $stackPtr The index of the token in the stack.\\n\\n@return bool Whether the token is (part of) a parameter to an\\narray-value comparison function.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function get_use_type( $stackPtr ) {\\n\\n\\t\\t// USE keywords inside closures.\\n\\t\\t$next = $this->phpcsFile->findNext( \\\\T_WHITESPACE, ( $stackPtr + 1 ), null, true );\\n\\n\\t\\tif ( \\\\T_OPEN_PARENTHESIS === $this->tokens[ $next ]['code'] ) {\\n\\t\\t\\treturn 'closure';\\n\\t\\t}\\n\\n\\t\\t// USE keywords for traits.\\n\\t\\t$valid_scopes = array(\\n\\t\\t\\t'T_CLASS'      => true,\\n\\t\\t\\t'T_ANON_CLASS' => true,\\n\\t\\t\\t'T_TRAIT'      => true,\\n\\t\\t);\\n\\t\\tif ( false !== $this->valid_direct_scope( $stackPtr, $valid_scopes ) ) {\\n\\t\\t\\treturn 'trait';\\n\\t\\t}\\n\\n\\t\\t// USE keywords for classes to import to a namespace.\\n\\t\\treturn 'class';\\n\\t}\", \"output\": \"Check what type of 'use' statement a token is part of.\\n\\nThe T_USE token has multiple different uses:\\n\\n1. In a closure: function () use ( $var ) {}\\n2. In a class, to import a trait: use Trait_Name\\n3. In a namespace, to import a class: use Some\\\\Class;\\n\\nThis function will check the token and return 'closure', 'trait', or 'class',\\nbased on which of these uses the use is being used for.\\n\\n@since 0.7.0\\n\\n@param int $stackPtr The position of the token to check.\\n\\n@return string The type of use.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function get_interpolated_variables( $string ) {\\n\\t\\t$variables = array();\\n\\t\\tif ( preg_match_all( '/(?P<backslashes>\\\\\\\\\\\\\\\\*)\\\\$(?P<symbol>\\\\w+)/', $string, $match_sets, \\\\PREG_SET_ORDER ) ) {\\n\\t\\t\\tforeach ( $match_sets as $matches ) {\\n\\t\\t\\t\\tif ( ! isset( $matches['backslashes'] ) || ( \\\\strlen( $matches['backslashes'] ) % 2 ) === 0 ) {\\n\\t\\t\\t\\t\\t$variables[] = $matches['symbol'];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn $variables;\\n\\t}\", \"output\": \"Get the interpolated variable names from a string.\\n\\nCheck if '$' is followed by a valid variable name, and that it is not preceded by an escape sequence.\\n\\n@since 0.9.0\\n\\n@param string $string The contents of a T_DOUBLE_QUOTED_STRING or T_HEREDOC token.\\n\\n@return array Variable names (without '$' sigil).\"}"}
{"text": "{\"input\": \"Summarize the following code: public function does_function_call_have_parameters( $stackPtr ) {\\n\\n\\t\\t// Check for the existence of the token.\\n\\t\\tif ( false === isset( $this->tokens[ $stackPtr ] ) ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// Is this one of the tokens this function handles ?\\n\\t\\tif ( false === \\\\in_array( $this->tokens[ $stackPtr ]['code'], array( \\\\T_STRING, \\\\T_ARRAY, \\\\T_OPEN_SHORT_ARRAY ), true ) ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t$next_non_empty = $this->phpcsFile->findNext( Tokens::$emptyTokens, ( $stackPtr + 1 ), null, true, null, true );\\n\\n\\t\\t// Deal with short array syntax.\\n\\t\\tif ( 'T_OPEN_SHORT_ARRAY' === $this->tokens[ $stackPtr ]['type'] ) {\\n\\t\\t\\tif ( false === isset( $this->tokens[ $stackPtr ]['bracket_closer'] ) ) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( $next_non_empty === $this->tokens[ $stackPtr ]['bracket_closer'] ) {\\n\\t\\t\\t\\t// No parameters.\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Deal with function calls & long arrays.\\n\\t\\t// Next non-empty token should be the open parenthesis.\\n\\t\\tif ( false === $next_non_empty && \\\\T_OPEN_PARENTHESIS !== $this->tokens[ $next_non_empty ]['code'] ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tif ( false === isset( $this->tokens[ $next_non_empty ]['parenthesis_closer'] ) ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t$close_parenthesis   = $this->tokens[ $next_non_empty ]['parenthesis_closer'];\\n\\t\\t$next_next_non_empty = $this->phpcsFile->findNext( Tokens::$emptyTokens, ( $next_non_empty + 1 ), ( $close_parenthesis + 1 ), true );\\n\\n\\t\\tif ( $next_next_non_empty === $close_parenthesis ) {\\n\\t\\t\\t// No parameters.\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\", \"output\": \"Checks if a function call has parameters.\\n\\nExpects to be passed the T_STRING stack pointer for the function call.\\nIf passed a T_STRING which is *not* a function call, the behaviour is unreliable.\\n\\nExtra feature: If passed an T_ARRAY or T_OPEN_SHORT_ARRAY stack pointer, it\\nwill detect whether the array has values or is empty.\\n\\n@link https://github.com/PHPCompatibility/PHPCompatibility/issues/120\\n@link https://github.com/PHPCompatibility/PHPCompatibility/issues/152\\n\\n@since 0.11.0\\n\\n@param int $stackPtr The position of the function call token.\\n\\n@return bool\"}"}
{"text": "{\"input\": \"Summarize the following code: public function get_function_call_parameter_count( $stackPtr ) {\\n\\t\\tif ( false === $this->does_function_call_have_parameters( $stackPtr ) ) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\treturn \\\\count( $this->get_function_call_parameters( $stackPtr ) );\\n\\t}\", \"output\": \"Count the number of parameters a function call has been passed.\\n\\nExpects to be passed the T_STRING stack pointer for the function call.\\nIf passed a T_STRING which is *not* a function call, the behaviour is unreliable.\\n\\nExtra feature: If passed an T_ARRAY or T_OPEN_SHORT_ARRAY stack pointer,\\nit will return the number of values in the array.\\n\\n@link https://github.com/PHPCompatibility/PHPCompatibility/issues/111\\n@link https://github.com/PHPCompatibility/PHPCompatibility/issues/114\\n@link https://github.com/PHPCompatibility/PHPCompatibility/issues/151\\n\\n@since 0.11.0\\n\\n@param int $stackPtr The position of the function call token.\\n\\n@return int\"}"}
{"text": "{\"input\": \"Summarize the following code: public function get_function_call_parameter( $stackPtr, $param_offset ) {\\n\\t\\t$parameters = $this->get_function_call_parameters( $stackPtr );\\n\\n\\t\\tif ( false === isset( $parameters[ $param_offset ] ) ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\treturn $parameters[ $param_offset ];\\n\\t}\", \"output\": \"Get information on a specific parameter passed to a function call.\\n\\nExpects to be passed the T_STRING stack pointer for the function call.\\nIf passed a T_STRING which is *not* a function call, the behaviour is unreliable.\\n\\nWill return a array with the start token pointer, end token pointer and the raw value\\nof the parameter at a specific offset.\\nIf the specified parameter is not found, will return false.\\n\\n@since 0.11.0\\n\\n@param int $stackPtr     The position of the function call token.\\n@param int $param_offset The 1-based index position of the parameter to retrieve.\\n\\n@return array|false\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function find_array_open_close( $stackPtr ) {\\n\\t\\t/*\\n\\t\\t * Determine the array opener & closer.\\n\\t\\t */\\n\\t\\tif ( \\\\T_ARRAY === $this->tokens[ $stackPtr ]['code'] ) {\\n\\t\\t\\tif ( isset( $this->tokens[ $stackPtr ]['parenthesis_opener'] ) ) {\\n\\t\\t\\t\\t$opener = $this->tokens[ $stackPtr ]['parenthesis_opener'];\\n\\n\\t\\t\\t\\tif ( isset( $this->tokens[ $opener ]['parenthesis_closer'] ) ) {\\n\\t\\t\\t\\t\\t$closer = $this->tokens[ $opener ]['parenthesis_closer'];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t// Short array syntax.\\n\\t\\t\\t$opener = $stackPtr;\\n\\n\\t\\t\\tif ( isset( $this->tokens[ $stackPtr ]['bracket_closer'] ) ) {\\n\\t\\t\\t\\t$closer = $this->tokens[ $stackPtr ]['bracket_closer'];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( isset( $opener, $closer ) ) {\\n\\t\\t\\treturn array(\\n\\t\\t\\t\\t'opener' => $opener,\\n\\t\\t\\t\\t'closer' => $closer,\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\", \"output\": \"Find the array opener & closer based on a T_ARRAY or T_OPEN_SHORT_ARRAY token.\\n\\n@since 0.12.0\\n\\n@param int $stackPtr The stack pointer to the array token.\\n\\n@return array|bool Array with two keys `opener`, `closer` or false if\\neither or these could not be determined.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function determine_namespace( $stackPtr ) {\\n\\n\\t\\t// Check for the existence of the token.\\n\\t\\tif ( ! isset( $this->tokens[ $stackPtr ] ) ) {\\n\\t\\t\\treturn '';\\n\\t\\t}\\n\\n\\t\\t// Check for scoped namespace {}.\\n\\t\\tif ( ! empty( $this->tokens[ $stackPtr ]['conditions'] ) ) {\\n\\t\\t\\t$namespacePtr = $this->phpcsFile->getCondition( $stackPtr, \\\\T_NAMESPACE );\\n\\t\\t\\tif ( false !== $namespacePtr ) {\\n\\t\\t\\t\\t$namespace = $this->get_declared_namespace_name( $namespacePtr );\\n\\t\\t\\t\\tif ( false !== $namespace ) {\\n\\t\\t\\t\\t\\treturn $namespace;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// We are in a scoped namespace, but couldn't determine the name.\\n\\t\\t\\t\\t// Searching for a global namespace is futile.\\n\\t\\t\\t\\treturn '';\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t/*\\n\\t\\t * Not in a scoped namespace, so let's see if we can find a non-scoped namespace instead.\\n\\t\\t * Keeping in mind that:\\n\\t\\t * - there can be multiple non-scoped namespaces in a file (bad practice, but it happens).\\n\\t\\t * - the namespace keyword can also be used as part of a function/method call and such.\\n\\t\\t * - that a non-named namespace resolves to the global namespace.\\n\\t\\t */\\n\\t\\t$previousNSToken = $stackPtr;\\n\\t\\t$namespace       = false;\\n\\t\\tdo {\\n\\t\\t\\t$previousNSToken = $this->phpcsFile->findPrevious( \\\\T_NAMESPACE, ( $previousNSToken - 1 ) );\\n\\n\\t\\t\\t// Stop if we encounter a scoped namespace declaration as we already know we're not in one.\\n\\t\\t\\tif ( ! empty( $this->tokens[ $previousNSToken ]['scope_condition'] )\\n\\t\\t\\t\\t&& $this->tokens[ $previousNSToken ]['scope_condition'] === $previousNSToken\\n\\t\\t\\t) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$namespace = $this->get_declared_namespace_name( $previousNSToken );\\n\\n\\t\\t} while ( false === $namespace && false !== $previousNSToken );\\n\\n\\t\\t// If we still haven't got a namespace, return an empty string.\\n\\t\\tif ( false === $namespace ) {\\n\\t\\t\\treturn '';\\n\\t\\t}\\n\\n\\t\\treturn $namespace;\\n\\t}\", \"output\": \"Determine the namespace name an arbitrary token lives in.\\n\\n@since 0.10.0\\n@since 0.12.0 Moved from the `AbstractClassRestrictionsSniff` to this class.\\n\\n@param int $stackPtr The token position for which to determine the namespace.\\n\\n@return string Namespace name or empty string if it couldn't be determined or no namespace applies.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function get_declared_namespace_name( $stackPtr ) {\\n\\n\\t\\t// Check for the existence of the token.\\n\\t\\tif ( false === $stackPtr || ! isset( $this->tokens[ $stackPtr ] ) ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tif ( \\\\T_NAMESPACE !== $this->tokens[ $stackPtr ]['code'] ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t$nextToken = $this->phpcsFile->findNext( Tokens::$emptyTokens, ( $stackPtr + 1 ), null, true, null, true );\\n\\t\\tif ( \\\\T_NS_SEPARATOR === $this->tokens[ $nextToken ]['code'] ) {\\n\\t\\t\\t// Not a namespace declaration, but use of, i.e. `namespace\\\\someFunction();`.\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tif ( \\\\T_OPEN_CURLY_BRACKET === $this->tokens[ $nextToken ]['code'] ) {\\n\\t\\t\\t// Declaration for global namespace when using multiple namespaces in a file.\\n\\t\\t\\t// I.e.: `namespace {}`.\\n\\t\\t\\treturn '';\\n\\t\\t}\\n\\n\\t\\t// Ok, this should be a namespace declaration, so get all the parts together.\\n\\t\\t$acceptedTokens = array(\\n\\t\\t\\t\\\\T_STRING       => true,\\n\\t\\t\\t\\\\T_NS_SEPARATOR => true,\\n\\t\\t);\\n\\t\\t$validTokens    = $acceptedTokens + Tokens::$emptyTokens;\\n\\n\\t\\t$namespaceName = '';\\n\\t\\twhile ( isset( $validTokens[ $this->tokens[ $nextToken ]['code'] ] ) ) {\\n\\t\\t\\tif ( isset( $acceptedTokens[ $this->tokens[ $nextToken ]['code'] ] ) ) {\\n\\t\\t\\t\\t$namespaceName .= trim( $this->tokens[ $nextToken ]['content'] );\\n\\t\\t\\t}\\n\\t\\t\\t++$nextToken;\\n\\t\\t}\\n\\n\\t\\treturn $namespaceName;\\n\\t}\", \"output\": \"Get the complete namespace name for a namespace declaration.\\n\\nFor hierarchical namespaces, the name will be composed of several tokens,\\ni.e. MyProject\\\\Sub\\\\Level which will be returned together as one string.\\n\\n@since 0.12.0 A lesser variant of this method previously existed in the\\n`AbstractClassRestrictionsSniff` class.\\n\\n@param int|bool $stackPtr The position of a T_NAMESPACE token.\\n\\n@return string|false Namespace name or false if not a namespace declaration.\\nNamespace name can be an empty string for global namespace declaration.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function is_class_constant( $stackPtr ) {\\n\\t\\tif ( ! isset( $this->tokens[ $stackPtr ] ) || \\\\T_CONST !== $this->tokens[ $stackPtr ]['code'] ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// Note: traits can not declare constants.\\n\\t\\t$valid_scopes = array(\\n\\t\\t\\t'T_CLASS'      => true,\\n\\t\\t\\t'T_ANON_CLASS' => true,\\n\\t\\t\\t'T_INTERFACE'  => true,\\n\\t\\t);\\n\\n\\t\\treturn is_int( $this->valid_direct_scope( $stackPtr, $valid_scopes ) );\\n\\t}\", \"output\": \"Check whether a T_CONST token is a class constant declaration.\\n\\n@since 0.14.0\\n\\n@param int $stackPtr  The position in the stack of the T_CONST token to verify.\\n\\n@return bool\"}"}
{"text": "{\"input\": \"Summarize the following code: public function is_class_property( $stackPtr ) {\\n\\t\\tif ( ! isset( $this->tokens[ $stackPtr ] ) || \\\\T_VARIABLE !== $this->tokens[ $stackPtr ]['code'] ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// Note: interfaces can not declare properties.\\n\\t\\t$valid_scopes = array(\\n\\t\\t\\t'T_CLASS'      => true,\\n\\t\\t\\t'T_ANON_CLASS' => true,\\n\\t\\t\\t'T_TRAIT'      => true,\\n\\t\\t);\\n\\n\\t\\t$scopePtr = $this->valid_direct_scope( $stackPtr, $valid_scopes );\\n\\t\\tif ( false !== $scopePtr ) {\\n\\t\\t\\t// Make sure it's not a method parameter.\\n\\t\\t\\tif ( empty( $this->tokens[ $stackPtr ]['nested_parenthesis'] ) ) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t$parenthesis  = array_keys( $this->tokens[ $stackPtr ]['nested_parenthesis'] );\\n\\t\\t\\t\\t$deepest_open = array_pop( $parenthesis );\\n\\t\\t\\t\\tif ( $deepest_open < $scopePtr\\n\\t\\t\\t\\t\\t|| isset( $this->tokens[ $deepest_open ]['parenthesis_owner'] ) === false\\n\\t\\t\\t\\t\\t|| \\\\T_FUNCTION !== $this->tokens[ $this->tokens[ $deepest_open ]['parenthesis_owner'] ]['code']\\n\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\", \"output\": \"Check whether a T_VARIABLE token is a class property declaration.\\n\\n@since 0.14.0\\n\\n@param int $stackPtr  The position in the stack of the T_VARIABLE token to verify.\\n\\n@return bool\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function valid_direct_scope( $stackPtr, array $valid_scopes ) {\\n\\t\\tif ( empty( $this->tokens[ $stackPtr ]['conditions'] ) ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t/*\\n\\t\\t * Check only the direct wrapping scope of the token.\\n\\t\\t */\\n\\t\\t$conditions = array_keys( $this->tokens[ $stackPtr ]['conditions'] );\\n\\t\\t$ptr        = array_pop( $conditions );\\n\\n\\t\\tif ( ! isset( $this->tokens[ $ptr ] ) ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tif ( isset( $valid_scopes[ $this->tokens[ $ptr ]['type'] ] ) ) {\\n\\t\\t\\treturn $ptr;\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\", \"output\": \"Check whether the direct wrapping scope of a token is within a limited set of\\nacceptable tokens.\\n\\nUsed to check, for instance, if a T_CONST is a class constant.\\n\\n@since 0.14.0\\n\\n@param int   $stackPtr     The position in the stack of the token to verify.\\n@param array $valid_scopes Array of token types.\\nKeys should be the token types in string format\\nto allow for newer token types.\\nValue is irrelevant.\\n\\n@return int|bool StackPtr to the scope if valid, false otherwise.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function prepare_regex() {\\n\\t\\t$extra = '';\\n\\t\\tif ( '' !== $this->additionalWordDelimiters && \\\\is_string( $this->additionalWordDelimiters ) ) {\\n\\t\\t\\t$extra = preg_quote( $this->additionalWordDelimiters, '`' );\\n\\t\\t}\\n\\n\\t\\treturn sprintf( $this->punctuation_regex, $extra );\\n\\t}\", \"output\": \"Prepare the punctuation regular expression.\\n\\nMerges the existing regular expression with potentially provided extra word delimiters to allow.\\nThis is done 'late' and for each found token as otherwise inline `phpcs:set` directives\\nwould be ignored.\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function transform( $string, $regex, $transform_type = 'full' ) {\\n\\n\\t\\tswitch ( $transform_type ) {\\n\\t\\t\\tcase 'case':\\n\\t\\t\\t\\treturn strtolower( $string );\\n\\n\\t\\t\\tcase 'punctuation':\\n\\t\\t\\t\\treturn preg_replace( $regex, '_', $string );\\n\\n\\t\\t\\tcase 'full':\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\treturn preg_replace( $regex, '_', strtolower( $string ) );\\n\\t\\t}\\n\\t}\", \"output\": \"Transform an arbitrary string to lowercase and replace punctuation and spaces with underscores.\\n\\n@param string $string         The target string.\\n@param string $regex          The punctuation regular expression to use.\\n@param string $transform_type Whether to a partial or complete transform.\\nValid values are: 'full', 'case', 'punctuation'.\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function transform_complex_string( $string, $regex, $transform_type = 'full' ) {\\n\\t\\t$output = preg_split( '`([\\\\{\\\\}\\\\$\\\\[\\\\] ])`', $string, -1, \\\\PREG_SPLIT_DELIM_CAPTURE );\\n\\n\\t\\t$is_variable = false;\\n\\t\\t$has_braces  = false;\\n\\t\\t$braces      = 0;\\n\\n\\t\\tforeach ( $output as $i => $part ) {\\n\\t\\t\\tif ( \\\\in_array( $part, array( '$', '{' ), true ) ) {\\n\\t\\t\\t\\t$is_variable = true;\\n\\t\\t\\t\\tif ( '{' === $part ) {\\n\\t\\t\\t\\t\\t$has_braces = true;\\n\\t\\t\\t\\t\\t$braces++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( true === $is_variable ) {\\n\\t\\t\\t\\tif ( '[' === $part ) {\\n\\t\\t\\t\\t\\t$has_braces = true;\\n\\t\\t\\t\\t\\t$braces++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( \\\\in_array( $part, array( '}', ']' ), true ) ) {\\n\\t\\t\\t\\t\\t$braces--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( false === $has_braces && ' ' === $part ) {\\n\\t\\t\\t\\t\\t$is_variable  = false;\\n\\t\\t\\t\\t\\t$output[ $i ] = $this->transform( $part, $regex, $transform_type );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( ( true === $has_braces && 0 === $braces ) && false === \\\\in_array( $output[ ( $i + 1 ) ], array( '{', '[' ), true ) ) {\\n\\t\\t\\t\\t\\t$has_braces  = false;\\n\\t\\t\\t\\t\\t$is_variable = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$output[ $i ] = $this->transform( $part, $regex, $transform_type );\\n\\t\\t}\\n\\n\\t\\treturn implode( '', $output );\\n\\t}\", \"output\": \"Transform a complex string which may contain variable extrapolation.\\n\\n@param string $string         The target string.\\n@param string $regex          The punctuation regular expression to use.\\n@param string $transform_type Whether to a partial or complete transform.\\nValid values are: 'full', 'case', 'punctuation'.\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getGroups() {\\n\\t\\t// Make sure all array keys are lowercase.\\n\\t\\t$this->deprecated_classes = array_change_key_case( $this->deprecated_classes, CASE_LOWER );\\n\\n\\t\\treturn array(\\n\\t\\t\\t'deprecated_classes' => array(\\n\\t\\t\\t\\t'classes' => array_keys( $this->deprecated_classes ),\\n\\t\\t\\t),\\n\\t\\t);\\n\\t}\", \"output\": \"Groups of classes to restrict.\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: public function process_arbitrary_tstring( $stackPtr ) {\\n\\t\\t$content = $this->tokens[ $stackPtr ]['content'];\\n\\n\\t\\tif ( ! isset( $this->discouraged_constants[ $content ] ) ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t$next = $this->phpcsFile->findNext( Tokens::$emptyTokens, ( $stackPtr + 1 ), null, true );\\n\\t\\tif ( false !== $next && \\\\T_OPEN_PARENTHESIS === $this->tokens[ $next ]['code'] ) {\\n\\t\\t\\t// Function call or declaration.\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t$prev = $this->phpcsFile->findPrevious( Tokens::$emptyTokens, ( $stackPtr - 1 ), null, true );\\n\\t\\tif ( false !== $prev && isset( $this->preceding_tokens_to_ignore[ $this->tokens[ $prev ]['code'] ] ) ) {\\n\\t\\t\\t// Not the use of a constant.\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( $this->is_token_namespaced( $stackPtr ) === true ) {\\n\\t\\t\\t// Namespaced constant of the same name.\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( false !== $prev\\n\\t\\t\\t&& \\\\T_CONST === $this->tokens[ $prev ]['code']\\n\\t\\t\\t&& true === $this->is_class_constant( $prev )\\n\\t\\t) {\\n\\t\\t\\t// Class constant of the same name.\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t/*\\n\\t\\t * Deal with a number of variations of use statements.\\n\\t\\t */\\n\\t\\tfor ( $i = $stackPtr; $i > 0; $i-- ) {\\n\\t\\t\\tif ( $this->tokens[ $i ]['line'] !== $this->tokens[ $stackPtr ]['line'] ) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t$first_on_line = $this->phpcsFile->findNext( Tokens::$emptyTokens, ( $i + 1 ), null, true );\\n\\t\\tif ( false !== $first_on_line && \\\\T_USE === $this->tokens[ $first_on_line ]['code'] ) {\\n\\t\\t\\t$next_on_line = $this->phpcsFile->findNext( Tokens::$emptyTokens, ( $first_on_line + 1 ), null, true );\\n\\t\\t\\tif ( false !== $next_on_line ) {\\n\\t\\t\\t\\tif ( ( \\\\T_STRING === $this->tokens[ $next_on_line ]['code']\\n\\t\\t\\t\\t\\t\\t&& 'const' === $this->tokens[ $next_on_line ]['content'] )\\n\\t\\t\\t\\t\\t|| \\\\T_CONST === $this->tokens[ $next_on_line ]['code'] // Happens in some PHPCS versions.\\n\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\t$has_ns_sep = $this->phpcsFile->findNext( \\\\T_NS_SEPARATOR, ( $next_on_line + 1 ), $stackPtr );\\n\\t\\t\\t\\t\\tif ( false !== $has_ns_sep ) {\\n\\t\\t\\t\\t\\t\\t// Namespaced const (group) use statement.\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// Not a const use statement.\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Ok, this is really one of the discouraged constants.\\n\\t\\t$this->phpcsFile->addWarning(\\n\\t\\t\\t'Found usage of constant \\\"%s\\\". Use %s instead.',\\n\\t\\t\\t$stackPtr,\\n\\t\\t\\t$this->string_to_errorcode( $content . 'UsageFound' ),\\n\\t\\t\\tarray(\\n\\t\\t\\t\\t$content,\\n\\t\\t\\t\\t$this->discouraged_constants[ $content ],\\n\\t\\t\\t)\\n\\t\\t);\\n\\t}\", \"output\": \"Process an arbitrary T_STRING token to determine whether it is one of the target constants.\\n\\n@since 0.14.0\\n\\n@param int $stackPtr The position of the current token in the stack.\\n\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: public function process_parameters( $stackPtr, $group_name, $matched_content, $parameters ) {\\n\\t\\t$function_name = strtolower( $matched_content );\\n\\t\\t$target_param  = $this->target_functions[ $function_name ];\\n\\n\\t\\t// Was the target parameter passed ?\\n\\t\\tif ( ! isset( $parameters[ $target_param ] ) ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t$raw_content = $this->strip_quotes( $parameters[ $target_param ]['raw'] );\\n\\n\\t\\tif ( isset( $this->discouraged_constants[ $raw_content ] ) ) {\\n\\t\\t\\t$this->phpcsFile->addWarning(\\n\\t\\t\\t\\t'Found declaration of constant \\\"%s\\\". Use %s instead.',\\n\\t\\t\\t\\t$stackPtr,\\n\\t\\t\\t\\t$this->string_to_errorcode( $raw_content . 'DeclarationFound' ),\\n\\t\\t\\t\\tarray(\\n\\t\\t\\t\\t\\t$raw_content,\\n\\t\\t\\t\\t\\t$this->discouraged_constants[ $raw_content ],\\n\\t\\t\\t\\t)\\n\\t\\t\\t);\\n\\t\\t}\\n\\t}\", \"output\": \"Process the parameters of a matched `define` function call.\\n\\n@since 0.14.0\\n\\n@param int    $stackPtr        The position of the current token in the stack.\\n@param array  $group_name      The name of the group which was matched.\\n@param string $matched_content The token content (function name) which was matched.\\n@param array  $parameters      Array with information about the parameters.\\n\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function retrieve_misspellings( $match_stack ) {\\n\\t\\t$mispelled = array();\\n\\t\\tforeach ( $match_stack as $match ) {\\n\\t\\t\\t// Deal with multi-dimensional arrays when capturing offset.\\n\\t\\t\\tif ( \\\\is_array( $match ) ) {\\n\\t\\t\\t\\t$match = $match[0];\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( 'WordPress' !== $match ) {\\n\\t\\t\\t\\t$mispelled[] = $match;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $mispelled;\\n\\t}\", \"output\": \"Retrieve a list of misspellings based on an array of matched variations on the target word.\\n\\n@param array $match_stack Array of matched variations of the target word.\\n@return array Array containing only the misspelled variants.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function callback( $key, $val, $line, $group ) {\\n\\t\\t$this->posts_per_page = (int) $this->posts_per_page;\\n\\n\\t\\tif ( $val > $this->posts_per_page ) {\\n\\t\\t\\treturn 'Detected high pagination limit, `%s` is set to `%s`';\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\", \"output\": \"Callback to process each confirmed key, to check value.\\n\\n@param  string $key   Array index / key.\\n@param  mixed  $val   Assigned value.\\n@param  int    $line  Token line.\\n@param  array  $group Group definition.\\n@return mixed         FALSE if no match, TRUE if matches, STRING if matches\\nwith custom error message passed to ->process().\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function set_config_data( $key, $value, $temp = false ) {\\n\\t\\tConfig::setConfigData( $key, $value, $temp );\\n\\t}\", \"output\": \"Pass config data to PHPCS.\\n\\nPHPCS cross-version compatibility helper.\\n\\n@since 0.13.0\\n\\n@param string      $key   The name of the config value.\\n@param string|null $value The value to set. If null, the config entry\\nis deleted, reverting it to the default value.\\n@param boolean     $temp  Set this config data temporarily for this script run.\\nThis will not write the config data to the config file.\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function get_tab_width( File $phpcsFile ) {\\n\\t\\t$tab_width = 4;\\n\\n\\t\\tif ( isset( $phpcsFile->config->tabWidth ) && $phpcsFile->config->tabWidth > 0 ) {\\n\\t\\t\\t$tab_width = $phpcsFile->config->tabWidth;\\n\\t\\t}\\n\\n\\t\\treturn $tab_width;\\n\\t}\", \"output\": \"Get the tab width as passed to PHPCS from the command-line or the ruleset.\\n\\n@since 0.13.0\\n\\n@param \\\\PHP_CodeSniffer\\\\Files\\\\File $phpcsFile The file being processed.\\n\\n@return int Tab width. Defaults to 4.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function process_global_statement( $stackPtr, $in_function_scope ) {\\n\\t\\t/*\\n\\t\\t * Collect the variables to watch for.\\n\\t\\t */\\n\\t\\t$search = array();\\n\\t\\t$ptr    = ( $stackPtr + 1 );\\n\\t\\twhile ( isset( $this->tokens[ $ptr ] ) ) {\\n\\t\\t\\t$var = $this->tokens[ $ptr ];\\n\\n\\t\\t\\t// Halt the loop at end of statement.\\n\\t\\t\\tif ( \\\\T_SEMICOLON === $var['code'] ) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( \\\\T_VARIABLE === $var['code'] ) {\\n\\t\\t\\t\\tif ( isset( $this->wp_globals[ substr( $var['content'], 1 ) ] ) ) {\\n\\t\\t\\t\\t\\t$search[] = $var['content'];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t$ptr++;\\n\\t\\t}\\n\\t\\tunset( $var );\\n\\n\\t\\tif ( empty( $search ) ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t/*\\n\\t\\t * Search for assignments to the imported global variables within the relevant scope.\\n\\t\\t */\\n\\t\\t$start = $ptr;\\n\\t\\tif ( true === $in_function_scope ) {\\n\\t\\t\\t$function_cond = $this->phpcsFile->getCondition( $stackPtr, \\\\T_FUNCTION );\\n\\t\\t\\t$closure_cond  = $this->phpcsFile->getCondition( $stackPtr, \\\\T_CLOSURE );\\n\\t\\t\\t$scope_cond    = max( $function_cond, $closure_cond ); // If false, it will evaluate as zero, so this is fine.\\n\\t\\t\\tif ( isset( $this->tokens[ $scope_cond ]['scope_closer'] ) === false ) {\\n\\t\\t\\t\\t// Live coding or parse error.\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\t$end = $this->tokens[ $scope_cond ]['scope_closer'];\\n\\t\\t} else {\\n\\t\\t\\t// Global statement in the global namespace with file is being treated as scoped.\\n\\t\\t\\t$end = ( $this->phpcsFile->numTokens + 1 );\\n\\t\\t}\\n\\n\\t\\tfor ( $ptr = $start; $ptr < $end; $ptr++ ) {\\n\\n\\t\\t\\t// Skip over nested functions, classes and the likes.\\n\\t\\t\\tif ( isset( $this->skip_over[ $this->tokens[ $ptr ]['code'] ] ) ) {\\n\\t\\t\\t\\tif ( ! isset( $this->tokens[ $ptr ]['scope_closer'] ) ) {\\n\\t\\t\\t\\t\\t// Live coding or parse error.\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t$ptr = $this->tokens[ $ptr ]['scope_closer'];\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( \\\\T_VARIABLE !== $this->tokens[ $ptr ]['code'] ) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( \\\\in_array( $this->tokens[ $ptr ]['content'], $search, true ) === false ) {\\n\\t\\t\\t\\t// Not one of the variables we're interested in.\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Don't throw false positives for static class properties.\\n\\t\\t\\tif ( $this->is_class_object_call( $ptr ) === true ) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( true === $this->is_assignment( $ptr ) ) {\\n\\t\\t\\t\\t$this->maybe_add_error( $ptr );\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Check if this is a variable assignment within a `foreach()` declaration.\\n\\t\\t\\tif ( $this->is_foreach_as( $ptr ) === true ) {\\n\\t\\t\\t\\t$this->maybe_add_error( $ptr );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\", \"output\": \"Check that global variables imported into a function scope using a global statement\\nare not being overruled.\\n\\n@since 1.1.0 Logic was previously contained in the process_token() method.\\n\\n@param int  $stackPtr          The position of the current token in the stack.\\n@param bool $in_function_scope Whether the global statement is within a scoped function/closure.\\n\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function add_error( $stackPtr, $data = array() ) {\\n\\t\\tif ( empty( $data ) ) {\\n\\t\\t\\t$data[] = $this->tokens[ $stackPtr ]['content'];\\n\\t\\t}\\n\\n\\t\\t$this->phpcsFile->addError(\\n\\t\\t\\t'Overriding WordPress globals is prohibited. Found assignment to %s',\\n\\t\\t\\t$stackPtr,\\n\\t\\t\\t'Prohibited',\\n\\t\\t\\t$data\\n\\t\\t);\\n\\t}\", \"output\": \"Add the error.\\n\\n@since 1.1.0\\n\\n@param int   $stackPtr The position of the token to throw the error for.\\n@param array $data     Optional. Array containing one entry holding the\\nname of the variable being overruled.\\nDefaults to the 'content' of the $stackPtr token.\\n\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function setup_groups( $key ) {\\n\\t\\t// Prepare the function group regular expressions only once.\\n\\t\\t$this->groups = $this->getGroups();\\n\\n\\t\\tif ( empty( $this->groups ) && empty( self::$unittest_groups ) ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// Allow for adding extra unit tests.\\n\\t\\tif ( ! empty( self::$unittest_groups ) ) {\\n\\t\\t\\t$this->groups = array_merge( $this->groups, self::$unittest_groups );\\n\\t\\t}\\n\\n\\t\\t$all_items = array();\\n\\t\\tforeach ( $this->groups as $groupName => $group ) {\\n\\t\\t\\tif ( empty( $group[ $key ] ) ) {\\n\\t\\t\\t\\tunset( $this->groups[ $groupName ] );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t$items       = array_map( array( $this, 'prepare_name_for_regex' ), $group[ $key ] );\\n\\t\\t\\t\\t$all_items[] = $items;\\n\\t\\t\\t\\t$items       = implode( '|', $items );\\n\\n\\t\\t\\t\\t$this->groups[ $groupName ]['regex'] = sprintf( $this->regex_pattern, $items );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( empty( $this->groups ) ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// Create one \\\"super-regex\\\" to allow for initial filtering.\\n\\t\\t$all_items                = \\\\call_user_func_array( 'array_merge', $all_items );\\n\\t\\t$all_items                = implode( '|', array_unique( $all_items ) );\\n\\t\\t$this->prelim_check_regex = sprintf( $this->regex_pattern, $all_items );\\n\\n\\t\\treturn true;\\n\\t}\", \"output\": \"Set up the regular expressions for each group.\\n\\n@since 0.10.0\\n\\n@param string $key The group array index key where the input for the regular expression can be found.\\n@return bool True if the groups were setup. False if not.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function is_targetted_token( $stackPtr ) {\\n\\n\\t\\t// Exclude function definitions, class methods, and namespaced calls.\\n\\t\\tif ( \\\\T_STRING === $this->tokens[ $stackPtr ]['code'] ) {\\n\\t\\t\\tif ( $this->is_class_object_call( $stackPtr ) === true ) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( $this->is_token_namespaced( $stackPtr ) === true ) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$prev = $this->phpcsFile->findPrevious( Tokens::$emptyTokens, ( $stackPtr - 1 ), null, true );\\n\\n\\t\\t\\tif ( false !== $prev ) {\\n\\t\\t\\t\\t// Skip sniffing if calling a same-named method, or on function definitions.\\n\\t\\t\\t\\t$skipped = array(\\n\\t\\t\\t\\t\\t\\\\T_FUNCTION        => \\\\T_FUNCTION,\\n\\t\\t\\t\\t\\t\\\\T_CLASS           => \\\\T_CLASS,\\n\\t\\t\\t\\t\\t\\\\T_AS              => \\\\T_AS, // Use declaration alias.\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\tif ( isset( $skipped[ $this->tokens[ $prev ]['code'] ] ) ) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\", \"output\": \"Verify is the current token is a function call.\\n\\n@since 0.11.0 Split out from the `process()` method.\\n\\n@param int $stackPtr The position of the current token in the stack.\\n\\n@return bool\"}"}
{"text": "{\"input\": \"Summarize the following code: public function check_for_matches( $stackPtr ) {\\n\\t\\t$token_content = strtolower( $this->tokens[ $stackPtr ]['content'] );\\n\\t\\t$skip_to       = array();\\n\\n\\t\\tforeach ( $this->groups as $groupName => $group ) {\\n\\n\\t\\t\\tif ( isset( $this->excluded_groups[ $groupName ] ) ) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( isset( $group['whitelist'][ $token_content ] ) ) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( preg_match( $group['regex'], $token_content ) === 1 ) {\\n\\t\\t\\t\\t$skip_to[] = $this->process_matched_token( $stackPtr, $groupName, $token_content );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( empty( $skip_to ) || min( $skip_to ) === 0 ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\treturn min( $skip_to );\\n\\t}\", \"output\": \"Verify if the current token is one of the targetted functions.\\n\\n@since 0.11.0 Split out from the `process()` method.\\n\\n@param int $stackPtr The position of the current token in the stack.\\n\\n@return int|void Integer stack pointer to skip forward or void to continue\\nnormal file processing.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function process_variable_variable( $stackPtr ) {\\n\\t\\tstatic $indicators = array(\\n\\t\\t\\t\\\\T_OPEN_CURLY_BRACKET => true,\\n\\t\\t\\t\\\\T_VARIABLE           => true,\\n\\t\\t);\\n\\n\\t\\t// Is this a variable variable ?\\n\\t\\t// Not concerned with nested ones as those will be recognized on their own token.\\n\\t\\t$next_non_empty = $this->phpcsFile->findNext( Tokens::$emptyTokens, ( $stackPtr + 1 ), null, true, null, true );\\n\\t\\tif ( false === $next_non_empty || ! isset( $indicators[ $this->tokens[ $next_non_empty ]['code'] ] ) ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( \\\\T_OPEN_CURLY_BRACKET === $this->tokens[ $next_non_empty ]['code']\\n\\t\\t\\t&& isset( $this->tokens[ $next_non_empty ]['bracket_closer'] )\\n\\t\\t) {\\n\\t\\t\\t// Skip over the variable part.\\n\\t\\t\\t$next_non_empty = $this->tokens[ $next_non_empty ]['bracket_closer'];\\n\\t\\t}\\n\\n\\t\\t$maybe_assignment = $this->phpcsFile->findNext( Tokens::$emptyTokens, ( $next_non_empty + 1 ), null, true, null, true );\\n\\n\\t\\twhile ( false !== $maybe_assignment\\n\\t\\t\\t&& \\\\T_OPEN_SQUARE_BRACKET === $this->tokens[ $maybe_assignment ]['code']\\n\\t\\t\\t&& isset( $this->tokens[ $maybe_assignment ]['bracket_closer'] )\\n\\t\\t) {\\n\\t\\t\\t$maybe_assignment = $this->phpcsFile->findNext(\\n\\t\\t\\t\\tTokens::$emptyTokens,\\n\\t\\t\\t\\t( $this->tokens[ $maybe_assignment ]['bracket_closer'] + 1 ),\\n\\t\\t\\t\\tnull,\\n\\t\\t\\t\\ttrue,\\n\\t\\t\\t\\tnull,\\n\\t\\t\\t\\ttrue\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\tif ( false === $maybe_assignment ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( ! isset( Tokens::$assignmentTokens[ $this->tokens[ $maybe_assignment ]['code'] ] ) ) {\\n\\t\\t\\t// Not an assignment.\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t$error = self::ERROR_MSG;\\n\\n\\t\\t/*\\n\\t\\t * Local variable variables in a function do not need to be prefixed.\\n\\t\\t * But a variable variable could evaluate to the name of an imported global\\n\\t\\t * variable.\\n\\t\\t * Not concerned with imported variable variables (global.. ) as that has been\\n\\t\\t * forbidden since PHP 7.0. Presuming cross-version code and if not, that\\n\\t\\t * is for the PHPCompatibility standard to detect.\\n\\t\\t */\\n\\t\\tif ( $this->phpcsFile->hasCondition( $stackPtr, array( \\\\T_FUNCTION, \\\\T_CLOSURE ) ) === true ) {\\n\\t\\t\\t$condition = $this->phpcsFile->getCondition( $stackPtr, \\\\T_FUNCTION );\\n\\t\\t\\tif ( false === $condition ) {\\n\\t\\t\\t\\t$condition = $this->phpcsFile->getCondition( $stackPtr, \\\\T_CLOSURE );\\n\\t\\t\\t}\\n\\n\\t\\t\\t$has_global = $this->phpcsFile->findPrevious( \\\\T_GLOBAL, ( $stackPtr - 1 ), $this->tokens[ $condition ]['scope_opener'] );\\n\\t\\t\\tif ( false === $has_global ) {\\n\\t\\t\\t\\t// No variable import happening.\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$error = 'Variable variable which could potentially override an imported global variable detected. ' . $error;\\n\\t\\t}\\n\\n\\t\\t$variable_name = $this->phpcsFile->getTokensAsString( $stackPtr, ( ( $next_non_empty - $stackPtr ) + 1 ) );\\n\\n\\t\\t// Still here ? In that case, the variable name should be prefixed.\\n\\t\\t$recorded = $this->phpcsFile->addWarning(\\n\\t\\t\\t$error,\\n\\t\\t\\t$stackPtr,\\n\\t\\t\\t'NonPrefixedVariableFound',\\n\\t\\t\\tarray(\\n\\t\\t\\t\\t'Global variables defined',\\n\\t\\t\\t\\t$variable_name,\\n\\t\\t\\t)\\n\\t\\t);\\n\\n\\t\\tif ( true === $recorded ) {\\n\\t\\t\\t$this->record_potential_prefix_metric( $stackPtr, $variable_name );\\n\\t\\t}\\n\\n\\t\\t// Skip over the variable part of the variable.\\n\\t\\treturn ( $next_non_empty + 1 );\\n\\t}\", \"output\": \"Handle variable variables defined in the global namespace.\\n\\n@since 0.12.0\\n\\n@param int $stackPtr The position of the current token in the stack.\\n\\n@return int|void Integer stack pointer to skip forward or void to continue\\nnormal file processing.\"}"}
{"text": "{\"input\": \"Summarize the following code: private function variable_prefixed_or_whitelisted( $stackPtr, $name ) {\\n\\t\\t// Ignore superglobals and WP global variables.\\n\\t\\tif ( isset( $this->superglobals[ $name ] ) || isset( $this->wp_globals[ $name ] ) ) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\treturn $this->is_prefixed( $stackPtr, $name );\\n\\t}\", \"output\": \"Check if a variable name might need a prefix.\\n\\nPrefix is not needed for:\\n- superglobals,\\n- WP native globals,\\n- variables which are already prefixed.\\n\\n@since 0.12.0\\n@since 1.0.1  Added $stackPtr parameter.\\n\\n@param int    $stackPtr The position of the token to record the metric against.\\n@param string $name     Variable name without the dollar sign.\\n\\n@return bool True if the variable name is whitelisted or already prefixed.\\nFalse otherwise.\"}"}
{"text": "{\"input\": \"Summarize the following code: private function validate_prefixes() {\\n\\t\\tif ( $this->previous_prefixes === $this->prefixes ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Set the cache *before* validation so as to not break the above compare.\\n\\t\\t$this->previous_prefixes = $this->prefixes;\\n\\n\\t\\t// Validate the passed prefix(es).\\n\\t\\t$prefixes    = array();\\n\\t\\t$ns_prefixes = array();\\n\\t\\tforeach ( $this->prefixes as $key => $prefix ) {\\n\\t\\t\\t$prefixLC = strtolower( $prefix );\\n\\n\\t\\t\\tif ( isset( $this->prefix_blacklist[ $prefixLC ] ) ) {\\n\\t\\t\\t\\t$this->phpcsFile->addError(\\n\\t\\t\\t\\t\\t'The \\\"%s\\\" prefix is not allowed.',\\n\\t\\t\\t\\t\\t0,\\n\\t\\t\\t\\t\\t'ForbiddenPrefixPassed',\\n\\t\\t\\t\\t\\tarray( $prefix )\\n\\t\\t\\t\\t);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Validate the prefix against characters allowed for function, class, constant names etc.\\n\\t\\t\\tif ( preg_match( '`^[a-zA-Z_\\\\x7f-\\\\xff][a-zA-Z0-9_\\\\x7f-\\\\xff\\\\\\\\\\\\\\\\]*$`', $prefix ) !== 1 ) {\\n\\t\\t\\t\\t$this->phpcsFile->addWarning(\\n\\t\\t\\t\\t\\t'The \\\"%s\\\" prefix is not a valid namespace/function/class/variable/constant prefix in PHP.',\\n\\t\\t\\t\\t\\t0,\\n\\t\\t\\t\\t\\t'InvalidPrefixPassed',\\n\\t\\t\\t\\t\\tarray( $prefix )\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Lowercase the prefix to allow for direct compare.\\n\\t\\t\\t$prefixes[ $key ] = $prefixLC;\\n\\n\\t\\t\\t/*\\n\\t\\t\\t * Replace non-word characters in the prefix with a regex snippet, but only if the\\n\\t\\t\\t * string doesn't already contain namespace separators.\\n\\t\\t\\t */\\n\\t\\t\\t$is_regex = false;\\n\\t\\t\\tif ( strpos( $prefix, '\\\\\\\\' ) === false && preg_match( '`[_\\\\W]`', $prefix ) > 0 ) {\\n\\t\\t\\t\\t$prefix   = preg_replace( '`([_\\\\W])`', '[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\$1]', $prefixLC );\\n\\t\\t\\t\\t$is_regex = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$ns_prefixes[ $prefixLC ] = array(\\n\\t\\t\\t\\t'prefix'   => $prefix,\\n\\t\\t\\t\\t'is_regex' => $is_regex,\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\t// Set the validated prefixes caches.\\n\\t\\t$this->validated_prefixes           = $prefixes;\\n\\t\\t$this->validated_namespace_prefixes = $ns_prefixes;\\n\\t}\", \"output\": \"Validate an array of prefixes as passed through a custom property or via the command line.\\n\\nChecks that the prefix:\\n- is not one of the blacklisted ones.\\n- complies with the PHP rules for valid function, class, variable, constant names.\\n\\n@since 0.12.0\"}"}
{"text": "{\"input\": \"Summarize the following code: private function record_potential_prefix_metric( $stackPtr, $construct_name ) {\\n\\t\\tif ( preg_match( '`^([A-Z]*[a-z0-9]*+)`', ltrim( $construct_name, '\\\\$_' ), $matches ) > 0\\n\\t\\t\\t&& isset( $matches[1] ) && '' !== $matches[1]\\n\\t\\t) {\\n\\t\\t\\t$this->phpcsFile->recordMetric( $stackPtr, 'Prefix all globals: potential prefixes - start of non-prefixed construct', strtolower( $matches[1] ) );\\n\\t\\t}\\n\\t}\", \"output\": \"Record the \\\"potential prefix\\\" metric.\\n\\n@since 1.0.1\\n\\n@param int    $stackPtr       The position of the token to record the metric against.\\n@param string $construct_name Name of the global construct to try and distill a potential prefix from.\\n\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function setup_groups() {\\n\\t\\t$this->groups_cache = $this->getGroups();\\n\\n\\t\\tif ( empty( $this->groups_cache ) && empty( self::$groups ) ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// Allow for adding extra unit tests.\\n\\t\\tif ( ! empty( self::$groups ) ) {\\n\\t\\t\\t$this->groups_cache = array_merge( $this->groups_cache, self::$groups );\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\", \"output\": \"Cache the groups.\\n\\n@since 0.13.0\\n\\n@return bool True if the groups were setup. False if not.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function validate_align_multiline_items() {\\n\\t\\t$alignMultilineItems = $this->alignMultilineItems;\\n\\n\\t\\tif ( 'always' === $alignMultilineItems || 'never' === $alignMultilineItems ) {\\n\\t\\t\\treturn;\\n\\t\\t} else {\\n\\t\\t\\t// Correct for a potentially added % sign.\\n\\t\\t\\t$alignMultilineItems = rtrim( $alignMultilineItems, '%' );\\n\\n\\t\\t\\tif ( preg_match( '`^([=<>!]{1,2})(100|[0-9]{1,2})$`', $alignMultilineItems, $matches ) > 0 ) {\\n\\t\\t\\t\\t$operator = $matches[1];\\n\\t\\t\\t\\t$number   = (int) $matches[2];\\n\\n\\t\\t\\t\\tif ( \\\\in_array( $operator, array( '<', '<=', '>', '>=', '==', '=', '!=', '<>' ), true ) === true\\n\\t\\t\\t\\t\\t&& ( $number >= 0 && $number <= 100 )\\n\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\t$this->alignMultilineItems = $alignMultilineItems;\\n\\t\\t\\t\\t\\t$this->number              = (string) $number;\\n\\t\\t\\t\\t\\t$this->operator            = $operator;\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t$this->phpcsFile->addError(\\n\\t\\t\\t'Invalid property value passed: \\\"%s\\\". The value for the \\\"alignMultilineItems\\\" property for the \\\"WordPress.Arrays.MultipleStatementAlignment\\\" sniff should be either \\\"always\\\", \\\"never\\\" or an comparison operator + a number between 0 and 100.',\\n\\t\\t\\t0,\\n\\t\\t\\t'InvalidPropertyPassed',\\n\\t\\t\\tarray( $this->alignMultilineItems )\\n\\t\\t);\\n\\n\\t\\t// Reset to the default if an invalid value was received.\\n\\t\\t$this->alignMultilineItems = 'always';\\n\\t}\", \"output\": \"Validate that a valid value has been received for the alignMultilineItems property.\\n\\nThis message may be thrown more than once if the property is being changed inline in a file.\\n\\n@since 0.14.0\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function is_local_data_stream( $raw_param_value ) {\\n\\n\\t\\t$raw_stripped = $this->strip_quotes( $raw_param_value );\\n\\t\\tif ( isset( $this->allowed_local_streams[ $raw_stripped ] )\\n\\t\\t\\t|| isset( $this->allowed_local_stream_constants[ $raw_param_value ] )\\n\\t\\t) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tforeach ( $this->allowed_local_stream_partials as $partial ) {\\n\\t\\t\\tif ( strpos( $raw_stripped, $partial ) === 0 ) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\", \"output\": \"Determine based on the \\\"raw\\\" parameter value, whether a file parameter points to\\na local data stream.\\n\\n@param string $raw_param_value Raw parameter value.\\n\\n@return bool True if this is a local data stream. False otherwise.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function processVariableInString( File $phpcs_file, $stack_ptr ) {\\n\\n\\t\\t$tokens = $phpcs_file->getTokens();\\n\\n\\t\\tif ( preg_match_all( '|[^\\\\\\\\\\\\]\\\\${?([a-zA-Z_\\\\x7f-\\\\xff][a-zA-Z0-9_\\\\x7f-\\\\xff]*)|', $tokens[ $stack_ptr ]['content'], $matches ) > 0 ) {\\n\\n\\t\\t\\t// Merge any custom variables with the defaults.\\n\\t\\t\\t$this->mergeWhiteList();\\n\\n\\t\\t\\tforeach ( $matches[1] as $var_name ) {\\n\\t\\t\\t\\t// If it's a php reserved var, then its ok.\\n\\t\\t\\t\\tif ( isset( $this->phpReservedVars[ $var_name ] ) ) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Likewise if it is a mixed-case var used by WordPress core.\\n\\t\\t\\t\\tif ( isset( $this->wordpress_mixed_case_vars[ $var_name ] ) ) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( false === self::isSnakeCase( $var_name ) ) {\\n\\t\\t\\t\\t\\t$error = 'Variable \\\"$%s\\\" is not in valid snake_case format, try \\\"$%s\\\"';\\n\\t\\t\\t\\t\\t$data  = array(\\n\\t\\t\\t\\t\\t\\t$var_name,\\n\\t\\t\\t\\t\\t\\tSniff::get_snake_case_name_suggestion( $var_name ),\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t$phpcs_file->addError( $error, $stack_ptr, 'InterpolatedVariableNotSnakeCase', $data );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\", \"output\": \"Processes the variable found within a double quoted string.\\n\\n@param \\\\PHP_CodeSniffer\\\\Files\\\\File $phpcs_file The file being scanned.\\n@param int                         $stack_ptr  The position of the double quoted\\nstring.\\n\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function mergeWhiteList() {\\n\\t\\tif ( $this->customPropertiesWhitelist !== $this->addedCustomProperties['properties'] ) {\\n\\t\\t\\t// Fix property potentially passed as comma-delimited string.\\n\\t\\t\\t$customProperties = Sniff::merge_custom_array( $this->customPropertiesWhitelist, array(), false );\\n\\n\\t\\t\\t$this->whitelisted_mixed_case_member_var_names = Sniff::merge_custom_array(\\n\\t\\t\\t\\t$customProperties,\\n\\t\\t\\t\\t$this->whitelisted_mixed_case_member_var_names\\n\\t\\t\\t);\\n\\n\\t\\t\\t$this->addedCustomProperties['properties'] = $this->customPropertiesWhitelist;\\n\\t\\t}\\n\\t}\", \"output\": \"Merge a custom whitelist provided via a custom ruleset with the predefined whitelist,\\nif we haven't already.\\n\\n@since 0.10.0\\n@since 2.0.0  Removed unused $phpcs_file parameter.\\n\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function ignore_token( $ptr ) {\\n\\t\\t$token_code = $this->tokens[ $ptr ]['code'];\\n\\n\\t\\tif ( isset( $this->ignore_tokens[ $token_code ] ) ) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\t/*\\n\\t\\t * If it's a subsequent line of a multi-line sting, it will not start with a quote\\n\\t\\t * character, nor just *be* a quote character.\\n\\t\\t */\\n\\t\\tif ( \\\\T_CONSTANT_ENCAPSED_STRING === $token_code\\n\\t\\t\\t|| \\\\T_DOUBLE_QUOTED_STRING === $token_code\\n\\t\\t) {\\n\\t\\t\\t// Deal with closing quote of a multi-line string being on its own line.\\n\\t\\t\\tif ( \\\"'\\\" === $this->tokens[ $ptr ]['content']\\n\\t\\t\\t\\t|| '\\\"' === $this->tokens[ $ptr ]['content']\\n\\t\\t\\t) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Deal with subsequent lines of a multi-line string where the token is broken up per line.\\n\\t\\t\\tif ( \\\"'\\\" !== $this->tokens[ $ptr ]['content'][0]\\n\\t\\t\\t\\t&& '\\\"' !== $this->tokens[ $ptr ]['content'][0]\\n\\t\\t\\t) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\", \"output\": \"Should the token be ignored ?\\n\\nThis method is only intended to be used with the first token on a line\\nfor subsequent lines in an multi-line array item.\\n\\n@param int $ptr Stack pointer to the first token on a line.\\n\\n@return bool\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function get_indentation_size( $ptr ) {\\n\\n\\t\\t// Find the first token on the line.\\n\\t\\tfor ( ; $ptr >= 0; $ptr-- ) {\\n\\t\\t\\tif ( 1 === $this->tokens[ $ptr ]['column'] ) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t$whitespace = '';\\n\\n\\t\\tif ( \\\\T_WHITESPACE === $this->tokens[ $ptr ]['code']\\n\\t\\t\\t|| \\\\T_DOC_COMMENT_WHITESPACE === $this->tokens[ $ptr ]['code']\\n\\t\\t) {\\n\\t\\t\\treturn $this->tokens[ $ptr ]['length'];\\n\\t\\t}\\n\\n\\t\\t/*\\n\\t\\t * Special case for multi-line, non-docblock comments.\\n\\t\\t * Only applicable for subsequent lines in an array item.\\n\\t\\t *\\n\\t\\t * First/Single line is tokenized as T_WHITESPACE + T_COMMENT\\n\\t\\t * Subsequent lines are tokenized as T_COMMENT including the indentation whitespace.\\n\\t\\t */\\n\\t\\tif ( \\\\T_COMMENT === $this->tokens[ $ptr ]['code'] ) {\\n\\t\\t\\t$content        = $this->tokens[ $ptr ]['content'];\\n\\t\\t\\t$actual_comment = ltrim( $content );\\n\\t\\t\\t$whitespace     = str_replace( $actual_comment, '', $content );\\n\\t\\t}\\n\\n\\t\\treturn \\\\strlen( $whitespace );\\n\\t}\", \"output\": \"Determine the line indentation whitespace.\\n\\n@param int $ptr Stack pointer to an arbitrary token on a line.\\n\\n@return int Nr of spaces found. Where necessary, tabs are translated to spaces.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function get_indentation_string( $nr ) {\\n\\t\\tif ( 0 >= $nr ) {\\n\\t\\t\\treturn '';\\n\\t\\t}\\n\\n\\t\\t// Space-based indentation.\\n\\t\\tif ( false === $this->tabIndent ) {\\n\\t\\t\\treturn str_repeat( ' ', $nr );\\n\\t\\t}\\n\\n\\t\\t// Tab-based indentation.\\n\\t\\t$num_tabs    = (int) floor( $nr / $this->tab_width );\\n\\t\\t$remaining   = ( $nr % $this->tab_width );\\n\\t\\t$tab_indent  = str_repeat( \\\"\\\\t\\\", $num_tabs );\\n\\t\\t$tab_indent .= str_repeat( ' ', $remaining );\\n\\n\\t\\treturn $tab_indent;\\n\\t}\", \"output\": \"Create an indentation string.\\n\\n@param int $nr Number of spaces the indentation should be.\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function add_array_alignment_error( $ptr, $error, $error_code, $expected, $found, $new_indent ) {\\n\\n\\t\\t$fix = $this->phpcsFile->addFixableError( $error, $ptr, $error_code, array( $expected, $found ) );\\n\\t\\tif ( true === $fix ) {\\n\\t\\t\\t$this->fix_alignment_error( $ptr, $new_indent );\\n\\t\\t}\\n\\t}\", \"output\": \"Throw an error and fix incorrect array alignment.\\n\\n@param int    $ptr        Stack pointer to the first content on the line.\\n@param string $error      Error message.\\n@param string $error_code Error code.\\n@param int    $expected   Expected nr of spaces (tabs translated to space value).\\n@param int    $found      Found nr of spaces (tabs translated to space value).\\n@param string $new_indent Whitespace indent replacement content.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function fix_alignment_error( $ptr, $new_indent ) {\\n\\t\\tif ( 1 === $this->tokens[ $ptr ]['column'] ) {\\n\\t\\t\\t$this->phpcsFile->fixer->addContentBefore( $ptr, $new_indent );\\n\\t\\t} else {\\n\\t\\t\\t$this->phpcsFile->fixer->replaceToken( ( $ptr - 1 ), $new_indent );\\n\\t\\t}\\n\\t}\", \"output\": \"Fix incorrect array alignment.\\n\\n@param int    $ptr        Stack pointer to the first content on the line.\\n@param string $new_indent Whitespace indent replacement content.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function is_falsy( $start, $end ) {\\n\\n\\t\\t// Find anything excluding the false tokens.\\n\\t\\t$has_non_false = $this->phpcsFile->findNext( $this->false_tokens, $start, ( $end + 1 ), true );\\n\\t\\t// If no non-false tokens are found, we are good.\\n\\t\\tif ( false === $has_non_false ) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\t$code_string = '';\\n\\t\\tfor ( $i = $start; $i <= $end; $i++ ) {\\n\\t\\t\\tif ( isset( $this->safe_tokens[ $this->tokens[ $i ]['code'] ] ) === false ) {\\n\\t\\t\\t\\t// Function call/variable or other token which makes it neigh impossible\\n\\t\\t\\t\\t// to determine whether the actual value would evaluate to false.\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( isset( Tokens::$emptyTokens[ $this->tokens[ $i ]['code'] ] ) === true ) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t$code_string .= $this->tokens[ $i ]['content'];\\n\\t\\t}\\n\\n\\t\\tif ( '' === $code_string ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// Evaluate the argument to figure out the outcome is false or not.\\n\\t\\t// phpcs:ignore Squiz.PHP.Eval -- No harm here.\\n\\t\\treturn ( false === eval( \\\"return (bool) $code_string;\\\" ) );\\n\\t}\", \"output\": \"Determine if a range has a falsy value.\\n\\n@param int $start The position to start looking from.\\n@param int $end   The position to stop looking (inclusive).\\n\\n@return bool True if the parameter is falsy.\\nFalse if the parameter is not falsy or when it\\ncouldn't be reliably determined.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function compare_single_and_plural_arguments( $stack_ptr, $single_context, $plural_context ) {\\n\\t\\t$single_content = $single_context['tokens'][0]['content'];\\n\\t\\t$plural_content = $plural_context['tokens'][0]['content'];\\n\\n\\t\\tpreg_match_all( self::SPRINTF_PLACEHOLDER_REGEX, $single_content, $single_placeholders );\\n\\t\\t$single_placeholders = $single_placeholders[0];\\n\\n\\t\\tpreg_match_all( self::SPRINTF_PLACEHOLDER_REGEX, $plural_content, $plural_placeholders );\\n\\t\\t$plural_placeholders = $plural_placeholders[0];\\n\\n\\t\\t// English conflates \\\"singular\\\" with \\\"only one\\\", described in the codex:\\n\\t\\t// https://codex.wordpress.org/I18n_for_WordPress_Developers#Plurals .\\n\\t\\tif ( \\\\count( $single_placeholders ) < \\\\count( $plural_placeholders ) ) {\\n\\t\\t\\t$error_string = 'Missing singular placeholder, needed for some languages. See https://codex.wordpress.org/I18n_for_WordPress_Developers#Plurals';\\n\\t\\t\\t$single_index = $single_context['tokens'][0]['token_index'];\\n\\n\\t\\t\\t$this->phpcsFile->addError( $error_string, $single_index, 'MissingSingularPlaceholder' );\\n\\t\\t}\\n\\n\\t\\t// Reordering is fine, but mismatched placeholders is probably wrong.\\n\\t\\tsort( $single_placeholders );\\n\\t\\tsort( $plural_placeholders );\\n\\n\\t\\tif ( $single_placeholders !== $plural_placeholders ) {\\n\\t\\t\\t$this->phpcsFile->addWarning( 'Mismatched placeholders is probably an error', $stack_ptr, 'MismatchedPlaceholders' );\\n\\t\\t}\\n\\t}\", \"output\": \"Check for inconsistencies between single and plural arguments.\\n\\n@param int   $stack_ptr      The position of the current token in the stack.\\n@param array $single_context Single context (@todo needs better description).\\n@param array $plural_context Plural context (@todo needs better description).\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function check_text( $context ) {\\n\\t\\t$stack_ptr = $context['stack_ptr'];\\n\\t\\t$arg_name  = $context['arg_name'];\\n\\t\\t$content   = $context['tokens'][0]['content'];\\n\\t\\t$is_error  = empty( $context['warning'] );\\n\\n\\t\\t// UnorderedPlaceholders: Check for multiple unordered placeholders.\\n\\t\\t$unordered_matches_count = preg_match_all( self::UNORDERED_SPRINTF_PLACEHOLDER_REGEX, $content, $unordered_matches );\\n\\t\\t$unordered_matches       = $unordered_matches[0];\\n\\t\\t$all_matches_count       = preg_match_all( self::SPRINTF_PLACEHOLDER_REGEX, $content, $all_matches );\\n\\n\\t\\tif ( $unordered_matches_count > 0 && $unordered_matches_count !== $all_matches_count && $all_matches_count > 1 ) {\\n\\t\\t\\t$code = $this->string_to_errorcode( 'MixedOrderedPlaceholders' . ucfirst( $arg_name ) );\\n\\t\\t\\t$this->phpcsFile->addError(\\n\\t\\t\\t\\t'Multiple placeholders should be ordered. Mix of ordered and non-ordered placeholders found. Found: %s.',\\n\\t\\t\\t\\t$stack_ptr,\\n\\t\\t\\t\\t$code,\\n\\t\\t\\t\\tarray( implode( ', ', $all_matches[0] ) )\\n\\t\\t\\t);\\n\\n\\t\\t} elseif ( $unordered_matches_count >= 2 ) {\\n\\t\\t\\t$code = $this->string_to_errorcode( 'UnorderedPlaceholders' . ucfirst( $arg_name ) );\\n\\n\\t\\t\\t$suggestions     = array();\\n\\t\\t\\t$replace_regexes = array();\\n\\t\\t\\t$replacements    = array();\\n\\t\\t\\tfor ( $i = 0; $i < $unordered_matches_count; $i++ ) {\\n\\t\\t\\t\\t$to_insert         = ( $i + 1 );\\n\\t\\t\\t\\t$to_insert        .= ( '\\\"' !== $content[0] ) ? '$' : '\\\\$';\\n\\t\\t\\t\\t$suggestions[ $i ] = substr_replace( $unordered_matches[ $i ], $to_insert, 1, 0 );\\n\\n\\t\\t\\t\\t// Prepare the strings for use a regex.\\n\\t\\t\\t\\t$replace_regexes[ $i ] = '`\\\\Q' . $unordered_matches[ $i ] . '\\\\E`';\\n\\t\\t\\t\\t// Note: the initial \\\\\\\\ is a literal \\\\, the four \\\\ in the replacement translate to also to a literal \\\\.\\n\\t\\t\\t\\t$replacements[ $i ] = str_replace( '\\\\\\\\', '\\\\\\\\\\\\\\\\', $suggestions[ $i ] );\\n\\t\\t\\t\\t// Note: the $ needs escaping to prevent numeric sequences after the $ being interpreted as match replacements.\\n\\t\\t\\t\\t$replacements[ $i ] = str_replace( '$', '\\\\\\\\$', $replacements[ $i ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t$fix = $this->addFixableMessage(\\n\\t\\t\\t\\t'Multiple placeholders should be ordered. Expected \\\\'%s\\\\', but got %s.',\\n\\t\\t\\t\\t$stack_ptr,\\n\\t\\t\\t\\t$is_error,\\n\\t\\t\\t\\t$code,\\n\\t\\t\\t\\tarray( implode( ', ', $suggestions ), implode( ', ', $unordered_matches ) )\\n\\t\\t\\t);\\n\\n\\t\\t\\tif ( true === $fix ) {\\n\\t\\t\\t\\t$fixed_str = preg_replace( $replace_regexes, $replacements, $content, 1 );\\n\\n\\t\\t\\t\\t$this->phpcsFile->fixer->replaceToken( $stack_ptr, $fixed_str );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t/*\\n\\t\\t * NoEmptyStrings.\\n\\t\\t *\\n\\t\\t * Strip placeholders and surrounding quotes.\\n\\t\\t */\\n\\t\\t$non_placeholder_content = trim( $this->strip_quotes( $content ) );\\n\\t\\t$non_placeholder_content = preg_replace( self::SPRINTF_PLACEHOLDER_REGEX, '', $non_placeholder_content );\\n\\n\\t\\tif ( '' === $non_placeholder_content ) {\\n\\t\\t\\t$this->phpcsFile->addError( 'Strings should have translatable content', $stack_ptr, 'NoEmptyStrings' );\\n\\t\\t}\\n\\t}\", \"output\": \"Check the string itself for problems.\\n\\n@param array $context Context (@todo needs better description).\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: public function is_targetted_token( $stackPtr ) {\\n\\n\\t\\t$token     = $this->tokens[ $stackPtr ];\\n\\t\\t$classname = '';\\n\\n\\t\\tif ( \\\\in_array( $token['code'], array( \\\\T_NEW, \\\\T_EXTENDS, \\\\T_IMPLEMENTS ), true ) ) {\\n\\t\\t\\tif ( \\\\T_NEW === $token['code'] ) {\\n\\t\\t\\t\\t$nameEnd = ( $this->phpcsFile->findNext( array( \\\\T_OPEN_PARENTHESIS, \\\\T_WHITESPACE, \\\\T_SEMICOLON, \\\\T_OBJECT_OPERATOR ), ( $stackPtr + 2 ) ) - 1 );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t$nameEnd = ( $this->phpcsFile->findNext( array( \\\\T_CLOSE_CURLY_BRACKET, \\\\T_WHITESPACE ), ( $stackPtr + 2 ) ) - 1 );\\n\\t\\t\\t}\\n\\n\\t\\t\\t$length    = ( $nameEnd - ( $stackPtr + 1 ) );\\n\\t\\t\\t$classname = $this->phpcsFile->getTokensAsString( ( $stackPtr + 2 ), $length );\\n\\n\\t\\t\\tif ( \\\\T_NS_SEPARATOR !== $this->tokens[ ( $stackPtr + 2 ) ]['code'] ) {\\n\\t\\t\\t\\t$classname = $this->get_namespaced_classname( $classname, ( $stackPtr - 1 ) );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( \\\\T_DOUBLE_COLON === $token['code'] ) {\\n\\t\\t\\t$nameEnd   = $this->phpcsFile->findPrevious( \\\\T_STRING, ( $stackPtr - 1 ) );\\n\\t\\t\\t$nameStart = ( $this->phpcsFile->findPrevious( array( \\\\T_STRING, \\\\T_NS_SEPARATOR, \\\\T_NAMESPACE ), ( $nameEnd - 1 ), null, true, null, true ) + 1 );\\n\\t\\t\\t$length    = ( $nameEnd - ( $nameStart - 1 ) );\\n\\t\\t\\t$classname = $this->phpcsFile->getTokensAsString( $nameStart, $length );\\n\\n\\t\\t\\tif ( \\\\T_NS_SEPARATOR !== $this->tokens[ $nameStart ]['code'] ) {\\n\\t\\t\\t\\t$classname = $this->get_namespaced_classname( $classname, ( $nameStart - 1 ) );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Stop if we couldn't determine a classname.\\n\\t\\tif ( empty( $classname ) ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// Nothing to do if 'parent', 'self' or 'static'.\\n\\t\\tif ( \\\\in_array( $classname, array( 'parent', 'self', 'static' ), true ) ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t$this->classname = $classname;\\n\\t\\treturn true;\\n\\t}\", \"output\": \"Determine if we have a valid classname for the target token.\\n\\n@since 0.11.0 This logic was originally contained in the `process()` method.\\n\\n@param int $stackPtr The position of the current token in the stack.\\n\\n@return bool\"}"}
{"text": "{\"input\": \"Summarize the following code: public function check_for_matches( $stackPtr ) {\\n\\t\\t$skip_to = array();\\n\\n\\t\\tforeach ( $this->groups as $groupName => $group ) {\\n\\n\\t\\t\\tif ( isset( $this->excluded_groups[ $groupName ] ) ) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( preg_match( $group['regex'], $this->classname ) === 1 ) {\\n\\t\\t\\t\\t$skip_to[] = $this->process_matched_token( $stackPtr, $groupName, $this->classname );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( empty( $skip_to ) || min( $skip_to ) === 0 ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\treturn min( $skip_to );\\n\\t}\", \"output\": \"Verify if the current token is one of the targetted classes.\\n\\n@since 0.11.0 Split out from the `process()` method.\\n\\n@param int $stackPtr The position of the current token in the stack.\\n\\n@return int|void Integer stack pointer to skip forward or void to continue\\nnormal file processing.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function get_namespaced_classname( $classname, $search_from ) {\\n\\t\\t// Don't do anything if this is already a fully qualified classname.\\n\\t\\tif ( empty( $classname ) || '\\\\\\\\' === $classname[0] ) {\\n\\t\\t\\treturn $classname;\\n\\t\\t}\\n\\n\\t\\t// Remove the namespace keyword if used.\\n\\t\\tif ( 0 === strpos( $classname, 'namespace\\\\\\\\' ) ) {\\n\\t\\t\\t$classname = substr( $classname, 10 );\\n\\t\\t}\\n\\n\\t\\t$namespace_keyword = $this->phpcsFile->findPrevious( \\\\T_NAMESPACE, $search_from );\\n\\t\\tif ( false === $namespace_keyword ) {\\n\\t\\t\\t// No namespace keyword found at all, so global namespace.\\n\\t\\t\\t$classname = '\\\\\\\\' . $classname;\\n\\t\\t} else {\\n\\t\\t\\t$namespace = $this->determine_namespace( $search_from );\\n\\n\\t\\t\\tif ( ! empty( $namespace ) ) {\\n\\t\\t\\t\\t$classname = '\\\\\\\\' . $namespace . '\\\\\\\\' . $classname;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// No actual namespace found, so global namespace.\\n\\t\\t\\t\\t$classname = '\\\\\\\\' . $classname;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn $classname;\\n\\t}\", \"output\": \"See if the classname was found in a namespaced file and if so, add the namespace to the classname.\\n\\n@param string $classname   The full classname as found.\\n@param int    $search_from The token position to search up from.\\n@return string Classname, potentially prefixed with the namespace.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function register() {\\n\\t\\t$this->assignment_tokens = Tokens::$assignmentTokens;\\n\\t\\tunset( $this->assignment_tokens[ \\\\T_DOUBLE_ARROW ] );\\n\\n\\t\\t$starters                        = Tokens::$booleanOperators;\\n\\t\\t$starters[ \\\\T_SEMICOLON ]        = \\\\T_SEMICOLON;\\n\\t\\t$starters[ \\\\T_OPEN_PARENTHESIS ] = \\\\T_OPEN_PARENTHESIS;\\n\\t\\t$starters[ \\\\T_INLINE_ELSE ]      = \\\\T_INLINE_ELSE;\\n\\n\\t\\t$this->condition_start_tokens = $starters;\\n\\n\\t\\treturn array(\\n\\t\\t\\t\\\\T_IF,\\n\\t\\t\\t\\\\T_ELSEIF,\\n\\t\\t\\t\\\\T_FOR,\\n\\t\\t\\t\\\\T_SWITCH,\\n\\t\\t\\t\\\\T_CASE,\\n\\t\\t\\t\\\\T_WHILE,\\n\\t\\t\\t\\\\T_INLINE_THEN,\\n\\t\\t);\\n\\t}\", \"output\": \"Registers the tokens that this sniff wants to listen for.\\n\\n@since 0.14.0\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: public function execute($queue)\\n    {\\n        $serializer = new Serializer();\\n        $closure = $serializer->unserialize($this->serialized);\\n        return $closure();\\n    }\", \"output\": \"Unserializes and executes a closure.\\n@inheritdoc\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function reserve($timeout)\\n    {\\n        $response = $this->getClient()->receiveMessage([\\n            'QueueUrl' => $this->url,\\n            'AttributeNames' => ['ApproximateReceiveCount'],\\n            'MessageAttributeNames' => ['TTR'],\\n            'MaxNumberOfMessages' => 1,\\n            'VisibilityTimeout' => $this->ttr,\\n            'WaitTimeSeconds' => $timeout,\\n        ]);\\n        if (!$response['Messages']) {\\n            return null;\\n        }\\n\\n        $payload = reset($response['Messages']);\\n\\n        $ttr = (int) $payload['MessageAttributes']['TTR']['StringValue'];\\n        if ($ttr != $this->ttr) {\\n            $this->getClient()->changeMessageVisibility([\\n                'QueueUrl' => $this->url,\\n                'ReceiptHandle' => $payload['ReceiptHandle'],\\n                'VisibilityTimeout' => $ttr,\\n            ]);\\n        }\\n\\n        return $payload;\\n    }\", \"output\": \"Gets a single message from SQS queue and sets the visibility to reserve message.\\n\\n@param int $timeout number of seconds for long polling. Must be between 0 and 20.\\n@return null|array payload.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function close()\\n    {\\n        if (!$this->context) {\\n            return;\\n        }\\n\\n        $this->context->close();\\n        $this->context = null;\\n        $this->setupBrokerDone = false;\\n    }\", \"output\": \"Closes connection and channel.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function validateNamespace($attribute)\\n    {\\n        $value = $this->$attribute;\\n        $value = ltrim($value, '\\\\\\\\');\\n        $path = Yii::getAlias('@' . str_replace('\\\\\\\\', '/', $value), false);\\n        if ($path === false) {\\n            $this->addError($attribute, 'Namespace must be associated with an existing directory.');\\n        }\\n    }\", \"output\": \"Validates the namespace.\\n\\n@param string $attribute Namespace attribute name.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function push($job)\\n    {\\n        $event = new PushEvent([\\n            'job' => $job,\\n            'ttr' => $this->pushTtr ?: (\\n                $job instanceof RetryableJobInterface\\n                    ? $job->getTtr()\\n                    : $this->ttr\\n            ),\\n            'delay' => $this->pushDelay ?: 0,\\n            'priority' => $this->pushPriority,\\n        ]);\\n        $this->pushTtr = null;\\n        $this->pushDelay = null;\\n        $this->pushPriority = null;\\n\\n        $this->trigger(self::EVENT_BEFORE_PUSH, $event);\\n        if ($event->handled) {\\n            return null;\\n        }\\n\\n        if ($this->strictJobType && !($event->job instanceof JobInterface)) {\\n            throw new InvalidArgumentException('Job must be instance of JobInterface.');\\n        }\\n\\n        if (!is_numeric($event->ttr)) {\\n            throw new InvalidArgumentException('Job TTR must be integer.');\\n        }\\n        $event->ttr = (int) $event->ttr;\\n        if ($event->ttr <= 0) {\\n            throw new InvalidArgumentException('Job TTR must be greater that zero.');\\n        }\\n\\n        if (!is_numeric($event->delay)) {\\n            throw new InvalidArgumentException('Job delay must be integer.');\\n        }\\n        $event->delay = (int) $event->delay;\\n        if ($event->delay < 0) {\\n            throw new InvalidArgumentException('Job delay must be positive.');\\n        }\\n\\n        $message = $this->serializer->serialize($event->job);\\n        $event->id = $this->pushMessage($message, $event->ttr, $event->delay, $event->priority);\\n        $this->trigger(self::EVENT_AFTER_PUSH, $event);\\n\\n        return $event->id;\\n    }\", \"output\": \"Pushes job into queue.\\n\\n@param JobInterface|mixed $job\\n@return string|null id of a job message\"}"}
{"text": "{\"input\": \"Summarize the following code: public function actionListen($timeout = 3)\\n    {\\n        if (!is_numeric($timeout)) {\\n            throw new Exception('Timeout must be numeric.');\\n        }\\n        if ($timeout < 1) {\\n            throw new Exception('Timeout must be greater than zero.');\\n        }\\n\\n        return $this->queue->run(true, $timeout);\\n    }\", \"output\": \"Listens file-queue and runs new jobs.\\nIt can be used as daemon process.\\n\\n@param int $timeout number of seconds to sleep before next reading of the queue.\\n@throws Exception when params are invalid.\\n@return null|int exit code.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function actionExec($id, $ttr, $attempt, $pid)\\n    {\\n        if ($this->queue->execute($id, file_get_contents('php://stdin'), $ttr, $attempt, $pid ?: null)) {\\n            return self::EXEC_DONE;\\n        }\\n        return self::EXEC_RETRY;\\n    }\", \"output\": \"Executes a job.\\nThe command is internal, and used to isolate a job execution. Manual usage is not provided.\\n\\n@param string|null $id of a message\\n@param int $ttr time to reserve\\n@param int $attempt number\\n@param int $pid of a worker\\n@return int exit code\\n@internal It is used with isolate mode.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function handleMessage($id, $message, $ttr, $attempt)\\n    {\\n        // Child process command: php yii queue/exec \\\"id\\\" \\\"ttr\\\" \\\"attempt\\\" \\\"pid\\\"\\n        $cmd = [\\n            $this->phpBinary,\\n            $_SERVER['SCRIPT_FILENAME'],\\n            $this->uniqueId . '/exec',\\n            $id,\\n            $ttr,\\n            $attempt,\\n            $this->queue->getWorkerPid() ?: 0,\\n        ];\\n\\n        foreach ($this->getPassedOptions() as $name) {\\n            if (in_array($name, $this->options('exec'), true)) {\\n                $cmd[] = '--' . $name . '=' . $this->$name;\\n            }\\n        }\\n        if (!in_array('color', $this->getPassedOptions(), true)) {\\n            $cmd[] = '--color=' . $this->isColorEnabled();\\n        }\\n\\n        $process = new Process($cmd, null, null, $message, $ttr);\\n        try {\\n            $result = $process->run(function ($type, $buffer) {\\n                if ($type === Process::ERR) {\\n                    $this->stderr($buffer);\\n                } else {\\n                    $this->stdout($buffer);\\n                }\\n            });\\n            if (!in_array($result, [self::EXEC_DONE, self::EXEC_RETRY])) {\\n                throw new ProcessFailedException($process);\\n            }\\n            return $result === self::EXEC_DONE;\\n        } catch (ProcessRuntimeException $error) {\\n            list($job) = $this->queue->unserializeMessage($message);\\n            return $this->queue->handleError(new ExecEvent([\\n                'id' => $id,\\n                'job' => $job,\\n                'ttr' => $ttr,\\n                'attempt' => $attempt,\\n                'error' => $error,\\n            ]));\\n        }\\n    }\", \"output\": \"Handles message using child process.\\n\\n@param string|null $id of a message\\n@param string $message\\n@param int $ttr time to reserve\\n@param int $attempt number\\n@return bool\\n@throws\\n@see actionExec()\"}"}
{"text": "{\"input\": \"Summarize the following code: public function run()\\n    {\\n        while (($payload = array_shift($this->payloads)) !== null) {\\n            list($ttr, $message) = $payload;\\n            $this->startedId = $this->finishedId + 1;\\n            $this->handleMessage($this->startedId, $message, $ttr, 1);\\n            $this->finishedId = $this->startedId;\\n            $this->startedId = 0;\\n        }\\n    }\", \"output\": \"Runs all jobs from queue.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function reserve()\\n    {\\n        return $this->db->useMaster(function () {\\n            if (!$this->mutex->acquire(__CLASS__ . $this->channel, $this->mutexTimeout)) {\\n                throw new Exception('Has not waited the lock.');\\n            }\\n\\n            try {\\n                $this->moveExpired();\\n\\n                // Reserve one message\\n                $payload = (new Query())\\n                    ->from($this->tableName)\\n                    ->andWhere(['channel' => $this->channel, 'reserved_at' => null])\\n                    ->andWhere('[[pushed_at]] <= :time - [[delay]]', [':time' => time()])\\n                    ->orderBy(['priority' => SORT_ASC, 'id' => SORT_ASC])\\n                    ->limit(1)\\n                    ->one($this->db);\\n                if (is_array($payload)) {\\n                    $payload['reserved_at'] = time();\\n                    $payload['attempt'] = (int) $payload['attempt'] + 1;\\n                    $this->db->createCommand()->update($this->tableName, [\\n                        'reserved_at' => $payload['reserved_at'],\\n                        'attempt' => $payload['attempt'],\\n                    ], [\\n                        'id' => $payload['id'],\\n                    ])->execute();\\n\\n                    // pgsql\\n                    if (is_resource($payload['job'])) {\\n                        $payload['job'] = stream_get_contents($payload['job']);\\n                    }\\n                }\\n            } finally {\\n                $this->mutex->release(__CLASS__ . $this->channel);\\n            }\\n\\n            return $payload;\\n        });\\n    }\", \"output\": \"Takes one message from waiting list and reserves it for handling.\\n\\n@return array|false payload\\n@throws Exception in case it hasn't waited the lock\"}"}
{"text": "{\"input\": \"Summarize the following code: private function moveExpired()\\n    {\\n        if ($this->reserveTime !== time()) {\\n            $this->reserveTime = time();\\n            $this->db->createCommand()->update(\\n                $this->tableName,\\n                ['reserved_at' => null],\\n                '[[reserved_at]] < :time - [[ttr]] and [[done_at]] is null',\\n                [':time' => $this->reserveTime]\\n            )->execute();\\n        }\\n    }\", \"output\": \"Moves expired messages into waiting list.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function beforePush(PushEvent $event)\\n    {\\n        if ($event->job instanceof \\\\Closure) {\\n            $serializer = new Serializer();\\n            $serialized = $serializer->serialize($event->job);\\n            $event->job = new Job();\\n            $event->job->serialized = $serialized;\\n        }\\n    }\", \"output\": \"Converts the closure to a job object.\\n@param PushEvent $event\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function delete($id)\\n    {\\n        $this->redis->zrem(\\\"$this->channel.reserved\\\", $id);\\n        $this->redis->hdel(\\\"$this->channel.attempts\\\", $id);\\n        $this->redis->hdel(\\\"$this->channel.messages\\\", $id);\\n    }\", \"output\": \"Deletes message by ID.\\n\\n@param int $id of a message\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function runWorker(callable $handler)\\n    {\\n        $this->_workerPid = getmypid();\\n        /** @var LoopInterface $loop */\\n        $loop = Yii::createObject($this->loopConfig, [$this]);\\n\\n        $event = new WorkerEvent(['loop' => $loop]);\\n        $this->trigger(self::EVENT_WORKER_START, $event);\\n        if ($event->exitCode !== null) {\\n            return $event->exitCode;\\n        }\\n\\n        $exitCode = null;\\n        try {\\n            call_user_func($handler, function () use ($loop, $event) {\\n                $this->trigger(self::EVENT_WORKER_LOOP, $event);\\n                return $event->exitCode === null && $loop->canContinue();\\n            });\\n        } finally {\\n            $this->trigger(self::EVENT_WORKER_STOP, $event);\\n            $this->_workerPid = null;\\n        }\\n\\n        return $event->exitCode;\\n    }\", \"output\": \"Runs worker.\\n\\n@param callable $handler\\n@return null|int exit code\\n@since 2.0.2\"}"}
{"text": "{\"input\": \"Summarize the following code: public function handle($id, $message, $ttr, $attempt)\\n    {\\n        return $this->handleMessage($id, $message, $ttr, $attempt);\\n    }\", \"output\": \"Provides public access for `handleMessage`\\n\\n@param $id string\\n@param $message string\\n@param $ttr int\\n@param $attempt int\\n@return bool\\n@since 2.0.2\"}"}
{"text": "{\"input\": \"Summarize the following code: public function init()\\n    {\\n        parent::init();\\n        if (extension_loaded('pcntl')) {\\n            foreach ($this->exitSignals as $signal) {\\n                pcntl_signal($signal, function () {\\n                    self::$exit = true;\\n                });\\n            }\\n            foreach ($this->suspendSignals as $signal) {\\n                pcntl_signal($signal, function () {\\n                    self::$pause = true;\\n                });\\n            }\\n            foreach ($this->resumeSignals as $signal) {\\n                pcntl_signal($signal, function () {\\n                    self::$pause = false;\\n                });\\n            }\\n        }\\n    }\", \"output\": \"Sets signal handlers.\\n\\n@inheritdoc\"}"}
{"text": "{\"input\": \"Summarize the following code: public function canContinue()\\n    {\\n        if (extension_loaded('pcntl')) {\\n            pcntl_signal_dispatch();\\n            // Wait for resume signal until loop is suspended\\n            while (self::$pause && !self::$exit) {\\n                usleep(10000);\\n                pcntl_signal_dispatch();\\n            }\\n        }\\n\\n        return !self::$exit;\\n    }\", \"output\": \"Checks signals state.\\n\\n@inheritdoc\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function reserve()\\n    {\\n        $id = null;\\n        $ttr = null;\\n        $attempt = null;\\n        $this->touchIndex(function (&$data) use (&$id, &$ttr, &$attempt) {\\n            if (!empty($data['reserved'])) {\\n                foreach ($data['reserved'] as $key => $payload) {\\n                    if ($payload[1] + $payload[3] < time()) {\\n                        list($id, $ttr, $attempt, $time) = $payload;\\n                        $data['reserved'][$key][2] = ++$attempt;\\n                        $data['reserved'][$key][3] = time();\\n                        return;\\n                    }\\n                }\\n            }\\n\\n            if (!empty($data['delayed']) && $data['delayed'][0][2] <= time()) {\\n                list($id, $ttr, $time) = array_shift($data['delayed']);\\n            } elseif (!empty($data['waiting'])) {\\n                list($id, $ttr) = array_shift($data['waiting']);\\n            }\\n            if ($id) {\\n                $attempt = 1;\\n                $data['reserved'][\\\"job$id\\\"] = [$id, $ttr, $attempt, time()];\\n            }\\n        });\\n\\n        if ($id) {\\n            return [$id, file_get_contents(\\\"$this->path/job$id.data\\\"), $ttr, $attempt];\\n        }\\n\\n        return null;\\n    }\", \"output\": \"Reserves message for execute.\\n\\n@return array|null payload\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function delete($payload)\\n    {\\n        $id = $payload[0];\\n        $this->touchIndex(function (&$data) use ($id) {\\n            foreach ($data['reserved'] as $key => $payload) {\\n                if ($payload[0] === $id) {\\n                    unset($data['reserved'][$key]);\\n                    break;\\n                }\\n            }\\n        });\\n        unlink(\\\"$this->path/job$id.data\\\");\\n    }\", \"output\": \"Deletes reserved message.\\n\\n@param array $payload\"}"}
{"text": "{\"input\": \"Summarize the following code: public function parse(): array\\n    {\\n        $previousEntityState = libxml_disable_entity_loader(true);\\n        $previousSetting = libxml_use_internal_errors(true);\\n\\n        try {\\n            while (self::ELEMENT !== $this->nodeType) {\\n                if (!$this->read()) {\\n                    $errors = libxml_get_errors();\\n                    libxml_clear_errors();\\n                    if ($errors) {\\n                        throw new LibXMLException($errors);\\n                    }\\n                }\\n            }\\n            $result = $this->parseCurrentElement();\\n\\n            // last line of defense in case errors did occur above\\n            $errors = libxml_get_errors();\\n            libxml_clear_errors();\\n            if ($errors) {\\n                throw new LibXMLException($errors);\\n            }\\n        } finally {\\n            libxml_use_internal_errors($previousSetting);\\n            libxml_disable_entity_loader($previousEntityState);\\n        }\\n\\n        return $result;\\n    }\", \"output\": \"Reads the entire document.\\n\\nThis function returns an array with the following three elements:\\n* name - The root element name.\\n* value - The value for the root element.\\n* attributes - An array of attributes.\\n\\nThis function will also disable the standard libxml error handler (which\\nusually just results in PHP errors), and throw exceptions instead.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function parseGetElements(array $elementMap = null): array\\n    {\\n        $result = $this->parseInnerTree($elementMap);\\n        if (!is_array($result)) {\\n            return [];\\n        }\\n\\n        return $result;\\n    }\", \"output\": \"parseGetElements parses everything in the current sub-tree,\\nand returns a an array of elements.\\n\\nEach element has a 'name', 'value' and 'attributes' key.\\n\\nIf the the element didn't contain sub-elements, an empty array is always\\nreturned. If there was any text inside the element, it will be\\ndiscarded.\\n\\nIf the $elementMap argument is specified, the existing elementMap will\\nbe overridden while parsing the tree, and restored after this process.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function parseInnerTree(array $elementMap = null)\\n    {\\n        $text = null;\\n        $elements = [];\\n\\n        if (self::ELEMENT === $this->nodeType && $this->isEmptyElement) {\\n            // Easy!\\n            $this->next();\\n\\n            return null;\\n        }\\n\\n        if (!is_null($elementMap)) {\\n            $this->pushContext();\\n            $this->elementMap = $elementMap;\\n        }\\n\\n        try {\\n            if (!$this->read()) {\\n                $errors = libxml_get_errors();\\n                libxml_clear_errors();\\n                if ($errors) {\\n                    throw new LibXMLException($errors);\\n                }\\n                throw new ParseException('This should never happen (famous last words)');\\n            }\\n\\n            while (true) {\\n                if (!$this->isValid()) {\\n                    $errors = libxml_get_errors();\\n\\n                    if ($errors) {\\n                        libxml_clear_errors();\\n                        throw new LibXMLException($errors);\\n                    }\\n                }\\n\\n                switch ($this->nodeType) {\\n                    case self::ELEMENT:\\n                        $elements[] = $this->parseCurrentElement();\\n                        break;\\n                    case self::TEXT:\\n                    case self::CDATA:\\n                        $text .= $this->value;\\n                        $this->read();\\n                        break;\\n                    case self::END_ELEMENT:\\n                        // Ensuring we are moving the cursor after the end element.\\n                        $this->read();\\n                        break 2;\\n                    case self::NONE:\\n                        throw new ParseException('We hit the end of the document prematurely. This likely means that some parser \\\"eats\\\" too many elements. Do not attempt to continue parsing.');\\n                    default:\\n                        // Advance to the next element\\n                        $this->read();\\n                        break;\\n                }\\n            }\\n        } finally {\\n            if (!is_null($elementMap)) {\\n                $this->popContext();\\n            }\\n        }\\n\\n        return $elements ? $elements : $text;\\n    }\", \"output\": \"Parses all elements below the current element.\\n\\nThis method will return a string if this was a text-node, or an array if\\nthere were sub-elements.\\n\\nIf there's both text and sub-elements, the text will be discarded.\\n\\nIf the $elementMap argument is specified, the existing elementMap will\\nbe overridden while parsing the tree, and restored after this process.\\n\\n@return array|string|null\"}"}
{"text": "{\"input\": \"Summarize the following code: public function readText(): string\\n    {\\n        $result = '';\\n        $previousDepth = $this->depth;\\n\\n        while ($this->read() && $this->depth != $previousDepth) {\\n            if (in_array($this->nodeType, [XMLReader::TEXT, XMLReader::CDATA, XMLReader::WHITESPACE])) {\\n                $result .= $this->value;\\n            }\\n        }\\n\\n        return $result;\\n    }\", \"output\": \"Reads all text below the current element, and returns this as a string.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function parseCurrentElement(): array\\n    {\\n        $name = $this->getClark();\\n\\n        $attributes = [];\\n\\n        if ($this->hasAttributes) {\\n            $attributes = $this->parseAttributes();\\n        }\\n\\n        $value = call_user_func(\\n            $this->getDeserializerForElementName((string) $name),\\n            $this\\n        );\\n\\n        return [\\n            'name' => $name,\\n            'value' => $value,\\n            'attributes' => $attributes,\\n        ];\\n    }\", \"output\": \"Parses the current XML element.\\n\\nThis method returns arn array with 3 properties:\\n* name - A clark-notation XML element name.\\n* value - The parsed value.\\n* attributes - A key-value list of attributes.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function parseAttributes(): array\\n    {\\n        $attributes = [];\\n\\n        while ($this->moveToNextAttribute()) {\\n            if ($this->namespaceURI) {\\n                // Ignoring 'xmlns', it doesn't make any sense.\\n                if ('http://www.w3.org/2000/xmlns/' === $this->namespaceURI) {\\n                    continue;\\n                }\\n\\n                $name = $this->getClark();\\n                $attributes[$name] = $this->value;\\n            } else {\\n                $attributes[$this->localName] = $this->value;\\n            }\\n        }\\n        $this->moveToElement();\\n\\n        return $attributes;\\n    }\", \"output\": \"Grabs all the attributes from the current element, and returns them as a\\nkey-value array.\\n\\nIf the attributes are part of the same namespace, they will simply be\\nshort keys. If they are defined on a different namespace, the attribute\\nname will be retured in clark-notation.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getDeserializerForElementName(string $name): callable\\n    {\\n        if (!array_key_exists($name, $this->elementMap)) {\\n            if ('{}' == substr($name, 0, 2) && array_key_exists(substr($name, 2), $this->elementMap)) {\\n                $name = substr($name, 2);\\n            } else {\\n                return ['Sabre\\\\\\\\Xml\\\\\\\\Element\\\\\\\\Base', 'xmlDeserialize'];\\n            }\\n        }\\n\\n        $deserializer = $this->elementMap[$name];\\n        if (is_subclass_of($deserializer, 'Sabre\\\\\\\\Xml\\\\\\\\XmlDeserializable')) {\\n            return [$deserializer, 'xmlDeserialize'];\\n        }\\n\\n        if (is_callable($deserializer)) {\\n            return $deserializer;\\n        }\\n\\n        $type = gettype($deserializer);\\n        if ('string' === $type) {\\n            $type .= ' ('.$deserializer.')';\\n        } elseif ('object' === $type) {\\n            $type .= ' ('.get_class($deserializer).')';\\n        }\\n        throw new \\\\LogicException('Could not use this type as a deserializer: '.$type.' for element: '.$name);\\n    }\", \"output\": \"Returns the function that should be used to parse the element identified\\nby it's clark-notation name.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function pushContext()\\n    {\\n        $this->contextStack[] = [\\n            $this->elementMap,\\n            $this->contextUri,\\n            $this->namespaceMap,\\n            $this->classMap,\\n        ];\\n    }\", \"output\": \"Create a new \\\"context\\\".\\n\\nThis allows you to safely modify the elementMap, contextUri or\\nnamespaceMap. After you're done, you can restore the old data again\\nwith popContext.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function popContext()\\n    {\\n        list(\\n            $this->elementMap,\\n            $this->contextUri,\\n            $this->namespaceMap,\\n            $this->classMap\\n        ) = array_pop($this->contextStack);\\n    }\", \"output\": \"Restore the previous \\\"context\\\".\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getWriter(): Writer\\n    {\\n        $w = new Writer();\\n        $w->namespaceMap = $this->namespaceMap;\\n        $w->classMap = $this->classMap;\\n\\n        return $w;\\n    }\", \"output\": \"Returns a fresh xml writer.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function parse($input, string $contextUri = null, string &$rootElementName = null)\\n    {\\n        if (is_resource($input)) {\\n            // Unfortunately the XMLReader doesn't support streams. When it\\n            // does, we can optimize this.\\n            $input = (string) stream_get_contents($input);\\n        }\\n        $r = $this->getReader();\\n        $r->contextUri = $contextUri;\\n        $r->XML($input, null, $this->options);\\n\\n        $result = $r->parse();\\n        $rootElementName = $result['name'];\\n\\n        return $result['value'];\\n    }\", \"output\": \"Parses a document in full.\\n\\nInput may be specified as a string or readable stream resource.\\nThe returned value is the value of the root document.\\n\\nSpecifying the $contextUri allows the parser to figure out what the URI\\nof the document was. This allows relative URIs within the document to be\\nexpanded easily.\\n\\nThe $rootElementName is specified by reference and will be populated\\nwith the root element name of the document.\\n\\n@param string|resource $input\\n\\n@throws ParseException\\n\\n@return array|object|string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function expect($rootElementName, $input, string $contextUri = null)\\n    {\\n        if (is_resource($input)) {\\n            // Unfortunately the XMLReader doesn't support streams. When it\\n            // does, we can optimize this.\\n            $input = (string) stream_get_contents($input);\\n        }\\n        $r = $this->getReader();\\n        $r->contextUri = $contextUri;\\n        $r->XML($input, null, $this->options);\\n\\n        $rootElementName = (array) $rootElementName;\\n\\n        foreach ($rootElementName as &$rEl) {\\n            if ('{' !== $rEl[0]) {\\n                $rEl = '{}'.$rEl;\\n            }\\n        }\\n\\n        $result = $r->parse();\\n        if (!in_array($result['name'], $rootElementName, true)) {\\n            throw new ParseException('Expected '.implode(' or ', $rootElementName).' but received '.$result['name'].' as the root element');\\n        }\\n\\n        return $result['value'];\\n    }\", \"output\": \"Parses a document in full, and specify what the expected root element\\nname is.\\n\\nThis function works similar to parse, but the difference is that the\\nuser can specify what the expected name of the root element should be,\\nin clark notation.\\n\\nThis is useful in cases where you expected a specific document to be\\npassed, and reduces the amount of if statements.\\n\\nIt's also possible to pass an array of expected rootElements if your\\ncode may expect more than one document type.\\n\\n@param string|string[] $rootElementName\\n@param string|resource $input\\n@param string|null     $contextUri\\n\\n@throws ParseException\\n\\n@return array|object|string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function write(string $rootElementName, $value, string $contextUri = null)\\n    {\\n        $w = $this->getWriter();\\n        $w->openMemory();\\n        $w->contextUri = $contextUri;\\n        $w->setIndent(true);\\n        $w->startDocument();\\n        $w->writeElement($rootElementName, $value);\\n\\n        return $w->outputMemory();\\n    }\", \"output\": \"Generates an XML document in one go.\\n\\nThe $rootElement must be specified in clark notation.\\nThe value must be a string, an array or an object implementing\\nXmlSerializable. Basically, anything that's supported by the Writer\\nobject.\\n\\n$contextUri can be used to specify a sort of 'root' of the PHP application,\\nin case the xml document is used as a http response.\\n\\nThis allows an implementor to easily create URI's relative to the root\\nof the domain.\\n\\n@param string|array|object|XmlSerializable $value\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function mapValueObject(string $elementName, string $className)\\n    {\\n        list($namespace) = self::parseClarkNotation($elementName);\\n\\n        $this->elementMap[$elementName] = function (Reader $reader) use ($className, $namespace) {\\n            return \\\\Sabre\\\\Xml\\\\Deserializer\\\\valueObject($reader, $className, $namespace);\\n        };\\n        $this->classMap[$className] = function (Writer $writer, $valueObject) use ($namespace) {\\n            return \\\\Sabre\\\\Xml\\\\Serializer\\\\valueObject($writer, $valueObject, $namespace);\\n        };\\n        $this->valueObjectMap[$className] = $elementName;\\n    }\", \"output\": \"Map an xml element to a PHP class.\\n\\nCalling this function will automatically setup the Reader and Writer\\nclasses to turn a specific XML element to a PHP class.\\n\\nFor example, given a class such as :\\n\\nclass Author {\\npublic $firstName;\\npublic $lastName;\\n}\\n\\nand an XML element such as:\\n\\n<author xmlns=\\\"http://example.org/ns\\\">\\n<firstName>...</firstName>\\n<lastName>...</lastName>\\n</author>\\n\\nThese can easily be mapped by calling:\\n\\n$service->mapValueObject('{http://example.org}author', 'Author');\"}"}
{"text": "{\"input\": \"Summarize the following code: public function writeValueObject($object, string $contextUri = null)\\n    {\\n        if (!isset($this->valueObjectMap[get_class($object)])) {\\n            throw new \\\\InvalidArgumentException('\\\"'.get_class($object).'\\\" is not a registered value object class. Register your class with mapValueObject.');\\n        }\\n\\n        return $this->write(\\n            $this->valueObjectMap[get_class($object)],\\n            $object,\\n            $contextUri\\n        );\\n    }\", \"output\": \"Writes a value object.\\n\\nThis function largely behaves similar to write(), except that it's\\nintended specifically to serialize a Value Object into an XML document.\\n\\nThe ValueObject must have been previously registered using\\nmapValueObject().\\n\\n@param object $object\\n\\n@throws \\\\InvalidArgumentException\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function parseClarkNotation(string $str): array\\n    {\\n        static $cache = [];\\n\\n        if (!isset($cache[$str])) {\\n            if (!preg_match('/^{([^}]*)}(.*)$/', $str, $matches)) {\\n                throw new \\\\InvalidArgumentException('\\\\''.$str.'\\\\' is not a valid clark-notation formatted string');\\n            }\\n\\n            $cache[$str] = [\\n                $matches[1],\\n                $matches[2],\\n            ];\\n        }\\n\\n        return $cache[$str];\\n    }\", \"output\": \"Parses a clark-notation string, and returns the namespace and element\\nname components.\\n\\nIf the string was invalid, it will throw an InvalidArgumentException.\\n\\n@throws \\\\InvalidArgumentException\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function xmlDeserialize(Reader $reader)\\n    {\\n        $result = new self($reader->readInnerXml());\\n        $reader->next();\\n\\n        return $result;\\n    }\", \"output\": \"The deserialize method is called during xml parsing.\\n\\nThis method is called statictly, this is because in theory this method\\nmay be used as a type of constructor, or factory method.\\n\\nOften you want to return an instance of the current class, but you are\\nfree to return other data as well.\\n\\nYou are responsible for advancing the reader to the next element. Not\\ndoing anything will result in a never-ending loop.\\n\\nIf you just want to skip parsing for this element altogether, you can\\njust call $reader->next();\\n\\n$reader->parseInnerTree() will parse the entire sub-tree, and advance to\\nthe next element.\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function xmlDeserialize(Xml\\\\Reader $reader)\\n    {\\n        return new self(\\n            \\\\Sabre\\\\Uri\\\\resolve(\\n                (string) $reader->contextUri,\\n                $reader->readText()\\n            )\\n        );\\n    }\", \"output\": \"This method is called during xml parsing.\\n\\nThis method is called statically, this is because in theory this method\\nmay be used as a type of constructor, or factory method.\\n\\nOften you want to return an instance of the current class, but you are\\nfree to return other data as well.\\n\\nImportant note 2: You are responsible for advancing the reader to the\\nnext element. Not doing anything will result in a never-ending loop.\\n\\nIf you just want to skip parsing for this element altogether, you can\\njust call $reader->next();\\n\\n$reader->parseSubTree() will parse the entire sub-tree, and advance to\\nthe next element.\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public function startElement($name): bool\\n    {\\n        if ('{' === $name[0]) {\\n            list($namespace, $localName) =\\n                Service::parseClarkNotation($name);\\n\\n            if (array_key_exists($namespace, $this->namespaceMap)) {\\n                $result = $this->startElementNS(\\n                    '' === $this->namespaceMap[$namespace] ? null : $this->namespaceMap[$namespace],\\n                    $localName,\\n                    null\\n                );\\n            } else {\\n                // An empty namespace means it's the global namespace. This is\\n                // allowed, but it mustn't get a prefix.\\n                if ('' === $namespace || null === $namespace) {\\n                    $result = $this->startElement($localName);\\n                    $this->writeAttribute('xmlns', '');\\n                } else {\\n                    if (!isset($this->adhocNamespaces[$namespace])) {\\n                        $this->adhocNamespaces[$namespace] = 'x'.(count($this->adhocNamespaces) + 1);\\n                    }\\n                    $result = $this->startElementNS($this->adhocNamespaces[$namespace], $localName, $namespace);\\n                }\\n            }\\n        } else {\\n            $result = parent::startElement($name);\\n        }\\n\\n        if (!$this->namespacesWritten) {\\n            foreach ($this->namespaceMap as $namespace => $prefix) {\\n                $this->writeAttribute(($prefix ? 'xmlns:'.$prefix : 'xmlns'), $namespace);\\n            }\\n            $this->namespacesWritten = true;\\n        }\\n\\n        return $result;\\n    }\", \"output\": \"Opens a new element.\\n\\nYou can either just use a local elementname, or you can use clark-\\nnotation to start a new element.\\n\\nExample:\\n\\n$writer->startElement('{http://www.w3.org/2005/Atom}entry');\\n\\nWould result in something like:\\n\\n<entry xmlns=\\\"http://w3.org/2005/Atom\\\">\\n\\nNote: this function doesn't have the string typehint, because PHP's\\nXMLWriter::startElement doesn't either.\\n\\n@param string $name\"}"}
{"text": "{\"input\": \"Summarize the following code: public function writeElement($name, $content = null): bool\\n    {\\n        $this->startElement($name);\\n        if (!is_null($content)) {\\n            $this->write($content);\\n        }\\n        $this->endElement();\\n\\n        return true;\\n    }\", \"output\": \"Write a full element tag and it's contents.\\n\\nThis method automatically closes the element as well.\\n\\nThe element name may be specified in clark-notation.\\n\\nExamples:\\n\\n$writer->writeElement('{http://www.w3.org/2005/Atom}author',null);\\nbecomes:\\n<author xmlns=\\\"http://www.w3.org/2005\\\" />\\n\\n$writer->writeElement('{http://www.w3.org/2005/Atom}author', [\\n'{http://www.w3.org/2005/Atom}name' => 'Evert Pot',\\n]);\\nbecomes:\\n<author xmlns=\\\"http://www.w3.org/2005\\\" /><name>Evert Pot</name></author>\\n\\nNote: this function doesn't have the string typehint, because PHP's\\nXMLWriter::startElement doesn't either.\\n\\n@param array|string|object|null $content\\n\\n@return bool\"}"}
{"text": "{\"input\": \"Summarize the following code: public function writeAttributes(array $attributes)\\n    {\\n        foreach ($attributes as $name => $value) {\\n            $this->writeAttribute($name, $value);\\n        }\\n    }\", \"output\": \"Writes a list of attributes.\\n\\nAttributes are specified as a key->value array.\\n\\nThe key is an attribute name. If the key is a 'localName', the current\\nxml namespace is assumed. If it's a 'clark notation key', this namespace\\nwill be used instead.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function writeAttribute($name, $value): bool\\n    {\\n        if ('{' !== $name[0]) {\\n            return parent::writeAttribute($name, $value);\\n        }\\n\\n        list(\\n            $namespace,\\n            $localName\\n        ) = Service::parseClarkNotation($name);\\n\\n        if (array_key_exists($namespace, $this->namespaceMap)) {\\n            // It's an attribute with a namespace we know\\n            return $this->writeAttribute(\\n                $this->namespaceMap[$namespace].':'.$localName,\\n                $value\\n            );\\n        }\\n\\n        // We don't know the namespace, we must add it in-line\\n        if (!isset($this->adhocNamespaces[$namespace])) {\\n            $this->adhocNamespaces[$namespace] = 'x'.(count($this->adhocNamespaces) + 1);\\n        }\\n\\n        return $this->writeAttributeNS(\\n            $this->adhocNamespaces[$namespace],\\n            $localName,\\n            $namespace,\\n            $value\\n        );\\n    }\", \"output\": \"Writes a new attribute.\\n\\nThe name may be specified in clark-notation.\\n\\nReturns true when successful.\\n\\nNote: this function doesn't have typehints, because for some reason\\nPHP's XMLWriter::writeAttribute doesn't either.\\n\\n@param string $name\\n@param string $value\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getModelRelations(string $model)\\n    {\\n        $class = new ReflectionClass($model);\\n\\n        $traitMethods = Collection::make($class->getTraits())->map(function (ReflectionClass $trait) {\\n            return Collection::make($trait->getMethods(ReflectionMethod::IS_PUBLIC));\\n        })->flatten();\\n\\n        $methods = Collection::make($class->getMethods(ReflectionMethod::IS_PUBLIC))\\n            ->merge($traitMethods)\\n            ->reject(function (ReflectionMethod $method) use ($model) {\\n                return $method->class !== $model || $method->getNumberOfParameters() > 0;\\n            });\\n\\n        $relations = Collection::make();\\n\\n        $methods->map(function (ReflectionMethod $method) use ($model, &$relations) {\\n            $relations = $relations->merge($this->getRelationshipFromMethodAndModel($method, $model));\\n        });\\n\\n        $relations = $relations->filter();\\n\\n        if ($ignoreRelations = array_get(config('erd-generator.ignore', []),$model))\\n        {\\n            $relations = $relations->diffKeys(array_flip($ignoreRelations));\\n        }\\n\\n        return $relations;\\n    }\", \"output\": \"Return all relations from a fully qualified model class name.\\n\\n@param string $model\\n@return Collection\\n@throws \\\\ReflectionException\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function validateJobName($name)\\n    {\\n        if (!$name || strlen($name) == 0) {\\n            throw new \\\\InvalidArgumentException('Please set a name.');\\n        }\\n\\n        if ($this->queryJob($name)) {\\n            throw new \\\\InvalidArgumentException('Name already in use.');\\n        }\\n\\n        return $name;\\n    }\", \"output\": \"Validate the job name.\\n\\n@param  string                    $name\\n@return string\\n@throws \\\\InvalidArgumentException\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function validateCommand($command)\\n    {\\n        $parts = explode(' ', $command);\\n        $this->getApplication()->get((string) $parts[0]);\\n\\n        return $command;\\n    }\", \"output\": \"Validate the command.\\n\\n@param  string                    $command\\n@return string\\n@throws \\\\InvalidArgumentException\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function createJob(CronJob $dbJob)\\n    {\\n        $job = new ShellJob();\\n        $job->setCommand($this->commandBuilder->build($dbJob->getCommand()), $this->rootDir);\\n        $job->setSchedule(new CrontabSchedule($dbJob->getSchedule()));\\n        $job->raw = $dbJob;\\n\\n        return $job;\\n    }\", \"output\": \"Transform a CronJon into a ShellJob.\\n\\n@param  CronJob  $dbJob\\n@return ShellJob\"}"}
{"text": "{\"input\": \"Summarize the following code: public function createScopeAndRetrieveItsCloser(?TraceContext $currentContext = null): callable\\n    {\\n        $previous = $this->context;\\n        $self = $this;\\n        $this->context = $currentContext;\\n\\n        return function () use ($previous, $self) {\\n            $self->context = $previous;\\n        };\\n    }\", \"output\": \"Sets the current span in scope until the returned callable is called. It is a programming\\nerror to drop or never close the result.\\n\\n@param TraceContext|null $currentContext\\n@return callable The scope closed\"}"}
{"text": "{\"input\": \"Summarize the following code: public function finish(?int $finishTimestamp = null): void\\n    {\\n        if ($this->finished) {\\n            return;\\n        }\\n\\n        if ($this->timestamp !== null && $finishTimestamp !== null) {\\n            $this->duration = $finishTimestamp - $this->timestamp;\\n        }\\n\\n        $this->finished = true;\\n    }\", \"output\": \"Completes and reports the span\\n\\n@param int|null $finishTimestamp\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getCurrentSpan(): ?Span\\n    {\\n        $currentContext = $this->currentTraceContext->getContext();\\n        return $currentContext === null ? null : $this->toSpan($currentContext);\\n    }\", \"output\": \"Returns the current span in scope or null if there isn't one.\\n\\n@return Span|null\"}"}
{"text": "{\"input\": \"Summarize the following code: private function toSpan(TraceContext $context): Span\\n    {\\n        if (!$this->isNoop && $context->isSampled()) {\\n            return RealSpan::create($context, $this->recorder);\\n        }\\n\\n        return NoopSpan::create($context);\\n    }\", \"output\": \"Converts the context as-is to a Span object\\n\\n@param TraceContext $context\\n@return Span\"}"}
{"text": "{\"input\": \"Summarize the following code: public function start(?int $timestamp = null): void\\n    {\\n        if ($timestamp === null) {\\n            $timestamp = now();\\n        } else {\\n            if (!isValid($timestamp)) {\\n                throw new InvalidArgumentException(\\n                    sprintf('Invalid timestamp. Expected int, got %s', $timestamp)\\n                );\\n            }\\n        }\\n\\n        $this->recorder->start($this->traceContext, $timestamp);\\n    }\", \"output\": \"Starts the span with an implicit timestamp.\\n\\nSpans can be modified before calling start. For example, you can add tags to the span and\\nset its name without lock contention.\\n\\n@param int $timestamp\\n@return void\\n@throws \\\\InvalidArgumentException\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setName(string $name): void\\n    {\\n        $this->recorder->setName($this->traceContext, $name);\\n    }\", \"output\": \"Sets the string name for the logical operation this span represents.\\n\\n@param string $name\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: public function annotate(string $value, ?int $timestamp = null): void\\n    {\\n        if (!isValid($timestamp)) {\\n            throw new InvalidArgumentException(\\n                sprintf('Valid timestamp represented microtime expected, got \\\\'%s\\\\'', $timestamp)\\n            );\\n        }\\n\\n        $this->recorder->annotate($this->traceContext, $timestamp, $value);\\n    }\", \"output\": \"Associates an event that explains latency with the current system time.\\n\\n@param string $value A short tag indicating the event, like \\\"finagle.retry\\\"\\n@param int|null $timestamp\\n@return void\\n@throws \\\\InvalidArgumentException\\n@see Zipkin\\\\Annotations\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setRemoteEndpoint(Endpoint $remoteEndpoint): void\\n    {\\n        $this->recorder->setRemoteEndpoint($this->traceContext, $remoteEndpoint);\\n    }\", \"output\": \"For a client span, this would be the server's address.\\n\\nIt is often expensive to derive a remote address: always check {@link #isNoop()} first!\\n\\n@param Endpoint $remoteEndpoint\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: public function generateNewToken(ServerRequestInterface $request)\\n    {\\n        \\n        $pair = $this->generateToken();\\n\\n        $request = $this->attachRequestAttributes($request, $pair);\\n\\n        return $request;\\n    }\", \"output\": \"Generates a new CSRF token and attaches it to the Request Object\\n\\n@param  ServerRequestInterface $request PSR7 response object.\\n\\n@return ServerRequestInterface PSR7 response object.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function getFromStorage($name)\\n    {\\n        return isset($this->storage[$name]) ? $this->storage[$name] : false;\\n    }\", \"output\": \"Get token from storage\\n\\n@param  string      $name CSRF token name\\n\\n@return string|bool CSRF token value or `false` if not present\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function getLastKeyPair()\\n    {\\n        // Use count, since empty ArrayAccess objects can still return false for `empty`\\n        if (count($this->storage) < 1) {\\n            return null;\\n        }\\n\\n        foreach ($this->storage as $name => $value) {\\n            continue;\\n        }\\n\\n        $keyPair = [\\n            $this->prefix . '_name' => $name,\\n            $this->prefix . '_value' => $value\\n        ];\\n\\n        return $keyPair;\\n    }\", \"output\": \"Get the most recent key pair from storage.\\n\\n@return string[]|null Array containing name and value if found, null otherwise\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function enforceStorageLimit()\\n    {\\n        if ($this->storageLimit < 1) {\\n            return;\\n        }\\n\\n        // $storage must be an array or implement Countable and Traversable\\n        if (!is_array($this->storage)\\n            && !($this->storage instanceof Countable && $this->storage instanceof Traversable)\\n        ) {\\n            return;\\n        }\\n\\n        if (is_array($this->storage)) {\\n            while (count($this->storage) > $this->storageLimit) {\\n                array_shift($this->storage);\\n            }\\n        } else {\\n            // array_shift() doesn't work for ArrayAccess, so we need an iterator in order to use rewind()\\n            // and key(), so that we can then unset\\n            $iterator = $this->storage;\\n            if ($this->storage instanceof \\\\IteratorAggregate) {\\n                $iterator = $this->storage->getIterator();\\n            }\\n            while (count($this->storage) > $this->storageLimit) {\\n                $iterator->rewind();\\n                unset($this->storage[$iterator->key()]);\\n            }\\n        }\\n    }\", \"output\": \"Remove the oldest tokens from the storage array so that there\\nare never more than storageLimit tokens in the array.\\n\\nThis is required as a token is generated every request and so\\nmost will never be used.\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function create(array $config): SanitizerInterface\\n    {\\n        $builder = new SanitizerBuilder();\\n        $builder->registerExtension(new BasicExtension());\\n        $builder->registerExtension(new ListExtension());\\n        $builder->registerExtension(new ImageExtension());\\n        $builder->registerExtension(new CodeExtension());\\n        $builder->registerExtension(new TableExtension());\\n        $builder->registerExtension(new IframeExtension());\\n        $builder->registerExtension(new DetailsExtension());\\n        $builder->registerExtension(new ExtraExtension());\\n\\n        return $builder->build($config);\\n    }\", \"output\": \"Quickly create an already configured sanitizer using the default builder.\\n\\n@param array $config\\n\\n@return SanitizerInterface\"}"}
{"text": "{\"input\": \"Summarize the following code: private function setAttributes(\\\\DOMNode $domNode, TagNodeInterface $node, array $allowedAttributes = [])\\n    {\\n        if (!\\\\count($domNode->attributes)) {\\n            return;\\n        }\\n\\n        /** @var \\\\DOMAttr $attribute */\\n        foreach ($domNode->attributes as $attribute) {\\n            $name = strtolower($attribute->name);\\n\\n            if (\\\\in_array($name, $allowedAttributes, true)) {\\n                $node->setAttribute($name, $attribute->value);\\n            }\\n        }\\n    }\", \"output\": \"Set attributes from a DOM node to a sanitized node.\\n\\n@param \\\\DOMNode         $domNode\\n@param TagNodeInterface $node\\n@param array            $allowedAttributes\"}"}
{"text": "{\"input\": \"Summarize the following code: private function getAttribute(\\\\DOMNode $domNode, string $name): ?string\\n    {\\n        if (!\\\\count($domNode->attributes)) {\\n            return null;\\n        }\\n\\n        /** @var \\\\DOMAttr $attribute */\\n        foreach ($domNode->attributes as $attribute) {\\n            if ($attribute->name === $name) {\\n                return $attribute->value;\\n            }\\n        }\\n\\n        return null;\\n    }\", \"output\": \"Read the value of a DOMNode attribute.\\n\\n@param \\\\DOMNode $domNode\\n@param string   $name\\n\\n@return null|string\"}"}
{"text": "{\"input\": \"Summarize the following code: private function processDefaultEntity(array $backendConfig)\\n    {\\n        $entityNames = \\\\array_keys($backendConfig['entities']);\\n        $firstEntityName = $entityNames[0] ?? null;\\n        $backendConfig['default_entity_name'] = $firstEntityName;\\n\\n        return $backendConfig;\\n    }\", \"output\": \"Finds the default entity to display when the backend index is not\\ndefined explicitly.\\n\\n@param array $backendConfig\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: private function processDefaultMenuItem(array $backendConfig)\\n    {\\n        $defaultMenuItem = $this->findDefaultMenuItem($backendConfig['design']['menu']);\\n\\n        if ('empty' === $defaultMenuItem['type']) {\\n            throw new \\\\RuntimeException(\\\\sprintf('The \\\"menu\\\" configuration sets \\\"%s\\\" as the default item, which is not possible because its type is \\\"empty\\\" and it cannot redirect to a valid URL.', $defaultMenuItem['label']));\\n        }\\n\\n        $backendConfig['default_menu_item'] = $defaultMenuItem;\\n\\n        return $backendConfig;\\n    }\", \"output\": \"Finds the default menu item to display when browsing the backend index.\\n\\n@param array $backendConfig\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function getTypeName($typeFqcn)\\n    {\\n        // needed to avoid collisions between immutable and non-immutable date types,\\n        // which are mapped to the same Symfony Form type classes\\n        $filteredNameToClassMap = \\\\array_filter(self::$nameToClassMap, function ($typeName) {\\n            return !\\\\in_array($typeName, ['datetime_immutable', 'date_immutable', 'time_immutable']);\\n        }, ARRAY_FILTER_USE_KEY);\\n        $classToNameMap = \\\\array_flip($filteredNameToClassMap);\\n\\n        return $classToNameMap[$typeFqcn] ?? $typeFqcn;\\n    }\", \"output\": \"It returns the short type name of the given FQCN. If the type name is not\\nfound, it returns the given value.\\n\\n@param string $typeFqcn\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: private function getFormTypeOptionsOfProperty(array $mergedConfig, array $guessedConfig, array $userDefinedConfig)\\n    {\\n        $resolvedFormOptions = $mergedConfig['type_options'];\\n\\n        // if the user has defined a 'type', the type options\\n        // must be reset so they don't get mixed with the form components guess.\\n        // Only the 'required' and user defined option are kept\\n        if (\\n            isset($userDefinedConfig['type'], $guessedConfig['fieldType'])\\n            && $userDefinedConfig['type'] !== $guessedConfig['fieldType']\\n        ) {\\n            $resolvedFormOptions = \\\\array_merge(\\n                \\\\array_intersect_key($resolvedFormOptions, ['required' => null]),\\n                isset($userDefinedConfig['type_options']) ? $userDefinedConfig['type_options'] : []\\n            );\\n        }\\n        // if the user has defined the \\\"type\\\" or \\\"type_options\\\"\\n        // AND the \\\"type\\\" is the same as the default one\\n        elseif (\\n            (\\n                isset($userDefinedConfig['type'])\\n                && isset($guessedConfig['fieldType'])\\n                && $userDefinedConfig['type'] === $guessedConfig['fieldType']\\n            ) || (\\n                !isset($userDefinedConfig['type']) && isset($userDefinedConfig['type_options'])\\n            )\\n        ) {\\n            $resolvedFormOptions = \\\\array_merge(\\n                $resolvedFormOptions,\\n                isset($userDefinedConfig['type_options']) ? $userDefinedConfig['type_options'] : []\\n            );\\n        }\\n\\n        return $resolvedFormOptions;\\n    }\", \"output\": \"Resolves from type options of field\\n\\n@param array $mergedConfig\\n@param array $guessedConfig\\n@param array $userDefinedConfig\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function autocompleteAction()\\n    {\\n        $results = $this->get('easyadmin.autocomplete')->find(\\n            $this->request->query->get('entity'),\\n            $this->request->query->get('query'),\\n            $this->request->query->get('page', 1)\\n        );\\n\\n        return new JsonResponse($results);\\n    }\", \"output\": \"The method that returns the values displayed by an autocomplete field\\nbased on the user's input.\\n\\n@return JsonResponse\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function editAction()\\n    {\\n        $this->dispatch(EasyAdminEvents::PRE_EDIT);\\n\\n        $id = $this->request->query->get('id');\\n        $easyadmin = $this->request->attributes->get('easyadmin');\\n        $entity = $easyadmin['item'];\\n\\n        if ($this->request->isXmlHttpRequest() && $property = $this->request->query->get('property')) {\\n            $newValue = 'true' === \\\\mb_strtolower($this->request->query->get('newValue'));\\n            $fieldsMetadata = $this->entity['list']['fields'];\\n\\n            if (!isset($fieldsMetadata[$property]) || 'toggle' !== $fieldsMetadata[$property]['dataType']) {\\n                throw new \\\\RuntimeException(\\\\sprintf('The type of the \\\"%s\\\" property is not \\\"toggle\\\".', $property));\\n            }\\n\\n            $this->updateEntityProperty($entity, $property, $newValue);\\n\\n            // cast to integer instead of string to avoid sending empty responses for 'false'\\n            return new Response((int) $newValue);\\n        }\\n\\n        $fields = $this->entity['edit']['fields'];\\n\\n        $editForm = $this->executeDynamicMethod('create<EntityName>EditForm', [$entity, $fields]);\\n        $deleteForm = $this->createDeleteForm($this->entity['name'], $id);\\n\\n        $editForm->handleRequest($this->request);\\n        if ($editForm->isSubmitted() && $editForm->isValid()) {\\n            $this->dispatch(EasyAdminEvents::PRE_UPDATE, ['entity' => $entity]);\\n            $this->executeDynamicMethod('update<EntityName>Entity', [$entity, $editForm]);\\n            $this->dispatch(EasyAdminEvents::POST_UPDATE, ['entity' => $entity]);\\n\\n            return $this->redirectToReferrer();\\n        }\\n\\n        $this->dispatch(EasyAdminEvents::POST_EDIT);\\n\\n        $parameters = [\\n            'form' => $editForm->createView(),\\n            'entity_fields' => $fields,\\n            'entity' => $entity,\\n            'delete_form' => $deleteForm->createView(),\\n        ];\\n\\n        return $this->executeDynamicMethod('render<EntityName>Template', ['edit', $this->entity['templates']['edit'], $parameters]);\\n    }\", \"output\": \"The method that is executed when the user performs a 'edit' action on an entity.\\n\\n@return Response|RedirectResponse\\n\\n@throws \\\\RuntimeException\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function showAction()\\n    {\\n        $this->dispatch(EasyAdminEvents::PRE_SHOW);\\n\\n        $id = $this->request->query->get('id');\\n        $easyadmin = $this->request->attributes->get('easyadmin');\\n        $entity = $easyadmin['item'];\\n\\n        $fields = $this->entity['show']['fields'];\\n        $deleteForm = $this->createDeleteForm($this->entity['name'], $id);\\n\\n        $this->dispatch(EasyAdminEvents::POST_SHOW, [\\n            'deleteForm' => $deleteForm,\\n            'fields' => $fields,\\n            'entity' => $entity,\\n        ]);\\n\\n        $parameters = [\\n            'entity' => $entity,\\n            'fields' => $fields,\\n            'delete_form' => $deleteForm->createView(),\\n        ];\\n\\n        return $this->executeDynamicMethod('render<EntityName>Template', ['show', $this->entity['templates']['show'], $parameters]);\\n    }\", \"output\": \"The method that is executed when the user performs a 'show' action on an entity.\\n\\n@return Response\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function newAction()\\n    {\\n        $this->dispatch(EasyAdminEvents::PRE_NEW);\\n\\n        $entity = $this->executeDynamicMethod('createNew<EntityName>Entity');\\n\\n        $easyadmin = $this->request->attributes->get('easyadmin');\\n        $easyadmin['item'] = $entity;\\n        $this->request->attributes->set('easyadmin', $easyadmin);\\n\\n        $fields = $this->entity['new']['fields'];\\n\\n        $newForm = $this->executeDynamicMethod('create<EntityName>NewForm', [$entity, $fields]);\\n\\n        $newForm->handleRequest($this->request);\\n        if ($newForm->isSubmitted() && $newForm->isValid()) {\\n            $this->dispatch(EasyAdminEvents::PRE_PERSIST, ['entity' => $entity]);\\n            $this->executeDynamicMethod('persist<EntityName>Entity', [$entity, $newForm]);\\n            $this->dispatch(EasyAdminEvents::POST_PERSIST, ['entity' => $entity]);\\n\\n            return $this->redirectToReferrer();\\n        }\\n\\n        $this->dispatch(EasyAdminEvents::POST_NEW, [\\n            'entity_fields' => $fields,\\n            'form' => $newForm,\\n            'entity' => $entity,\\n        ]);\\n\\n        $parameters = [\\n            'form' => $newForm->createView(),\\n            'entity_fields' => $fields,\\n            'entity' => $entity,\\n        ];\\n\\n        return $this->executeDynamicMethod('render<EntityName>Template', ['new', $this->entity['templates']['new'], $parameters]);\\n    }\", \"output\": \"The method that is executed when the user performs a 'new' action on an entity.\\n\\n@return Response|RedirectResponse\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function deleteAction()\\n    {\\n        $this->dispatch(EasyAdminEvents::PRE_DELETE);\\n\\n        if ('DELETE' !== $this->request->getMethod()) {\\n            return $this->redirect($this->generateUrl('easyadmin', ['action' => 'list', 'entity' => $this->entity['name']]));\\n        }\\n\\n        $id = $this->request->query->get('id');\\n        $form = $this->createDeleteForm($this->entity['name'], $id);\\n        $form->handleRequest($this->request);\\n\\n        if ($form->isSubmitted() && $form->isValid()) {\\n            $easyadmin = $this->request->attributes->get('easyadmin');\\n            $entity = $easyadmin['item'];\\n\\n            $this->dispatch(EasyAdminEvents::PRE_REMOVE, ['entity' => $entity]);\\n\\n            try {\\n                $this->executeDynamicMethod('remove<EntityName>Entity', [$entity, $form]);\\n            } catch (ForeignKeyConstraintViolationException $e) {\\n                throw new EntityRemoveException(['entity_name' => $this->entity['name'], 'message' => $e->getMessage()]);\\n            }\\n\\n            $this->dispatch(EasyAdminEvents::POST_REMOVE, ['entity' => $entity]);\\n        }\\n\\n        $this->dispatch(EasyAdminEvents::POST_DELETE);\\n\\n        return $this->redirectToReferrer();\\n    }\", \"output\": \"The method that is executed when the user performs a 'delete' action to\\nremove any entity.\\n\\n@return RedirectResponse\\n\\n@throws EntityRemoveException\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function searchAction()\\n    {\\n        $this->dispatch(EasyAdminEvents::PRE_SEARCH);\\n\\n        $query = \\\\trim($this->request->query->get('query'));\\n        // if the search query is empty, redirect to the 'list' action\\n        if ('' === $query) {\\n            $queryParameters = \\\\array_replace($this->request->query->all(), ['action' => 'list']);\\n            unset($queryParameters['query']);\\n\\n            return $this->redirect($this->get('router')->generate('easyadmin', $queryParameters));\\n        }\\n\\n        $searchableFields = $this->entity['search']['fields'];\\n        $defaultSortField = $this->entity['search']['sort']['field'] ?? null;\\n        $defaultSortDirection = isset($this->entity['search']['sort']['direction']) ? $this->entity['search']['sort']['direction'] : null;\\n        $paginator = $this->findBy(\\n            $this->entity['class'],\\n            $query,\\n            $searchableFields,\\n            $this->request->query->get('page', 1),\\n            $this->entity['list']['max_results'],\\n            $this->request->query->get('sortField', $defaultSortField),\\n            $this->request->query->get('sortDirection', $defaultSortDirection),\\n            $this->entity['search']['dql_filter']\\n        );\\n        $fields = $this->entity['list']['fields'];\\n\\n        $this->dispatch(EasyAdminEvents::POST_SEARCH, [\\n            'fields' => $fields,\\n            'paginator' => $paginator,\\n        ]);\\n\\n        $parameters = [\\n            'paginator' => $paginator,\\n            'fields' => $fields,\\n            'batch_form' => $this->createBatchForm($this->entity['name'])->createView(),\\n            'delete_form_template' => $this->createDeleteForm($this->entity['name'], '__id__')->createView(),\\n        ];\\n\\n        return $this->executeDynamicMethod('render<EntityName>Template', ['search', $this->entity['templates']['list'], $parameters]);\\n    }\", \"output\": \"The method that is executed when the user performs a query on an entity.\\n\\n@return Response\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function batchAction(): RedirectResponse\\n    {\\n        $batchForm = $this->createBatchForm($this->entity['name']);\\n        $batchForm->handleRequest($this->request);\\n\\n        if ($batchForm->isSubmitted() && $batchForm->isValid()) {\\n            $actionName = $batchForm->get('name')->getData();\\n            $actionIds = $batchForm->get('ids')->getData();\\n\\n            $this->executeDynamicMethod($actionName.'<EntityName>BatchAction', [$actionIds, $batchForm]);\\n        }\\n\\n        return $this->redirectToReferrer();\\n    }\", \"output\": \"The method that is executed when the user performs a 'batch' action to any entity.\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function updateEntityProperty($entity, $property, $value)\\n    {\\n        $entityConfig = $this->entity;\\n\\n        if (!$this->get('easyadmin.property_accessor')->isWritable($entity, $property)) {\\n            throw new \\\\RuntimeException(\\\\sprintf('The \\\"%s\\\" property of the \\\"%s\\\" entity is not writable.', $property, $entityConfig['name']));\\n        }\\n\\n        $this->get('easyadmin.property_accessor')->setValue($entity, $property, $value);\\n\\n        $this->dispatch(EasyAdminEvents::PRE_UPDATE, ['entity' => $entity, 'newValue' => $value]);\\n        $this->executeDynamicMethod('update<EntityName>Entity', [$entity]);\\n        $this->dispatch(EasyAdminEvents::POST_UPDATE, ['entity' => $entity, 'newValue' => $value]);\\n\\n        $this->dispatch(EasyAdminEvents::POST_EDIT);\\n    }\", \"output\": \"It updates the value of some property of some entity to the new given value.\\n\\n@param mixed  $entity   The instance of the entity to modify\\n@param string $property The name of the property to change\\n@param bool   $value    The new value of the property\\n\\n@throws \\\\RuntimeException\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function findAll($entityClass, $page = 1, $maxPerPage = 15, $sortField = null, $sortDirection = null, $dqlFilter = null)\\n    {\\n        if (null === $sortDirection || !\\\\in_array(\\\\strtoupper($sortDirection), ['ASC', 'DESC'])) {\\n            $sortDirection = 'DESC';\\n        }\\n\\n        $queryBuilder = $this->executeDynamicMethod('create<EntityName>ListQueryBuilder', [$entityClass, $sortDirection, $sortField, $dqlFilter]);\\n\\n        $this->dispatch(EasyAdminEvents::POST_LIST_QUERY_BUILDER, [\\n            'query_builder' => $queryBuilder,\\n            'sort_field' => $sortField,\\n            'sort_direction' => $sortDirection,\\n        ]);\\n\\n        return $this->get('easyadmin.paginator')->createOrmPaginator($queryBuilder, $page, $maxPerPage);\\n    }\", \"output\": \"Performs a database query to get all the records related to the given\\nentity. It supports pagination and field sorting.\\n\\n@param string      $entityClass\\n@param int         $page\\n@param int         $maxPerPage\\n@param string|null $sortField\\n@param string|null $sortDirection\\n@param string|null $dqlFilter\\n\\n@return Pagerfanta The paginated query results\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function createListQueryBuilder($entityClass, $sortDirection, $sortField = null, $dqlFilter = null)\\n    {\\n        return $this->get('easyadmin.query_builder')->createListQueryBuilder($this->entity, $sortField, $sortDirection, $dqlFilter);\\n    }\", \"output\": \"Creates Query Builder instance for all the records.\\n\\n@param string      $entityClass\\n@param string      $sortDirection\\n@param string|null $sortField\\n@param string|null $dqlFilter\\n\\n@return QueryBuilder The Query Builder instance\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function findBy($entityClass, $searchQuery, array $searchableFields, $page = 1, $maxPerPage = 15, $sortField = null, $sortDirection = null, $dqlFilter = null)\\n    {\\n        if (empty($sortDirection) || !\\\\in_array(\\\\strtoupper($sortDirection), ['ASC', 'DESC'])) {\\n            $sortDirection = 'DESC';\\n        }\\n\\n        $queryBuilder = $this->executeDynamicMethod('create<EntityName>SearchQueryBuilder', [$entityClass, $searchQuery, $searchableFields, $sortField, $sortDirection, $dqlFilter]);\\n\\n        $this->dispatch(EasyAdminEvents::POST_SEARCH_QUERY_BUILDER, [\\n            'query_builder' => $queryBuilder,\\n            'search_query' => $searchQuery,\\n            'searchable_fields' => $searchableFields,\\n        ]);\\n\\n        return $this->get('easyadmin.paginator')->createOrmPaginator($queryBuilder, $page, $maxPerPage);\\n    }\", \"output\": \"Performs a database query based on the search query provided by the user.\\nIt supports pagination and field sorting.\\n\\n@param string      $entityClass\\n@param string      $searchQuery\\n@param array       $searchableFields\\n@param int         $page\\n@param int         $maxPerPage\\n@param string|null $sortField\\n@param string|null $sortDirection\\n@param string|null $dqlFilter\\n\\n@return Pagerfanta The paginated query results\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function createSearchQueryBuilder($entityClass, $searchQuery, array $searchableFields, $sortField = null, $sortDirection = null, $dqlFilter = null)\\n    {\\n        return $this->get('easyadmin.query_builder')->createSearchQueryBuilder($this->entity, $searchQuery, $sortField, $sortDirection, $dqlFilter);\\n    }\", \"output\": \"Creates Query Builder instance for search query.\\n\\n@param string      $entityClass\\n@param string      $searchQuery\\n@param array       $searchableFields\\n@param string|null $sortField\\n@param string|null $sortDirection\\n@param string|null $dqlFilter\\n\\n@return QueryBuilder The Query Builder instance\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function createEntityFormBuilder($entity, $view)\\n    {\\n        $formOptions = $this->executeDynamicMethod('get<EntityName>EntityFormOptions', [$entity, $view]);\\n\\n        return $this->get('form.factory')->createNamedBuilder(\\\\mb_strtolower($this->entity['name']), EasyAdminFormType::class, $entity, $formOptions);\\n    }\", \"output\": \"Creates the form builder of the form used to create or edit the given entity.\\n\\n@param object $entity\\n@param string $view   The name of the view where this form is used ('new' or 'edit')\\n\\n@return FormBuilder\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function getEntityFormOptions($entity, $view)\\n    {\\n        $formOptions = $this->entity[$view]['form_options'];\\n        $formOptions['entity'] = $this->entity['name'];\\n        $formOptions['view'] = $view;\\n\\n        return $formOptions;\\n    }\", \"output\": \"Retrieves the list of form options before sending them to the form builder.\\nThis allows adding dynamic logic to the default form options.\\n\\n@param object $entity\\n@param string $view\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function createEntityForm($entity, array $entityProperties, $view)\\n    {\\n        if (\\\\method_exists($this, $customMethodName = 'create'.$this->entity['name'].'EntityForm')) {\\n            $form = $this->{$customMethodName}($entity, $entityProperties, $view);\\n            if (!$form instanceof FormInterface) {\\n                throw new \\\\UnexpectedValueException(\\\\sprintf(\\n                    'The \\\"%s\\\" method must return a FormInterface, \\\"%s\\\" given.',\\n                    $customMethodName, \\\\is_object($form) ? \\\\get_class($form) : \\\\gettype($form)\\n                ));\\n            }\\n\\n            return $form;\\n        }\\n\\n        $formBuilder = $this->executeDynamicMethod('create<EntityName>EntityFormBuilder', [$entity, $view]);\\n\\n        if (!$formBuilder instanceof FormBuilderInterface) {\\n            throw new \\\\UnexpectedValueException(\\\\sprintf(\\n                'The \\\"%s\\\" method must return a FormBuilderInterface, \\\"%s\\\" given.',\\n                'createEntityForm', \\\\is_object($formBuilder) ? \\\\get_class($formBuilder) : \\\\gettype($formBuilder)\\n            ));\\n        }\\n\\n        return $formBuilder->getForm();\\n    }\", \"output\": \"Creates the form object used to create or edit the given entity.\\n\\n@param object $entity\\n@param array  $entityProperties\\n@param string $view\\n\\n@return FormInterface\\n\\n@throws \\\\Exception\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function createDeleteForm($entityName, $entityId)\\n    {\\n        /** @var FormBuilder $formBuilder */\\n        $formBuilder = $this->get('form.factory')->createNamedBuilder('delete_form')\\n            ->setAction($this->generateUrl('easyadmin', ['action' => 'delete', 'entity' => $entityName, 'id' => $entityId]))\\n            ->setMethod('DELETE')\\n        ;\\n        $formBuilder->add('submit', SubmitType::class, ['label' => 'delete_modal.action', 'translation_domain' => 'EasyAdminBundle']);\\n        // needed to avoid submitting empty delete forms (see issue #1409)\\n        $formBuilder->add('_easyadmin_delete_flag', HiddenType::class, ['data' => '1']);\\n\\n        return $formBuilder->getForm();\\n    }\", \"output\": \"Creates the form used to delete an entity. It must be a form because\\nthe deletion of the entity are always performed with the 'DELETE' HTTP method,\\nwhich requires a form to work in the current browsers.\\n\\n@param string     $entityName\\n@param int|string $entityId   When reusing the delete form for multiple entities, a pattern string is passed instead of an integer\\n\\n@return Form|FormInterface\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function redirectToBackendHomepage()\\n    {\\n        $homepageConfig = $this->config['homepage'];\\n\\n        $url = $homepageConfig['url'] ?? $this->get('router')->generate($homepageConfig['route'], $homepageConfig['params']);\\n\\n        return $this->redirect($url);\\n    }\", \"output\": \"Generates the backend homepage and redirects to it.\"}"}
{"text": "{\"input\": \"Summarize the following code: private function normalizeMenuConfig(array $menuConfig, array $backendConfig, $parentItemIndex = -1)\\n    {\\n        // if the backend doesn't define the menu configuration: create a default\\n        // menu configuration to display all its entities\\n        if (empty($menuConfig)) {\\n            foreach ($backendConfig['entities'] as $entityName => $entityConfig) {\\n                $menuConfig[] = ['entity' => $entityName, 'label' => $entityConfig['label']];\\n            }\\n        }\\n\\n        // replaces the short config syntax:\\n        //   design.menu: ['Product', 'User']\\n        // by the expanded config syntax:\\n        //   design.menu: [{ entity: 'Product' }, { entity: 'User' }]\\n        foreach ($menuConfig as $i => $itemConfig) {\\n            if (\\\\is_string($itemConfig)) {\\n                $itemConfig = ['entity' => $itemConfig];\\n            }\\n\\n            $menuConfig[$i] = $itemConfig;\\n        }\\n\\n        foreach ($menuConfig as $i => $itemConfig) {\\n            // normalize icon configuration\\n            if (!\\\\array_key_exists('icon', $itemConfig)) {\\n                $itemConfig['icon'] = ($parentItemIndex > -1) ? '' : 'fa-folder-open';\\n            } elseif (empty($itemConfig['icon'])) {\\n                $itemConfig['icon'] = null;\\n            } else {\\n                $itemConfig['icon'] = 'fa-'.$itemConfig['icon'];\\n            }\\n\\n            // normalize css_class configuration\\n            if (!\\\\array_key_exists('css_class', $itemConfig)) {\\n                $itemConfig['css_class'] = '';\\n            }\\n\\n            // normalize submenu configuration (only for main menu items)\\n            if (-1 === $parentItemIndex && !isset($itemConfig['children'])) {\\n                $itemConfig['children'] = [];\\n            }\\n\\n            // normalize 'default' option, which sets the menu item used as the backend index\\n            if (!\\\\array_key_exists('default', $itemConfig)) {\\n                $itemConfig['default'] = false;\\n            } else {\\n                $itemConfig['default'] = (bool) $itemConfig['default'];\\n            }\\n\\n            // normalize 'target' option, which allows to open menu items in different windows or tabs\\n            if (!\\\\array_key_exists('target', $itemConfig)) {\\n                $itemConfig['target'] = false;\\n            } else {\\n                $itemConfig['target'] = (string) $itemConfig['target'];\\n            }\\n\\n            // normalize 'rel' option, which adds html5 rel attribute (https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types)\\n            if (!\\\\array_key_exists('rel', $itemConfig)) {\\n                $itemConfig['rel'] = \\\\array_key_exists('url', $itemConfig) ? 'noreferrer' : false;\\n            } else {\\n                $itemConfig['rel'] = (string) $itemConfig['rel'];\\n            }\\n\\n            $menuConfig[$i] = $itemConfig;\\n        }\\n\\n        return $menuConfig;\\n    }\", \"output\": \"Normalizes the different shortcut notations of the menu config to simplify\\nfurther processing.\\n\\n@param array $menuConfig\\n@param array $backendConfig\\n@param int   $parentItemIndex The index of the parent item for this menu item (allows to treat submenus differently)\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getEntityConfiguration($entityName)\\n    {\\n        return null !== $this->getBackendConfiguration('entities.'.$entityName)\\n            ? $this->configManager->getEntityConfig($entityName)\\n            : null;\\n    }\", \"output\": \"Returns the entire configuration of the given entity.\\n\\n@param string $entityName\\n\\n@return array|null\"}"}
{"text": "{\"input\": \"Summarize the following code: public function isActionEnabled($view, $action, $entityName)\\n    {\\n        return $this->configManager->isActionEnabled($entityName, $view, $action);\\n    }\", \"output\": \"Checks whether the given 'action' is enabled for the given 'entity'.\\n\\n@param string $view\\n@param string $action\\n@param string $entityName\\n\\n@return bool\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getActionConfiguration($view, $action, $entityName)\\n    {\\n        return $this->configManager->getActionConfig($entityName, $view, $action);\\n    }\", \"output\": \"Returns the full action configuration for the given 'entity' and 'view'.\\n\\n@param string $view\\n@param string $action\\n@param string $entityName\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: public function transchoice($message, $count, array $arguments = [], $domain = null, $locale = null)\\n    {\\n        if (null === $this->translator) {\\n            return strtr($message, $arguments);\\n        }\\n\\n        return $this->translator->trans($message, array_merge(['%count%' => $count], $arguments), $domain, $locale);\\n    }\", \"output\": \"Remove this filter when the Symfony's requirement is equal or greater than 4.2\\nand use the built-in trans filter instead with a %count% parameter.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function createOrmPaginator($queryBuilder, $page = 1, $maxPerPage = self::MAX_ITEMS)\\n    {\\n        $query = $queryBuilder->getQuery();\\n        if (0 === \\\\count($queryBuilder->getDQLPart('join'))) {\\n            $query->setHint(CountWalker::HINT_DISTINCT, false);\\n        }\\n\\n        // don't change the following line (you did that twice in the past and broke everything)\\n        $paginator = new Pagerfanta(new DoctrineORMAdapter($query, true, false));\\n        $paginator->setMaxPerPage($maxPerPage);\\n        $paginator->setCurrentPage($page);\\n\\n        return $paginator;\\n    }\", \"output\": \"Creates a Doctrine ORM paginator for the given query builder.\\n\\n@param DoctrineQuery|DoctrineQueryBuilder $queryBuilder\\n@param int                                $page\\n@param int                                $maxPerPage\\n\\n@return Pagerfanta\"}"}
{"text": "{\"input\": \"Summarize the following code: private function doProcessConfig($backendConfig): array\\n    {\\n        foreach ($this->configPasses as $configPass) {\\n            $backendConfig = $configPass->process($backendConfig);\\n        }\\n\\n        return $backendConfig;\\n    }\", \"output\": \"It processes the given backend configuration to generate the fully\\nprocessed configuration used in the application.\\n\\n@param array $backendConfig\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: public function initializeRequest(GenericEvent $event)\\n    {\\n        $request = null;\\n        if (null !== $this->requestStack) {\\n            $request = $this->requestStack->getCurrentRequest();\\n        }\\n\\n        if (null === $request) {\\n            return;\\n        }\\n\\n        $request->attributes->set('easyadmin', [\\n            'entity' => $entity = $event->getArgument('entity'),\\n            'view' => $request->query->get('action', 'list'),\\n            'item' => ($id = $request->query->get('id')) ? $this->findCurrentItem($entity, $id) : null,\\n        ]);\\n    }\", \"output\": \"Adds to the request some attributes with useful information, such as the\\ncurrent entity and the selected item, if any.\\n\\n@param GenericEvent $event\"}"}
{"text": "{\"input\": \"Summarize the following code: private function findCurrentItem(array $entityConfig, $itemId)\\n    {\\n        if (null === $manager = $this->doctrine->getManagerForClass($entityConfig['class'])) {\\n            throw new \\\\RuntimeException(\\\\sprintf('There is no Doctrine Entity Manager defined for the \\\"%s\\\" class', $entityConfig['class']));\\n        }\\n\\n        if (null === $entity = $manager->getRepository($entityConfig['class'])->find($itemId)) {\\n            throw new EntityNotFoundException(['entity_name' => $entityConfig['name'], 'entity_id_name' => $entityConfig['primary_key_field_name'], 'entity_id_value' => $itemId]);\\n        }\\n\\n        return $entity;\\n    }\", \"output\": \"Looks for the object that corresponds to the selected 'id' of the current entity.\\n\\n@param array $entityConfig\\n@param mixed $itemId\\n\\n@return object The entity\\n\\n@throws EntityNotFoundException\\n@throws \\\\RuntimeException\"}"}
{"text": "{\"input\": \"Summarize the following code: private function getAttributesNormalizer()\\n    {\\n        return function (Options $options, $value) {\\n            return \\\\array_replace([\\n                'id' => \\\\sprintf('%s-%s-form', $options['view'], \\\\mb_strtolower($options['entity'])),\\n            ], $value);\\n        };\\n    }\", \"output\": \"Returns a closure normalizing the form html attributes.\\n\\n@return \\\\Closure\"}"}
{"text": "{\"input\": \"Summarize the following code: private function processEntityPropertiesMetadata(ClassMetadata $entityMetadata)\\n    {\\n        $entityPropertiesMetadata = [];\\n\\n        if ($entityMetadata->isIdentifierComposite) {\\n            throw new \\\\RuntimeException(\\\\sprintf(\\\"The '%s' entity isn't valid because it contains a composite primary key.\\\", $entityMetadata->name));\\n        }\\n\\n        // introspect regular entity fields\\n        foreach ($entityMetadata->fieldMappings as $fieldName => $fieldMetadata) {\\n            $entityPropertiesMetadata[$fieldName] = $fieldMetadata;\\n        }\\n\\n        // introspect fields for entity associations\\n        foreach ($entityMetadata->associationMappings as $fieldName => $associationMetadata) {\\n            $entityPropertiesMetadata[$fieldName] = \\\\array_merge($associationMetadata, [\\n                'type' => 'association',\\n                'associationType' => $associationMetadata['type'],\\n            ]);\\n\\n            // associations different from *-to-one cannot be sorted\\n            if ($associationMetadata['type'] & ClassMetadata::TO_MANY) {\\n                $entityPropertiesMetadata[$fieldName]['sortable'] = false;\\n            }\\n        }\\n\\n        return $entityPropertiesMetadata;\\n    }\", \"output\": \"Takes the entity metadata introspected via Doctrine and completes its\\ncontents to simplify data processing for the rest of the application.\\n\\n@param ClassMetadata $entityMetadata The entity metadata introspected via Doctrine\\n\\n@return array The entity properties metadata provided by Doctrine\\n\\n@throws \\\\RuntimeException\"}"}
{"text": "{\"input\": \"Summarize the following code: private function getDefaultActions($view)\\n    {\\n        $defaultActions = [];\\n        $defaultActionsConfig = $this->getDefaultActionsConfig($view);\\n\\n        // actions are displayed in the same order as defined in this array\\n        $actionsEnabledByView = [\\n            'edit' => ['delete', 'list'],\\n            'list' => ['edit', 'delete', 'new', 'search'],\\n            'new' => ['list'],\\n            'show' => ['edit', 'delete', 'list'],\\n        ];\\n\\n        foreach ($actionsEnabledByView[$view] as $actionName) {\\n            $defaultActions[$actionName] = $defaultActionsConfig[$actionName];\\n        }\\n\\n        return $defaultActions;\\n    }\", \"output\": \"Returns the built-in actions defined by EasyAdmin for the given view.\\nThis allows to provide some nice defaults for backends that don't\\ndefine their own actions.\\n\\n@param string $view\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: public function handleViolations(FormEvent $event)\\n    {\\n        $formTabs = $event->getForm()->getConfig()->getAttribute('easyadmin_form_tabs');\\n\\n        $firstTabWithErrors = null;\\n        foreach ($event->getForm() as $child) {\\n            $errors = $child->getErrors(true);\\n\\n            if (\\\\count($errors) > 0) {\\n                $formTab = $child->getConfig()->getAttribute('easyadmin_form_tab');\\n                $formTabs[$formTab]['errors'] += \\\\count($errors);\\n\\n                if (null === $firstTabWithErrors) {\\n                    $firstTabWithErrors = $formTab;\\n                }\\n            }\\n        }\\n\\n        // ensure that the first tab with errors is displayed\\n        $firstTab = \\\\key($formTabs);\\n        if ($firstTab !== $firstTabWithErrors) {\\n            $formTabs[$firstTab]['active'] = false;\\n            $formTabs[$firstTabWithErrors]['active'] = true;\\n        }\\n    }\", \"output\": \"Deal with form constraint violations. This method has to be executed with\\na negative priority to make sure that the validation process is done.\\n\\n@param FormEvent $event\"}"}
{"text": "{\"input\": \"Summarize the following code: public function find($entity, $query, $page = 1)\\n    {\\n        if (empty($entity) || empty($query)) {\\n            return ['results' => []];\\n        }\\n\\n        $backendConfig = $this->configManager->getBackendConfig();\\n        if (!isset($backendConfig['entities'][$entity])) {\\n            throw new \\\\InvalidArgumentException(\\\\sprintf('The \\\"entity\\\" argument must contain the name of an entity managed by EasyAdmin (\\\"%s\\\" given).', $entity));\\n        }\\n\\n        $paginator = $this->finder->findByAllProperties($backendConfig['entities'][$entity], $query, $page, $backendConfig['show']['max_results']);\\n\\n        return [\\n            'results' => $this->processResults($paginator->getCurrentPageResults(), $backendConfig['entities'][$entity]),\\n            'has_next_page' => $paginator->hasNextPage(),\\n        ];\\n    }\", \"output\": \"Finds the values of the given entity which match the query provided.\\n\\n@param string $entity\\n@param string $query\\n@param int    $page\\n\\n@return array\\n\\n@throws \\\\InvalidArgumentException\"}"}
{"text": "{\"input\": \"Summarize the following code: private function processConfigFiles(array $configs)\\n    {\\n        $existingEntityNames = [];\\n\\n        foreach ($configs as $i => $config) {\\n            if (\\\\array_key_exists('entities', $config)) {\\n                $processedConfig = [];\\n\\n                foreach ($config['entities'] as $key => $value) {\\n                    $entityConfig = $this->normalizeEntityConfig($key, $value);\\n                    $entityName = $this->getUniqueEntityName($key, $entityConfig, $existingEntityNames);\\n                    $entityConfig['name'] = $entityName;\\n\\n                    $processedConfig[$entityName] = $entityConfig;\\n\\n                    $existingEntityNames[] = $entityName;\\n                }\\n\\n                $config['entities'] = $processedConfig;\\n            }\\n\\n            $configs[$i] = $config;\\n        }\\n\\n        return $configs;\\n    }\", \"output\": \"This method allows to define the entity configuration is several files.\\nWithout this, Symfony doesn't merge correctly the 'entities' config key\\ndefined in different files.\\n\\n@param array $configs\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: private function normalizeEntityConfig($entityName, $entityConfig)\\n    {\\n        // normalize config formats #1 and #2 to use the 'class' option as config format #3\\n        if (!\\\\is_array($entityConfig)) {\\n            $entityConfig = ['class' => $entityConfig];\\n        }\\n\\n        // if config format #3 is used, ensure that it defines the 'class' option\\n        if (!isset($entityConfig['class'])) {\\n            throw new \\\\RuntimeException(\\\\sprintf('The \\\"%s\\\" entity must define its associated Doctrine entity class using the \\\"class\\\" option.', $entityName));\\n        }\\n\\n        return $entityConfig;\\n    }\", \"output\": \"Transforms the two simple configuration formats into the full expanded\\nconfiguration. This allows to reuse the same method to process any of the\\ndifferent configuration formats.\\n\\nThese are the two simple formats allowed:\\n\\n# Config format #1: no custom entity name\\neasy_admin:\\nentities:\\n- AppBundle\\\\Entity\\\\User\\n\\n# Config format #2: simple config with custom entity name\\neasy_admin:\\nentities:\\nUser: AppBundle\\\\Entity\\\\User\\n\\nAnd this is the full expanded configuration syntax generated by this method:\\n\\n# Config format #3: expanded entity configuration with 'class' parameter\\neasy_admin:\\nentities:\\nUser:\\nclass: AppBundle\\\\Entity\\\\User\\n\\n@param mixed $entityName\\n@param mixed $entityConfig\\n\\n@return array\\n\\n@throws \\\\RuntimeException\"}"}
{"text": "{\"input\": \"Summarize the following code: private function getUniqueEntityName($entityName, array $entityConfig, array $existingEntityNames)\\n    {\\n        // the shortcut config syntax doesn't require to give entities a name\\n        if (\\\\is_numeric($entityName)) {\\n            $entityClassParts = \\\\explode('\\\\\\\\', $entityConfig['class']);\\n            $entityName = \\\\end($entityClassParts);\\n        }\\n\\n        $i = 2;\\n        $uniqueName = $entityName;\\n        while (\\\\in_array($uniqueName, $existingEntityNames)) {\\n            $uniqueName = $entityName.($i++);\\n        }\\n\\n        $entityName = $uniqueName;\\n\\n        // make sure that the entity name is valid as a PHP method name\\n        // (this is required to allow extending the backend with a custom controller)\\n        if (!$this->isValidMethodName($entityName)) {\\n            throw new \\\\InvalidArgumentException(\\\\sprintf('The name of the \\\"%s\\\" entity contains invalid characters (allowed: letters, numbers, underscores; the first character cannot be a number).', $entityName));\\n        }\\n\\n        return $entityName;\\n    }\", \"output\": \"The name of the entity is included in the URLs of the backend to define\\nthe entity used to perform the operations. Obviously, the entity name\\nmust be unique to identify entities unequivocally.\\n\\nThis method ensures that the given entity name is unique among all the\\npreviously existing entities passed as the second argument. This is\\nachieved by iteratively appending a suffix until the entity name is\\nguaranteed to be unique.\\n\\n@param string $entityName\\n@param array  $entityConfig\\n@param array  $existingEntityNames\\n\\n@return string The entity name transformed to be unique\"}"}
{"text": "{\"input\": \"Summarize the following code: private function normalizeViewConfig(array $backendConfig)\\n    {\\n        foreach ($backendConfig['entities'] as $entityName => $entityConfig) {\\n            // if the original 'search' config doesn't define its own DQL filter, use the one form 'list'\\n            if (!isset($entityConfig['search']) || !\\\\array_key_exists('dql_filter', $entityConfig['search'])) {\\n                $entityConfig['search']['dql_filter'] = $entityConfig['list']['dql_filter'] ?? null;\\n            }\\n\\n            foreach (['edit', 'form', 'list', 'new', 'search', 'show'] as $view) {\\n                $entityConfig[$view] = \\\\array_replace_recursive(\\n                    $this->defaultViewConfig[$view],\\n                    $entityConfig[$view] ?? []\\n                );\\n            }\\n\\n            $backendConfig['entities'][$entityName] = $entityConfig;\\n        }\\n\\n        return $backendConfig;\\n    }\", \"output\": \"Normalizes the view configuration when some of them doesn't define any\\nconfiguration.\\n\\n@param array $backendConfig\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: private function mergeFormConfig(array $parentConfig, array $childConfig)\\n    {\\n        // save the fields config for later processing\\n        $parentFields = $parentConfig['fields'] ?? [];\\n        $childFields = $childConfig['fields'] ?? [];\\n        $removedFieldNames = $this->getRemovedFieldNames($childFields);\\n\\n        // first, perform a recursive replace to merge both configs\\n        $mergedConfig = \\\\array_replace_recursive($parentConfig, $childConfig);\\n\\n        // merge the config of each field individually\\n        $mergedFields = [];\\n        foreach ($parentFields as $parentFieldName => $parentFieldConfig) {\\n            if (isset($parentFieldConfig['property']) && \\\\in_array($parentFieldConfig['property'], $removedFieldNames)) {\\n                continue;\\n            }\\n\\n            if (!isset($parentFieldConfig['property'])) {\\n                // this isn't a regular form field but a special design element (group, section, divider); add it\\n                $mergedFields[$parentFieldName] = $parentFieldConfig;\\n                continue;\\n            }\\n\\n            $childFieldConfig = $this->findFieldConfigByProperty($childFields, $parentFieldConfig['property']) ?: [];\\n            $mergedFields[$parentFieldName] = \\\\array_replace_recursive($parentFieldConfig, $childFieldConfig);\\n        }\\n\\n        // add back the fields that are defined in child config but not in parent config\\n        foreach ($childFields as $childFieldName => $childFieldConfig) {\\n            $isFormDesignElement = !isset($childFieldConfig['property']);\\n            $isNotRemovedField = isset($childFieldConfig['property']) && 0 !== \\\\strpos($childFieldConfig['property'], '-');\\n            $isNotAlreadyIncluded = isset($childFieldConfig['property']) && !\\\\array_key_exists($childFieldConfig['property'], $mergedFields);\\n\\n            if ($isFormDesignElement || ($isNotRemovedField && $isNotAlreadyIncluded)) {\\n                $mergedFields[$childFieldName] = $childFieldConfig;\\n            }\\n        }\\n\\n        // finally, copy the processed field config into the merged config\\n        $mergedConfig['fields'] = $mergedFields;\\n\\n        return $mergedConfig;\\n    }\", \"output\": \"Merges the form configuration recursively from the 'form' view to the\\n'edit' and 'new' views. It processes the configuration of the form fields\\nin a special way to keep all their configuration and allow overriding and\\nremoving of fields.\\n\\n@param array $parentConfig The config of the 'form' view\\n@param array $childConfig  The config of the 'edit' and 'new' views\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: public function createListQueryBuilder(array $entityConfig, $sortField = null, $sortDirection = null, $dqlFilter = null)\\n    {\\n        /* @var EntityManager $em */\\n        $em = $this->doctrine->getManagerForClass($entityConfig['class']);\\n        /* @var ClassMetadata $classMetadata */\\n        $classMetadata = $em->getClassMetadata($entityConfig['class']);\\n        /* @var DoctrineQueryBuilder $queryBuilder */\\n        $queryBuilder = $em->createQueryBuilder()\\n            ->select('entity')\\n            ->from($entityConfig['class'], 'entity')\\n        ;\\n\\n        $isSortedByDoctrineAssociation = $this->isDoctrineAssociation($classMetadata, $sortField);\\n        if ($isSortedByDoctrineAssociation) {\\n            $sortFieldParts = \\\\explode('.', $sortField);\\n            $queryBuilder->leftJoin('entity.'.$sortFieldParts[0], $sortFieldParts[0]);\\n        }\\n\\n        if (!empty($dqlFilter)) {\\n            $queryBuilder->andWhere($dqlFilter);\\n        }\\n\\n        if (null !== $sortField) {\\n            $queryBuilder->orderBy(\\\\sprintf('%s%s', $isSortedByDoctrineAssociation ? '' : 'entity.', $sortField), $sortDirection);\\n        }\\n\\n        return $queryBuilder;\\n    }\", \"output\": \"Creates the query builder used to get all the records displayed by the\\n\\\"list\\\" view.\\n\\n@param array       $entityConfig\\n@param string|null $sortField\\n@param string|null $sortDirection\\n@param string|null $dqlFilter\\n\\n@return DoctrineQueryBuilder\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function isDoctrineAssociation(ClassMetadata $classMetadata, $fieldName)\\n    {\\n        if (null === $fieldName) {\\n            return false;\\n        }\\n\\n        $fieldNameParts = \\\\explode('.', $fieldName);\\n\\n        return false !== \\\\strpos($fieldName, '.') && !\\\\array_key_exists($fieldNameParts[0], $classMetadata->embeddedClasses);\\n    }\", \"output\": \"Checking if the field name contains a '.' is not enough to decide if it's a\\nDoctrine association. This also happens when using embedded classes, so the\\nembeddedClasses property from Doctrine class metadata must be checked too.\\n\\n@param ClassMetadata $classMetadata\\n@param string|null   $fieldName\\n\\n@return bool\"}"}
{"text": "{\"input\": \"Summarize the following code: private function processFieldConfig(array $backendConfig)\\n    {\\n        foreach ($backendConfig['entities'] as $entityName => $entityConfig) {\\n            foreach (['edit', 'list', 'new', 'search', 'show'] as $view) {\\n                foreach ($entityConfig[$view]['fields'] as $fieldName => $fieldConfig) {\\n                    if (!isset($fieldConfig['label']) && 'id' === $fieldConfig['property']) {\\n                        // if the field is called 'id' and doesn't define a custom label, use 'ID' as label to\\n                        // improve the readability of the label, which is usually related to a primary key\\n                        $fieldConfig['label'] = 'ID';\\n                    } elseif (isset($fieldConfig['label']) && false === $fieldConfig['label']) {\\n                        // if the label is the special value 'false', label must be hidden (use an empty string as the label)\\n                        $fieldConfig['label'] = '';\\n                        $fieldConfig['sortable'] = false;\\n                    } elseif (null === $fieldConfig['label'] && 0 !== strpos($fieldConfig['property'], '_easyadmin_form_design_element_')) {\\n                        // else, generate the label automatically from its name (except if it's a\\n                        // special element created to render complex forms)\\n                        $fieldConfig['label'] = $this->humanize($fieldConfig['property']);\\n                    }\\n\\n                    $backendConfig['entities'][$entityName][$view]['fields'][$fieldName] = $fieldConfig;\\n                }\\n            }\\n        }\\n\\n        return $backendConfig;\\n    }\", \"output\": \"This methods makes some minor tweaks in fields configuration to improve\\nthe user experience.\\n\\n@param array $backendConfig\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: private function getExcludedFieldNames($view, array $entityConfig)\\n    {\\n        $excludedFieldNames = [\\n            'edit' => [$entityConfig['primary_key_field_name']],\\n            'list' => ['password', 'salt', 'slug', 'updatedAt', 'uuid'],\\n            'new' => [$entityConfig['primary_key_field_name']],\\n            'search' => ['password', 'salt'],\\n            'show' => [],\\n        ];\\n\\n        return isset($excludedFieldNames[$view]) ? $excludedFieldNames[$view] : [];\\n    }\", \"output\": \"Returns the list of excluded field names for the given view.\\n\\n@param string $view\\n@param array  $entityConfig\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: private function filterFieldList(array $fields, array $excludedFieldNames, array $excludedFieldTypes, $maxNumFields)\\n    {\\n        $filteredFields = [];\\n\\n        foreach ($fields as $name => $metadata) {\\n            if (!\\\\in_array($name, $excludedFieldNames) && !\\\\in_array($metadata['type'], $excludedFieldTypes)) {\\n                $filteredFields[$name] = $fields[$name];\\n            }\\n        }\\n\\n        if (\\\\count($filteredFields) > $maxNumFields) {\\n            $filteredFields = \\\\array_slice($filteredFields, 0, $maxNumFields, true);\\n        }\\n\\n        return $filteredFields;\\n    }\", \"output\": \"Filters a list of fields excluding the given list of field names and field types.\\n\\n@param array    $fields\\n@param string[] $excludedFieldNames\\n@param string[] $excludedFieldTypes\\n@param int      $maxNumFields\\n\\n@return array The filtered list of fields\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function run(string $command, string $cwd = null): array\\n    {\\n        $descriptors = [\\n            0 => ['pipe', 'r'], // stdin - read channel\\n            1 => ['pipe', 'w'], // stdout - write channel\\n            2 => ['pipe', 'w'], // stdout - error channel\\n            3 => ['pipe', 'r'], // stdin - This is the pipe we can feed the password into\\n        ];\\n\\n        $process = proc_open($command, $descriptors, $pipes, $cwd);\\n\\n        if (!\\\\is_resource($process)) {\\n            throw new \\\\RuntimeException('Can\\\\'t open resource with proc_open.');\\n        }\\n\\n        // Nothing to push to input.\\n        fclose($pipes[0]);\\n\\n        $output = stream_get_contents($pipes[1]);\\n        fclose($pipes[1]);\\n\\n        $error = stream_get_contents($pipes[2]);\\n        fclose($pipes[2]);\\n\\n        fclose($pipes[3]);\\n\\n        // Close all pipes before proc_close! $code === 0 is success.\\n        $code = proc_close($process);\\n\\n        return [trim($code), trim($output), trim($error)];\\n    }\", \"output\": \"run a command. it is support windows\\n@param string $command\\n@param string|null $cwd\\n@return array\\n@throws \\\\RuntimeException\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function deleteOrdCheck(string $stmt, int $offset)\\n    {\\n        $sqlType = self::OTHER;\\n        switch ($stmt[$offset + 1]) {\\n            case 'E':\\n            case 'e':\\n                $sqlType = self::dCheck($stmt, $offset);\\n                break;\\n            case 'R':\\n            case 'r':\\n                $sqlType = self::dropCheck($stmt, $offset);\\n                break;\\n            default:\\n                $sqlType = self::OTHER;\\n        }\\n        return $sqlType;\\n    }\", \"output\": \"delete or drop\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function dCheck(string $stmt, int $offset)\\n    {\\n        if (strlen($stmt) > $offset + 4) {\\n            $res = self::describeCheck($stmt, $offset);\\n            if ($res == self::DESCRIBE) {\\n                return $res;\\n            }\\n        }\\n        // continue check\\n        if (strlen($stmt) > $offset + 6) {\\n            $c1 = $stmt[++$offset];\\n            $c2 = $stmt[++$offset];\\n            $c3 = $stmt[++$offset];\\n            $c4 = $stmt[++$offset];\\n            $c5 = $stmt[++$offset];\\n            $c6 = $stmt[++$offset];\\n            if (($c1 == 'E' || $c1 == 'e') && ($c2 == 'L' || $c2 == 'l')\\n                && ($c3 == 'E' || $c3 == 'e') && ($c4 == 'T' || $c4 == 't')\\n                && ($c5 == 'E' || $c5 == 'e')\\n                && ($c6 == ' ' || $c6 == '\\\\t' || $c6 == '\\\\r' || $c6 == '\\\\n')) {\\n                return self::DELETE;\\n            }\\n        }\\n        return self::OTHER;\\n    }\", \"output\": \"DESCRIBE or desc or DELETE' '\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function uCheck(string $stmt, int $offset, bool $has_Space = true)\\n    {\\n        if (strlen($stmt) > ++$offset) {\\n            switch ($stmt[$offset]) {\\n                case 'P':\\n                case 'p':\\n                    if (strlen($stmt) > $offset + 5) {\\n                        $c1 = $stmt[++$offset];\\n                        $c2 = $stmt[++$offset];\\n                        $c3 = $stmt[++$offset];\\n                        $c4 = $stmt[++$offset];\\n                        $c5 = $stmt[++$offset];\\n                        if (($c1 == 'D' || $c1 == 'd')\\n                            && ($c2 == 'A' || $c2 == 'a')\\n                            && ($c3 == 'T' || $c3 == 't')\\n                            && ($c4 == 'E' || $c4 == 'e')\\n                            && ($has_Space ? (' ' == $c5 || '\\\\t' == $c5 || '\\\\r' == $c5 || '\\\\n' == $c5) : true)) {\\n                            return self::UPDATE;\\n                        }\\n                    }\\n                    break;\\n                case 'S':\\n                case 's':\\n                    if (strlen($stmt) > $offset + 2) {\\n                        $c1 = $stmt[++$offset];\\n                        $c2 = $stmt[++$offset];\\n                        if (($c1 == 'E' || $c1 == 'e')\\n                            && ($c2 == ' ' || $c2 == '\\\\t' || $c2 == '\\\\r' || $c2 == '\\\\n')) {\\n                            return ($offset << 8) | self::USE;\\n                        }\\n                    }\\n                    break;\\n                case 'N':\\n                case 'n':\\n                    if (strlen($stmt) > $offset + 5) {\\n                        $c1 = $stmt[++$offset];\\n                        $c2 = $stmt[++$offset];\\n                        $c3 = $stmt[++$offset];\\n                        $c4 = $stmt[++$offset];\\n                        $c5 = $stmt[++$offset];\\n                        if (($c1 == 'L' || $c1 == 'l')\\n                            && ($c2 == 'O' || $c2 == 'o')\\n                            && ($c3 == 'C' || $c3 == 'c')\\n                            && ($c4 == 'K' || $c4 == 'k')\\n                            && ($c5 == ' ' || $c5 == '\\\\t' || $c5 == '\\\\r' || $c5 == '\\\\n')) {\\n                            return self::UNLOCK;\\n                        }\\n                    }\\n                    break;\\n                default:\\n                    return self::OTHER;\\n            }\\n        }\\n        return self::OTHER;\\n    }\", \"output\": \"UPDATE' ' | USE' '\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function readLength(array $data)\\n    {\\n        $length = $data[0];\\n        switch ($length) {\\n            case 251:\\n                return MySQLMessage::$NULL_LENGTH;\\n            case 252:\\n                return self::readUB2($data);\\n            case 253:\\n                return self::readUB3($data);\\n            case 254:\\n                return self::readLong($data);\\n            default:\\n                return $length;\\n        }\\n    }\", \"output\": \"this is for the String.\\n\\n@param array $data\\n\\n@return int|mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function build(OutputInterface $output, $action, $index, $type, $offset)\\n    {\\n        $progress = null;\\n\\n        return function ($increment, $totalObjects, $message = null) use (&$progress, $output, $action, $index, $type, $offset) {\\n            if (null === $progress) {\\n                $progress = new ProgressBar($output, $totalObjects);\\n                $progress->start();\\n                $progress->setProgress($offset);\\n            }\\n\\n            if (null !== $message) {\\n                $progress->clear();\\n                $output->writeln(sprintf('<info>%s</info> <error>%s</error>', $action, $message));\\n                $progress->display();\\n            }\\n\\n            $progress->setMessage(sprintf('<info>%s</info> <comment>%s/%s</comment>', $action, $index, $type));\\n            $progress->advance($increment);\\n        };\\n    }\", \"output\": \"Builds a loggerClosure to be called from inside the Provider to update the command\\nline.\\n\\n@param OutputInterface $output\\n@param string          $action\\n@param string          $index\\n@param string          $type\\n@param int             $offset\\n\\n@return callable\"}"}
{"text": "{\"input\": \"Summarize the following code: private function log(BulkException $e)\\n    {\\n        if (!$this->logger) {\\n            throw $e;\\n        }\\n\\n        $this->logger->error($e);\\n    }\", \"output\": \"Log exception if logger defined for persister belonging to the current listener, otherwise re-throw.\\n\\n@param BulkException $e\\n\\n@throws BulkException\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function getTypes($config)\\n    {\\n        $types = array();\\n\\n        if (isset($config['types'])) {\\n            foreach ($config['types'] as $typeConfig) {\\n                $types[$typeConfig['name']] = new TypeConfig(\\n                    $typeConfig['name'],\\n                    $typeConfig['mapping'],\\n                    $typeConfig['config']\\n                );\\n            }\\n        }\\n\\n        return $types;\\n    }\", \"output\": \"Builds TypeConfig objects for each type.\\n\\n@param array $config\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getConfiguration()\\n    {\\n        $indexes = [];\\n        foreach ($this->configArray as $config) {\\n            $types = $this->getTypes($config);\\n            $index = new IndexConfig($config['name'], $types, [\\n                'elasticSearchName' => $config['elasticsearch_name'],\\n                'settings' => $config['settings'],\\n                'useAlias' => $config['use_alias'],\\n            ]);\\n\\n            $indexes[$config['name']] = $index;\\n        }\\n\\n        return $indexes;\\n    }\", \"output\": \"Should return all configuration available from the data source.\\n\\n@return IndexConfig[]\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getAllProviders()\\n    {\\n        $providers = [];\\n\\n        foreach ($this->providers as $index => $indexProviders) {\\n            foreach ($indexProviders as $type => $providerId) {\\n                $providers[sprintf('%s/%s', $index, $type)] = $this->container->get($providerId);\\n            }\\n        }\\n\\n        return $providers;\\n    }\", \"output\": \"Gets all registered providers.\\n\\nProviders will be indexed by \\\"index/type\\\" strings in the returned array.\\n\\n@return PagerProviderInterface[]\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getIndexProviders($index)\\n    {\\n        if (!isset($this->providers[$index])) {\\n            throw new \\\\InvalidArgumentException(sprintf('No providers were registered for index \\\"%s\\\".', $index));\\n        }\\n\\n        $providers = [];\\n        foreach ($this->providers[$index] as $type => $providerId) {\\n            $providers[$type] = $this->getProvider($index, $type);\\n        }\\n\\n        return $providers;\\n    }\", \"output\": \"Gets all providers for an index.\\n\\nProviders will be indexed by \\\"type\\\" strings in the returned array.\\n\\n@param string $index\\n\\n@return PagerProviderInterface[]|\\n\\n@throws \\\\InvalidArgumentException if no providers were registered for the index\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getProvider($index, $type)\\n    {\\n        if (!isset($this->providers[$index][$type])) {\\n            throw new \\\\InvalidArgumentException(sprintf('No provider was registered for index \\\"%s\\\" and type \\\"%s\\\".', $index, $type));\\n        }\\n\\n        return $this->container->get($this->providers[$index][$type]);\\n    }\", \"output\": \"Gets the provider for an index and type.\\n\\n@param string $index\\n@param string $type\\n\\n@return PagerProviderInterface\\n\\n@throws \\\\InvalidArgumentException if no provider was registered for the index and type\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function setSorting(ItemsEvent $event)\\n    {\\n        $options = $event->options;\\n        $sortField = $this->getRequest()->get($options['sortFieldParameterName']);\\n\\n        if (!$sortField && isset($options['defaultSortFieldName'])) {\\n            $sortField = $options['defaultSortFieldName'];\\n        }\\n\\n        if (!empty($sortField)) {\\n            $event->target->getQuery()->setSort([\\n                $sortField => $this->getSort($sortField, $options),\\n            ]);\\n        }\\n    }\", \"output\": \"Adds knp paging sort to query.\\n\\n@param ItemsEvent $event\"}"}
{"text": "{\"input\": \"Summarize the following code: public function buildIndexMapping(IndexConfigInterface $indexConfig)\\n    {\\n        $typeMappings = [];\\n        foreach ($indexConfig->getTypes() as $typeConfig) {\\n            $typeMappings[$typeConfig->getName()] = $this->buildTypeMapping($typeConfig);\\n        }\\n\\n        $mapping = [];\\n        if (!empty($typeMappings)) {\\n            $mapping['mappings'] = $typeMappings;\\n        }\\n        // 'warmers' => $indexConfig->getWarmers(),\\n\\n        $settings = $indexConfig->getSettings();\\n        if (!empty($settings)) {\\n            $mapping['settings'] = $settings;\\n        }\\n\\n        return $mapping;\\n    }\", \"output\": \"Builds mappings for an entire index.\\n\\n@param IndexConfigInterface $indexConfig\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: public function buildIndexTemplateMapping(IndexTemplateConfig $indexTemplateConfig)\\n    {\\n        $mapping = $this->buildIndexMapping($indexTemplateConfig);\\n        $mapping['template'] = $indexTemplateConfig->getTemplate();\\n\\n        return $mapping;\\n    }\", \"output\": \"Builds mappings for an entire index template.\\n\\n@param IndexTemplateConfig $indexTemplateConfig\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: public function buildTypeMapping(TypeConfig $typeConfig)\\n    {\\n        $mapping = $typeConfig->getMapping();\\n\\n        if (null !== $typeConfig->getDynamicDateFormats()) {\\n            $mapping['dynamic_date_formats'] = $typeConfig->getDynamicDateFormats();\\n        }\\n\\n        if (null !== $typeConfig->getDateDetection()) {\\n            $mapping['date_detection'] = $typeConfig->getDateDetection();\\n        }\\n\\n        if (null !== $typeConfig->getNumericDetection()) {\\n            $mapping['numeric_detection'] = $typeConfig->getNumericDetection();\\n        }\\n\\n        if ($typeConfig->getAnalyzer()) {\\n            $mapping['analyzer'] = $typeConfig->getAnalyzer();\\n        }\\n\\n        if (null !== $typeConfig->getDynamic()) {\\n            $mapping['dynamic'] = $typeConfig->getDynamic();\\n        }\\n\\n        if (isset($mapping['dynamic_templates']) and empty($mapping['dynamic_templates'])) {\\n            unset($mapping['dynamic_templates']);\\n        }\\n\\n        $this->fixProperties($mapping['properties']);\\n        if (!$mapping['properties']) {\\n            unset($mapping['properties']);\\n        }\\n\\n        if ($typeConfig->getModel()) {\\n            $mapping['_meta']['model'] = $typeConfig->getModel();\\n        }\\n\\n        unset($mapping['_parent']['identifier'], $mapping['_parent']['property']);\\n\\n        if (empty($mapping)) {\\n            // Empty mapping, we want it encoded as a {} instead of a []\\n            $mapping = new \\\\ArrayObject();\\n        }\\n\\n        return $mapping;\\n    }\", \"output\": \"Builds mappings for a single type.\\n\\n@param TypeConfig $typeConfig\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: private function fixProperties(&$properties)\\n    {\\n        foreach ($properties as $name => &$property) {\\n            unset($property['property_path']);\\n\\n            if (!isset($property['type'])) {\\n                $property['type'] = 'text';\\n            }\\n            if (isset($property['fields'])) {\\n                $this->fixProperties($property['fields']);\\n            }\\n            if (isset($property['properties'])) {\\n                $this->fixProperties($property['properties']);\\n            }\\n        }\\n    }\", \"output\": \"Fixes any properties and applies basic defaults for any field that does not have\\nrequired options.\\n\\n@param $properties\"}"}
{"text": "{\"input\": \"Summarize the following code: public function logQuery($path, $method, $data, $queryTime, $connection = [], $query = [], $engineTime = 0, $itemCount = 0)\\n    {\\n        $executionMS = $queryTime * 1000;\\n\\n        if ($this->debug) {\\n            $e = new \\\\Exception();\\n            if (is_string($data)) {\\n                $jsonStrings = explode(\\\"\\\\n\\\", $data);\\n                $data = [];\\n                foreach ($jsonStrings as $json) {\\n                    if ($json != '') {\\n                        $data[] = json_decode($json, true);\\n                    }\\n                }\\n            } else {\\n                $data = [$data];\\n            }\\n\\n            $this->queries[] = [\\n                'path' => $path,\\n                'method' => $method,\\n                'data' => $data,\\n                'executionMS' => $executionMS,\\n                'engineMS' => $engineTime,\\n                'connection' => $connection,\\n                'queryString' => $query,\\n                'itemCount' => $itemCount,\\n                'backtrace' => $e->getTraceAsString(),\\n            ];\\n        }\\n\\n        if (null !== $this->logger) {\\n            $message = sprintf('%s (%s) %0.2f ms', $path, $method, $executionMS);\\n            $this->logger->info($message, (array) $data);\\n        }\\n    }\", \"output\": \"Logs a query.\\n\\n@param string $path       Path to call\\n@param string $method     Rest method to use (GET, POST, DELETE, PUT)\\n@param array|string $data Arguments\\n@param float  $queryTime  Execution time (in seconds)\\n@param array  $connection Host, port, transport, and headers of the query\\n@param array  $query      Arguments\\n@param int    $engineTime\\n@param int    $itemCount\"}"}
{"text": "{\"input\": \"Summarize the following code: public function transformToElasticaDocument($object)\\n    {\\n        $document = $this->transformer->transform($object, []);\\n\\n        $data = call_user_func($this->serializer, $object);\\n        $document->setData($data);\\n\\n        return $document;\\n    }\", \"output\": \"Transforms an object to an elastica document\\nwith just the identifier set.\\n\\n@param object $object\\n\\n@return Document the elastica document\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getTotalHits($genuineTotal = false)\\n    {\\n        if (!isset($this->totalHits)) {\\n            $this->totalHits = $this->searchable->count($this->query);\\n        }\\n\\n        return $this->query->hasParam('size') && !$genuineTotal\\n            ? min($this->totalHits, (int) $this->query->getParam('size'))\\n            : $this->totalHits;\\n    }\", \"output\": \"Returns the number of results.\\n\\nIf genuineTotal is provided as true, total hits is returned from the\\nhits.total value from the search results instead of just returning\\nthe requested size.\\n\\n{@inheritdoc}\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function getElasticaResults($offset, $itemCountPerPage)\\n    {\\n        $offset = (int) $offset;\\n        $itemCountPerPage = (int) $itemCountPerPage;\\n        $size = $this->query->hasParam('size')\\n            ? (int) $this->query->getParam('size')\\n            : null;\\n\\n        if (null !== $size && $size < $offset + $itemCountPerPage) {\\n            $itemCountPerPage = $size - $offset;\\n        }\\n\\n        if ($itemCountPerPage < 1) {\\n            throw new InvalidArgumentException('$itemCountPerPage must be greater than zero');\\n        }\\n\\n        $query = clone $this->query;\\n        $query->setFrom($offset);\\n        $query->setSize($itemCountPerPage);\\n\\n        $resultSet = $this->searchable->search($query, $this->options);\\n        $this->totalHits = $resultSet->getTotalHits();\\n        $this->aggregations = $resultSet->getAggregations();\\n        $this->suggests = $resultSet->getSuggests();\\n        $this->maxScore = $resultSet->getMaxScore();\\n\\n        return $resultSet;\\n    }\", \"output\": \"Returns the paginated results.\\n\\n@param int $offset\\n@param int $itemCountPerPage\\n\\n@throws \\\\InvalidArgumentException\\n\\n@return ResultSet\"}"}
{"text": "{\"input\": \"Summarize the following code: public function deleteTemplateIndexes(IndexTemplateConfig $template)\\n    {\\n        $this->client->request($template->getTemplate() . '/', Request::DELETE);\\n    }\", \"output\": \"Delete all template indexes\\n\\n@param IndexTemplateConfig $template\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getIndex($name = null)\\n    {\\n        if (null === $name) {\\n            return $this->defaultIndex;\\n        }\\n\\n        if (!isset($this->indexes[$name])) {\\n            throw new \\\\InvalidArgumentException(sprintf('The index \\\"%s\\\" does not exist', $name));\\n        }\\n\\n        return $this->indexes[$name];\\n    }\", \"output\": \"Gets an index by its name.\\n\\n@param string $name Index to return, or the default index if null\\n\\n@return Index\\n\\n@throws \\\\InvalidArgumentException if no index exists for the given name\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getPersister($index, $type)\\n    {\\n        if (!isset($this->persisters[$index][$type])) {\\n            throw new \\\\InvalidArgumentException(sprintf('No persister was registered for index \\\"%s\\\" and type \\\"%s\\\".', $index, $type));\\n        }\\n\\n        return $this->container->get($this->persisters[$index][$type]);\\n    }\", \"output\": \"Gets the persister for an index and type.\\n\\n@param string $index\\n@param string $type\\n\\n@return ObjectPersisterInterface\\n\\n@throws \\\\InvalidArgumentException if no persister was registered for the index and type\"}"}
{"text": "{\"input\": \"Summarize the following code: private function populateIndex(OutputInterface $output, $index, $reset, $options)\\n    {\\n        $event = new IndexPopulateEvent($index, $reset, $options);\\n        $this->dispatcher->dispatch(IndexPopulateEvent::PRE_INDEX_POPULATE, $event);\\n\\n        if ($event->isReset()) {\\n            $output->writeln(sprintf('<info>Resetting</info> <comment>%s</comment>', $index));\\n            $this->resetter->resetIndex($index, true);\\n        }\\n\\n        $types = array_keys($this->pagerProviderRegistry->getIndexProviders($index));\\n        foreach ($types as $type) {\\n            $this->populateIndexType($output, $index, $type, false, $event->getOptions());\\n        }\\n\\n        $this->dispatcher->dispatch(IndexPopulateEvent::POST_INDEX_POPULATE, $event);\\n\\n        $this->refreshIndex($output, $index);\\n    }\", \"output\": \"Recreates an index, populates its types, and refreshes the index.\\n\\n@param OutputInterface $output\\n@param string          $index\\n@param bool            $reset\\n@param array           $options\"}"}
{"text": "{\"input\": \"Summarize the following code: private function refreshIndex(OutputInterface $output, $index)\\n    {\\n        $output->writeln(sprintf('<info>Refreshing</info> <comment>%s</comment>', $index));\\n        $this->indexManager->getIndex($index)->refresh();\\n    }\", \"output\": \"Refreshes an index.\\n\\n@param OutputInterface $output\\n@param string          $index\"}"}
{"text": "{\"input\": \"Summarize the following code: public function transform($object, array $fields)\\n    {\\n        $identifier = $this->propertyAccessor->getValue($object, $this->options['identifier']);\\n        if ($identifier && !is_scalar($identifier)) {\\n            $identifier = (string) $identifier;\\n        }\\n\\n        return $this->transformObjectToDocument($object, $fields, $identifier);\\n    }\", \"output\": \"Transforms an object into an elastica object having the required keys.\\n\\n@param object $object the object to convert\\n@param array  $fields the keys we want to have in the returned array\\n\\n@return Document\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function transformNested($objects, array $fields)\\n    {\\n        if (is_array($objects) || $objects instanceof \\\\Traversable || $objects instanceof \\\\ArrayAccess) {\\n            $documents = [];\\n            foreach ($objects as $object) {\\n                $document = $this->transformObjectToDocument($object, $fields);\\n                $documents[] = $document->getData();\\n            }\\n\\n            return $documents;\\n        } elseif (null !== $objects) {\\n            $document = $this->transformObjectToDocument($objects, $fields);\\n\\n            return $document->getData();\\n        }\\n\\n        return [];\\n    }\", \"output\": \"transform a nested document or an object property into an array of ElasticaDocument.\\n\\n@param array|\\\\Traversable|\\\\ArrayAccess $objects the object to convert\\n@param array                           $fields  the keys we want to have in the returned array\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function normalizeValue($value)\\n    {\\n        $normalizeValue = function (&$v) {\\n            if ($v instanceof \\\\DateTimeInterface) {\\n                $v = $v->format('c');\\n            } elseif (!is_scalar($v) && !is_null($v)) {\\n                $v = (string) $v;\\n            }\\n        };\\n\\n        if (is_array($value) || $value instanceof \\\\Traversable || $value instanceof \\\\ArrayAccess) {\\n            $value = is_array($value) ? $value : iterator_to_array($value, false);\\n            array_walk_recursive($value, $normalizeValue);\\n        } else {\\n            $normalizeValue($value);\\n        }\\n\\n        return $value;\\n    }\", \"output\": \"Attempts to convert any type to a string or an array of strings.\\n\\n@param mixed $value\\n\\n@return string|array\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function transformObjectToDocument($object, array $fields, $identifier = '')\\n    {\\n        $document = new Document($identifier, [], '', $this->options['index']);\\n\\n        if ($this->dispatcher) {\\n            $event = new TransformEvent($document, $fields, $object);\\n            $this->dispatcher->dispatch(TransformEvent::PRE_TRANSFORM, $event);\\n\\n            $document = $event->getDocument();\\n        }\\n\\n        foreach ($fields as $key => $mapping) {\\n            if ('_parent' == $key) {\\n                $property = (null !== $mapping['property']) ? $mapping['property'] : $mapping['type'];\\n                $value = $this->propertyAccessor->getValue($object, $property);\\n                $document->setParent($this->propertyAccessor->getValue($value, $mapping['identifier']));\\n\\n                continue;\\n            }\\n\\n            $path = isset($mapping['property_path']) ?\\n                $mapping['property_path'] :\\n                $key;\\n            if (false === $path) {\\n                continue;\\n            }\\n            $value = $this->propertyAccessor->getValue($object, $path);\\n\\n            if (isset($mapping['type']) && in_array(\\n                    $mapping['type'], ['nested', 'object']\\n                ) && isset($mapping['properties']) && !empty($mapping['properties'])\\n            ) {\\n                /* $value is a nested document or object. Transform $value into\\n                 * an array of documents, respective the mapped properties.\\n                 */\\n                $document->set($key, $this->transformNested($value, $mapping['properties']));\\n\\n                continue;\\n            }\\n\\n            if (isset($mapping['type']) && 'attachment' == $mapping['type']) {\\n                // $value is an attachment. Add it to the document.\\n                if ($value instanceof \\\\SplFileInfo) {\\n                    $document->addFile($key, $value->getPathName());\\n                } else {\\n                    $document->addFileContent($key, $value);\\n                }\\n\\n                continue;\\n            }\\n\\n            $document->set($key, $this->normalizeValue($value));\\n        }\\n\\n        if ($this->dispatcher) {\\n            $event = new TransformEvent($document, $fields, $object);\\n            $this->dispatcher->dispatch(TransformEvent::POST_TRANSFORM, $event);\\n\\n            $document = $event->getDocument();\\n        }\\n\\n        return $document;\\n    }\", \"output\": \"Transforms the given object to an elastica document.\\n\\n@param object $object     the object to convert\\n@param array  $fields     the keys we want to have in the returned array\\n@param string $identifier the identifier for the new document\\n\\n@return Document\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function getEntityQueryBuilder()\\n    {\\n        $repository = $this->registry\\n            ->getManagerForClass($this->objectClass)\\n            ->getRepository($this->objectClass);\\n\\n        return $repository->{$this->options['query_builder_method']}(static::ENTITY_ALIAS);\\n    }\", \"output\": \"Retrieves a query builder to be used for querying by identifiers.\\n\\n@return \\\\Doctrine\\\\ORM\\\\QueryBuilder\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getIndexTemplate($name)\\n    {\\n        if (!isset($this->templates[$name])) {\\n            throw new \\\\InvalidArgumentException(sprintf('The index template \\\"%s\\\" does not exist', $name));\\n        }\\n\\n        return $this->templates[$name];\\n    }\", \"output\": \"Gets an index template by its name.\\n\\n@param string $name Index template to return\\n\\n@return IndexTemplate\\n\\n@throws \\\\InvalidArgumentException if no index template exists for the given name\"}"}
{"text": "{\"input\": \"Summarize the following code: public function resetAllIndexes($populating = false, $force = false)\\n    {\\n        foreach ($this->configManager->getIndexNames() as $name) {\\n            $this->resetIndex($name, $populating, $force);\\n        }\\n    }\", \"output\": \"Deletes and recreates all indexes.\\n\\n@param bool $populating\\n@param bool $force\"}"}
{"text": "{\"input\": \"Summarize the following code: public function resetIndex($indexName, $populating = false, $force = false)\\n    {\\n        $indexConfig = $this->configManager->getIndexConfiguration($indexName);\\n        $index = $this->indexManager->getIndex($indexName);\\n\\n        if ($indexConfig->isUseAlias()) {\\n            $this->aliasProcessor->setRootName($indexConfig, $index);\\n        }\\n\\n        $event = new IndexResetEvent($indexName, $populating, $force);\\n        $this->dispatcher->dispatch(IndexResetEvent::PRE_INDEX_RESET, $event);\\n\\n        $mapping = $this->mappingBuilder->buildIndexMapping($indexConfig);\\n        $index->create($mapping, true);\\n\\n        if (!$populating and $indexConfig->isUseAlias()) {\\n            $this->aliasProcessor->switchIndexAlias($indexConfig, $index, $force);\\n        }\\n\\n        $this->dispatcher->dispatch(IndexResetEvent::POST_INDEX_RESET, $event);\\n    }\", \"output\": \"Deletes and recreates the named index. If populating, creates a new index\\nwith a randomised name for an alias to be set after population.\\n\\n@param string $indexName\\n@param bool   $populating\\n@param bool   $force      If index exists with same name as alias, remove it\\n\\n@throws \\\\InvalidArgumentException if no index exists for the given name\"}"}
{"text": "{\"input\": \"Summarize the following code: public function resetIndexType($indexName, $typeName)\\n    {\\n        $typeConfig = $this->configManager->getTypeConfiguration($indexName, $typeName);\\n\\n        $this->resetIndex($indexName, true);\\n\\n        $index = $this->indexManager->getIndex($indexName);\\n        $type = $index->getType($typeName);\\n\\n        $event = new TypeResetEvent($indexName, $typeName);\\n        $this->dispatcher->dispatch(TypeResetEvent::PRE_TYPE_RESET, $event);\\n\\n        $mapping = new Mapping();\\n        foreach ($this->mappingBuilder->buildTypeMapping($typeConfig) as $name => $field) {\\n            $mapping->setParam($name, $field);\\n        }\\n\\n        $type->setMapping($mapping);\\n\\n        $this->dispatcher->dispatch(TypeResetEvent::POST_TYPE_RESET, $event);\\n    }\", \"output\": \"Deletes and recreates a mapping type for the named index.\\n\\n@param string $indexName\\n@param string $typeName\\n\\n@throws \\\\InvalidArgumentException if no index or type mapping exists for the given names\\n@throws ResponseException\"}"}
{"text": "{\"input\": \"Summarize the following code: public function switchIndexAlias($indexName, $delete = true)\\n    {\\n        $indexConfig = $this->configManager->getIndexConfiguration($indexName);\\n\\n        if ($indexConfig->isUseAlias()) {\\n            $index = $this->indexManager->getIndex($indexName);\\n            $this->aliasProcessor->switchIndexAlias($indexConfig, $index, false, $delete);\\n        }\\n    }\", \"output\": \"Switching aliases.\\n\\n@param string $indexName\\n@param bool   $delete    Delete or close index\\n\\n@throws \\\\FOS\\\\ElasticaBundle\\\\Exception\\\\AliasIsIndexException\"}"}
{"text": "{\"input\": \"Summarize the following code: private function loadIndexFinder(ContainerBuilder $container, $name, Reference $index)\\n    {\\n        /* Note: transformer services may conflict with \\\"collection.index\\\", if\\n         * an index and type names were \\\"collection\\\" and an index, respectively.\\n         */\\n        $transformerId = sprintf('fos_elastica.elastica_to_model_transformer.collection.%s', $name);\\n        $transformerDef = new ChildDefinition('fos_elastica.elastica_to_model_transformer.collection');\\n        $container->setDefinition($transformerId, $transformerDef);\\n\\n        $finderId = sprintf('fos_elastica.finder.%s', $name);\\n        $finderDef = new ChildDefinition('fos_elastica.finder');\\n        $finderDef->replaceArgument(0, $index);\\n        $finderDef->replaceArgument(1, new Reference($transformerId));\\n\\n        $container->setDefinition($finderId, $finderDef);\\n    }\", \"output\": \"Loads the configured index finders.\\n\\n@param \\\\Symfony\\\\Component\\\\DependencyInjection\\\\ContainerBuilder $container\\n@param string                                                  $name      The index name\\n@param Reference                                               $index     Reference to the related index\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: private function loadTypePersistenceIntegration(array $typeConfig, ContainerBuilder $container, Reference $typeRef, $indexName, $typeName)\\n    {\\n        if (isset($typeConfig['driver'])) {\\n            $this->loadDriver($container, $typeConfig['driver']);\\n        }\\n\\n        $elasticaToModelTransformerId = $this->loadElasticaToModelTransformer($typeConfig, $container, $indexName, $typeName);\\n        $modelToElasticaTransformerId = $this->loadModelToElasticaTransformer($typeConfig, $container, $indexName, $typeName);\\n        $objectPersisterId = $this->loadObjectPersister($typeConfig, $typeRef, $container, $indexName, $typeName, $modelToElasticaTransformerId);\\n\\n        if (isset($typeConfig['provider'])) {\\n            $this->loadTypePagerProvider($typeConfig, $container, $indexName, $typeName);\\n        }\\n        if (isset($typeConfig['finder'])) {\\n            $this->loadTypeFinder($typeConfig, $container, $elasticaToModelTransformerId, $typeRef, $indexName, $typeName);\\n        }\\n        if (isset($typeConfig['listener']) && $typeConfig['listener']['enabled']) {\\n            $this->loadTypeListener($typeConfig, $container, $objectPersisterId, $indexName, $typeName);\\n        }\\n    }\", \"output\": \"Loads the optional provider and finder for a type.\\n\\n@param array            $typeConfig\\n@param ContainerBuilder $container\\n@param Reference        $typeRef\\n@param string           $indexName\\n@param string           $typeName\"}"}
{"text": "{\"input\": \"Summarize the following code: private function loadElasticaToModelTransformer(array $typeConfig, ContainerBuilder $container, $indexName, $typeName)\\n    {\\n        if (isset($typeConfig['elastica_to_model_transformer']['service'])) {\\n            return $typeConfig['elastica_to_model_transformer']['service'];\\n        }\\n\\n        /* Note: transformer services may conflict with \\\"prototype.driver\\\", if\\n         * the index and type names were \\\"prototype\\\" and a driver, respectively.\\n         */\\n        $abstractId = sprintf('fos_elastica.elastica_to_model_transformer.prototype.%s', $typeConfig['driver']);\\n        $serviceId = sprintf('fos_elastica.elastica_to_model_transformer.%s.%s', $indexName, $typeName);\\n        $serviceDef = new ChildDefinition($abstractId);\\n        $serviceDef->addTag('fos_elastica.elastica_to_model_transformer', ['type' => $typeName, 'index' => $indexName]);\\n\\n        $serviceDef->replaceArgument(1, $typeConfig['model']);\\n        $serviceDef->replaceArgument(2, array_merge($typeConfig['elastica_to_model_transformer'], [\\n            'identifier' => $typeConfig['identifier'],\\n        ]));\\n        $container->setDefinition($serviceId, $serviceDef);\\n\\n        return $serviceId;\\n    }\", \"output\": \"Creates and loads an ElasticaToModelTransformer.\\n\\n@param array            $typeConfig\\n@param ContainerBuilder $container\\n@param string           $indexName\\n@param string           $typeName\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: private function loadObjectPersister(array $typeConfig, Reference $typeRef, ContainerBuilder $container, $indexName, $typeName, $transformerId)\\n    {\\n        if (isset($typeConfig['persister']['service'])) {\\n            return $typeConfig['persister']['service'];\\n        }\\n\\n        $arguments = [\\n            $typeRef,\\n            new Reference($transformerId),\\n            $typeConfig['model'],\\n        ];\\n\\n        if ($container->hasDefinition('fos_elastica.serializer_callback_prototype')) {\\n            $abstractId = 'fos_elastica.object_serializer_persister';\\n            $callbackId = sprintf('%s.%s.serializer.callback', $this->indexConfigs[$indexName]['reference'], $typeName);\\n            $arguments[] = [new Reference($callbackId), 'serialize'];\\n        } else {\\n            $abstractId = 'fos_elastica.object_persister';\\n            $mapping = $this->indexConfigs[$indexName]['types'][$typeName]['mapping'];\\n            $argument = $mapping['properties'];\\n            if (isset($mapping['_parent'])) {\\n                $argument['_parent'] = $mapping['_parent'];\\n            }\\n            $arguments[] = $argument;\\n        }\\n\\n        $arguments[] = array_intersect_key($typeConfig['persister'], array_flip(['refresh']));\\n\\n        $serviceId = sprintf('fos_elastica.object_persister.%s.%s', $indexName, $typeName);\\n        $serviceDef = new ChildDefinition($abstractId);\\n        foreach ($arguments as $i => $argument) {\\n            $serviceDef->replaceArgument($i, $argument);\\n        }\\n\\n        $serviceDef->addTag('fos_elastica.persister', ['index' => $indexName, 'type' => $typeName]);\\n\\n        $container->setDefinition($serviceId, $serviceDef);\\n\\n        return $serviceId;\\n    }\", \"output\": \"Creates and loads an object persister for a type.\\n\\n@param array            $typeConfig\\n@param Reference        $typeRef\\n@param ContainerBuilder $container\\n@param string           $indexName\\n@param string           $typeName\\n@param string           $transformerId\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: private function loadTypePagerProvider(array $typeConfig, ContainerBuilder $container, $indexName, $typeName)\\n    {\\n        if (isset($typeConfig['provider']['service'])) {\\n            return $typeConfig['provider']['service'];\\n        }\\n\\n        $baseConfig = $typeConfig['provider'];\\n        unset($baseConfig['service']);\\n\\n        $driver = $typeConfig['driver'];\\n\\n        switch ($driver) {\\n            case 'orm':\\n                $providerDef = new ChildDefinition('fos_elastica.pager_provider.prototype.'.$driver);\\n                $providerDef->replaceArgument(2, $typeConfig['model']);\\n                $providerDef->replaceArgument(3, $baseConfig);\\n\\n                break;\\n            case 'mongodb':\\n                $providerDef = new ChildDefinition('fos_elastica.pager_provider.prototype.'.$driver);\\n                $providerDef->replaceArgument(2, $typeConfig['model']);\\n                $providerDef->replaceArgument(3, $baseConfig);\\n\\n                break;\\n            case 'phpcr':\\n                $providerDef = new ChildDefinition('fos_elastica.pager_provider.prototype.'.$driver);\\n                $providerDef->replaceArgument(2, $typeConfig['model']);\\n                $providerDef->replaceArgument(3, $baseConfig);\\n\\n                break;\\n            default:\\n                throw new \\\\LogicException(sprintf('The pager provider for driver \\\"%s\\\" does not exist.', $driver));\\n        }\\n\\n        /* Note: provider services may conflict with \\\"prototype.driver\\\", if the\\n         * index and type names were \\\"prototype\\\" and a driver, respectively.\\n         */\\n        $providerId = sprintf('fos_elastica.pager_provider.%s.%s', $indexName, $typeName);\\n        $providerDef->addTag('fos_elastica.pager_provider', ['index' => $indexName, 'type' => $typeName]);\\n\\n        $container->setDefinition($providerId, $providerDef);\\n\\n        return $providerId;\\n    }\", \"output\": \"Loads a pager provider for a type.\\n\\n@param array            $typeConfig\\n@param ContainerBuilder $container\\n@param string           $indexName\\n@param string           $typeName\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: private function loadTypeListener(array $typeConfig, ContainerBuilder $container, $objectPersisterId, $indexName, $typeName)\\n    {\\n        if (isset($typeConfig['listener']['service'])) {\\n            return $typeConfig['listener']['service'];\\n        }\\n\\n        /* Note: listener services may conflict with \\\"prototype.driver\\\", if the\\n         * index and type names were \\\"prototype\\\" and a driver, respectively.\\n         */\\n        $abstractListenerId = sprintf('fos_elastica.listener.prototype.%s', $typeConfig['driver']);\\n        $listenerId = sprintf('fos_elastica.listener.%s.%s', $indexName, $typeName);\\n        $listenerDef = new ChildDefinition($abstractListenerId);\\n        $listenerDef->replaceArgument(0, new Reference($objectPersisterId));\\n        $listenerDef->replaceArgument(3, $typeConfig['listener']['logger'] ?\\n            new Reference($typeConfig['listener']['logger']) :\\n            null\\n        );\\n        $listenerConfig = [\\n            'identifier' => $typeConfig['identifier'],\\n            'indexName' => $indexName,\\n            'typeName' => $typeName,\\n        ];\\n\\n        $tagName = null;\\n        switch ($typeConfig['driver']) {\\n            case 'orm':\\n                $tagName = 'doctrine.event_listener';\\n                break;\\n            case 'phpcr':\\n                $tagName = 'doctrine_phpcr.event_listener';\\n                break;\\n            case 'mongodb':\\n                $tagName = 'doctrine_mongodb.odm.event_listener';\\n                break;\\n        }\\n\\n        if ($typeConfig['listener']['defer']) {\\n            $listenerDef->setPublic(true);\\n            $listenerDef->addTag(\\n                'kernel.event_listener',\\n                ['event' => 'kernel.terminate', 'method' => 'onTerminate']\\n            );\\n            $listenerDef->addTag(\\n                'kernel.event_listener',\\n                ['event' => 'console.terminate', 'method' => 'onTerminate']\\n            );\\n            $listenerConfig['defer'] = true;\\n        }\\n\\n        $listenerDef->replaceArgument(2, $listenerConfig);\\n\\n        if (null !== $tagName) {\\n            foreach ($this->getDoctrineEvents($typeConfig) as $event) {\\n                $listenerDef->addTag($tagName, ['event' => $event]);\\n            }\\n        }\\n\\n        $container->setDefinition($listenerId, $listenerDef);\\n\\n        return $listenerId;\\n    }\", \"output\": \"Loads doctrine listeners to handle indexing of new or updated objects.\\n\\n@param array            $typeConfig\\n@param ContainerBuilder $container\\n@param string           $objectPersisterId\\n@param string           $indexName\\n@param string           $typeName\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: private function getDoctrineEvents(array $typeConfig)\\n    {\\n        switch ($typeConfig['driver']) {\\n            case 'orm':\\n                $eventsClass = '\\\\Doctrine\\\\ORM\\\\Events';\\n                break;\\n            case 'phpcr':\\n                $eventsClass = '\\\\Doctrine\\\\ODM\\\\PHPCR\\\\Event';\\n                break;\\n            case 'mongodb':\\n                $eventsClass = '\\\\Doctrine\\\\ODM\\\\MongoDB\\\\Events';\\n                break;\\n            default:\\n                throw new \\\\InvalidArgumentException(sprintf('Cannot determine events for driver \\\"%s\\\"', $typeConfig['driver']));\\n        }\\n\\n        $events = [];\\n        $eventMapping = [\\n            'insert' => [constant($eventsClass.'::postPersist')],\\n            'update' => [constant($eventsClass.'::postUpdate')],\\n            'delete' => [constant($eventsClass.'::preRemove')],\\n            'flush' => [constant($eventsClass.'::postFlush')],\\n        ];\\n\\n        foreach ($eventMapping as $event => $doctrineEvents) {\\n            if (isset($typeConfig['listener'][$event]) && $typeConfig['listener'][$event]) {\\n                $events = array_merge($events, $doctrineEvents);\\n            }\\n        }\\n\\n        return $events;\\n    }\", \"output\": \"Map Elastica to Doctrine events for the current driver.\"}"}
{"text": "{\"input\": \"Summarize the following code: private function loadTypeFinder(array $typeConfig, ContainerBuilder $container, $elasticaToModelId, Reference $typeRef, $indexName, $typeName)\\n    {\\n        if (isset($typeConfig['finder']['service'])) {\\n            $finderId = $typeConfig['finder']['service'];\\n        } else {\\n            $finderId = sprintf('fos_elastica.finder.%s.%s', $indexName, $typeName);\\n            $finderDef = new ChildDefinition('fos_elastica.finder');\\n            $finderDef->replaceArgument(0, $typeRef);\\n            $finderDef->replaceArgument(1, new Reference($elasticaToModelId));\\n            $container->setDefinition($finderId, $finderDef);\\n        }\\n\\n        $indexTypeName = \\\"$indexName/$typeName\\\";\\n        $arguments = [$indexTypeName, new Reference($finderId)];\\n        if (isset($typeConfig['repository'])) {\\n            $arguments[] = $typeConfig['repository'];\\n        }\\n\\n        $container->getDefinition('fos_elastica.repository_manager')\\n            ->addMethodCall('addType', $arguments);\\n\\n        $managerId = sprintf('fos_elastica.manager.%s', $typeConfig['driver']);\\n        $container->getDefinition($managerId)\\n            ->addMethodCall('addEntity', [$typeConfig['model'], $indexTypeName]);\\n\\n        return $finderId;\\n    }\", \"output\": \"Loads a Type specific Finder.\\n\\n@param array            $typeConfig\\n@param ContainerBuilder $container\\n@param string           $elasticaToModelId\\n@param Reference        $typeRef\\n@param string           $indexName\\n@param string           $typeName\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: private function loadIndexManager(ContainerBuilder $container)\\n    {\\n        $indexRefs = array_map(function ($index) {\\n            return $index['reference'];\\n        }, $this->indexConfigs);\\n\\n        $managerDef = $container->getDefinition('fos_elastica.index_manager');\\n        $managerDef->replaceArgument(0, $indexRefs);\\n    }\", \"output\": \"Loads the index manager.\\n\\n@param ContainerBuilder $container\"}"}
{"text": "{\"input\": \"Summarize the following code: private function loadIndexTemplateManager(ContainerBuilder $container)\\n    {\\n        $indexTemplateRefs = array_map(function ($index) {\\n            return $index['reference'];\\n        }, $this->indexTemplateConfigs);\\n\\n        $managerDef = $container->getDefinition('fos_elastica.index_template_manager');\\n        $managerDef->replaceArgument(0, $indexTemplateRefs);\\n    }\", \"output\": \"Load index template manager\\n\\n@param ContainerBuilder $container\\n\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: private function loadDriver(ContainerBuilder $container, $driver)\\n    {\\n        if (in_array($driver, $this->loadedDrivers)) {\\n            return;\\n        }\\n\\n        $loader = new XmlFileLoader($container, new FileLocator(__DIR__.'/../Resources/config'));\\n        $loader->load($driver.'.xml');\\n        $this->loadedDrivers[] = $driver;\\n    }\", \"output\": \"Makes sure a specific driver has been loaded.\\n\\n@param ContainerBuilder $container\\n@param string           $driver\"}"}
{"text": "{\"input\": \"Summarize the following code: private function loadSerializer($config, ContainerBuilder $container)\\n    {\\n        $container->setAlias('fos_elastica.serializer', $config['serializer']);\\n\\n        $serializer = $container->getDefinition('fos_elastica.serializer_callback_prototype');\\n        $serializer->setClass($config['callback_class']);\\n\\n        if (is_subclass_of($config['callback_class'], ContainerAwareInterface::class)) {\\n            $serializer->addMethodCall('setContainer', [new Reference('service_container')]);\\n        }\\n    }\", \"output\": \"Loads and configures the serializer prototype.\\n\\n@param array            $config\\n@param ContainerBuilder $container\"}"}
{"text": "{\"input\": \"Summarize the following code: private function createDefaultManagerAlias($defaultManager, ContainerBuilder $container)\\n    {\\n        if (0 == count($this->loadedDrivers)) {\\n            return;\\n        }\\n\\n        if (count($this->loadedDrivers) > 1\\n            && in_array($defaultManager, $this->loadedDrivers)\\n        ) {\\n            $defaultManagerService = $defaultManager;\\n        } else {\\n            $defaultManagerService = $this->loadedDrivers[0];\\n        }\\n\\n        $container->setAlias('fos_elastica.manager', sprintf('fos_elastica.manager.%s', $defaultManagerService));\\n        $container->getAlias('fos_elastica.manager')->setPublic(true);\\n        $container->setAlias(RepositoryManagerInterface::class, 'fos_elastica.manager');\\n        $container->getAlias(RepositoryManagerInterface::class)->setPublic(false);\\n    }\", \"output\": \"Creates a default manager alias for defined default manager or the first loaded driver.\\n\\n@param string           $defaultManager\\n@param ContainerBuilder $container\"}"}
{"text": "{\"input\": \"Summarize the following code: private function getDynamicTemplateNode()\\n    {\\n        $node = $this->createTreeBuilderNode('dynamic_templates');\\n\\n        $node\\n            ->prototype('array')\\n                ->prototype('array')\\n                    ->children()\\n                        ->scalarNode('match')->end()\\n                        ->scalarNode('unmatch')->end()\\n                        ->scalarNode('match_mapping_type')->end()\\n                        ->scalarNode('path_match')->end()\\n                        ->scalarNode('path_unmatch')->end()\\n                        ->scalarNode('match_pattern')->end()\\n                        ->arrayNode('mapping')\\n                            ->prototype('variable')\\n                                ->treatNullLike([])\\n                            ->end()\\n                        ->end()\\n                    ->end()\\n                ->end()\\n            ->end()\\n        ;\\n\\n        return $node;\\n    }\", \"output\": \"Returns the array node used for \\\"dynamic_templates\\\".\"}"}
{"text": "{\"input\": \"Summarize the following code: private function getTypesNode()\\n    {\\n        $node = $this->createTreeBuilderNode('types');\\n\\n        $node\\n            ->useAttributeAsKey('name')\\n            ->prototype('array')\\n                ->treatNullLike([])\\n                ->beforeNormalization()\\n                ->ifNull()\\n                    ->thenEmptyArray()\\n                ->end()\\n                // Support multiple dynamic_template formats to match the old bundle style\\n                // and the way ElasticSearch expects them\\n                ->beforeNormalization()\\n                ->ifTrue(function ($v) {\\n                    return isset($v['dynamic_templates']);\\n                })\\n                ->then(function ($v) {\\n                    $dt = [];\\n                    foreach ($v['dynamic_templates'] as $key => $type) {\\n                        if (is_int($key)) {\\n                            $dt[] = $type;\\n                        } else {\\n                            $dt[][$key] = $type;\\n                        }\\n                    }\\n\\n                    $v['dynamic_templates'] = $dt;\\n\\n                    return $v;\\n                })\\n                ->end()\\n                ->children()\\n                    ->booleanNode('date_detection')->end()\\n                    ->arrayNode('dynamic_date_formats')->prototype('scalar')->end()->end()\\n                    ->scalarNode('analyzer')->end()\\n                    ->booleanNode('numeric_detection')->end()\\n                    ->scalarNode('dynamic')->end()\\n                    ->variableNode('indexable_callback')->end()\\n                    ->append($this->getPersistenceNode())\\n                    ->append($this->getSerializerNode())\\n                ->end()\\n                ->append($this->getIdNode())\\n                ->append($this->getPropertiesNode())\\n                ->append($this->getDynamicTemplateNode())\\n                ->append($this->getSourceNode())\\n                ->append($this->getRoutingNode())\\n                ->append($this->getParentNode())\\n                ->append($this->getAllNode())\\n            ->end()\\n        ;\\n\\n        return $node;\\n    }\", \"output\": \"Returns the array node used for \\\"types\\\".\"}"}
{"text": "{\"input\": \"Summarize the following code: private function getIdNode()\\n    {\\n        $node = $this->createTreeBuilderNode('_id');\\n\\n        $node\\n            ->children()\\n            ->scalarNode('path')->end()\\n            ->end()\\n        ;\\n\\n        return $node;\\n    }\", \"output\": \"Returns the array node used for \\\"_id\\\".\"}"}
{"text": "{\"input\": \"Summarize the following code: private function getSourceNode()\\n    {\\n        $node = $this->createTreeBuilderNode('_source');\\n\\n        $node\\n            ->children()\\n                ->arrayNode('excludes')\\n                    ->useAttributeAsKey('name')\\n                    ->prototype('scalar')->end()\\n                ->end()\\n                ->arrayNode('includes')\\n                    ->useAttributeAsKey('name')\\n                    ->prototype('scalar')->end()\\n                ->end()\\n                ->scalarNode('compress')->end()\\n                ->scalarNode('compress_threshold')->end()\\n                ->scalarNode('enabled')->defaultTrue()->end()\\n            ->end()\\n        ;\\n\\n        return $node;\\n    }\", \"output\": \"Returns the array node used for \\\"_source\\\".\"}"}
{"text": "{\"input\": \"Summarize the following code: private function getRoutingNode()\\n    {\\n        $node = $this->createTreeBuilderNode('_routing');\\n\\n        $node\\n            ->children()\\n                ->scalarNode('required')->end()\\n                ->scalarNode('path')->end()\\n            ->end()\\n        ;\\n\\n        return $node;\\n    }\", \"output\": \"Returns the array node used for \\\"_routing\\\".\"}"}
{"text": "{\"input\": \"Summarize the following code: private function getParentNode()\\n    {\\n        $node = $this->createTreeBuilderNode('_parent');\\n\\n        $node\\n            ->children()\\n                ->scalarNode('type')->end()\\n                ->scalarNode('property')->defaultValue(null)->end()\\n                ->scalarNode('identifier')->defaultValue('id')->end()\\n            ->end()\\n        ;\\n\\n        return $node;\\n    }\", \"output\": \"Returns the array node used for \\\"_parent\\\".\"}"}
{"text": "{\"input\": \"Summarize the following code: private function getAllNode()\\n    {\\n        $node = $this->createTreeBuilderNode('_all');\\n\\n        $node\\n            ->children()\\n            ->scalarNode('enabled')->defaultValue(true)->end()\\n            ->scalarNode('analyzer')->end()\\n            ->end()\\n        ;\\n\\n        return $node;\\n    }\", \"output\": \"Returns the array node used for \\\"_all\\\".\"}"}
{"text": "{\"input\": \"Summarize the following code: private function addIndexesSection(ArrayNodeDefinition $rootNode)\\n    {\\n        $rootNode\\n            ->fixXmlConfig('index')\\n            ->children()\\n                ->arrayNode('indexes')\\n                    ->useAttributeAsKey('name')\\n                    ->prototype('array')\\n                        ->children()\\n                            ->scalarNode('index_name')\\n                                ->info('Defaults to the name of the index, but can be modified if the index name is different in ElasticSearch')\\n                            ->end()\\n                            ->booleanNode('use_alias')->defaultValue(false)->end()\\n                            ->scalarNode('client')->end()\\n                            ->scalarNode('finder')\\n                                ->treatNullLike(true)\\n                                ->defaultFalse()\\n                            ->end()\\n                            ->arrayNode('type_prototype')\\n                                ->children()\\n                                    ->scalarNode('analyzer')->end()\\n                                    ->append($this->getPersistenceNode())\\n                                    ->append($this->getSerializerNode())\\n                                ->end()\\n                            ->end()\\n                            ->variableNode('settings')->defaultValue([])->end()\\n                        ->end()\\n                        ->append($this->getTypesNode())\\n                    ->end()\\n                ->end()\\n            ->end()\\n        ;\\n    }\", \"output\": \"Adds the configuration for the \\\"indexes\\\" key.\"}"}
{"text": "{\"input\": \"Summarize the following code: private function addIndexTemplatesSection(ArrayNodeDefinition $rootNode)\\n    {\\n        $rootNode\\n            ->fixXmlConfig('index_template')\\n            ->children()\\n                ->arrayNode('index_templates')\\n                    ->useAttributeAsKey('name')\\n                    ->prototype('array')\\n                        ->children()\\n                            ->scalarNode('template_name')\\n                                ->info('Defaults to the name of the index template, but can be modified if the index name is different in ElasticSearch')\\n                            ->end()\\n                            ->scalarNode('template')->isRequired()->end()\\n                            ->scalarNode('client')->end()\\n                            ->variableNode('settings')->defaultValue([])->end()\\n                        ->end()\\n                        ->append($this->getTypesNode())\\n                    ->end()\\n                ->end()\\n            ->end()\\n        ;\\n    }\", \"output\": \"Adds the configuration for the \\\"index_templates\\\" key.\\n\\n@param ArrayNodeDefinition $rootNode\\n\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: public function transform(array $elasticaObjects)\\n    {\\n        $ids = $highlights = [];\\n        foreach ($elasticaObjects as $elasticaObject) {\\n            $ids[] = $elasticaObject->getId();\\n            $highlights[$elasticaObject->getId()] = $elasticaObject->getHighlights();\\n        }\\n\\n        $objects = $this->findByIdentifiers($ids, $this->options['hydrate']);\\n        $objectsCnt = count($objects);\\n        $elasticaObjectsCnt = count($elasticaObjects);\\n        if (!$this->options['ignore_missing'] && $objectsCnt < $elasticaObjectsCnt) {\\n            throw new \\\\RuntimeException(sprintf('Cannot find corresponding Doctrine objects (%d) for all Elastica results (%d). IDs: %s', $objectsCnt, $elasticaObjectsCnt, implode(', ', $ids)));\\n        }\\n\\n        $propertyAccessor = $this->propertyAccessor;\\n        $identifier = $this->options['identifier'];\\n        foreach ($objects as $object) {\\n            if ($object instanceof HighlightableModelInterface) {\\n                $id = $propertyAccessor->getValue($object, $identifier);\\n                $object->setElasticHighlights($highlights[(string) $id]);\\n            }\\n        }\\n\\n        // sort objects in the order of ids\\n        $idPos = array_flip($ids);\\n        usort(\\n            $objects,\\n            function ($a, $b) use ($idPos, $identifier, $propertyAccessor) {\\n                if ($this->options['hydrate']) {\\n                    return $idPos[(string) $propertyAccessor->getValue(\\n                        $a,\\n                        $identifier\\n                    )] > $idPos[(string) $propertyAccessor->getValue($b, $identifier)];\\n                }\\n\\n                return $idPos[$a[$identifier]] > $idPos[$b[$identifier]];\\n            }\\n        );\\n\\n        return $objects;\\n    }\", \"output\": \"Transforms an array of elastica objects into an array of\\nmodel objects fetched from the doctrine repository.\\n\\n@param array $elasticaObjects of elastica objects\\n\\n@throws \\\\RuntimeException\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: public function isObjectIndexable($indexName, $typeName, $object)\\n    {\\n        $type = sprintf('%s/%s', $indexName, $typeName);\\n        $callback = $this->getCallback($type, $object);\\n        if (!$callback) {\\n            return true;\\n        }\\n\\n        if ($callback instanceof Expression) {\\n            return (bool) $this->getExpressionLanguage()->evaluate($callback, [\\n                'object' => $object,\\n                $this->getExpressionVar($object) => $object,\\n            ]);\\n        }\\n\\n        return is_string($callback)\\n            ? call_user_func([$object, $callback])\\n            : call_user_func($callback, $object);\\n    }\", \"output\": \"Return whether the object is indexable with respect to the callback.\\n\\n@param string $indexName\\n@param string $typeName\\n@param mixed  $object\\n\\n@return bool\"}"}
{"text": "{\"input\": \"Summarize the following code: private function buildCallback($type, $object)\\n    {\\n        if (!array_key_exists($type, $this->callbacks)) {\\n            return null;\\n        }\\n\\n        $callback = $this->callbacks[$type];\\n\\n        if (is_callable($callback) or is_callable([$object, $callback])) {\\n            return $callback;\\n        }\\n\\n        if (is_string($callback)) {\\n            return $this->buildExpressionCallback($type, $object, $callback);\\n        }\\n\\n        throw new \\\\InvalidArgumentException(sprintf('Callback for type \\\"%s\\\" is not a valid callback.', $type));\\n    }\", \"output\": \"Builds and initialises a callback.\\n\\n@param string $type\\n@param object $object\\n\\n@return callable|string|ExpressionLanguage|null\"}"}
{"text": "{\"input\": \"Summarize the following code: private function buildExpressionCallback($type, $object, $callback)\\n    {\\n        $expression = $this->getExpressionLanguage();\\n        if (!$expression) {\\n            throw new \\\\RuntimeException('Unable to process an expression without the ExpressionLanguage component.');\\n        }\\n\\n        try {\\n            $callback = new Expression($callback);\\n            $expression->compile($callback, [\\n                'object', $this->getExpressionVar($object),\\n            ]);\\n\\n            return $callback;\\n        } catch (SyntaxError $e) {\\n            throw new \\\\InvalidArgumentException(sprintf(\\n                'Callback for type \\\"%s\\\" is an invalid expression',\\n                $type\\n            ), $e->getCode(), $e);\\n        }\\n    }\", \"output\": \"Processes a string expression into an Expression.\\n\\n@param string $type\\n@param mixed  $object\\n@param string $callback\\n\\n@return Expression\"}"}
{"text": "{\"input\": \"Summarize the following code: private function getCallback($type, $object)\\n    {\\n        if (!array_key_exists($type, $this->initialisedCallbacks)) {\\n            $this->initialisedCallbacks[$type] = $this->buildCallback($type, $object);\\n        }\\n\\n        return $this->initialisedCallbacks[$type];\\n    }\", \"output\": \"Retreives a cached callback, or creates a new callback if one is not found.\\n\\n@param string $type\\n@param object $object\\n\\n@return mixed\"}"}
{"text": "{\"input\": \"Summarize the following code: private function getExpressionVar($object = null)\\n    {\\n        if (!is_object($object)) {\\n            return 'object';\\n        }\\n\\n        $ref = new \\\\ReflectionClass($object);\\n\\n        return strtolower($ref->getShortName());\\n    }\", \"output\": \"Returns the variable name to be used to access the object when using the ExpressionLanguage\\ncomponent to parse and evaluate an expression.\\n\\n@param mixed $object\\n\\n@return string\"}"}
{"text": "{\"input\": \"Summarize the following code: public function setRootName(IndexConfig $indexConfig, Index $index)\\n    {\\n        $index->overrideName(\\n            sprintf('%s_%s',\\n                $indexConfig->getElasticSearchName(),\\n                date('Y-m-d-His')\\n            )\\n        );\\n    }\", \"output\": \"Sets the randomised root name for an index.\\n\\n@param IndexConfig $indexConfig\\n@param Index       $index\"}"}
{"text": "{\"input\": \"Summarize the following code: public function switchIndexAlias(IndexConfig $indexConfig, Index $index, $force = false, $delete = true)\\n    {\\n        $client = $index->getClient();\\n\\n        $aliasName = $indexConfig->getElasticSearchName();\\n        $oldIndexName = null;\\n        $newIndexName = $index->getName();\\n\\n        try {\\n            $oldIndexName = $this->getAliasedIndex($client, $aliasName);\\n        } catch (AliasIsIndexException $e) {\\n            if (!$force) {\\n                throw $e;\\n            }\\n\\n            if ($delete) {\\n                $this->deleteIndex($client, $aliasName);\\n            } else {\\n                $this->closeIndex($client, $aliasName);\\n            }\\n        }\\n\\n        try {\\n            $aliasUpdateRequest = $this->buildAliasUpdateRequest($oldIndexName, $aliasName, $newIndexName);\\n            $client->request('_aliases', 'POST', $aliasUpdateRequest);\\n        } catch (ExceptionInterface $e) {\\n            $this->cleanupRenameFailure($client, $newIndexName, $e);\\n        }\\n\\n        // Delete the old index after the alias has been switched\\n        if (null !== $oldIndexName) {\\n            if ($delete) {\\n                $this->deleteIndex($client, $oldIndexName);\\n            } else {\\n                $this->closeIndex($client, $oldIndexName);\\n            }\\n        }\\n    }\", \"output\": \"Switches an index to become the new target for an alias. Only applies for\\nindexes that are set to use aliases.\\n\\n$force will delete an index encountered where an alias is expected.\\n\\n@param IndexConfig $indexConfig\\n@param Index       $index\\n@param bool        $force\\n@param bool        $delete\\n\\n@throws AliasIsIndexException\"}"}
{"text": "{\"input\": \"Summarize the following code: private function buildAliasUpdateRequest($aliasedIndex, $aliasName, $newIndexName)\\n    {\\n        $aliasUpdateRequest = ['actions' => []];\\n        if (null !== $aliasedIndex) {\\n            // if the alias is set - add an action to remove it\\n            $aliasUpdateRequest['actions'][] = [\\n                'remove' => ['index' => $aliasedIndex, 'alias' => $aliasName],\\n            ];\\n        }\\n\\n        // add an action to point the alias to the new index\\n        $aliasUpdateRequest['actions'][] = [\\n            'add' => ['index' => $newIndexName, 'alias' => $aliasName],\\n        ];\\n\\n        return $aliasUpdateRequest;\\n    }\", \"output\": \"Builds an ElasticSearch request to rename or create an alias.\\n\\n@param string|null $aliasedIndex\\n@param string      $aliasName\\n@param string      $newIndexName\\n\\n@return array\"}"}
{"text": "{\"input\": \"Summarize the following code: private function cleanupRenameFailure(Client $client, $indexName, \\\\Exception $renameAliasException)\\n    {\\n        $additionalError = '';\\n        try {\\n            $this->deleteIndex($client, $indexName);\\n        } catch (ExceptionInterface $deleteNewIndexException) {\\n            $additionalError = sprintf(\\n                'Tried to delete newly built index %s, but also failed: %s',\\n                $indexName,\\n                $deleteNewIndexException->getMessage()\\n            );\\n        }\\n\\n        throw new \\\\RuntimeException(sprintf(\\n            'Failed to updated index alias: %s. %s',\\n            $renameAliasException->getMessage(),\\n            $additionalError ?: sprintf('Newly built index %s was deleted', $indexName)\\n        ), 0, $renameAliasException);\\n    }\", \"output\": \"Cleans up an index when we encounter a failure to rename the alias.\\n\\n@param Client     $client\\n@param string     $indexName\\n@param \\\\Exception $renameAliasException\"}"}
{"text": "{\"input\": \"Summarize the following code: private function closeIndex(Client $client, $indexName)\\n    {\\n        try {\\n            $path = sprintf('%s/_close', $indexName);\\n            $client->request($path, Request::POST);\\n        } catch (ExceptionInterface $e) {\\n            throw new \\\\RuntimeException(\\n                sprintf(\\n                    'Failed to close index %s with message: %s',\\n                    $indexName,\\n                    $e->getMessage()\\n                ),\\n                0,\\n                $e\\n            );\\n        }\\n    }\", \"output\": \"Close an index.\\n\\n@param Client $client\\n@param string $indexName\"}"}
{"text": "{\"input\": \"Summarize the following code: private function getAliasedIndex(Client $client, $aliasName)\\n    {\\n        $aliasesInfo = $client->request('_aliases', 'GET')->getData();\\n        $aliasedIndexes = [];\\n\\n        foreach ($aliasesInfo as $indexName => $indexInfo) {\\n            if ($indexName === $aliasName) {\\n                throw new AliasIsIndexException($indexName);\\n            }\\n            if (!isset($indexInfo['aliases'])) {\\n                continue;\\n            }\\n\\n            $aliases = array_keys($indexInfo['aliases']);\\n            if (in_array($aliasName, $aliases)) {\\n                $aliasedIndexes[] = $indexName;\\n            }\\n        }\\n\\n        if (count($aliasedIndexes) > 1) {\\n            throw new \\\\RuntimeException(sprintf(\\n                'Alias %s is used for multiple indexes: [%s]. Make sure it\\\\'s'.\\n                'either not used or is assigned to one index only',\\n                $aliasName,\\n                implode(', ', $aliasedIndexes)\\n            ));\\n        }\\n\\n        return array_shift($aliasedIndexes);\\n    }\", \"output\": \"Returns the name of a single index that an alias points to or throws\\nan exception if there is more than one.\\n\\n@param Client $client\\n@param string $aliasName Alias name\\n\\n@return string|null\\n\\n@throws AliasIsIndexException\"}"}
{"text": "{\"input\": \"Summarize the following code: private function logQuery($path, $method, $data, array $query, $queryTime, $engineMS = 0, $itemCount = 0)\\n    {\\n        if (!$this->_logger or !$this->_logger instanceof ElasticaLogger) {\\n            return;\\n        }\\n\\n        $connection = $this->getLastRequest()->getConnection();\\n\\n        $connectionArray = [\\n            'host' => $connection->getHost(),\\n            'port' => $connection->getPort(),\\n            'transport' => $connection->getTransport(),\\n            'headers' => $connection->hasConfig('headers') ? $connection->getConfig('headers') : [],\\n        ];\\n\\n        /** @var ElasticaLogger $logger */\\n        $logger = $this->_logger;\\n        $logger->logQuery($path, $method, $data, $queryTime, $connectionArray, $query, $engineMS, $itemCount);\\n    }\", \"output\": \"Log the query if we have an instance of ElasticaLogger.\\n\\n@param string $path\\n@param string $method\\n@param array|string $data\\n@param array  $query\\n@param int    $queryTime\\n@param int    $engineMS\\n@param int    $itemCount\"}"}
{"text": "{\"input\": \"Summarize the following code: public function postPersist(LifecycleEventArgs $eventArgs)\\n    {\\n        $entity = $eventArgs->getObject();\\n\\n        if ($this->objectPersister->handlesObject($entity) && $this->isObjectIndexable($entity)) {\\n            $this->scheduledForInsertion[] = $entity;\\n        }\\n    }\", \"output\": \"Looks for new objects that should be indexed.\\n\\n@param LifecycleEventArgs $eventArgs\"}"}
{"text": "{\"input\": \"Summarize the following code: public function postUpdate(LifecycleEventArgs $eventArgs)\\n    {\\n        $entity = $eventArgs->getObject();\\n\\n        if ($this->objectPersister->handlesObject($entity)) {\\n            if ($this->isObjectIndexable($entity)) {\\n                $this->scheduledForUpdate[] = $entity;\\n            } else {\\n                // Delete if no longer indexable\\n                $this->scheduleForDeletion($entity);\\n            }\\n        }\\n    }\", \"output\": \"Looks for objects being updated that should be indexed or removed from the index.\\n\\n@param LifecycleEventArgs $eventArgs\"}"}
{"text": "{\"input\": \"Summarize the following code: public function preRemove(LifecycleEventArgs $eventArgs)\\n    {\\n        $entity = $eventArgs->getObject();\\n\\n        if ($this->objectPersister->handlesObject($entity)) {\\n            $this->scheduleForDeletion($entity);\\n        }\\n    }\", \"output\": \"Delete objects preRemove instead of postRemove so that we have access to the id.  Because this is called\\npreRemove, first check that the entity is managed by Doctrine.\\n\\n@param LifecycleEventArgs $eventArgs\"}"}
{"text": "{\"input\": \"Summarize the following code: private function persistScheduled()\\n    {\\n        if ($this->shouldPersist()) {\\n            if (count($this->scheduledForInsertion)) {\\n                $this->objectPersister->insertMany($this->scheduledForInsertion);\\n                $this->scheduledForInsertion = [];\\n            }\\n            if (count($this->scheduledForUpdate)) {\\n                $this->objectPersister->replaceMany($this->scheduledForUpdate);\\n                $this->scheduledForUpdate = [];\\n            }\\n            if (count($this->scheduledForDeletion)) {\\n                $this->objectPersister->deleteManyByIdentifiers($this->scheduledForDeletion);\\n                $this->scheduledForDeletion = [];\\n            }\\n        }\\n    }\", \"output\": \"Persist scheduled objects to ElasticSearch\\nAfter persisting, clear the scheduled queue to prevent multiple data updates when using multiple flush calls.\"}"}
{"text": "{\"input\": \"Summarize the following code: private function scheduleForDeletion($object)\\n    {\\n        if ($identifierValue = $this->propertyAccessor->getValue($object, $this->config['identifier'])) {\\n            $this->scheduledForDeletion[] = !is_scalar($identifierValue) ? (string) $identifierValue : $identifierValue;\\n        }\\n    }\", \"output\": \"Record the specified identifier to delete. Do not need to entire object.\\n\\n@param object $object\"}"}
{"text": "{\"input\": \"Summarize the following code: private function isObjectIndexable($object)\\n    {\\n        return $this->indexable->isObjectIndexable(\\n            $this->config['indexName'],\\n            $this->config['typeName'],\\n            $object\\n        );\\n    }\", \"output\": \"Checks if the object is indexable or not.\\n\\n@param object $object\\n\\n@return bool\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getRepository($entityName)\\n    {\\n        $realEntityName = $entityName;\\n        if (false !== strpos($entityName, ':')) {\\n            list($namespaceAlias, $simpleClassName) = explode(':', $entityName);\\n            $realEntityName = $this->managerRegistry->getAliasNamespace($namespaceAlias).'\\\\\\\\'.$simpleClassName;\\n        }\\n\\n        if (isset($this->entities[$realEntityName])) {\\n            $realEntityName = $this->entities[$realEntityName];\\n        }\\n\\n        return $this->repositoryManager->getRepository($realEntityName);\\n    }\", \"output\": \"Returns custom repository if one specified otherwise returns a basic repository.\\n\\n{@inheritdoc}\"}"}
{"text": "{\"input\": \"Summarize the following code: public function transform($object, array $fields)\\n    {\\n        $identifier = $this->propertyAccessor->getValue($object, $this->options['identifier']);\\n\\n        return new Document($identifier);\\n    }\", \"output\": \"Creates an elastica document with the id of the doctrine object as id.\\n\\n@param object $object the object to convert\\n@param array  $fields the keys we want to have in the returned array\\n\\n@return Document\"}"}
{"text": "{\"input\": \"Summarize the following code: public function getRepository($typeName)\\n    {\\n        if (isset($this->repositories[$typeName])) {\\n            return $this->repositories[$typeName];\\n        }\\n\\n        if (!isset($this->types[$typeName])) {\\n            throw new RuntimeException(sprintf('No search finder configured for %s', $typeName));\\n        }\\n\\n        $repository = $this->createRepository($typeName);\\n        $this->repositories[$typeName] = $repository;\\n\\n        return $repository;\\n    }\", \"output\": \"Return repository for entity.\\n\\nReturns custom repository if one specified otherwise\\nreturns a basic repository.\\n\\n@param string $typeName\\n\\n@return Repository\"}"}
{"text": "{\"input\": \"Summarize the following code: public function make(array $config): Hashids\\n    {\\n        $config = $this->getConfig($config);\\n\\n        return $this->getClient($config);\\n    }\", \"output\": \"Make a new Hashids client.\\n\\n@param array $config\\n\\n@return \\\\Hashids\\\\Hashids\"}"}
{"text": "{\"input\": \"Summarize the following code: protected function registerFactory(): void\\n    {\\n        $this->app->singleton('hashids.factory', function () {\\n            return new HashidsFactory();\\n        });\\n\\n        $this->app->alias('hashids.factory', HashidsFactory::class);\\n    }\", \"output\": \"Register the factory class.\\n\\n@return void\"}"}
{"text": "{\"input\": \"Summarize the following code: public function verifyHash(array $params)\\n    {\\n        if (empty($params['HASH'])) {\\n            return false;\\n        }\\n\\n        $hash = $params['HASH'];\\n        unset($params['HASH']);\\n\\n        return $hash === $this->calculateHash($params);\\n    }\", \"output\": \"Verify if the hash of the given parameter is correct\\n\\n@param array $params\\n\\n@return bool\"}"}
{"text": "{\"input\": \"Summarize the following code: public static function createGuzzle()\\n    {\\n        $client = null;\\n        if (!class_exists(Client::class)) {\\n            @trigger_error('The function \\\"HttpClientFactory::createGuzzle\\\" is depcrecated and will be removed in 2.0.', E_USER_DEPRECATED);\\n            throw new \\\\LogicException('Can not use \\\"HttpClientFactory::createGuzzle\\\" since Guzzle is not installed. This function is deprecated and will be removed in 2.0.');\\n        }\\n\\n        $version = \\\\GuzzleHttp\\\\ClientInterface::VERSION;\\n        if (substr($version, 0, 1) !== '6') {\\n            throw new \\\\LogicException('This version of Guzzle is not supported.');\\n        }\\n\\n        $curl = curl_version();\\n\\n        $curlOptions = [\\n             CURLOPT_USERAGENT => sprintf('Payum/1.x curl/%s PHP/%s', $curl['version'], phpversion()),\\n         ];\\n\\n        return new \\\\GuzzleHttp\\\\Client([\\n             'curl' => $curlOptions,\\n         ]);\\n    }\", \"output\": \"Create a Guzzle client.\\n\\n@return \\\\GuzzleHttp\\\\Client\"}"}
{"text": "{\"input\": \"Summarize the following code: public function addCookie(Cookie $cookie): void\\n    {\\n        $this->cookies[$this->getHash($cookie)] = $cookie;\\n    }\", \"output\": \"Adds a cookie to the current cookie jar.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function addCookieHeaders(RequestInterface $request): RequestInterface\\n    {\\n        $cookies = [];\\n        foreach ($this->getCookies() as $cookie) {\\n            if ($cookie->matchesRequest($request)) {\\n                $cookies[] = $cookie->toCookieHeader();\\n            }\\n        }\\n        if ($cookies) {\\n            $request = $request->withAddedHeader('Cookie', implode('; ', $cookies));\\n        }\\n\\n        return $request;\\n    }\", \"output\": \"Adds Cookie headers to the supplied request.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function clearExpiredCookies(): void\\n    {\\n        $cookies = $this->getCookies();\\n        foreach ($cookies as $i => $cookie) {\\n            if ($cookie->isExpired()) {\\n                unset($cookies[$i]);\\n            }\\n        }\\n\\n        $this->clear();\\n        $this->setCookies(array_values($cookies));\\n    }\", \"output\": \"Removes expired cookies.\"}"}
{"text": "{\"input\": \"Summarize the following code: private function getHash(Cookie $cookie): string\\n    {\\n        return sha1(sprintf(\\n            '%s|%s|%s',\\n            $cookie->getName(),\\n            $cookie->getAttribute(Cookie::ATTR_DOMAIN),\\n            $cookie->getAttribute(Cookie::ATTR_PATH)\\n        ));\\n    }\", \"output\": \"Create an unique identifier for the cookie. Two cookies with the same identifier\\nmay have different values.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function addHeader(string $input): void\\n    {\\n        list($key, $value) = explode(':', $input, 2);\\n        $this->response = $this->response->withAddedHeader(trim($key), trim($value));\\n    }\", \"output\": \"Add a single HTTP header line.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function parseHttpHeaders(array $headers): void\\n    {\\n        $headers = $this->filterHeaders($headers);\\n        $statusLine = array_shift($headers);\\n\\n        try {\\n            $this->setStatus($statusLine);\\n        } catch (InvalidArgumentException $e) {\\n            array_unshift($headers, $statusLine);\\n        }\\n\\n        foreach ($headers as $header) {\\n            $this->addHeader($header);\\n        }\\n    }\", \"output\": \"Add HTTP headers. The input array is all the header lines from the HTTP message. Optionally including the\\nstatus line.\"}"}
{"text": "{\"input\": \"Summarize the following code: public function handleRequest(RequestInterface $request, callable $next)\\n    {\\n        $this->setUri($request->getUri()->getPath());\\n        $this->setMethod(strtoupper($request->getMethod()));\\n        $this->setEntityBody($request->getBody()->__toString());\\n\\n        $header = $this->getHeader();\\n        if (null !== $header) {\\n            $request = $request->withHeader('Authorization', $header);\\n        }\\n\\n        return $next($request);\\n    }\", \"output\": \"Populates uri, method and entityBody used to generate the Authentication header using the specified request object.\\nAppends the Authentication header if it is present and has been able to be calculated.\"}"}
