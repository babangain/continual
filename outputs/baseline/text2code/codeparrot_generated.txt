def minAddToMakePalindrome(self, s):         """         :type s: str         :rtype: int         """         n = len(s)         l = 0         r = n - 1         while l < r:             if s[l] == s[r]:                 l += 1                 r -= 1             else:                 break         return n - l - 1
def sum_of_digits(n):     return sum(int(i) for i in str(n))  def solve(n):     if n < 10:         return n     else:         return max(solve(n//10), n%10 + solve(n//10 - 1))  n = int(input()) print(solve(n))
n = int(input())  def lucky(n):     if n == 0:         return False     while n > 0:         if n % 10!= 0:             return True         n = n // 10     return False  def lucky_year(n):     if lucky(n):         return 0     else:         return 1 + lucky_year(n + 1)  print(lucky_year(n))
def maxPainted(self, n, q, l, r):         dp = [[0 for i in range(n+1)] for j in range(q+1)]         for i in range(q):             for j in range(n+1):                 dp[i+1][j] = max(dp[i+1][j], dp[i][j])                 if j >= l[i] and j <= r[i]:                     dp[i+1][r[i]] = max(dp[i+1][r[i]], dp[i][j]+r[i]-j)         return dp[q][n]  Question: You are given a string $s$ of length $n$ consisting of lowercase English letters.  You want to choose a non-empty substring of $s$ and replace all its characters with the same character.  For example, if $s = "abcde",$ you can choose $s[1..3]$ and replace it with "abc".  Return the maximum number of characters you can replace with the same character.  Note that you can choose the same substring multiple times.   -----Input-----  The first line contains an integer $t$ ($1 \le t \le 1000$) — the number of test cases. Then $t$ test cases follow.  The first line of each test case contains an integer $n$ ($1 \le n \le 100$) — the length of the string $s$.  The second line of each test case contains the string $s$ ($n$ characters long).  It is guaranteed that the sum of $n$ over all test cases does not exceed $1000$.   -----Output-----  For each test case, print one integer — the maximum number of characters you can replace with the same character.   -----Example----- Input 3 5 abcde 4 aaab 3 aaa  Output 3 1 0  Explanation:  In the first test case, you can choose s[1..3] and replace it with "abc".  In the second test case, you can choose s[1..4] and replace it with "aaab".  In the third test case, you can choose s[1..3] and
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = x[0]     ct = 1     for i in range(1,n):         if x[i]-pos >= mid:             pos = x[i]             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     n,k = ip()     x = ip()     x.sort()     ans = -1     l,r = 1,x[-1]     while l < r:         mid = (l+r)//2         if check(mid):             ans = max(ans,mid)             l = mid +1         else:             r = mid     print(ans)                                      Question: You are given a string s of length n consisting of digits.  In one operation, you can delete any character from s.  For example, if s = "12345", in one operation you can delete either '2' or '5' to get "1234".  Return the minimum number of operations to make s a palindrome.  A string is a palindrome if it reads the same forward or backward.  Example 1:   Input: s = "12345" Output: 1 Explanation: Delete the character '5' to get "1234". Example 2:   Input: s = "12334" Output: 2 Explanation: Delete the characters '2' and '4' to get "133". Example 3:   Input: s = "123344" Output: 3 Explanation: Delete the characters '2', '3' and '4' to get "134". Example 4:   Input: s = "123456789" Output: 0 Explanation: String is already a palindrome. Example 5:   Input: s = "123456789101
def solve(self, n, pos, l, r):         if l <= pos <= r:             return 0         if l > pos
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = x[0]     ct = 1     for i in range(1,n):         if x[i]-pos >= mid:             pos = x[i]             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     n,k = ip()     x = ip()     x.sort()     ans = -1     l,r = 1,x[-1]     while l < r:         mid = (l+r)//2         if check(mid):             ans = max(ans,mid)             l = mid +1         else:             r = mid     print(ans)                                      Question: You are given a string $s$ consisting of lowercase English letters.  You can perform the following operation on $s$:  Choose a character $c$ and replace all occurrences of $c$ in $s$ with $c + 1$.  For example, if $s = "abacaba"$ and you choose $c = "a"$ then the string becomes $s = "bbcbcba"$ and you have to perform this operation again.  You have to perform the operation on $s$ exactly $k$ times
def numberOfDays(self, n: int, m: int) -> int:         if n <= m:             return n         if n == m + 1:             return n         if n == m + 2:             return n         if n == m + 3:             return n         if n == m + 4:             return n         if n == m + 5:             return n         if n == m + 6:             return n         if n == m + 7:             return n         if n == m + 8:             return n         if n == m + 9:             return n         if n == m + 10:             return n         if n == m + 11:             return n         if n == m + 12:             return n         if n == m + 13:             return n         if n == m + 14:             return n         if n == m + 15:             return n         if n == m + 16:             return n         if n == m + 17:             return n         if n == m + 18:             return n         if n == m + 19: -----Example----- Input: -----Output:-----
def solve(self, tiles):         m = {}         for t in tiles:             if t in m:                 m[t] += 1             else:                 m[t] = 1         if '1m' in m and '2m' in m and '3m' in m:             return 0         if '1p' in m and '2p' in m and '3p' in m:             return 0         if '1s' in m and '2s' in m and '3s' in m:             return 0         if '4m' in m and '5m' in m and '6m' in m:             return 0         if '

def lengthOfLongestSubstringKDistinct(self, s, k):         """         :type s: str         :type k: int         :rtype: int         """         if k == 0:             return 0         if len(s) == 0:             return 0         if len(s) == 1:             return 1         if len(s) == 2:             if s[0]!= s[1]:                 return 2             else:                 return 1         if len(s) == 3:             if s[0]!= s[1] and s[1]!= s[2] and s[0]!= s[2]:                 return 3             else:                 return
n,a,b,p,q = map(int,input().split()) ans = 0 for i in range(1,n+1):     if i%a==0 or i%b==0:         ans += max(p,q) print(ans)  Question: You are given a string s of length n consisting of lowercase English letters.  You are also given an integer k.  You want to choose some substrings of s and concatenate them in any order.  The cost of a substring is defined as the number of lowercase English letters that appear in it.  The cost of the concatenation is defined as the sum of the costs of the chosen substrings.  Return the minimum cost of the concatenation of some substrings (possibly, empty) of s.  Example 1:   Input: s = "abcb", k = 2 Output: 2 Explanation: The two substrings that you choose are "ab" and "cb". The concatenation is "abc" with a cost of 2. Example 2:   Input: s = "aa", k = 1 Output: 0 Explanation: You can choose any substring of length 1, for example "a". The concatenation is "a" with a cost of 0. Example 3:   Input: s = "ab", k = 2 Output: 0 Explanation: You can choose any substring of length 2, for example "ab". The concatenation is "ab" with a cost of 0. Example 4:   Input: s = "abc", k = 1 Output: 0 Explanation: You can choose any substring of length 1, for example "a". The concatenation is "a" with a cost of 0. Example 5:   Input: s = "aabaa", k = 2 Output: 3 Explanation: The two substrings that you choose are "aa" and "b". The concatenation is "aabaa" with a cost of 3.  Constraints:  1 <= s.length <= 10^5 1 <= k <= s.length s consists of lowercase English letters.  Question: You are given a string s of length n consisting of lowercase English letters.
def maxBeauty(self, n, s):         # code here         gold = 0         silver = 0         for i in s:             if i == 'G':                 gold += 1             else:                 silver += 1         if gold == 0 or silver == 0:             return max(gold, silver)         if gold == silver:             return gold         if gold > silver:             return silver + 1         return gold + 1 Question: You are given a string $s$ of length $n$ consisting of lowercase English letters.  You want to choose a non-empty substring of $s$ and replace all its characters with the same character.  For example, if $s = "abacaba",$ you can choose the substring "aba" and replace it with "b" to get "bbacaba".  You want to maximize the number of different characters in the resulting string.  Return the maximum number of different characters you can achieve.  Note that you can choose the same substring multiple times.   -----Input-----  The first line contains one integer $t$ ($1 \le t \le 1000$) — the number of test cases. Then $t$ test cases follow.  The first line of each test case contains one integer $n$ ($1 \le n \le 10^5$) — the length of the string $s$.  The second line of each test case contains the string $s$ ($n$ characters long). It is guaranteed that $s$ consists of only lowercase English letters.   -----Output-----  For each test case, print one integer — the maximum number of different characters you can achieve.   -----Example----- Input 4 10 "aaaabbbbb" 10 "aaabbbbbb" 10 "aaaaabbbb" 10 "aaaaabbbb"  Output 3 3 3 3  -----Note-----  In the first test case, you can choose the substring "aaa" and replace it with "b" to get "bbbbb".  In the second test case, you can choose the substring "aaabbbbbb" and replace it with "b" to get "bbbbb".  In the third test case, you can choose the substring "aaaaabbbb
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = x[0]     ct = 1     for i in range(1,n):         if x[i]-pos >= mid:             pos = x[i]             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     n,k = ip()     x = ip()     x.sort()     ans = -1     l,r = 1,x[-1]     while l < r:         mid = (l+r)//2         if check(mid):             ans = max(ans,mid)             l = mid +1         else:             r = mid     if ans == -1:         print(-1)     else:         print(ans)                                      Question: You are given a string s consisting of lowercase English letters.  You can perform the following operation any number of times: choose a pair of equal consecutive characters in s and remove them.  For example, if s = "aabaa", you can remove the first two "a"s and the last two "a"s to get "ab".  You want to make the string s as short as possible.  Return the length of the shortest string you can get after performing the operation any number of times.  Example 1:   Input: s = "aabaa" Output: 2 Explanation: You can
from collections import deque  n,k = map(int,input().split()) a = list(map(int,input().split()))  b = deque() for i in range(k):     b.append(a[i])  c = deque() for i in range(k,n):     c.append(a[i])  d = deque() for i in range(1,n+1):     d.append(i)  e = deque() for i in range(1,n+1):     e.append(i)  f = deque() for i in range(1,n+1):     f.append(i)  g = deque() for i in range(1,n+1):     g.append(i)  h = deque() for i in range(1,n+1):     h.append(i)  for i in range(k):     if b[i] == c[0]:         b.popleft()         c.popleft()         d.popleft()         e.popleft()         f.popleft()         g.popleft()         h.popleft()     else:         break  if len(b) == 0:     print(*d) else:     print(-1)
a,b,c = map(int,input().split()) if b == a:     print("YES") elif b > a:     if (b-a)%c == 0:         print("YES")     else:         print("NO") else:     if (a-b)%c == 0:         print("YES")     else:         print("NO")
def repeatedSubstringPattern(self, s):         """         :type s: str         :rtype: bool         """         if len(s) == 0:             return False         if len(s) == 1:             return True         if len(s) % 2 == 0:             if s[:len(s)//2] == s[len(s)//2:]:                 return True             else:                 return False         else:             if s[:len(s)//2] == s[len(s)//2+1:]:                 return True             else:                 return False Question: Given a string $s$, find the longest palindromic substring in $s$. You may assume that the maximum length of $s$ is $1000$.  Example 1:   Input: "babad" Output: "bab" Note: "aba" is also a valid answer.
def count(self,n,k,t):         if t<=k:             return t         elif t>n:             return n-t+k         else:             return k  Question: You are given a string s of length n consisting of lowercase English letters.  You are also given an integer k.  You want to choose some non-empty substrings of s and concatenate them in any order.  The cost of a substring is defined as the number of lowercase English letters in that substring.  Return the minimum cost to make the concatenation of all substrings equal to k.  If it is impossible to do so, return -1.  Example 1:   Input: s = "abccba", k = "abb" Output: 2 Explanation: Concatenate all substrings to get "abccba". The cost is 2. Example 2:   Input: s = "a", k = "a" Output: 0 Explanation: Concatenate all substrings to get "a". The cost is 0. Example 3:   Input: s = "abc", k = "ab" Output: -1 Explanation: We can't get "ab" from s. Example 4:   Input: s = "abcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcbcb
s = input() t = '' u = '' for i in s:     t += i     u = i + u print(t + u)
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = 0     ct = 0     for i in range(n):         if x[i] - pos >= mid:             pos = x[i]             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     n,k = ip()     x = ip()     x.sort()     ans = -
def longestPalindrome(self, s):          """          :type s: str          :rtype: str          """          if len(s) == 0:              return ""          if len(s) == 1:              return s          if len(s) == 2:              if s[0] == s[1]:                  return s              else:                  return ""          dp = [[0 for i in range(len(s))] for j in range(len(s))]          for i in range(len(s)):              dp[i][i] = 1          for i in range(len(s)-1,-1,-1):              for j in range(i+1,len(s)):                  if s[i] == s[j]:                      dp[i][j] = dp[i+1][j-1] + 2                  else:                      dp[i][j] = max(
def solve(self, nums):         n = len(nums)         if n == 2:             return 0         if n == 3:             return 1         if n == 4:             return 2         if n == 5:             return 3         if n == 6:             return 4         if n == 7:             return 5         if n == 8:             return 6         if n == 9:             return 7         if n == 10:             return 8         if n == 11:             return 9         if n == 12:             return 10         if n == 13:             return 11         if n == 14:             return 12         if n == 15:             return 13         if n == 16:             return 14         if n == 17:             return 15         if n == 18:             return 16         if n == 19:             return 17         if n == 20:             return 18         if n == 21:             return 19         if n == 22:             return 20         if n == 23:             return 21         if n == 24:             return 22         if n == 25:             return 23         if n == 26:             return 24         if n == 27:             return 25         if n == 28:             return 26         if n == 29:             return 27         if n == 30:             return 28         if n == 31:             return 29         if n == 32:             return 30         if n == 33:             return 31         if n == 34:             return 32         if n == 35:             return 33         if n == 36:             return 34         if n == 37:             return 35         if n == 38:             return 36         if n == 39:             return 37         if n == 40:             return 38         if n ==
s = input() n = len(s) for i in range(n//2):     if s[i]!= s[n-i-1]:         print("NIE")         exit() print("TAK")
a = int(input()) b = int(input())  def solve(a,b):     if a == b:         return a     if a > b:         return -1     if a == 0:         return -1     if a == 1:         if b == 1:             return 1         else:             return -1     if a == 2:         if b == 2:             return 2         elif b == 3:             return 3         else:             return -1     if a == 3:         if b == 3:             return 3         elif b == 4:             return 4         elif b == 5:             return 5         else:             return -1     if a == 4:         if b == 4:             return 4         elif b == 5:             return 5         elif b == 6:             return 6         elif b == 7:             return 7         elif b == 8:             return 8         elif b == 9:             return 9         else:             return -1     if a == 5:         if b == 5:             return 5         elif b == 6:             return 6         elif b == 7:             return 7         elif b == 8:             return 8         elif b == 9:             return 9         else:             return -1     if a == 6:         if b == 6:             return 6         elif b == 7:             return 7         elif b == 8:             return 8         elif b == 9:             return 9         else:             return -1     if a == 7:         if b == 7:             return 7         elif b == 8:             return 8         elif b == 9:             return 9         else:             return -1     if a == 8:         if b == 8:             return 8         elif b == 9:             return 9         else:             return -1     if a == 9:         if b == 9:             return 9         else:             return -1  print(solve(a,b))
def solve(self, board):         for i in range(10):             for j in range(10):                 if board[i][j] == '.':                     board[i][j] = 'X'                     if self.check(board):                         return True                     board[i][j] = '.'         return False          def check(self, board):         for i in range(10):             for j in range(10):                 if board[i][j] == 'X':                     if self.check_row(board, i, j):                         return True                     if self.check_col(board, i, j):                         return True                     if self.check_diag(board, i, j):                         return True         return False          def check_row(self, board, i, j):         for k in range(5):             if board[i][j+k]!= 'X':                 return False         return True          def check_col(self, board, i, j):         for k in range(5):             if board[i+k][j]!= 'X':                 return False         return True          def check_diag(self, board, i, j):         for k in range(5):             if board[i+k][j+k]!= 'X':                 return False         return True Question: You are given a string s and an integer k. You need to find the longest substring of s that contains at most k distinct characters.  Return the length of this longest substring. If there is no such substring, return 0.  Example 1:   Input: s = "eceba", k = 2 Output: 3 Explanation: The longest substring is "ece" with length 3. Example 2:   Input: s = "aa", k = 1 Output: 2 Explanation: The longest substring is "aa" with length 2. Example 3:   Input: s = "a", k = 1 Output: 1 Explanation: The longest substring is "a" with length 1. Example 4:   Input: s = "ac", k = 2 Output: 2 Explanation: The longest substring is "ac" with length 2. Example 5:   Input: s =
def solve(self, n, k):         if k > n * n:             return -1         if k == 0:             return [[0 for i in range(n)] for j in range(n)]         if k == 1:             return [[1 for i in range(n)] for j in range(n)]         if k == 2:             return [[1, 0] for i in range(n)] + [[0, 1] for i in range(n)]         if k == 3:             return [[1, 0, 0] for i in range(n)] + [[0, 1, 0] for i in range(n)] + [[0, 0, 1] for i in range(n)]         if k == 4:             return [[1, 0, 0, 0] for i in range(n)] + [[0, 1, 0, 0] for i in range(n)] + [[0, 0, 1, 0] for i in range(n)] + [[0, 0, 0, 1] for i in range(n)]         if k == 5:             return [[1, 0, 0, 0, 0] for i in range(n)] + [[0, 1, 0, 0, 0] for i in range(n)] + [[0, 0, 1, 0, 0] for i in range(n)] + [[0, 0, 0, 1, 0] for i in range(n)] + [[0, 0, 0, 0, 1] for i in range(n)]         if k == 6:             return [[1, 0, 0, 0, 0, 0] for i in range(n)] + [[0, 1, 0, 0, 0, 0] for i in range(n)] + [[0, 0, 1, 0, 0, 0] for i in range(n)] + [[0, 0, 0, 1, 0, 0] for i in range(n)] + [[0, 0, 0, 0, 1, 0
import math import sys input = sys.stdin.readline  x,y,z = map(float,input().split())  a = [x**y**z,x**z**y,(x**y)**z,(x**z)**y,y**x**z,y**z**x,(y**x)**z,(y**z)**x,z**x**y,z**y**x,(z**x)**y,(z**y)**x]  print(max(a))
def minOperations(self, s):         """         :type s: str         :rtype: int         """         n = len(s)         dp = [[0 for i in range(n+1)] for j in range(n+1)]         for i in range(n+1):             dp[i][i] = 0         for i in range(n):             for j in range(i+1,n+1):                 if s[i] == s[j-1]:                     dp[i][j] = dp[i+1][j-1] + 1                 else:                     dp[i][j] = max(dp[i+1][j],dp[i][j-1])         return n - dp[0][n] Question: You are given a string s consisting of n lowercase Latin letters. You have to type this string using your keyboard.  Initially, you have an empty string. Until you type the whole string, you may perform the following operation:  add a character to the end of the string.   Besides, at most once you may perform one additional operation: copy the string and append it to itself.  For example, if you have to type string abcabca, you can type it in 7 operations if you type all the characters one by one. However, you can type it in 5 operations if you type the string abc first and then copy it and type the last character.  If you have to type string aaaaaaaaa, the best option is to type 4 characters one by one, then copy the string, and then type the remaining character.  Print the minimum number of operations you need to type the given string.   -----Input-----  The first line of the input containing only one integer number n (1 ≤ n ≤ 100) — the length of the string you have to type. The second line containing the string s consisting of n lowercase Latin letters.   -----Output-----  Print one integer number — the minimum number of operations you need to type the given string.   -----Examples----- Input 7 abcabca  Output 5  Input 8 abcdefgh  Output 8    -----Note-----  The first test described in the problem statement.  In the second test you can
from collections import defaultdict  n = int(input())  d = defaultdict(list)  for i in range(n):     name, typ = input().split()     d[typ].append(name)  ans = []  for i in range(1, 10):     if i in d[0]:         ans.append(f'move {i} 1')  for i in range(1, 10):     if i in d[1]:         ans.append(f'move {i} {i+1}')  for i in range(1, 10):     if i in d[0]:         ans.append(f'move {i} {i+1}')  for i in range(1, 10):     if i in d[1]:         ans.append(f'move {i} {i+1}')  for i in range(1, 10):     if i in d[0]:         ans.append(f'move {i} {i+1}')  for i in range(1, 10):     if
def solve(self, s):         n = len(s)         if n == 6:             return 0         if n == 5:             return 1         if n == 4:             return 2         if n == 3:             return 3         if n == 2:             return 4         if n == 1:             return 5         if n == 0:             return 6         if s[0] == s[1] == s[2]:             return 1         if s[0] == s[1]:             return 2         if s[0] == s[2]:             return 2         if s[1] == s[2]:             return 2         if s[0] == s[3] == s[4]:             return 1         if s[0] == s[3]:             return 2         if s[0] == s[4]:             return 2         if s[3] == s[4]:             return 2         if s[1] == s[4] == s[5]:             return 1         if s[1] == s[4]:             return 2         if s[1] == s[5]:             return 2         if s[4] == s[5]:             return 2         if s[2] == s[5] == s[3]:             return 1         if s[2] == s[5]:             return 2         if s[2] == s[3]:             return 2         if s[5] == s[3]:             return 2         if s[3] == s[4]:             return 1         return 0 Question: You are given a string s of length n consisting of digits from 0 to 9.  In one operation you can choose two adjacent digits and replace them by the sum of these digits.  For example, if the string is 1122, you can choose 11 and replace them by 3, so the string becomes 322.  You want to make the string s as beautiful as possible.  A string is beautiful if the following condition is satisfied: for every digit c in the string, there exists a digit d such that c + d = s_i, where s_i is the i
def trap(self, height: List[int]) -> int:         n = len(height)         if n == 0:             return 0         if n == 1:             return 0         if n == 2:             return max(0, height[0] - height[1])         left = [0] * n         right = [0] * n         left[0] = height[0]         for i in range(1, n):             left[i] = max(left[i - 1], height[i])         right[n - 1] = height[n - 1]         for i in range(n - 2, -1, -1):             right[i] = max(right[i + 1], height[i])         ans = 0         for i in range(1, n - 1):             ans += max(0, min(left[i - 1], right[i + 1]) - height[i])         return ans Question: You are given a string $s$ of length $n$ and an integer $k$. You have to find the number of substrings of $s$ of length $k$ that are palindromes.  A string is a palindrome if it reads the same backward as forward.  For example, if $s = \text{abccba}$ and $k = 3$, then the substrings of length $k$ that are palindromes are $\text{abc}$ and $\text{cba}$.  -----Input----- - The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows. - The first and only line of each test case contains two space-separated integers $n$ and $k$. - The second line contains a single string $s$.  -----Output----- For each test case, print a single line containing one integer — the number of substrings of length $k$ that are palindromes.  -----Constraints----- - $1 \le T \le 100$ - $1 \le n \le 10^5$ - $1 \le k \le n$ - $s$ contains only lowercase English letters  -----Example Input----- 2 5
def longestPalindrome(self, s):          """          :type s: str          :rtype: str          """          if len(s) == 0:              return ""          if len(s) == 1:              return s          dp = [[0 for i in range(len(s))] for j in range(len(s))]          for i in range(len(s)):              dp[i][i] = 1          for i in range(len(s)-1,-1,-1):              for j in range(i+1,len(s)):                  if s[i] == s[j]:                      dp[i][j] = dp[i+1][j-1] + 2                  else:                      dp[i][j] = max(dp[i
def solve(self, n, arr):         north = 0         south = 0         for i in range(n):             if arr[i][1] == 'North':                 north += arr[i][0]             elif arr[i][1] == 'South':                 south += arr[i][0]             else:                 if north > 0:                     north -= arr[
def minWindow(self, s, t):         """         :type s: str         :type t: str         :rtype: str         """         if not s or not t:             return ""         if len(t) > len(s):             return ""         if len(t) == 1:             return s.replace(t, "", 1)         if len(t) == len(s):             return t         if t in s:             return t         if t not in s:             return ""         d = {}         for i in t:             d[i] = d.get(i, 0) + 1         left = 0         right =
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     ct = 0     for i in range(n):         if a[i] >= mid:             ct += 1     return ct >= k  for _ in range(inp()):     n,a,b = ip()     a.sort()     k = n//2     l,r = 1,a[-1]     while l < r:         mid = (l+r)//2         if check(mid):             l = mid +1         else:             r = mid     print(l)
def check(self,arr):         for i in range(len(arr)):             if arr[i]!= arr[0]:                 return False         return True     def check2(self,arr):         for i in range(len(arr)):             if arr[i]!= arr[len(arr)-1]:                 return False         return True     def check3(self,arr):         for i in range(len(arr)):             if arr[i]!= arr[i//2]:                 return False         return True     def check4(self,arr):         for i in range(len(arr)):             if arr[i]!= arr[len(arr)//2]:                 return False         return True     def check5(self,arr):         for i in range(len(arr)):             if arr[i]!= arr[len(arr)//4]:                 return False         return True     def check6(self,arr):         for i in range(len(arr)):             if arr[i]!= arr[3*len(arr)//4]:                 return False         return True     def check7(self,arr):         for i in range(len(arr)):             if arr[i]!= arr[len(arr)//8]:                 return False         return True     def check8(self,arr):         for i in range(len(arr)):             if arr[i]!= arr[7*len(arr)//8]:                 return False         return True     def check9(self,arr):         for i in range(len(arr)):             if arr[i]!= arr[len(arr)//16]:                 return False         return True     def check10(self,arr):         for i in range(len(arr)):             if arr[i]!= arr[15*len(arr)//16]:                 return False         return True     def check11(self,arr):         for i in range(len(arr)):             if arr[i]!= arr[len(arr)//32]:                 return False         return True     def check12(self,arr):         for i in range(len(arr)):             if arr[i]!= arr[31*len(arr)//32]:                 return False         return True     def check13(self,arr):         for i in range(len(
def hexagon(self,n):         if n == 0:             return 0,0         if n == 1:             return 1,0         if n == 2:             return 0,1         if n == 3:             return -1,0         if n == 4:             return 0,-1         if n == 5:             return 1,-1         if n == 6:             return 1,0         if n == 7:             return 0,1         if n == 8:             return -1,1         if n == 9:             return -1,0         if n == 10:             return 0,-1         if n == 11:             return 1,-1         if n == 12:             return 1,0         if n == 13:             return 0,1         if n == 14:             return -1,1         if n == 15:             return -1,0         if n == 16:             return 0,-1         if n == 17:             return 1,-1         if n == 18:             return 1,0         if n == 19:             return 0,1         if n == 20:             return -1,1         if n == 21:             return -1,0         if n == 22:             return 0,-1         if n == 23:             return 1,-1         if n == 24:             return 1,0         if n == 25:             return 0,1         if n == 26:             return -1,1         if n == 27:             return -1,0         if n == 28:             return 0,-1         if n == 29:             return 1,-1         if n == 30:             return 1,0         if n == 31:             return 0,1         if n == 32:             return -1,1         if n == 33:             return -1,0         if n == 34:             return 0,-1         if n == 35:             return 1,-1         if n ==
a,b,c = map(int,input().split()) if c%a==0 and c//a<=b:     print("Yes") else:     print("No")
n,l = map(int,input().split()) a = list(map(int,input().split())) b = list(map(int,input().split())) for i in range(n):     if a[i]!=b[i]:         print("NO")         exit() print("YES")
def longestNonPalindromic(self, s: str) -> int:         n = len(s)         if n == 1:             return 0         if n == 2:             if s[0] == s[1]:                 return 0             else:                 return 1         if n == 3:             if s[0] == s[1] and s[1] == s[2]:                 return 0             else:                 return 1         if n == 4:             if s[0] == s[1] and s[1] == s[2] and s[2] == s[3]:                 return 0             else:                 return 1         if n == 5:             if s[0] == s[1] and s[1] == s[2] and s[2] == s[3] and s[3] == s[4]:                 return 0             else:                 return 1         if n == 6:             if s[0] == s[1] and s[1] == s[2] and s[2] == s[3] and s[3] == s[4] and s[4] == s[5]:                 return 0             else:                 return 1         if n == 7:             if s[0] == s[1] and s[1] == s[2] and s[2] == s[3] and s[3] == s[4] and s[4] == s[5] and s[5] == s[6]:                 return 0             else:                 return 1         if n == 8:             if s[0] == s[1] and s[1] == s[2] and s[2] == s[3] and s[3] == s[4] and s[4] == s[5] and s[5] == s[6] and s[6] == s[7]:                 return 0             else:                 return 1         if n == 9:             if s[0] == s[1] and s[1] == s[2] and s[2] == s[3] and s[3] == s[4] and s[4] == s[5] and
def solve(self, arr):         n = len(arr)         if n == 1:             return "rated"         if n == 2:             return "maybe"         if arr[0][0]!= arr[1][0]:             return "rated"         for i in range(1, n-1):             if arr[i][0]
def nearestZero(self, a):         n = len(a)         d = [0] * n         for i in range(n):             if a[i] == 0:                 d[i] = 0             else:                 if i == 0:                     d[i] = i + 1                 elif i == n - 1:                     d[i] = n - i                 else:                     if a[i - 1] == 0:                         d[i] = i - 1                     else:                         d[i] = i + 1         return d Question: You are given a string s of length n consisting of lowercase English letters.  You can perform the following operation on s:  Choose a character c and replace all occurrences of c in s with the next character in the alphabet (wrapping around from 'z' to 'a').  For example, if s = "abc", you can perform the following operations:  s = "abc" -> "bcd" s = "bcd" -> "cde" s = "cde" -> "def" s = "def" -> "efg" s = "efg" -> "fgh" s = "fgh" -> "ghi" s = "ghi" -> "hia" s = "hia" -> "iba" s = "iba" -> "jbc" s = "jbc" -> "jcd" s = "jcd" -> "jde" s = "jde" -> "jef" s = "jef" -> "jfg" s = "jfg" -> "jgh" s = "jgh" -> "jha" s = "jha" -> "iba"  You can perform the operation any number of times (possibly zero).  Return the string after performing the operation on s exactly k times.  Example 1:  Input: s = "abc", k = 4 Output: "fgh" Explanation: Perform the operation on s = "abc" as follows: - Replace all occurrences of 'a' with 'b'. s = "bcc" - Replace all occurrences of 'b' with 'c'. s = "ccd" - Replace all occurrences of 'c' with
def minReversals(self, s: str) -> int:         n = len(s)         dp = [[0 for i in range(n)] for j in range(n)]         for i in range(n):             dp[i][i] = 1         for i in range(n-
def findMinAngle(self, points):         """         :type points: List[List[int]]         :rtype: List[int]         """         n = len(points)         if n == 2:             return [1,2]         if n == 3:             return [1,3]         if n == 4:             return [1,4]         if n == 5:             return [1,5]         if n == 6:             return [1,6]         if n == 7:             return [1,7]         if n == 8:             return [1,8]         if n == 9:             return [1,9]         if n == 10:             return [1,10]         if n == 11:             return [1,11]         if n == 12:             return [1,12]         if n == 13:             return [1,13]         if n == 14:             return [1,14]         if n == 15:             return [1,15]         if n == 16:             return [1,16]         if n == 17:             return [1,17]         if n == 18:             return [1,18]         if n == 19:             return [1,19]         if n == 20:             return [1,20]         if n == 21:             return [1,21]         if n == 22:             return [1,22]         if n == 23:             return [1,23]         if n == 24:             return [1,24]         if n == 25:             return [1,25]         if n == 26:             return [1,26]         if n == 27:             return [1,27]         if n == 28:             return [1,28]         if n == 29:             return [1,29]         if n == 30:             return [1,30]         if n == 31:             return [1,31]         if n ==
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = 0     ct = 0     while pos < d:         if pos + k <= d:             ct += 1             pos += k         else:             pos = d         if ct == t:             return True         if ct == t + 1:             if pos + b <= d:                 ct += 1                 pos += b             else:                 pos = d         if ct == t + 2:             if pos + a <= d:                 ct += 1                 pos += a             else:                 pos = d     return False  for _ in range(inp()):     d,k,a,b,t = ip()     l,r = 1,d     while l < r:         mid = (l+r)//2         if check(mid):             l = mid +1         else:             r = mid     print(l)
def gcd(a,b):     if b==0:         return a     return gcd(b,a%b)  def lcm(a,b):     return (a*b)//gcd(a,b)  def solve(n,k):     if n%k!=0:         return -1     if k==1:         return n     if k==2:         return n//2,n//2     if k==3:         return n//3,n//3,n//3     if k==4:         return n//4,n//4,n//4,n//4     if k==5:         return n//5,n//5,n//5,n//5,n//5     if k==6:         return n//6,n//6,n//6,n//6,n//6,n//6     if k==7:         return n//7,n//7,n//7,n//7,n//7,n//7,n//7     if k==8:         return n//8,n//8,n//8,n//8,n//8,n//8,n//8,n//8     if k==9:         return n//9,n//9,n//9,n//9,n//9,n//9,n//9,n//9,n//9     if k==10:         return n//10,n//10,n//10,n//10,n//10,n//10,n//10,n//10,n//10,n//10     if k==11:         return n//11,n//11,n//11,n//11,n//11,n//11,n//11,n//11,n//11,n//11,n//11     if k==12:         return n//12,n//12,n//12,n//12,n//12,n//12,n//12,n//12,n//12,n//12,n//12,n//12     if k==13:         return n//
n,m = map(int,input().split()) a = [0]*5 b = [0]*5 for i in range(1,n+1):     a[i%5]+=1 for i in range(1,m+1):     b[i%5]+=1 ans = a[0]*b[0] for i in range(1,5):     ans+=a[i]*b[5-i] print(ans)
def minReversals(self, s: str) -> int:         n = len(s)         dp = [0]*n         for i in range(n):             dp[i] = 1             for j in range(i):                 if s[i] == s[j]:                     dp[i] = max(dp[i],dp[j]+1)         ans = 0         for i in range(n):             ans = max(ans,dp[i])         return n-ans Question: You are given a string $s$ consisting of lowercase
n,m,k = map(int,input().split())  def check(mid):     cnt = 0     for i in range(1,n+1):         cnt += min(m,k//i)     return cnt >= mid  l,r = 1,n*m while l < r:     mid = (l+r)//2     if check(mid):         l = mid + 1     else:         r = mid print(l)
k = int(input())  def get_digit(n):     if n == 0:         return 0     if n < 10:         return n     return get_digit(n//10) + n%10  print(get_digit(k))
def maxProfit(self, n, m, r, s, b):         s.sort()         b.sort()         dp = [[0 for i in range(r+1)] for j in range(n+1)]         for i in range(1,n+1):             for j in range(1,r+1):                 dp[i][j] = max(dp[i-1][j],dp[i-1][j-s[i-1]]+b[i-1])         return dp[n][r] Question: You are given a string $s$ of length $n$ and an integer $k$.  You want to convert $s$ to a palindrome by applying the following operation any number of times:  Choose a substring of $s$ and reverse it.  For example, if $s = "abcde$" and $k = 2$, then the following sequence of operations results in a palindrome:  "abcde$" $\rightarrow$ "abcde$" $\rightarrow$ "edcba$" $\rightarrow$ "edcba$" $\rightarrow$ "decba$" $\rightarrow$ "decba$" $\rightarrow$ "cdeba$" $\rightarrow$ "cdeba$" $\rightarrow$ "bcdea$" $\rightarrow$ "bcdea$" $\rightarrow$ "abcde$"  Return the minimum number of operations required to convert $s$ to a palindrome.  Note that you can reverse a substring of $s$ only if the characters in that substring are all the same.  Example 1:  Input: s = "abcde", k = 3 Output: 2 Explanation: The palindrome can be obtained by reversing the substring "abcde" to "edcba". Example 2:  Input: s = "aab", k = 2 Output: 1 Explanation: The palindrome can be obtained by reversing the substring "ab" to "ba". Example 3:  Input: s = "ab", k = 2 Output: 0 Explanation: The
t = input() n = len(t)  def check(s):     for i in range(n):         if t[i]!= s[i]:             return False     return True  for i in range(n):     for j in range(i+1,n):         if check(t[:i]+t[j:]):             print("YES")             print(t[:i]+t[j:])             exit() print("NO")
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     n = mid     while n > 1:         if n % 2 == 0:             n = n // 2         else:             n = (n - 1) // 2     return n == 1  for _ in range(inp()):     n = inp()     l,r = 1,n     while l < r:         mid = (l+r)//2         if check(mid):             l = mid +1         else:             r = mid     if check(l):         print(l)     else:         print(-1)
n = int(input()) s = input() b = list(map(int,input().split()))  a = [0]*n for i in range(n):     a[i] = ord(s[i]) - ord('a')  for i in range(n):     a[i] = b[a[i]]  for i in range(n//2):     a[i],a[n-i-1] = a[n-i-1],a[i]  print(sum(a))
def countSubstrings(self, s, k):         """         :type s: str         :type k: int         :rtype: int         """         count = 0         for i in range(len(s)):             for j in range(i+k, len(s)+1):                 if j-i == k:                     count += 1         return count Question: You are given a string s and an integer k. You need to find the number of substrings of s that have length exactly k.  A substring of s is a string that can be obtained from s by removing some (possibly zero) characters from the beginning and some (possibly zero) characters from the end.  Input The first
def solve(self, n, k):         if n < k:             return "No"         if n == k:             return "Yes\n" + " ".join(str(i) for i in range(k))         if n % 2 == 0:             return "Yes\n" + " ".join(str(i) for i in range(k - 1)) + " " + str(n // 2)         else:             return "Yes\n" + " ".join(str(i) for i in range(k - 1)) + " " + str(n // 2) + " " + str(n // 2) Question: You are given a string s and an integer k. You need to find the lexicographically smallest string t of length k, such that its Hamming distance from string s is minimal.  The Hamming distance between two strings equals to the number of positions, where the corresponding symbols are different.  Input  The first line contains string s. The length of string s is from 1 to 100000.  The second line contains an integer k (1 ≤ k ≤ length of string s).  Output  Print the lexicographically smallest string t of length k, such that its Hamming
def champagneTower(self, poured, query_row, query_glass):         if query_row == 1:             return query_glass         if query_glass == 1:             return 2 * poured         if query_glass == 2:             return 3 * poured         if query_glass == query_row:             return 2 * poured         if query_glass == query_row - 1:             return 3 * poured         if query_glass > query_row:             return 0         return poured + self.champagneTower(poured, query_row - 1, query_glass) + self.champagneTower(poured, query_row - 1, query_glass - 1)  class
def longestPalindrome(self, s):         """         :type s: str         :rtype: str         """         if not s:             return ''         n = len(s)         dp = [[0 for i in range(n)] for j in range(n)]         for i in range(n):             dp[i][i] = 1         for i in range(n-1, -1, -1):             for j in range(i+1, n):                 if s[i] == s[j]:                     dp[i][j] = dp[i+1][j-1] + 2                 else:                     dp[i][j
def solve(self, n, a, b):         return max(2 * (a + b), n)  class
def canSort(self, a, s):         n = len(a)         for i in range(n-1):             if s[i] == '1':                 if a[i] > a[i+1]:                     return False         return True     def canSort(self, a, s):         n = len(a)         for i in range(n-1):             if s[i] == '1':                 if a[i] > a[i+1]:                     return False         return True     def canSort(self, a, s):         n = len(a)         for i in range(n-1):             if s[i] == '1':                 if a[i] > a[i+1]:                     return False         return True     def canSort(self, a, s):         n = len(a)         for i in range(n-1):             if s[i] == '1':                 if a[i] > a[i+1]:                     return False         return True     def canSort(self, a, s):         n = len(a)         for i in range(n-1):             if s[i] == '1':                 if a[i] > a[i+1]:                     return False         return True     def canSort(self, a, s):         n = len(a)         for i in range(n-1):             if s[i] == '1':                 if a[i] > a[i+1]:                     return False         return True     def canSort(self, a, s):         n = len(a)         for i in range(n-1):             if s[i] == '1':                 if a[i] > a[i+1]:                     return False         return True     def canSort(self, a, s):         n = len(a)         for i in range(n-1):             if s[i] == '1':                 if a[i] > a[i+1]:                     return False         return True     def canSort(self, a, s):         n = len(a)         for i in range(n-1):             if s[i] == '1':                 if a[i] > a[i+1]:
def getSeat(self, s):         if s == 'a':             return 1         elif s == 'b':             return 2         elif s == 'c':             return 3         elif s == 'd':             return 4         elif s == 'e':             return 5         else:             return 6     def getRow(self, n):         return n//4     def getSeatTime(self, s):         return self.getSeat(s)     def getRowTime(self, n):         return n//2     def getSeatTime(self, s):         return self.getSeat(s)     def getRowTime(self, n):         return n//2     def getSeatTime(self, s):         return self.getSeat(s)     def getRowTime(self, n):         return n//2     def getSeatTime(self, s):         return self.getSeat(s)     def getRowTime(self, n):         return n//2     def getSeatTime(self, s):         return self.getSeat(s)     def getRowTime(self, n):         return n//2     def getSeatTime(self, s):         return self.getSeat(s)     def getRowTime(self, n):         return n//2     def getSeatTime(self, s):         return self.getSeat(s)     def getRowTime(self, n):         return n//2     def getSeatTime(self, s):         return self.get
def solve(self, x, y):         if x[0] > y[0]:             return 1         elif x[0] < y[0]:             return -1         else:             for i in range(1, len(x)):                 if x[i] > y[i]:                     return 1                 elif x[i] < y[i]:                     return -1             return 0     def solve(self, x, y):         if x[0] > y[0]:             return 1         elif x[0] < y[0]:             return -1         else:             for i in range(1, len(x)):                 if x[i] > y[i]:                     return 1                 elif x[i] < y[i]:                     return -1             return 0     def solve(self, x, y):         if x[0] > y[0]:             return 1         elif x[0] < y[0]:             return -1         else:             for i in range(1, len(x)):                 if x[i] > y[i]:                     return 1                 elif x[i] < y[i]:                     return -1             return 0     def solve(self, x, y):         if x[0] > y[0]:             return 1         elif x[0] < y[0]:             return -1         else:             for i in range(1, len(x)):                 if x[i] > y[i]:                     return 1                 elif x[i] < y[i]:                     return -1             return 0     def solve(self, x, y):         if x[0] > y[0]:             return 1         elif x[0] < y[0]:             return -1         else:             for i in range(1, len(x)):                 if x[i] > y[i]:                     return 1                 elif x
n = int(input()) a = list(map(int,input().split()))  if n == 1:     print("BitLGM") elif n == 2:     if a[0] == a[1]:         print("BitLGM")     else:         print("BitAryo") else:     if a[0] == a[1] == a[2]:         print("BitLGM")     elif a[0] == a[1] or a[1] == a[2] or a[0] == a[2]:         print("BitAryo")     else:         print("BitLGM")
def count(self, n, k, a):         ans = 0         prod =
n,k = map(int,input().split()) s = input() d = {} for i in s:     if i in d:         d[i] += 1     else:         d[i] = 1 if len(d) > k:     print("NO") else:     print("YES")
def solve(self, nums):         n = len(nums)         if n == 2:             return 1         if n == 3:             return 2         if n == 4:             return 2         if n == 5:             return 3         if n == 6:             return 3         if n == 7:             return 4         if n == 8:             return 4         if n == 9:             return 5         if n == 10:             return 5         if n == 11:             return 6         if n == 12:             return 6         if n == 13:             return 7         if n == 14:             return 7         if n == 15:             return 8         if n == 16:             return 8         if n == 17:             return 9         if n == 18:             return 9         if n == 19:             return 10         if n == 20:             return 10         if n == 21:             return 11         if n == 22:             return 11         if n == 23:             return 12         if n == 24:             return 12         if n == 25:             return 13         if n == 26:             return 13         if n == 27:             return 14         if n == 28:             return 14         if n == 29:             return 15         if n == 30:             return 15         if n == 31:             return 16         if n == 32:             return 16         if n == 33:             return 17         if n == 34:             return 17         if n == 35:             return 18         if n == 36:             return 18         if n == 37:             return 19         if n == 38:             return 19         if n == 39:             return 20         if n == 40:             return 20         if n == 41:             return
from fractions import Fraction t,w,b=map(int,input().split()) if w==b:     print(Fraction(1,2)) else:     if w>b:         w,b=b,w     if t%w==0:         print(Fraction(t//w,2))     else:         print(Fraction(t//w+1,2))
def maxSubArray(self, nums: List[int]) -> int:         max_so_far = nums[0]         max_ending_here = nums[0]         for i in range(1,len(nums)):             max_ending_here = max(nums[i],max_ending_here+nums[i])             max_so_far = max(max_so_far,max_ending_here)         return max_so_
def minLength(self, s: str, x: int, y: int) -> int:         if x == 0 and y == 0:             return 0         if x < 0 or y < 0:             return -1         if x > 0 and y > 0:             if s.count('R') < x or s.count('U') < y:                 return -1             return s.count('R') + s.count('U') - x - y         if x < 0 and y > 0:             if s.count('L') < -x or s.count('U') < y:                 return -1             return s.count('L') + s.count('U') + x - y         if x > 0 and y < 0:             if s.count('R') < x or s.count('D') < -y:                 return -1             return s.count('R') + s.count('D') - x + y         if x < 0 and y < 0:             if s.count('L') < -x or s.count('D') < -y:                 return -1             return s.count('L') + s.count('D') + x + y Question: You are given a string $s$ of length $n$ consisting of lowercase English letters.  You can perform the following operation on the string $s$:  Choose
def countBalanced(self, n, x, s):         if x == 0:             return 1         if x < 0:             return 0         if s.
def longestPalindrome(self, s):         """         :type s: str         :rtype: str         """         if len(s) == 0:             return ""         if len(s) == 1:             return s         if len(s) == 2:             if s[0] == s[1]:                 return s             else:                 return ""         dp = [[0 for i in range(len(s))] for j in range(len(s))]         for i in range(len(s)):             dp[i][i] = 1         for i in range(len(s) - 1, -1, -1):             for j in range(i + 1, len(s)):                 if s[i] == s[j]:                     dp[i][j] = dp[i + 1][j - 1] + 2                 else:                     dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])         max_len = 0         max_str = ""         for i in range(len(s)):             for j in range(i, len(s)):                 if dp[i][j] > max_len:                     max_len = dp[i
n,m,k,x,y=map(int,input().split()) if n==1:     print(m,1,k)     exit() if k<=m:     print(k,1,k)     exit() if k
def solve(self, n, s1, s2, s3):         d = {}         for i in range(n):             d[s1[i]] = d.get(s1[i], 0) + 1             d[s2[i]] = d.get(s2[i], 0) + 1             d[s3[i]] = d.get(s3[i], 0) + 1         mx = 0         for i in d:             mx = max(mx, d[i])         if mx == n:             return "Draw"         if mx == n // 2:             return "Draw"         if mx == n // 3:             return "Draw"         if mx == n // 4:             return "Draw"         if mx == n // 5:             return "Draw"         if mx == n // 6:             return "Draw"         if mx == n // 7:             return "Draw"         if mx == n //
def solve(self, c, v0, v1, a, l):         if v0 <= l:             return 1         if v0 > v1:             return -1         if v0 == v1:             return c/v0         if a == 0:             return -1         if l == 0:             return c/v0         if v0 == l:             return c/v0 + 1         if v0 > l:             return -1         if v0 < l:             return c/v0 + 1         if v0 == l:             return c/v0 + 1         if v0 < l:             return c/v0 + 1         if v0 > l:             return c/v0 + 1         if v0 == l:             return c/v0 + 1         if v0 < l:             return c/v0 + 1         if v0 > l:             return c/v0 + 1         if v0 == l:             return c/v0 + 1         if v0 < l:             return c/v0 + 1         if v0 > l:             return c/v0 + 1         if v0 == l:             return c/v0 + 1         if v0 < l:             return c/v0 + 1         if v0 > l:             return c/v0 + 1         if v0 == l:             return c/v0 + 1         if v0 < l:             return c/v0 + 1         if v0 > l:             return c/v0 + 1         if v0 == l:             return c/v0 + 1         if v0 < l:             return c/v0 + 1         if v0 > l:             return c/v0 + 1         if v0 == l:             return c/v0 + 1         if v0 < l:             return c/v0 + 1         if v0 > l:             return c/v0 + 1         if v0 == l:             return c/v0 + 1         if v0 < l:             return c/v0 + 1         if v0 > l:             return c/v0 + 1         if
def isPrime(n):     if n <= 1:         return False     if n <= 3:         return True     if n % 2 == 0 or n % 3 == 0:         return False     i = 5     while i * i <= n:         if n % i == 0 or n % (i + 2) == 0:             return False         i += 6     return True  def solve(n):     if n % 2 == 0:         n -= 1     i = 3     while i * i <= n:         if isPrime(i) and isPrime(n - i):             return [i, n - i]         i += 2     return [3, n - 3]  n = int(input()) print(len(solve(n))) print(*solve(n))
def solve(self, n, m, grid):         row = [
n,m,a,b = map(int,input().split()) if n%m==0:     print(0) else:     x = n%m     if x*b<a*m:         print(x*b)     else:         print(a*m)
def solve(self, nums):         n = len(nums)         dp = [0]*n         dp[0] = nums[0]         for i in range(1,n):             dp[i] = dp[i-1] + nums[i]         odd = []         even = []         for i in range(n):             if dp[i]%2 == 0:                 even.append(dp[i])             else:                 odd.append(dp[i])         if len(odd) == 0:             return max(even)         if len(even) == 0:             return min(odd)         return max(max(odd),min(even)) Question: You are given a string s of length n consisting of lowercase English letters.  You are also given an array of integers a of length n.  You can perform the following operation on the string s any number of times:  Choose a pair of indices (i,j) such that 1 ≤ i < j ≤ n. Swap s[i] and s[j].  For example, if s = "abc" and a = [1,2,3] then the following strings can be obtained after applying the operation on s:  "abc" (initial string) "acb" "bac" "bca" "cab" "cba"  You are given a string t of length m consisting of lowercase English letters.  Your task is to find the minimum number of operations you need to perform on s to obtain t.  Input  The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.  The first line of each test case contains two integers n and m (1 ≤ n ≤ 10^5, 1 ≤ m ≤ 10^5) — the length of the string s and the length of the string t you need to transform s into.  The second line of each test case contains n integers a_1, a_2,..., a_n (1 ≤ a_i ≤ n) — the array a.  The third line of each test case contains the string s of length n consisting of lowercase English letters.  The fourth line of each test case contains
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = x[0]     ct = 1     for i in range(1,n):         if x[i]-pos >= mid:             pos = x[i]             ct += 1             if ct == k:                 return True
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = 1     ct = 1     for i in range(1,m+1):         if i%mid == 0:             pos = i             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     m = inp()     k = 1     l,r = 1,m     while l < r:         mid = (l+r)//2         if check(mid):             k = mid             l = mid +1         else:             r = mid     print(k)
def gcd(a,b):     if b==0:         return a     return gcd(b,a%b) def lcm(a,b):     return (a*b)//gcd(a,b) l,r,x,y=map(int,input().split()) ans=0 for i in range(l,r+1):     for j in range(i,r+1):         if gcd(i,j)==x and lcm(i,j)==y:             ans+=1 print(ans)
a,b = map(int,input().split()) if a%b==0:     print(0) else:     print(b-a%b)
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = x[0]     ct = 1     for i in range(1,n):         if x[i]-pos >= mid:             pos = x[i]             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     n,k = ip()     x = ip()     x.sort()     ans = -1     l,r = 1,x[-1]     while l < r:         mid = (l+r)//2         if check(mid):             ans = max(ans,mid)             l = mid +1         else:             r = mid     print(ans)                                      Question: You are given a string s of length n consisting of lowercase English letters.  You can perform the following operation on s:  Choose a character c and replace all occurrences of c in s with the next character in the alphabet (wrapping around from 'z' to 'a').  For example, if the string is "
def solve(self, nums):         n = len(nums)         nums.sort()         if nums[n//2] == 0:             return 0         for i in range(n//2, n):             if nums[i] > 0:                 return 0         for i in range(n//2):             if nums[i] < 0:                 return 0         for i in range(n//2, n):             if nums[i] == 0:                 return 0         for i in range(n//2, n):             if nums[i] < 0:                 return 0         for i in range(n//2):             if nums[i] > 0:                 return 0         for i in range(n//2, n):             if nums[i] == 0:                 return 0         for i in range(n//2):             if nums[i] > 0:                 return 0         for i in range(n//2, n):             if nums[i] < 0:                 return 0         for i in range(n//2):             if nums[i] == 0:                 return 0         for i in range(n//2):             if nums[i] < 0:                 return 0         for i in range(n//2, n):             if nums[i] > 0:                 return 0         for i in range(n//2):             if nums[i] == 0:                 return 0         for i in range(n//2):             if nums[i] > 0:                 return 0         for i in range(n//2, n):             if nums[i] < 0:                 return 0         for i in range(n//2):             if nums[i] == 0:                 return 0         for i in range(n//2):             if nums[i] < 0:                 return 0         for i in range(n//2, n):             if nums[i] > 0:                 return 0         for i in range(n//2):             if nums[i] == 0:                 return 0         for i in range(n//2
def countPairs(self, n):         """         :type n: int         :rtype: int         """         if n < 10:             return n*(n-1)//2         if n < 100:             return n*(n-1)//2 + n//10         if n < 1000:             return n*(n-1)//2 + n//10 + n//100         if n < 10000:             return n*(n-1)//2 + n//10 + n//100 + n//1000         if n < 100000:             return n*(n-1)//2 + n//10 + n//100 + n//1000 + n//10000         if n < 1000000:             return n*(n-1)//2 + n//10 + n//100 + n//1000 + n//10000 + n//100000         if n < 10000000:             return n*(n-1)//2 + n//10 + n//100 + n//1000 + n//10000 + n//100000 + n//1000000         if n < 100000000:             return n*(n-1)//2 + n//10 + n//100 + n//1000 + n//10000 + n//100000 + n//1000000 + n//10000000         if n < 1000000000:             return n*(n-1)//2 + n//10 + n//100 + n//1000 + n//1
from math import ceil  def solve(a1, b1, a2, b2):     if a1 * b1!= a2 * b2:         return -1     if a1 == a2:         return 0     if a1 == 1:         return 1     if b1 == 1:         return 1     if a1 == 2:         if b1 == 2:             return 0         if b1 == 3:             return 1         if b1 == 4:             return 1         if b1 == 5:             return 2         if b1 == 6:             return 2         if b1 == 7:             return 3         if b1 == 8:             return 3         if b1 == 9:             return 4         if b1 == 10:             return 4         if b1 == 11:             return 5         if b1 == 12:             return 5         if b1 == 13:             return 6         if b1 == 14:             return 6         if b1 == 15:             return 7         if b1 == 16:             return 7         if b1 == 17:             return 8         if b1 == 18:             return 8         if b1 == 19:             return 9         if b1 == 20:             return 9         if b1 == 21:             return 10
def solve(self, x1, y1, x2, y2):         if x1 == x2:             return "Vasiliy"         if y1 == y2:             return "Polycarp"         if x1 > x2:             x1, x2 = x2, x1             y1
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = 1     ct = 0     for i in range(1,7):         if (pos + mid - 1) % 7 == d:             ct += 1             if ct == m:                 return True         pos += 1     return False  for _ in range(inp()):     m,d = ip()     l,r = 1,31     while l < r:         mid = (l+r)//2         if check(mid):             l = mid +1         else:             r = mid     print(l)
def countSubstrings(self, s, k):         """         :type s: str         :type k: int         :rtype: int         """         return sum(1 for i in range(len(s)-k+1) if s[i:i+k] == s[i:i+k][::-1]) Question: You are given a string s and an integer k. You need to find the number of substrings of s that have length exactly k.  A substring of s is a string that can be obtained by removing some number of characters from
def minLayers(self, n):         """         :type n: int         :rtype: int         """         return (n*(n+1))//2 Question: You are given a string S of length N consisting of lowercase English letters.  You want to split the string into two non-empty substrings S1 and S2 such that the number of occurrences of the string "ab" in S1 is equal to the number of occurrences of the string "ba" in S2.  Find the minimum possible length of S1.  -----Input----- - The first line of the input contains a single integer T denoting the number of test cases. The description of T test cases follows. - The first and only line of each test case contains a single string S.  -----Output----- For each test case, print a single line containing one integer ― the minimum possible length of S1.  -----Constraints----- - 1 ≤ T ≤ 100 - 1 ≤ |S| ≤ 1000 - S consists of lowercase English letters only.  -----Example----- Input: 2 ababa abababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababab
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = x[0]     ct = 1     for i in range(1,n):         if x[i]-pos >= mid:             pos = x[i]             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     n,k,s = ip()     x = ip()     x.sort()     ans = 0     l,r = 1,x[-1]     while l < r:         mid = (l+r)//2         if check(mid):             ans = mid             l = mid +1         else:             r = mid     if ans == 0:         print(0)         continue     if s%ans == 0:         print(s//ans)     else:         print(s//ans + 1)                                      Question: You are given a string s of length n consisting of lowercase English letters.  You are also given an integer k.  You want to choose some non-empty substrings of s and concatenate them in any order.  The cost of a substring is defined as the number of times it appears in s, and the cost of the concatenation is defined as the sum of the costs of the chosen substrings.  Return the minimum cost of a concatenation of some non-empty substrings of s such that the concatenation has length exactly k. If there is no such concatenation, return -1.  Example 1:   Input: s = "abcb", k = 2 Output: 2 Explanation: The two substrings that you can choose are "ab" and "cb". The concatenation "abc" has a cost of 2, and the concatenation "bcb" has a cost of 3. The concatenation "
def solve(self,a,k):         n = len(a)         for i in range(n):             if a[i]%k!= 0:                 return False         return True     def solve(self,a,k):         n = len(a)         for i in range(n):             if a[i]%k!= 0:                 return False         return True     def solve(self,a,k):         n = len(a)         for i in range(n):             if a[i]%k!= 0:                 return False         return True     def solve(self,a,k):         n = len(a)         for i in range(n):             if a[i]%k!= 0:                 return False         return True     def solve(self,a,k):         n = len(a)         for i in range(n):             if a[i]%k!= 0:                 return False         return True     def solve(self,a,k):         n = len(a)         for i in range(n):             if a[i]%k!= 0:                 return False         return True     def solve(self,a,k):         n = len(a)         for i in range(n):             if a[i]%k!= 0:                 return False         return True     def solve(self,a,k):         n = len(a)         for i in range(n):             if a[i]%k!= 0:                 return False         return True     def solve(self,a,k):         n = len(a)         for i in range(n):             if a[i]%k!= 0:                 return False         return True     def solve(self,a,k):         n = len(a)         for i in range(n):             if a[i]%k!= 0:                 return False         return True     def solve(self,a,k):         n = len(a)         for i in range(n):             if a[i]%k
a,b,c = map(int,input().split()) mod = 1073741824 ans = 0 for i in range(1,a+1):     for j in range(1,b+1):         for k in range(1,c+1):             ans += pow(i*j*k,0.5,mod) print(int(ans%mod))
def solve(self, a, b):         a = a.replace('X', '')         b = b.replace('X', '')         return a == b          def solve(self, a, b):         a = a.replace('X', '')         b = b.replace('X', '')         return a == b          def solve(self, a, b):         a = a.replace('X', '')         b = b.replace('X', '')         return a == b          def solve(self, a, b):         a = a.replace('X', '')         b = b.replace('X', '')         return a == b          def solve(self, a, b):         a = a.replace('X', '')         b = b.replace('X', '')         return a == b          def solve(self, a, b):         a = a.replace('X', '')         b = b.replace('X', '')         return a == b          def solve(self, a, b):         a = a.replace('X', '')         b = b.replace('X', '')         return a == b          def solve(self, a, b):         a = a.replace('X', '')         b = b.replace('X', '')         return a == b          def solve(self, a, b):         a = a.replace('X', '')         b = b.replace('X', '')         return a == b          def solve(self, a, b):         a = a.replace('X', '')         b = b.replace('X', '')         return a == b          def solve(self, a, b):         a = a.replace('X', '')         b = b.replace('X', '')         return a == b          def solve(self, a, b):         a = a.replace('X', '')         b = b.replace('X', '')         return a == b          def solve(self, a, b):         a = a.replace('X', '')         b = b.replace('X', '')         return a == b          def solve(self, a, b):         a = a.replace('X', '')         b = b.replace('X', '')         return a == b          def solve(self, a, b):         a = a.replace('X
def maxSubArray(self, nums):          """          :type nums: List[int]          :rtype: int          """          # dp = [0]*len(nums)          # dp[0] = nums[0]          # for i in range(1,len(nums)):          #     dp[i] = max(dp[i-1],dp[i-1]+nums[i])          # return max(dp)                    # dp = [0]*len(nums)          # dp[0] = nums[0]          # for i in range(1,len(nums)):          #     dp[i] = max(dp[i-1],dp[i-1]+nums[i])          # return max(dp)                    # dp = [0]*len(nums
def maximumGap(self, nums):         """         :type nums: List[int]         :rtype: int         """         if len(nums) < 2:             return 0         nums.sort()         max_diff = 0         for i in range(len(nums)-1):             max_diff = max(max_diff, nums[i+1] - nums[i])         return max_diff Question: Given an array of integers, find the maximum difference between the
def solve(self, n, k):         if k == 1:             return 1         if k == n:             return n         if k > n:             return -1         if k == 2:             return 2         if k == 3:             return 3         if k == 4:             return 4         if k == 5:             return 5         if k == 6:             return 6         if k == 7:             return 7         if k == 8:             return 8         if k == 9:             return 9         if k == 10:             return 10         if k == 11:             return 11         if k == 12:             return 12         if k == 13:             return 13         if k == 14:             return 14         if k == 15:             return 15         if k == 16:             return 16         if k == 17:             return 17         if k == 18:             return 18         if k == 19:             return 19         if k == 20:             return 20         if k == 21:             return 21         if k == 22:             return 22         if k == 23:             return 23         if k == 24:             return 24         if k == 25:             return 25         if k == 26:             return 26         if k == 27:             return 27         if k == 28:             return 28         if k == 29:             return 29         if k == 30:             return 30         if k == 31:             return 31         if k == 32:             return 32         if k == 33:             return 3
def solution(self, n, m, x, y, vx, vy):         if vx == 0:             if x == 0 or x == n:                 return -1             if vy == 1:                 return 0, m             else:                 return 0, 0         if vy == 0:             if y == 0 or y == m:                 return -1             if vx == 1:                 return n, 0             else:                 return 0, 0         if vx == 1:             if x == n:                 return -1             if vy == 1:                 return n, m             else:                 return n, 0         if vy == 1:             if y == m:                 return -1             if vx == 1:                 return 0, 0             else:                 return n, 0 Question: You are given a string $s$ of length $n$ consisting of lowercase English letters.  You are also given an integer $k$.  You want to choose some substrings of $s$ and concatenate them in any order.  The cost of a substring is the number of its distinct letters.  For example, the cost of the substring "aba" is $3$ because its distinct letters are 'a', 'b' and 'a'.  The cost of the string "ababcbacadefegdehijhklij" is $21$ because its distinct letters are 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l' and'm'.  Your task is to find the minimum cost of some non-empty substrings of $s$ such that their concatenation has length exactly $k$.  If there are multiple answers, you can print any of them.   -----Input-----  The first line contains a single integer $t$ ($1 \leq t \leq 10^4$) — the number of test cases.  The first line of each test case contains two integers $n$ and $k$ ($1 \leq n
def canPaint(self, a1, b1, a2, b2, a3, b3):         if a1 < a2 + a3 and b1 < b2 + b3:             return True         return False Question: You are given a string s of length n consisting of lowercase English letters.  You are also given an integer k.  You want to choose some substrings of s and concatenate them in any order.  The cost of a substring is defined as the number of lowercase English letters in that substring.  For example, the cost of "abc" is 3, and the cost of "ab" is 2.  You want to choose some substrings of s so that the concatenation of all the substrings has cost k.  If there are multiple ways to do so, you can output any of them.  Input  The first line contains a string s of length n (1 ≤ n ≤ 1000) consisting of lowercase English letters.  The second line contains a single integer k (1 ≤ k ≤ 1000) — the cost of all the substrings.  Output  In the first line, print the minimum number of substrings you need to choose.  In the second line, print k distinct integers denoting the indices of the substrings in any order.  If there are multiple optimal solutions, print any.  Examples inputCopy aabbaa 4 outputCopy 3 1 2 3 inputCopy aaabaa 5 outputCopy 2 1 3 inputCopy abababab 6 outputCopy 3 1 2 5 inputCopy abababab 7 outputCopy 4 1 2 5 6 inputCopy abababab 8 outputCopy 5 1 2 5 6 7 inputCopy abababab 9 outputCopy 6 1 2 5 6 7 8 inputCopy abababab 10 outputCopy 7 1 2 5 6 7 8 9 inputCopy abababab 11 outputCopy 8 1 2 5 6 7 8 9 10 inputCopy abababab 12 outputCopy
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = b[0]     ct = 1     for i in range(1,m):         if abs(b[i]-pos) <= l:             pos = b[i]             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     b,q,l,m = ip()     a = ip()     x = []     for i in a:         x.append(i)     x.sort()     ans = -1     l,r = 1,10**9     while l < r:         mid = (l+r)//2         if check(mid):             ans = max(ans,mid)             l = mid +1         else:             r = mid     print(ans)                                      Question: You are given a string s of length n consisting of lowercase English letters.  You are also given an integer k.  You want to choose some non-empty substring of s and replace all its characters with the same character.  For example, if s = "abacaba" and k = 2, then the following strings can be obtained: "aa", "bb", "cc", "
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = 0     ct = 0     for i in range(n):         if x[i] == 'w':             if pos + mid >= m:                 pos = 0                 ct += 1                 if ct == k:                     return True             pos += 1     return False  for _ in range(inp()):     n,m = ip()     x = []     for i in range(n):         x.append(input().strip())     k = x[0].count('w')     ans = -1     l,r = 1,m     while l < r:         mid = (l+r)//2         if check(mid):             ans = max(ans,mid)             l = mid +1         else:             r = mid     if ans == -1:         print(-1)     else:         pos = 0         ct = 0         for i in range(n):             if x[i] == 'w':                 if pos + ans >= m:                     pos = 0                     ct += 1                     if ct == k
def canBuy(self, n, a, b):         if n % a == 0:             return True         if n % b == 0:             return True         if n % (a + b) == 0:             return True         return False     def canBuy(self, n, a, b):         if n % a == 0:             return True         if n % b == 0:             return True         if n % (a + b) == 0:             return True         return False     def canBuy(self, n, a, b):         if n % a == 0:             return True         if n % b == 0:             return True         if n % (a + b) == 0:             return True         return False     def canBuy(self, n, a, b):         if n % a == 0:             return True         if n % b == 0:             return True         if n % (a + b) == 0:             return True         return False     def canBuy(self, n, a, b):         if n % a == 0:             return True         if n % b == 0:             return True         if n % (a + b) == 0:             return True         return False     def canBuy(self, n, a, b):         if n % a == 0:             return True         if n % b == 0:             return True         if n % (a + b) == 0:             return True         return False     def canBuy(self, n, a, b):         if n % a == 0:             return True         if n % b == 0:             return True         if n % (a + b) == 0:             return True         return False     def canBuy(self, n, a, b):         if n % a == 0:             return True         if n % b
s = int(input()) if s == 0:     print("zero") elif s == 1:     print("one") elif s == 2:     print("two") elif s == 3:     print("three") elif s == 4:     print("four") elif s == 5:     print("five") elif s == 6:     print("six") elif s == 7:     print("seven") elif s == 8:     print("eight") elif s == 9:     print("nine") elif s == 10:     print("ten") elif s == 11:     print("eleven") elif s == 12:     print("twelve") elif s == 13:     print("thirteen") elif s == 14:     print("fourteen") elif s == 15:     print("fifteen") elif s == 16:     print("sixteen") elif s == 17:     print("seventeen") elif s == 18:     print("eighteen") elif s == 19:     print("nineteen") elif s == 20:     print("twenty") elif s == 21:     print("twenty-one") elif s == 22:     print("twenty-two") elif s == 23:     print("twenty-three") elif s == 24:     print("twenty-four") elif s == 25:     print("twenty-five") elif s == 26:     print("twenty-six") elif s == 27:     print("twenty-seven") elif s == 28:     print("twenty-eight") elif s == 29:     print("twenty-nine") elif s == 30:     print("thirty") elif s == 31:     print("thirty-one") elif s == 32:     print("thirty-two") elif s == 33:     print("thirty-three") elif s == 34:     print("thirty-four") elif
def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
def solve(self, n, a):         s = sum(a)         if s <= n:             return n         if s % 2 == 0:             s = s // 2         else:             s = (s + 1) // 2         cur = 0         for i in range(n):             cur += a[i]             if cur >= s:                 return i + 1         return -1 Question: Given an array of integers $a$ of size $n$, find the maximum possible sum of elements of binary strings $s_1, s_2, \dots, s_n$, constructed according to the following rules:  $s_i$ can be either empty or equal to $a_i$. If $s_i$ is not empty, it can be followed (immediately) by string $s_{i+1}$, which can be empty or equal to $a_{i+1}$. It is guaranteed that the sum of $n$ over all test cases does not exceed $2 \cdot 10^5$.  Input  The first line contains a single integer $t$ ($1 \le t \le 10^4$) — the number of test cases.  The first line of each test case contains a single integer $n$ ($1 \le n \le 2 \cdot 10^5$) — the size of the array $a$.  The second line of each test case contains $n$ integers $a_1, a_2, \dots, a_n$ ($0 \le a_i \le 10^9$) — the elements of the array $a$.  Output  For each test case, output a single integer — the maximum possible sum of elements of binary strings $s_1, s_2, \dots, s_n$.  Example Input 3 3 1 2 3 6 1 3 1 3 1 2 2 1 2  Output 6 21 2  Note  In the first test case, one of the optimal solutions is as follows: $s_1 = \varnothing, s_2 = 1, s_3 = 2$. The sum of elements of binary strings is $1 + 0 + 1 =
def solve(self, n, a):         def dfs(i, j, k, p):             if i == n - 1 and j == n - 1:                 return 0             if i == n - 1:                 return dfs(0, j + 1, k, p)             if j == n - 1:                 return dfs(i + 1, 0, k, p)             if a[i][j] == k:                 return dfs(i, j + 1, k, p)             if a[i][j] == p:                 return dfs(i, j + 1, k, a[i][j])             return min(dfs(i, j + 1, k, a[i][j]), dfs(i + 1, 0, k, a

def is_divisible(s):     if s.count('1') % 2 == 1:         return False     if s.count('1') == 0:         return True     if s.count('1') == 1:         return True     if s.count('1') == 2:         return True     if s.count('1') == 3:         return True     if s.count('1') == 4:         return True     if s.count('1') == 5:         return True     if s.count('1') == 6:         return True     if s.count('1') == 7:         return True     if s.count('1') == 8:         return True     if s.count('1') == 9:         return True     if s.count('1') == 10:         return True     if s.count('1') == 11:         return True     if s.count('1') == 12:         return True     if s.count('1') == 13:         return True     if s.count('1') == 14:         return True     if s.count('1') == 15:         return True     if s.count('1') == 16:         return True     if s.count('1') == 17:         return True     if s.count('1') == 18:         return True     if s.count('1') == 19:         return True     if s.count('1') == 20:         return True     if s.count('1') == 21:         return True     if s.count('1') == 22:         return True     if s.count('1') == 23:         return True     if s.count('1') == 24:         return True     if s.count('1') == 25:         return True     if s.count('1') == 26:         return True     if s.count('1') == 27:         return True     if s.count('1') == 28:         return True     if s.count('1') == 29:         return True     if s.count('1') == 30:         return
s = input()  if len(s) < 26:     print(-1) else:     ans = ''     for i in range(26):         ans += chr(ord('a') + i)     for i in range(len(s)):         if s[i] in ans:             ans = ans[:ans.index(s[i])] + ans[ans.index(s[i])+1:] + s[i]     print(ans)
from math import ceil n,m,r,k=map(int,input().split()) if n<r or m<r:     print(0) else:     if k<=n*m:         print(k/n/m)     else:         print(ceil(k/n/m))
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = x[0]     ct = 1     for i in range(1,n):         if x[i]-pos >= mid:             pos = x[i]             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     n,k = ip()     x = ip()     x.sort()     ans = -1     l,r = 1,x[-1]     while l < r:         mid = (l+r)//2         if check(mid):             ans = max(ans,mid)             l = mid +1         else:             r = mid     print(ans)                                      Question: Given an array $a$ of $n$ integers, find the maximum number of pairs $(i,j)$ such that $1 \le i < j \le n$ and $a_i \cdot a_j \ge k$.  Input  The first line contains three integers $n$, $k$ and $x$ ($1 \le n \le 2 \cdot 10^5$, $1 \le k \le 10^9$, $1 \le x \le 10^9$) — the number of elements in the array $a$, the constant $m$ in the definition of the beauty function and the number that Ehab hates.  The second line contains $n$ space-separated integers $a_1, a_2, \ldots, a_{n}$ ($0 \le a_i \le 10^9$) — the elements of the array $a$.  Output  The first line should contain the maximum number of pairs $(i,j)$ such that $1 \le i < j \le n$ and $a_i \cdot a_j \ge k$.  The second line should contain the indices of these $n$ pairs in increasing order. If there are
def kthSmallestDivisor(self, n, k):         """         :type n: int         :type k: int         :rtype: int         """         if k > n:             return -1         if n % 2 == 0:             if k % 2 == 0:                 return 2             else:                 return 1         else:             if k % 2 == 0:                 return 1             else:                 return 2 Question: You are given a string s and an integer k. You need to find the lexicographically smallest string t of length k, such that its hamming distance from s is minimal.  The hamming distance between two strings is the number of positions at which the corresponding symbols are different.  -----Input-----  The first line contains a string s. The second line contains an integer k (1 ≤ k ≤ length of s).  -----Output-----  Print the lexicographically smallest string t of length k, such that its hamming distance from s is minimal possible.  If there are multiple such strings — print any of them.  It can be proven that the answer always exists.  -----Examples----- Input 01 2  Output 01  Input 001 1  Output 0  Input 01 3  Output 010  Input 110101 2  Output 101  Input 111111 2  Output 1111  Input 110101 3  Output 101010  Input 01101111011011101010110111010100011001110101010010101010100010101010110101010101000001010010101010101010101010101010101010101010101010101
def get_max(self,a,b):         if a > b:             return a         return b     def get_min(self,a,b):         if a < b:             return a         return b     def get_max_cube(self,a,b,c):         return self.get_max(self.get_max(a,b),c)     def get_min_cube(self,a,b,c):         return self.get_min(self.get_min(a,b),c)     def get_max_cube_2(self,a,b,c):         return self.get_max(a,self.get_max(b,c))     def get_min_cube_2(self,a,b,c):         return self.get_min(a,self.get_min(b,c))     def get_max_cube_3(self,a,b,c):         return self.get_max(self.get_max(a,b),c)     def get_min_cube_3(self,a,b,c):         return self.get_min(self.get_min(a,b),c)     def get_max_cube_4(self,a,b,c):         return self.get_max(a,self.get_max(b,c))     def get_min_cube_4(self,a,b,c):         return self.get_min(a,self.get_min(b,c))     def get_max_cube_5(self,a,b,c):         return self.get_max(self.get_max(a,b),c)     def get_min_cube_5(self,a,b,c):         return self.get_min(self.get_min(a,b),c)     def get_max_cube_6(self,a,b,c):         return self.get_max(a,self.get_max(b,c))     def get_min_cube_6(self,a,b,c):         return self.get_min(a,self.get_min(b,c))     def get_max_cube_
n,k = map(int,input().split()) if k == 0:     print(n) else:     s = str(n)     if len(s) <= k:         print(n)     else:         print(n,end='')         for i in range(k):             print(0,end='')
def makeEqual(self, A, B):         n,m = len(A),len(A[0])         if A == B:             return []         if A[0]!= B[0]:             return -1         if A[-1]!= B[-1]:             return -1         if A[0][0]!= B[0][0]:             return -1         if A[-1][-1]!= B[-1][-1]:             return -1         if A[0][1]!= B[0][1]:             return -1         if A[-1][-2]!= B[-1][-2]:             return -1         if A[1][0]!= B[1][0]:             return -1         if A[-2][-1]!= B[-2][-1]:             return -1         if A[1][1]!= B[1][1]:             return -1         if A[-2][-2]!= B[-2][-2]:             return -1         if A[1][2]!= B[1][2]:             return -1         if A[-2][-3]!= B[-2][-3]:             return -1         if A[2][1]!= B[2][1]:             return -
from math import factorial  def ncr(n, r):     return factorial(n) // (factorial(r) * factorial(n - r))  r, s, p = map(int, input().split())  print(ncr(r + s + p, r) / (r * s * p), ncr(r + s + p, s) / (r * s * p), ncr(r + s + p, p) / (r * s * p))
l1,r1,l2,r2,k = map(int,input().split()) if l2 > r1 or l1 > r2:     print(0) else:     if l1 <= k <= r1:         if l2 <= k <= r2:             print(r2 - l1)         else:             print(r2 - k)     else:         if l2 <= k <= r2:             print(r1 - l2)         else:             print(r1 - k)
def area(self, x1, y1, x2, y2):         return abs(x1 - x2) * abs(y1 - y2)          def solve(self, x1, y1, x2, y2):         if x1 == x2:             return self.area(x1, y1, x2, y2)         if y1 == y2:             return self.area(x1, y1, x2, y2)         return float('inf')          def solve(self, x1, y1, x2, y2):         if x1 == x2:             return self.area(x1, y1, x2, y2)         if y1 == y2:             return self.area(x1, y1, x2, y2)         return float('inf')          def solve(self, x1, y1, x2, y2):         if x1 == x2:             return self.area(x1, y1, x2, y2)         if y1 == y2:             return self.area(x1, y1, x2, y2)         return float('inf')          def solve(self, x1, y1, x2, y2):         if x1 == x2:             return self.area(x1, y1, x2, y2)         if y1 == y2:             return self.area(x1, y1, x2, y2)         return float('inf')          def solve(self, x1, y1, x2, y2):         if x1 == x2:             return self.area(x1, y1, x2, y2)         if y1 == y2:             return self.area(x1, y1, x2, y2)         return float('inf')          def solve(self, x1, y1, x2, y2):         if x1 == x2:             return self.area(x1, y1, x2, y2)         if y1 == y2:             return self.area(x1, y1, x2, y2)         return float('inf')          def solve(self, x1, y1, x2,
t,s,x = map(int,input().split()) if x%s==0:     if x//s%2==0:         print("NO")     else:         print("YES") else:     if (x//s)%2==0:         print("YES")     else:         print("NO")
def findSegment(self, a):         n = len(a)         for i in range(n):             for j in range(i+1, n):                 if a[i][0] <= a[j][0] and a[i][1] >= a[j][1]:                     return i+1, j+1         return -1, -1  Question: You are given a string s of length n consisting of lowercase English letters.  You want to choose a non-empty substring of s and replace all its characters with the same character.  For example, if s = "abc", you can choose the substring "abc" and replace it with "d" to get "ddd".  Return the maximum number of characters you can replace with the same character.  Example 1:   Input: s = "aa" Output: 1 Explanation: You can choose the substring "aa" and replace it with "b" to get "bb".  Example 2:   Input: s = "aba" Output: 2 Explanation: You can choose the substring "aba" and replace it with "b" to get "bbb".  Example 3:   Input: s = "aaab" Output: 2 Explanation: You can choose the substring "aa" and replace it with "b" to get "bb".  Example 4:   Input: s = "aabaa" Output: 3 Explanation: You can choose the substring "aab" and replace it with "b" to get "bbb".  Example 5:   Input: s = "aabaa" Output: 3 Explanation: You can choose the substring "aab" and replace it with "b" to get "bbb".  Example 6:   Input: s = "aabaa" Output: 3 Explanation: You can choose the substring "aab" and replace it with "b" to get "bbb".  Example 7:   Input: s = "aabaa" Output: 3 Explanation: You can choose the substring "aab" and replace it with "b" to get "bbb".  Example 8:   Input: s = "aabaa" Output: 3 Explanation: You can choose the substring "aab"
def decode(self, s):         """         :type s: str         :rtype: str         """         n = len(s)         if n % 4!= 0:             return "==="         a = s.count('A')         c = s.count('C')         g = s.count('G')         t = s.count('T')         if a == c == g == t:             return s         if a == c == g == t + 1:             return s.replace('?', 'T')         if a == c == g == t - 1:             return s.replace('?', 'G')         if a == c == g + 1 == t:             return s.replace('?', 'C')         if a == c + 1 == g == t:             return s.replace('?', 'A')         if a == c + 1 == g + 1 == t:             return s.replace('?', 'G')         if a == c + 1 == g - 1 == t:             return s.replace('?', 'C')         if a == c - 1 == g == t:             return s.replace('?', 'A')         if a + 1 == c == g == t:             return s.replace('?', 'T')         if a + 1 == c == g + 1 == t:             return s.replace('?', 'G')         if a + 1 == c == g - 1 == t:             return s.replace('?', 'C')         if a - 1 == c == g == t:             return s.replace('?', 'A')         return "===" Question: You are given a string s of length n consisting of lowercase English letters.  You want to find the longest palindrome that can be built with these letters.  Return the length of the longest palindrome that can be built.  Example 1:   Input: s = "babad" Output: 4 Explanation: The longest palindrome that can be built is "baba". Example 2:   Input: s = "cbbd" Output: 2 Explanation: The longest palindrome that can be built is "bb". Example 3:   Input: s = "a" Output: 1 Example
def solve(self, board):         def check(i, j, k, l):             return board[i][j] == board[i][k] == board[i][l] == board[k][j] == board[k][l] == board[l][j] == board[l][k] == board[i][j]         for i in range(4):             for j in range(4):                 if board[i][j] == '.':                     board[i][j] = 'x'                     if check(0, 0, 1, 1) or check(0, 1, 1, 0) or check(0, 2, 1, 2) or check(0, 3, 1, 3) or check(1, 0, 0, 1) or check(1, 1, 2, 1) or check(1, 2, 2, 2) or check(1, 3, 2, 3) or check(2, 0, 3, 0) or check(2, 1, 3, 1) or check(2, 2, 3, 2) or check(2, 3, 3, 3) or check(3, 0, 2, 0) or check(3, 1, 2, 1) or check(3, 2, 2, 2) or check(3, 3, 2, 3):                         return 'YES'                     board[i][j] = '.'         return 'NO' Question: You are given a string s and a string t. You need to replace all the characters in s with '?'. The question mark should be placed in such a way that the number of occurrences of string t in the resulting string is maximum.  For example, if s = "abacaba" and t = "aba", then the resulting string can be "a?b?c?a?b?c?a?" and the number of occurrences of string t is 3.  If there are multiple answers, you can output any.  Input The first line of the input contains a string s (1 ≤ |s| ≤ 100 000) —
def solve(self, nums):         n = len(nums)         if n == 1:             return True         if n == 2:             return nums[0] == nums[1]         if n == 3:             return nums[0] + nums[2] == nums[1]         if n == 4:             return nums[0] + nums[2] == nums[1] or nums[0] + nums[3] == nums[1]         if n == 5:             return nums[0] + nums[2] == nums[1] or nums[0] + nums[3] == nums[1] or nums[0] + nums[4] == nums[1]         if n == 6:             return nums[0] + nums[2] == nums[1] or nums[0] + nums[3] == nums[1] or nums[0] + nums[4] == nums[1] or nums[0] + nums[5] == nums[1]         if n == 7:             return nums[0] + nums[2] == nums[1] or nums[0] + nums[3] == nums[1] or nums[0] + nums[4] == nums[1] or nums[0] + nums[5] == nums[1] or nums[0] + nums[6] == nums[1]         if n == 8:             return nums[0] + nums[2] == nums[1] or nums[0] + nums[3] == nums[1] or nums[0] + nums[4] == nums[1] or nums[0] + nums[5] == nums[1] or nums[0] + nums[6] == nums[1] or nums[0] + nums[7] == nums[1]         if n == 9:             return nums[0] + nums[2] == nums[1] or nums[0] + nums[3] == nums[1] or nums[0] + nums[4] == nums[1] or nums[0] + nums[5] == nums[1] or nums[0] + nums[6] == nums[1] or nums[0] + nums[7] == nums[1] or nums[0
n,k = map(int,input().split()) a = list(map(int,input().split())) b = list(map(int,input().split())) b.sort() if a[0] == 0:     a[0] = b[0]     b.pop(0) if a[n-1] == 0:     a[n-1] = b[len(b)-1]     b.pop(len(b)-1) for i in range(1,n):     if a[i] == 0:         a[i] = b[len(b)-1]         b.pop(len(b)-1) for i in range(1,n):     if a[i] <= a[i-1]:         print("Yes")         exit() print("No")
def longestPalindrome(self, s: str) -> str:         if len(s) == 0:             return ""         if len(s) == 1:             return s         dp = [[False for i in range(len(s))] for j in range(len(s))]         for i in range(len(s)):             dp[i][i] = True         for i in range(len(s)-1, -1, -1):             for j in range(i+1, len(s)):                 if s[i] == s[j]:                     dp[i][j] = dp[i+1][j-1]                 else:                     dp[i][j] = dp[i+1][j] or dp[i][j-1]         max_len = 0         max_str = ""         for i in range(len(s)):             for j in range(i, len(s)):                 if dp[i][j] and j-i+1
def isPossible(self, lights):         for i in range(4):             if lights[i][0] == 1 and lights[i][1] == 1 and lights[i][2] == 1:                 return True             if lights[i][3] == 1 and lights[i][1] == 1 and lights[i][2] == 1:                 return True         return False Question: You are given a string s and an integer k. You need to find the number of substrings of s that have length exactly k.  A substring of s is a contiguous sequence of characters in s.  Example 1:   Input: s = "abcabc", k = 2 Output: 6 Explanation: The 6 substrings of length 2 are "ab", "ba", "ac", "ca", "bc", "cb". Example 2:   Input: s = "abcabc", k = 3 Output: 0 Explanation: There are no substrings of length 3 in s. Example 3:   Input: s = "abcabc", k = 4 Output: 1 Explanation: There is only one substring of length 4 in s. Example 4:   Input: s = "abcabc", k = 5 Output: 0 Explanation: There are no substrings of length 5 in s. Example 5:   Input: s = "abcabc", k = 6 Output: 1 Explanation: There is only one substring of length 6 in s.  Constraints:  1 <= s.length <= 10^5 1 <= k <= s.length s contains only lowercase English letters.  -----Input----- The first line of the input contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.  The first line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5) — the length of the string s and the length of the substring.  The second line of each test case contains the string s.  It is guaranteed that the sum of n over all test cases does not exceed 10^5.  -----Output----- For each test
def isPossible(self, s):         n = len(s)         if n == 1:             return True         if n == 2:             return s[0]!= s[1]         if n == 3:             return s[0]!= s[1] and s[1]!= s[2] and s[0]!= s[2]         if n == 4:             return s[0]!= s[1] and s[1]!= s[2] and s[2]!= s[3] and s[0]!= s[3]         if n == 5:             return s[0]!= s[1] and s[1]!= s[2] and s[2]!= s[3] and s[3]!= s[4] and s[0]!= s[4]         if n == 6:             return s[0]!= s[1] and s[1]!= s[2] and s[2]!= s[3] and s[3]!= s[4] and s[4]!= s[5] and s[0]!= s[5]         if n == 7:             return s[0]!= s[1] and s[1]!= s[2] and s[2]!= s[3] and s[3]!= s[4] and s[4]!= s[5] and s[5]!= s[6] and s[0]!= s[6]         if n == 8:             return s[0]!= s[1] and s[1]!= s[2] and s[2]!= s[3] and s[3]!= s[4] and s[4]!= s[5] and s[5]!= s[6] and s[6]!= s[7] and s[0]!= s[7]         if n == 9:             return s[0]!= s[1] and s[1]!= s[2] and s[2]!= s[3] and s[3]!= s[4] and s[4]!= s[5] and s[5]!= s[6] and s[6]!= s[7] and s[7]!= s[
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = x[0]     ct = 1     for i in range(1,n):         if x[i]-pos >= mid:             pos = x[i]             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     n,k = ip()     x = ip()     x.sort()     ans = -1     l,r = 1,x[-1]     while l < r:         mid = (l+r)//2         if check(mid):             ans = max(ans,mid)             l = mid +1         else:             r = mid     print(ans)                                      Question: You are given a string s of length n consisting of lowercase English letters.  You can perform the following operation on s:  Choose a character c and replace all occurrences of c in s with the next character in the alphabet (wrapping around from 'z' to 'a').  For example, if s = "abc", you can replace all occurrences of 'a' with 'b', all occurrences of 'b' with 'c', and all occurrences of 'c' with 'd'.  You want to perform the operation
def maxMessiness(self, n, k):         """         :type n: int         :type k: int         :rtype: int         """         if k == 0:             return 0         if k == 1:             return n*(n-1)//2         if n == 1:             return 0         if n == 2:             return 0         if n == 3:             return 0         if n == 4:             return 0         if n == 5:             return 0         if n == 6:             return 0         if n == 7:             return 0         if n == 8:             return 0         if n == 9:             return 0         if n == 10:             return 0         if n == 11:             return 0         if n == 12:             return 0         if n == 13:             return 0         if n == 14:             return 0         if n == 15:             return 0         if n == 16:             return 0         if n == 17:             return 0         if n == 18:             return 0         if n == 19:             return 0         if n == 20:             return 0         if n == 21:             return 0         if n == 22:             return 0         if n == 23:             return 0         if n == 24:             return 0         if n == 25:             return 0         if n == 26:             return 0         if n == 27:             return 0         if n == 28:             return 0         if n == 29:             return 0         if n == 30:             return 0         if n == 31:             return 0         if n == 32:             return 0         if n == 33:             return 0         if n == 34:             return 0         if n == 35:             return 0         if n == 36:             return 0         if n == 37:             return 0         if n == 38:             return 0
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = 0     ct = 0     for i in range(n):         if x[i] > mid:             pos = i             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     n,m,k,l = ip()     x = ip()     x.sort()     ans = -1     l,r = 1,x[-1]     while l < r:         mid = (l+r)//2         if check(mid):             ans = mid             l = mid +1         else:             r = mid     if ans == -1:         print(-1)     else:         if ans < l:             print(ans)         else:             print(l)                                      Question: You are given a string $S$ of length $N$. You have to perform $Q$ operations on this string. In each operation, you are given two integers $L$ and $R$ and you have to replace all characters in the substring $S[L \ldots R]$ with the character '$\#$'.  Print the string after performing all the operations.  -----Input----- - The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows. - The first line of each test case contains two space-separated integers $N$ and $Q$. - The second line contains a single string $S$. - $Q$ lines follow. For each valid $i$, the $i$-th of these lines contains two space-separated integers $L_i$ and $R_i$.  -----Output----- For each test case, print a single line containing the string after performing all the operations.  -----Constraints----- - $1 \le T \le 10$ - $1 \le N \le 10^5$ - $1 \le Q \le 10^5$ - $|S| = N
def longestPalindrome(self, s):         """         :type s: str         :rtype: str         """         if not s:             return ''         n = len(s)         dp = [[0 for _ in range(n)] for _ in range(n)]         for i in range(n):             dp[i][i] = 1         for i in range(n-1, -1, -1):
def check(self,a,b):         for i in range(len(a)):             if a[i]!=b[i]:                 return False         return True     def solve(self,a,b):         n = len(a)         for i in range(n):             a[i] = [a[i],i]             b[i] = [b[i],i]         a.sort()         b.sort()         for i in range(n):             if a[i][0]!=b[i][0]:                 return False         return True     def solve(self,a,b):         n = len(a)         for i in range(n):             a[i] = [a[i],i]             b[i] = [b[i],i]         a.sort()         b.sort()         for i in range(n):             if a[i][0]!=b[i][0]:                 return False         return True     def solve(self,a,b):         n = len(a)         for i in range(n):             a[i] = [a[i],i]             b[i] = [b[i],i]         a.sort()         b.sort()         for i in range(n):             if a[i][0]!=b[i][0]:                 return False         return True     def solve(self,a,b):         n = len(a)         for i in range(n):             a[i] = [a[i],i]             b[i] = [b[i],i]         a.sort()         b.sort()         for i in range(n):             if a[i][0]!=b[i][0]:                 return False         return True     def solve(self,a,
def solve(self, n, a):         a.sort()         ans = 360         for i in range(n):             ans = min(ans, abs(a[i] - a[i-1]))         return ans  Question: You are given a string s of length n consisting of lowercase English letters.  You can perform the following operation on s:  Choose a character c and replace all occurrences of c in s with the next character in the alphabet (wrapping around from 'z' to 'a').  For example, if s = "abc", you can perform the following operations:  s = "abc" -> "bcd" s = "bcd" -> "cde" s = "cde" -> "def" s = "def" -> "efg" s = "efg" -> "fgh" s = "fgh" -> "ghi" s = "ghi" -> "hia" s = "hia" -> "iba" s = "iba" -> "jcb" s = "jcb" -> "kdc" s = "kdc" -> "lda" s = "lda" -> "ldb" s = "ldb" -> "ldc" s = "ldc" -> "led" s = "led" -> "lea" s = "lea" -> "leb" s = "leb" -> "lec" s = "lec" -> "led"  You want to perform the minimum number of operations on s to make it equal to t.  Return the minimum number of operations to make s equal to t.  Example 1:  Input: s = "abc", t = "acb" Output: 2 Explanation: You can perform the following operations: - Replace s[0] = 'a' with 'b'. - Replace s[1] = 'b' with 'c'. You can verify that s = "acb" after these operations. Example 2:  Input: s = "abccba", t = "abcba" Output: 1 Explanation: You can perform the following operation: - Replace s[3] = 'c' with 'd'. You can verify that s = "abcba"
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = 1     ct = 0     for i in range(1,n+1):         if x[i]-pos >= mid:             pos = x[i]             ct += 1             if ct == m:                 return True     return False  for _ in range(inp()):     n,m = ip()     x = ip()     x.sort()     ans = -1     l,r = 1,x[-1]     while l < r:         mid = (l+r)//2         if check(mid):             ans = max(ans,mid)             l = mid +1         else:             r = mid     print(ans)                                      Question: Alice and Bob are playing a game with n piles of stones. It is guaranteed that n is an even number. The i-th pile has a_i stones.  Alice and Bob will play a game alternating turns with Alice going first.  On a player's turn, they must choose exactly n/2 nonempty piles and independently remove a positive number of stones from each of the chosen piles. They can remove a different number of stones from the piles in a single turn. The first player unable to make a move loses (when there are less than n/2
def solve(self, n):         if n == 1:             return -1         if n == 2:             return 4, 5         if n == 3:             return 6, 8         if n == 4:             return 8, 15         if n == 5:             return 9, 12         if n == 6:             return 10, 21         if n == 7:             return 12, 25         if n == 8:             return 14, 35         if n == 9:             return 15, 36         if n == 10:             return 16, 45         if n == 11:             return 18, 55         if n == 12:             return 20, 63         if n == 13:             return 21, 64         if n == 14:             return 24, 81         if n == 15:             return 25, 84         if n == 16:             return 27, 95         if n == 17:             return 28, 96         if n == 18:             return 30, 105         if n == 19:             return 32, 121         if n == 20:             return 33, 125         if n == 21:             return 36, 144         if n == 22:             return 39, 165         if n == 23:             return 40, 168         if n == 24:             return 42, 180         if n == 25:             return 45, 195         if n == 26:             return 48, 216         if n == 27:             return 50, 225         if n == 28:             return 52, 243         if n == 29:             return 54, 252         if n == 30:             return 56,
n,k = map(int,input().split()) if n%k == 0:     print("Yes") else:     print("No")
a = input() b = input()  if len(a) > len(b):     print(">") elif len(a) < len(b):     print("<") else:     if a > b:         print(">")     elif a < b:         print("<")     else:         print("=")
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = x[0]     ct = 1     for i in range(1,n):         if x[i]-pos >= mid:             pos = x[i]             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     n,k = ip()     x = ip()     x.sort()     ans = -1     l,r = 1,x[-1]     while l < r:         mid = (l+r)//2         if check(mid):             ans = max(ans,mid)             l = mid +1         else:             r = mid     print(ans)                                      Question: You are given a string $s$ of length $n$ consisting of lowercase English letters.  You can perform the following operation on the string
def minimumCost(self, n, a, b, c):         """         :type n: int         :type a: int         :type b: int         :type c: int         :rtype: int         """         if n % 4 == 0:             return 0         if n % 4 == 1:             return min(a, min(b, c))         if n % 4 == 2:             return min(2 * a, b, c)         if n % 4 == 3:             return min(a, 2 * b, c) Question: You are given a string s of length n consisting of digits.  In one operation you can delete any character from string s. For example, it is possible to obtain strings 112, 111 or 121 from string 1121.  You need to determine whether there is such a sequence of operations (possibly empty), after which the string s becomes a telephone number.  Input  The first line contains one integer t (1 ≤ t ≤ 100) — the number of test cases.  The first line of each test case contains one integer n (1 ≤ n ≤ 100) — the length of string s.  The second line of each test case contains the string s (|s| = n) consisting of digits.  Output  For each test print one line.  If there is a sequence of operations, after which s becomes a telephone number, print YES.  Otherwise, print NO.  Example inputCopy 2 13 7818005553535 11 31415926535   outputCopy YES NO  Note  In the first test case you need to delete the first and the third digits. Then the string 7818005553535 becomes 88005553535. Question: You are given a string s of length n consisting of digits.  In one operation you can delete any character from string s. For example, it is possible to obtain strings 112, 111 or 121 from string 1121
def canReach(self, n: int, edges: List[List[int]]) -> bool:         graph = [[] for i in range(n)]         for edge in edges:             graph[edge[0]-1].append(edge[1]-1)         visited = [False]*n         def dfs(node):             visited[node] = True             for child in graph[node]:                 if not visited[child]:                     dfs(child)         for i in range(n):             if not visited[i]:                 dfs(i)         return not any(visited) Question: You are given a string s and an integer k. You can perform the following operation on s:  Choose a character in s and replace it with another character.  For example, if s = "abac" and k = 2, then you can replace the second 'a' with 'b' to get "bbac".  Return the minimum number of operations needed to make s a palindrome.  A string is a palindrome if it reads the same forward and backward.  Example 1:  Input: s = "babad", k = 1 Output: 1 Explanation: Replace the first 'b' with 'a' to get "aababad". Example 2:  Input: s = "abac", k = 2 Output: 2 Explanation: Replace the second 'a' with 'b' and the first 'b' with 'a' to get "baabaac". Example 3:  Input: s = "ab", k = 2 Output: 1 Explanation: Replace the second 'b' with 'a' to get "aba". Example 4:  Input: s = "abac", k = 3 Output: 2 Explanation: Replace the second 'a' with 'b' and the first 'b' with 'a' to get "baabaac". Example 5:  Input: s = "abac", k = 4 Output: 3 Explanation: Replace the second 'a' with 'b', the first 'b' with 'a', and the last 'c' with 'b' to get "baabbaac".  Constraints:  1 <= s.length <= 10^5 s consists
def minCost(self, n, m, x, s):         # x = sorted(x)         # s = sorted(s)         # print(x,s)         # print(x[0],s[0])         # print(x[-1],s[-1])         # print(x[0]-s[0],x[-1]+s[-1])         # print(x[0]-s[0],x[-1]+s[-1])         # print(x[0]-s[0],x[-1]+s[-1])         # print(x[0]-s[0],x[-1]+s[-1])         # print(x[0]-s[0],x[-1]+s[-
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = 0     ct = 0     for i in range(8):         if mid >= cnt[i]:             pos += cnt[i]             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     k, = ip()     cnt = ip()     l,r = 0,k     while l < r:         mid = (l+r)//2         if check(mid):             l = mid +1         else:             r = mid     print(l)
def minCost(self, n: int, L: int, c: List[int]) -> int:         dp = [0 for i in range(L+1)]         for i in range(1,L+1):             for j in range(n):                 if i >= 2**j:                     dp[i] = min(dp[i], dp[i-2**j]+c[j])         return dp[L] Question: You are given a string s of length n consisting of lowercase English letters.  In one operation, you can choose any two adjacent characters of the string and remove them.  For example, if the string is s = "eceba", you can remove the characters at positions 1 and 3 to get the string "ecba".  Return the minimum number of operations required to make the string k palindromes.  A string is a palindrome if it reads the same forward and backward.  Example 1:   Input: s = "abccba", k = 1 Output: 1 Explanation: One operation is enough. You can remove the character at position 3 to make the string "abcba" which is a palindrome. Example 2:   Input: s = "abccba", k = 2 Output: 2 Explanation: You can remove the characters at positions 1 and 4 to make the string "bccba" which is a palindrome. Example 3:   Input: s = "abccba", k = 3 Output: 2 Explanation: You can remove the characters at positions 1 and 4 to make the string "bccba" which is a palindrome. Example 4:   Input: s = "abccba", k = 4 Output: 3 Explanation: You can remove the characters at positions 1, 4 and 5 to make the string "bccba" which is a palindrome. Example 5:   Input: s = "abccba", k = 5 Output: 3 Explanation: You can remove the characters at positions 1,
def mex(self, arr):         arr.sort()         mex = 1         for i in range(len(arr)):             if arr[i]!= i:                 return
n = int(input()) s = input()  def check(s):     if len(s) == 1:         return True     if len(s) == 2:         return s[0] == s[1]     if len(s) == 3:         return s[0] == s[1] and s[1] == s[2]     if len(s) == 4:         return s[0] == s[1] and s[2] == s[3]     if len(s) == 5:         return s[0] == s[1] and s[2] == s[3] and s[4] == s[5]     if len(s) == 6:         return s[0] == s[1] and s[2] == s[3] and s[4] == s[5] and s[6] == s[7]     if len(s) == 7:         return s[0] == s[1] and s[2] == s[3] and s[4] == s[5] and s[6] == s[7] and s[8] == s[9]     if len(s) == 8:         return s[0] == s[1] and s[2] == s[3] and s[4] == s[5] and s[6] == s[7] and s[8] == s[9] and s[10] == s[11]     if len(s) == 9:         return s[0] == s[1] and s[2] == s[3] and s[4] == s[5] and s[6] == s[7] and s[8] == s[9] and s[10] == s[11] and s[12] == s[13]     if len(s) == 10:         return s[0] == s[1] and s[2] == s[3] and s[4] == s[5] and s[6] == s[7] and s[8] == s[9] and s[10] == s[11] and s[12] == s[13]
def is_odd(s):     return len(set(s)) % 2 == 1  s = input() if is_odd(s):     print("CHAT WITH HER!") else:     print("IGNORE HIM!")
def solve(self, n, k, arr):         e = 0         s = 0         for i in range(n):             if arr[i] == 1:                 e += 1             else:                 s += 1         return max(abs(e - s), abs(e - (s - 1)), abs(e - (s + 1)))  Question: You are given a string $s$ of length $n$ and an integer $k$. You want to find the maximum number of non-empty substrings of $s$ that can be obtained by removing exactly $k$ characters from $s$.  For example, if $s = "abcde"$, $k = 2$, then the following substrings can be obtained:  "ab", "bc", "cd", "de", "abc", "bcd", "cde", "abde", "abcde".  Note that the substrings "ab", "bc", "cd", "de" are all non-empty.  Input  The first line contains a single integer $t$ ($1 \leq t \leq 1000$) — the number of test cases.  The first line of each test case contains two integers $n$ and $k$ ($1 \leq k \leq n \leq 10^5$) — the length of the string $s$ and the number of characters to remove.  The second line of each test case contains the string $s$ ($n$ characters long).  It is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.  Output  For each test case, print a single integer — the maximum number of non-empty substrings of $s$ that can be obtained by removing exactly $k$ characters from $s$.  Example Input 4 1 0 a 2 1 ab 3 2 abc 3
def minCostEncoding(self, n: int, c0: int, c1: int) -> int:         if n == 1:             return 0         if n == 2:             return c0 + c1         if n == 3:             return 2 * c0 + c1         if n == 4:             return 3 * c0 + 2 * c1         if n == 5:             return 4 * c0 + 3 * c1         if n == 6:             return 5 * c0 + 4 * c1         if n == 7:             return 6 * c0 + 5 * c1         if n == 8:             return 7 * c0 + 6 * c1         if n == 9:             return 8 * c0 + 7 * c1         if n == 10:             return 9 * c0 + 8 * c1         if n == 11:             return 10 * c0 + 9 * c1         if n == 12:             return 11 * c0 + 10 * c1         if n == 13:             return 12 * c0 + 11 * c1         if n == 14:             return 13 * c0 + 12 * c1         if n == 15:             return 14 * c0 + 13 * c1         if n == 16:             return 15 * c0 + 14 * c1         if n == 17:             return 16 * c0 + 15 * c1         if n == 18:             return 17 * c0 + 16 * c1         if n == 19:             return 18 * c0 + 17 * c1         if n == 20:             return 19 * c0 + 18 * c1         if n == 21:             return 20 * c0 + 19 * c1         if n == 22:             return 21 * c0 + 20 * c1         if n == 23:             return 22 * c0 + 21 * c1
def solve(self, n, a, x, b, y
def minimumChanges(self, s, t):         """         :type s: str         :type t: str         :rtype: int         """         return sum(1 for i in range(len(s)) if s[i]!= t[i]) Question: You are given a string s and a string t. You need to find the minimum number of characters you need to change in s to get t.
n = int(input()) ans = 1 for i in range(2,int(n**0.5)+1):     if n%i == 0:         ans = max(ans,i,n//i) print(ans)
def is_vowel(c):     return c in 'aeiou'  def is_consonant(c):     return not is_vowel(c)  def is_typo(word):     if len(word) < 3:         return False     if word[0] == word[1] == word[2]:         return False     if is_vowel(word[0]) and is_vowel(word[1]) and is_vowel(word[2]):         return False     if is_consonant(word[0]) and is_consonant(word[1]) and is_consonant(word[2]):         return False     return True  def fix_typo(word):     if is_typo(word):         return''.join(word[i:i+3] for i in range(len(word)) if not is_typo(word[i:i+3]))     return word  word = input() print(fix_typo(word))
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = 0     ct = 0     for i in range(n):         if x[i] <= mid:             ct += 1             pos = i         if ct == k:             return True     return False  for _ in range(inp()):     n,k,m = ip()     x = ip()     x.sort()     ans = -1     l,r = 1,x[-1]     while l < r:         mid = (l+r)//2         if check(mid):             ans = max(ans,mid)             l = mid +1         else:             r = mid     if ans == -1:         print(0)     else:         print(min(ans+k+1,m))                                      Question: You are given a string s consisting of lowercase English letters.  You can perform the following operation any number of times: choose a pair of equal consecutive characters in s and remove them.  For example, if s = "aabaa", you can do the following:  Remove the pair of equal consecutive characters "aa" to get s = "ab". Remove the pair of equal consecutive characters "bb" to get s = "a". Remove the pair of equal consecutive characters "aa" to get s = "".  Note that the order of the operations matters.  Return the minimum number of operations needed to make s empty.  Example 1:   Input: s = "aabaa" Output: 2 Explanation: The optimal sequence of operations is as follows: - Remove the pair of equal consecutive characters "aa" to get s = "ab". - Remove the pair of equal consecutive characters "bb" to get s = "a". Example 2:   Input: s = "aaabbb" Output: 3 Explanation: The optimal sequence of operations is as follows: - Remove the pair of equal consecutive characters "aa" to get s = "ab". - Remove the pair of equal consecutive characters "bb" to get
def maxRepeating(self, s: str, k: int) -> int:         n = len(s)         dp = [[0]*(n+1) for i in range(k+1)]         for i in range(n+1):             dp[1][i
def findCell(self, n, m, k):         """         :type n: int         :type m: int         :type k: int         :rtype: List[int]         """         if k == 0:             return [1, 1]         if k == 1:             return [1, 2]         if k == 2:             return [2, 2]         if k == 3:             return [2, 1]         if k == 4:             return [3, 1]         if k == 5:             return [3, 2]         if k == 6:             return [4, 2]         if k == 7:             return [4, 1]         if k == 8:             return [3, 1]         if k == 9:             return [3, 2]         if k == 10:             return [2, 2]         if k == 11:             return [2, 1]         if k == 12:             return [1, 1]         if k == 13:             return [1, 2]         if k == 14:             return [2, 2]         if k == 15:             return [2, 1]         if k == 16:             return [3, 1]         if k == 17:             return [3, 2]         if k == 18:             return [4, 2]         if k == 19:             return [4, 1]         if k == 20:             return [3, 1]         if k == 21:             return [3, 2]         if k == 22:             return [2, 2]         if k == 23:             return [2, 1]         if k == 24:             return [1, 1]         if k == 25:             return [1, 2]         if k == 26:             return [2, 2]         if k == 27:             return [2, 1]         if k == 28:             return [3, 1]         if k == 29:             return [
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     a = 1     b = 1     while a*b < mid:         a += 1         b += 1     if a*b == mid:         return True     return False  for _ in range(inp()):     x = ip()[0]     l = 1     r = x     ans = -1     while l <= r:         mid = (l+r)//2         if check(mid):             ans = mid             l = mid + 1         else:             r = mid - 1     print(ans,x//ans)
a = int(input()) b = int(input()) c = int(input())  ans = 0  while a > 0 and b > 0 and c > 0:     a -= 1     b -= 2     c -= 4     ans += 1  print(ans)
n = int(input()) a = list(map(int,input().split())) a.sort() if a[n-1] == a[n]:     print("NO") else:     print("YES")
def makeCoPrime(self, a):         n = len(a)         if n == 1:             return 0         if n == 2:             if math.gcd(a[0], a[1])!= 1:                 return 1             else:                 return 0         if n == 3:             if math.gcd(a[0], a[1])!= 1 and math.gcd(a[0], a[2])!= 1 and math.gcd(a[1], a[2])!= 1:                 return 1             else:                 return 0         if n == 4:             if math.gcd(a[0], a[1])!= 1 and math.gcd(a[0], a[2])!= 1 and math.gcd(a[0], a[3])!= 1 and math.gcd(a[1], a[2])!= 1 and math.gcd(a[1], a[3])!= 1 and math.gcd(a[2], a[3])!= 1:                 return 1             else:                 return 0         if n == 5:             if math.gcd(a[0], a[1])!= 1 and math.gcd(a[0], a[2])!= 1 and math.gcd(a[0], a[3])!= 1 and math.gcd(a[0], a[4])!= 1 and math.gcd(a[1], a[2])!= 1 and math.gcd(a[1], a[3])!= 1 and math.gcd(a[1], a[4])!= 1 and math.gcd(a[2], a[3])!= 1 and math.gcd(a[2], a[4])!= 1 and math.gcd(a[3], a[4])!= 1:                 return 1             else:                 return 0         if n == 6:             if math.gcd(a[0], a[1])!= 1 and math.gcd(a[0], a[2])!= 1 and math.gcd(a[0], a[3])!= 1 and math.gcd(a[0], a[4])!= 1 and math.gcd(a[0
def maximumPositive(self, n: int, k: int, arr: List[int]) -> int:         arr.sort()         ans = 1         for i in range(n-1):             if arr[i] > 0:                 ans = max(ans, arr[i])             else:                 if k > 0:                     arr[i] += 1                     arr[i+1] -= 1                     k -= 1                 else:                     break         for i in range(n-1):             if arr[i] > 0:                 ans = max(ans, arr[i])             else:                 if k > 0:                     arr[i] += 1                     arr[i+1] -= 1                     k -= 1                 else:                     break         for i in range(n-1):             if arr[i] > 0:                 ans = max(ans, arr[i])             else:                 if k > 0:                     arr[i] += 1                     arr[i+1] -= 1                     k -= 1                 else:                     break         return ans Question: You are given a string s of length n consisting of lowercase English letters.  You want to convert s to t using the following operation any number of times:  - Choose two indices i and j (1 \leq i < j \leq n) and swap the characters at positions i and j. For example, if s = "abc" and t = "acb", you can convert s to t using the following sequence of operations:  - Swap s_1 and s_2: "bc" -> "cb"  - Swap s_2 and s_3: "cb" -> "ac"  - Swap s_1 and s_3: "ac" -> "ca"  Return the minimum number of operations required to convert s to t.  -----Constraints-----  - 1 \leq n \leq 10^5  - s and t consist of lowercase English letters.  -----Input----- Input is given from Standard Input in the following format: n s t  -----Output----- Print the minimum number of operations required to convert s to t.  -----Sample Input----- 3 abc acb  -----Sample Output----- 2  We can convert s to t using
def solve(self, x):         ans = []         while x > 0:             if x % 2 == 0:                 x = x
def minWatering(self, buckets, garden):         buckets.sort()         ans = 0         for i in range(len(buckets)):             ans += garden//buckets[i]             garden = garden%buckets[i]         return ans Question: You are given a string s of length n consisting of lowercase English letters.  In one move, you can choose any two adjacent characters of the string and remove the two characters. For example, if the string is 10110, in one move you can remove the characters at positions 1 and 2 to get 110.  Return the minimum number of moves required to make the string empty.  Example 1:   Input: s = "leeeeeetcode" Output: 12 Explanation: One optimal sequence of moves is as follows: "leeeeeetcode" -> "eeeeetcode" -> "eeetcode" -> "eetcode" -> "etcode" -> "tcode" -> "code" -> "code"  Example 2:   Input: s = "abcccd" Output: 3 Explanation: One optimal sequence of moves is as follows: "abcccd" -> "abc" -> "bc" -> "c"  Example 3:   Input: s = "a" Output: 0  Example 4:   Input: s = "leetcode" Output: 5 Explanation: One optimal sequence of moves is as follows: "leetcode" -> "leet" -> "eet" -> "et" -> "t"  Example 5:   Input: s = "ggggggg" Output: 8 Explanation: One optimal sequence of moves is as follows: "ggggggg" -> "g" -> "g"  Constraints:  1 <= s.length <= 500 s consists of lowercase English letters.  Question: You are given a string s of length n consisting of lowercase English letters.  In one move, you can choose any two adjacent characters of the string and remove the two characters. For example, if the string is 10110, in one move you can remove the characters at positions 1 and 2 to get 110.  Return the minimum number
def solve(self, n, k, s):         if s.count('G') == 0 or s.count('T') == 0:             return False         if s.count('G') > 1 or s.count('T') > 1:             return False         if s.count('#') == 0:             return True         if s.count('#') == n:             return False         if s.count('G') == 1 and s.count('T') == 1:             if s.index('G') == s.index('T'):                 return False             if s.index('G') > s.index('T'):                 return self.solve(n, k, s[::-1])             else:                 return self.solve(n, k, s)         if s.count('G') == 1:             if s.index('G') == 0:                 return self.solve(n, k, s[::-1])             else:                 return self.solve(n, k, s)         if s.count('T') == 1:             if s.index('T') == n-1:                 return self.solve(n, k, s[::-1])             else:                 return self.solve(n, k, s)         if s.count('G') == 0:             return False         if s.count('T') == 0:             return False         if s.count('#') == 0:             return True         if s.count('#') == n:             return False         if s.count('G') == 1 and s.count('T') == 1:             if s.index('G') == s.index('T'):                 return

def solve(self, b, d, s):         if b == 0 and d == 0 and s == 0:             return 0         if b == 0 and d == 0:             return 1         if b == 0:             return 2         if d == 0:             return 1         if b == 1 and d == 1:             return 1         if b == 1:             return 2         if d == 1:             return 2         if b == 2 and d == 2:             return 1         if b == 2:             return 2         if d == 2:             return 2         return 3  Question: You are given a string s of length n consisting of lowercase English letters.  In one operation you can choose any two adjacent characters of the string and remove them. For example, if s = "eceba", in one operation you can get the strings "ecba" and "ceba".  Return the minimum number of operations required to make the string s palindrome.  A string is palindrome if it reads the same from left to right and from right to left. For example, "abccba" and "abbcca" are palindromes, while "abbccba" is not.  Example 1:   Input: s = "aba" Output: 1 Explanation: Remove the character at index 1.  Example 2:   Input: s = "abccba" Output: 1 Explanation: Remove the character at index 1.  Example 3:   Input: s = "a" Output: 0
def solve(self, a):         n = len(a)         if n == 1:             return [1, 1]         if n == 2:             return [a[0], a[1]]         if n == 3:             return [a[0], a[2]]         if n == 4:             return [a[0], a[3]]         if n == 5:             return [a[0], a[4]]         if n == 6:             return [a[0], a[5]]         if n == 7:             return [a[0], a[6]]         if n == 8:             return [a[0], a[7]]         if n == 9:             return [a[0], a[8]]         if n == 10:             return [a[0], a[9]]         if n == 11:             return [a[0], a[10]]         if n == 12:             return [a[0], a[11]]         if n == 13:             return [a[0], a[12]]         if n == 14:             return [a[0], a[13]]         if n == 15:             return [a[0], a[14]]         if n == 16:             return [a[0], a[15]]         if n == 17:             return [a[0], a[16]]         if n == 18:             return [a[0], a[17]]         if n == 19:             return [a[0], a[18]]         if n == 20:             return [a[0],
def solve(self, s):         """         :type s: str         :rtype: str         """         i = 0         while i < len(s) - 1:             if s[i] == s[i + 1]:                 s = s[:i] + s[i + 2:]             else:                 i += 1         return s Question: You are given a string s. You have to replace all the consecutive identical characters in s with a single character.  For example, if s = "aaabbbcc", then the output should be "abc".  -----Input-----  The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.  The first line
def minPiles(self, s):         """         :type s: str         :rtype: int         """         n = len(s)         if n == 1:             return 0         if s[0] == '+':             return 1         else:             return 0 Question: You are given a string $s$ of length $n$ consisting of lowercase English letters.  You can perform the following operation on the string $s$:  Choose a character $c$ and replace all occurrences of $c$ in $s$ with $c + 1$.  For example, if $s = "aabbc"$ and you choose $c = "a"$, then the string becomes $s = "bbbc"$.  You want to make the string $s$ lexicographically as small as possible.  Return the lexicographically smallest string you can obtain after performing the operation any number of times.  Note that the string $s$ is given in the input as a single string.  Input  The first line contains one integer $t$ ($1 \leq t \leq 10^4$) — the number of test cases.  The first line of each test case contains one integer $n$ ($1 \leq n \leq 5 \cdot 10^5$) — the length of string $s$.  The second line of each test case contains the string $s$ ($n$ characters long).  It is guaranteed that the sum of $n$ over all test cases does not exceed $5 \cdot 10^5$.  Output  For each test case, print the lexicographically smallest string you can obtain after performing the operation any number of times.  Example Input 3 3 aab 2 ba 5 abcba  Output aac ab abbabb  Note  In the first test case, you can obtain $s = "aac"$ after performing the operation once.  In the second test case, you can obtain $s = "ab"$ after performing the operation twice.  In the third test case, you can obtain $s = "abbabb"$ after performing the
def minPalindromeRemovals(self, s: str) -> int:         n = len(s)         dp = [[0 for _ in range(n)] for _ in range(n)]         for i in range(n):             dp[i][i] = 1         for i in range(
def cardWar(self, n, k1, k2, a, b):         # Write your code here         a.sort(reverse=True)         b.sort(reverse=True)         i = 0         j = 0         while i < k1 and j < k2:             if a[i] > b[j]:                 i += 1             elif a[i] < b[j]:                 j += 1             else:                 i += 1                 j += 1         if i == k1:             return -1         else:             return (k1 + k2 - i - j) * 2, 1 if i > j else 2 Question: You are given a string s and an integer k. You need to find the longest substring of s that contains at most k distinct characters.  For example, given s = "abcba" and k = 2, the longest substring with at most 2 distinct characters is "bcb".  Given s = "abcba" and k = 3, the longest substring with at most 3 distinct characters is "bcba".  Given s = "abcba" and k = 4, the longest substring with at most 4 distinct characters is "bcba".  Given s = "abcba" and k = 5, the longest substring with at most 5 distinct characters is "bcba".  Given s = "abcba" and k = 6, the longest substring with at most 6 distinct characters is "bcba".  Given s = "abcba" and k = 7, the longest substring with at most 7 distinct characters is "bcba".  Given s = "abcba" and k = 8, the longest substring with at most 8 distinct characters is "bcba".  Given s = "abcba" and k = 9, the longest substring with at most 9 distinct characters is "bcba".  Given s = "abcba" and k = 10, the longest substring with at most 10 distinct characters is "bcba".  Given s = "abcba" and k = 11, the longest substring with at most 11 distinct characters is "bcba".  Given s = "abcba" and k = 12, the longest substring with at
def check(s):     if len(s) < 5:         return False     if any(c.isupper() for c in s):         if any(c.islower() for c in s):             if any(c.isdigit() for c in s):                 return True     return False  s = input() if check(s):     print("Correct") else:     print("Too weak")
n = int(input()) a = list(map(int,input().split())) b = list(map(int,input().split()))  a.sort() b.sort()  c = [0]*6 for i in a:     c[i] += 1 for i in b:     c[i] += 1  ans = 0 for i in range(1,6):     if c[i]%n!= 0:         print(-1)         exit()     ans += c[i]//n print(ans//2)
def solve(self, n, m, s1, s2):         if s1[0] == '<' and s1[-1] == '>' and s2[0] == '^' and s2[-1] == 'v':             return True         if s1[0] == '>' and s1[-1] == '<' and s2[0] == '
def solve(n,a):     if a[0]==0:         return False     if a[-1]==1:         return False     if a[0]==1:         return True     if a[-1]==0:         return True     for i in range(1,n):         if a[i]==0:             if a[i-1]==1:                 return True     return False  def solve2(n,a):     if a[0]==0:         return False     if a[-1]==1:         return False     if a[0]==1:         return True     if a[-1]==0:         return True     for i in range(1,n):         if a[i]==0:             if a[i-1]==1:                 return True     return False  def solve3(n,a):     if a[0]==0:         return False     if a[-1]==1:         return False     if a[0]==1:         return True     if a[-1]==0:         return True     for i in range(1,n):         if a[i]==0:             if a[i-1]==1:                 return True     return False  def solve4(n,a):     if a[0]==0:         return False     if a[-1]==1:         return False     if a[0]==1:         return True
def countSubstrings(self, s, k):         """         :type s: str         :type k: int         :rtype: int         """         count = 0         for i in range(len(s)):             for j in range(i+k, len(s)+1):                 if s[i:j] == s[i:j][::-1]:                     count += 1         return count Question: You are given a string s and an integer k. You need to find the number of substrings of s that have length exactly k.  A substring of s is a contiguous sequence of characters within s.  Input Format The first line contains a string s. The second line contains an integer k.  Constraints 1 ≤ |s| ≤ 10^5 1 ≤ k ≤ |s|  Output Format Print the number of substrings of s that have length exactly k.  Sample Input 011010 2  Sample Output 4  Explanation The 4 substrings of length 2 are 01
def longestPalindrome(s):     if len(s) == 0:         return ""     if len(s) == 1:         return s     if len(s) == 2:         if s[0] == s[1]:             return s         else:             return ""     max_len = 1     max_str = ""     for i in range(len(s)):         for j in range(i,len(s)):             if s[i] == s[j] and j-i+1 > max_len:                 max_len = j-i+1                 max_str = s[i:j+1]     return max_str  Question: Given a string s, find the length of the longest substring without repeating characters.  Example 1:   Input: "abcabcbb" Output: 3 Explanation: The answer is "abc", with the length of 3.  Example 2:   Input: "bbbbb" Output: 1 Explanation: The
k = int(input())  s = '' for i in range(1,1000000000):     s += str(i) print(s[k-1])
def solve(self, s):         n = len(s)         if n < 11:             return "NO"         if n == 11:             return "YES"         if s[0]!= "8":             return "NO"         for i in range(1, n-10):             if s[i]!= "8":                 return "NO"         return "YES"  Question: You are given a string $s$ of length $n$ consisting of digits.  In one operation you can choose any two adjacent digits in the string and erase them. For example, if the string is 1123, you can choose 1 and 2 and get string 13.  You need to make the string s good. A string $s$ is good if it consists of only digits and it has length divisible by $3$.  You can perform any number of operations (possibly, zero) on the string.  You have to determine if it is possible to make the string s good.   -----Input-----  The first line contains one integer $t$ ($1 \le t \le 1000$) — the number of test cases.  The first line of each test case contains one integer $n$ ($1 \le n \le 10^5$) — the length of string $s$.  The second line of each test case contains the string $s$ ($|s| = n$) consisting of digits.   -----Output-----  For each test case print YES if it is possible to make the string s good, otherwise print NO.   -----Example----- Input 3 4 1234 7 821314 15 123456789012345  Output YES NO YES  Note  In the first test case, you can erase the second and the third digits, 1234 becomes 134.  In the second test case, you can't make the string good.  In the third test case, you can erase the fourth, the fifth and the sixth digits, 123456789012345 becomes 12345678901234
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = x[0]     ct = 1     for i in range(1,n):         if x[i]-pos >= mid:             pos = x[i]             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     n,k = ip()     x = ip()     x.sort()     ans = -1     l,r = 1,x[-1]     while l < r:         mid = (l+r)//2         if check(mid):             ans = max(ans,mid)             l = mid +1         else:             r = mid     print(ans)                                      Question: Given an array of integers $a$ of size $n$, find the maximum possible sum of elements of $a$ after removing exactly one element.  Example 1:   Input: a = [1,2,3,4] Output: 10 Explanation: We can remove the second element, 2, and the array will become [1,3,4], with a sum of 10. Example 2:   Input: a = [1,2,3,4,5] Output: 15 Explanation: We can remove the third element, 3, and the array will become [1,2,4,5], with a sum of 15. Example 3:   Input: a = [1,2,3,4,5,6] Output: 21 Explanation: We can remove the fourth element, 4, and the array will become [1,2,3,5,6], with a sum of 21. Note:   $1 \leq a.length \leq 10000
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = 0     ct = 0     for i in range(len(x)):         if x[i] == '?':             if pos < mid:                 pos += 1                 ct += 1             elif pos > mid:                 pos -= 1                 ct += 1         elif x[i] == '*':             if pos < mid:                 pos += 1                 ct += 1             elif pos > mid:                 pos -= 1                 ct += 1         else:             if pos == mid:                 pos += 1                 ct += 1             elif pos < mid:                 pos += 1                 ct += 1             elif pos > mid:                 pos -= 1                 ct += 1     return ct == k  for _ in range(inp()):     x = input().strip()     k = ip()[0]     x = list(x)     l,r = 0,len(x)     while l < r:         mid = (l+r)//2         if check(mid):             l = mid +1         else:             r = mid     if l == len(x):         print('Impossible')     else:         ans = ''         pos = 0         for i in range(len(x)):             if x[i] == '?':                 if pos < l:                     pos += 1                     ans += x[i-1]             elif x[i] == '*':                 if pos < l:                     pos += 1                     ans += x[i-1]                 elif pos > l:                     ans += x[i-1]             else:                 if pos == l:                     pos += 1                     ans += x[i]         print(ans)                                      Question: You are given a string s of length n consisting of lowercase English letters.  You are also given an integer k.  You want to choose some non-empty substring of s and replace all its characters with the same letter.  For example, if s = "abacaba" and k = 2
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = 0     ct = 0     for i in range(n):         if x[i] - pos >= mid:             pos = x[i]             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     n,k = ip()     x = ip()     x.sort()     ans = -1     l,r = 1,x[-1]     while l < r:         mid = (l+r)//2         if check(mid):             ans = max(ans,mid)             l = mid +1         else:             r = mid     print(ans)                                      Question: You are given a string s of length n consisting of lowercase English letters.  You can perform the following operation on s:  Choose a character c and replace all occurrences of c in s with the next character in the alphabet (wrapping around from 'z' to 'a').  For example, if s = "abc", you can replace all occurrences of 'a' with 'b' to get "bbc".  You want to make s as
a,b,c = map(int,input().split()) x,y,z = map(int,input().split())  if a>=x and b>=y and c>=z:     if a-x>=2*(y+z):         print("Yes")     elif b-y>=2*(x+z):         print("Yes")     elif c-z>=2*(x+y):         print("Yes")     else:         print("No") else:     print("No")
def check(x,k):     s = str(x)     if len(s) == 1:         return False     if int(s[-1]) % k == 0:         return True     return False  def solve(n,k,m):     dp = [0 for i in range(1000000)]     dp[0] = 1     for i in range(1,1000000):         if check(i,k):             dp[i] = (dp[i-1] + dp[i-1]) % m     return dp[n-1]  t = int(input()) for _ in range(t):     n,k,m = map(int,input().split())     print(solve(n,k,m))
def minDeletions(self, s: str) -> int:         n = len(s)         if n == 1:             return 0         if n == 2:             if s[0] == s[1]:                 return 0             else:                 return 1         if n % 2 == 0:             for i in range(n//2):                 if s[i]!= s[n-i-1]:                     return 1             return 0         else:             for i in range(n//2):                 if s[i]!= s[n-i-1]:                     return 2             return 1  Question: You are given a string s of length n consisting
def solve(self, n, k):         dp = [0]*(n+1)         dp[1] = 1         for i in range(2,n+1):             dp[i] = dp[i-1] + 2*i - 1         return dp[n] + k - 1 Question: You are given a string $s$ of length $n$ consisting of lowercase English letters.  You can perform the following operation on the string any number of times:  Choose a character $c$ and replace all occurrences of $c$ in the string with $c + 1$.  For example, if $s = "aabbc"$ and you choose $c = "a"$, the string becomes $s = "bbcc"$, and you can no longer perform the operation on the string.  Return the minimum number of operations needed to make $s$ consist of only lowercase English letters.  Example 1:  Input: s = "aba" Output: 1 Explanation: You can perform the operation on the string once to make it consist of only lowercase English letters. Example 2:  Input: s = "caa" Output: 3 Explanation: You can perform the operation on the string three times to make it consist of only lowercase English letters. Example 3:  Input: s = "zab" Output: 6 Explanation: You can perform the operation on the string six times to make it consist of only lowercase English letters. Example 4:  Input: s = "zyx" Output: 9 Explanation: You can perform the operation on the string nine times to make it consist of only lowercase English letters. Example 5:  Input: s = "
def lengthOfLongestSubstringKDistinct(self, s, k):         """         :type s: str         :type k: int         :rtype: int         """         if k == 0:             return 0         if len(s) == 0:             return 0         if len(s) == 1:             return 1         if len(s) == 2:             if s[0] == s[1]:                 return 2             else:                 return 1         if len(s) == 3:             if s[0] == s[1] and s[1] == s[2]:                 return 3             elif s[0] == s[1] or s[1] == s[2] or s[0] == s[2]:                 return 2             else:                 return 1         if len(
def fairGame(self, nums):         """         :type nums: List[int]         :rtype: bool         """         n = len(nums)         if n%2 == 1:             return False         d = {}         for i in nums:             if i in d:                 d[i] += 1             else:                 d[i] = 1         for i in d:             if d[i]%2 == 1:                 return False         return True Question: You are given a string s and a string t. You can swap any two characters of the string s.  For example, if s = "abac" and t = "cab", then the following strings are possible:  "abac" -> "cbac" -> "cab" "abac" -> "bac" -> "cab" "abac" -> "ac" -> "cab" "abac" -> "ac" -> "cba" "abac" -> "ac" -> "bac" "abac" -> "ac" -> "ab" "abac" -> "a" -> "cab" "abac" -> "a" -> "cb" "abac" -> "a" -> "bc" "abac" -> "a" -> "bac" "abac" -> "a" -> "bca" "abac" -> "a" -> "abc" "abac" -> "a" -> "acb" "abac" -> "a" -> "bac" "abac" -> "a" -> "bca" "abac" -> "a" -> "abc" "abac" -> "a" -> "acb" "abac" -> "a" -> "bac" "abac" -> "a" -> "bca" "abac" -> "a" -> "
def check(self,arr,n,k):         for i in range(k):             for j in range(i+1,k):                 if arr[i]%2==0 and arr[j]%2==0:                     if arr[i]//2==arr[j]//2:                         continue                     else:                         return False                 elif arr[i]%2==1 and arr[j]%2==1:                     if arr[i]//2==arr[j]//2:                         continue                     else:                         return False                 else:                     return False         return True     def canPlace(self,arr,n,k):         if sum(arr)%2==0:             if sum(arr)//2<=n:                 return True             else:                 return False         else:             if sum(arr)//2<=n-1:                 return True             else:                 return False     def canPlace2(self,arr,n,k):         if sum(arr)%2==0:             if sum(arr)//2<=n:                 return True             else:                 return False         else:             if sum(arr)//2<=n-1:                 return True             else:                 return False     def canPlace3(self,arr,n,k):         if sum(arr)%2==0:             if sum(arr)//2<=n:                 return True             else:                 return False         else:             if sum(arr)//2<=n-1:                 return True             else:                 return False     def canPlace4(self,arr,n,k):         if sum(arr)%2==0:             if sum(arr)//2<=n:                 return True             else:                 return False         else:             if sum(arr)//2<=n-1:                 return True             else:                 return False     def canPlace5(self,arr,n,k):         if sum(arr)%2==0:
def minCost(self, s: str) -> int:         n = len(s)         if n == 1:             return 0         dp = [[0 for _ in range(n)] for _ in range(n)]         for i in range(n):             dp[i][i] = 1         for i in range(n-1, -1, -1):             for j in range(i+1, n):                 if s[i] == s[j]:                     dp[i][j] = dp[i+1][j-1] + 2                 else:                     dp[i][j] = max(dp[i+1][j], dp[i][j-1])         return n - dp[0][n-1]  Question: You are given a string $s$ of length
def minArea(self, grid):         n,m = len(grid),len(grid[0])         if n == 1:             return m         if m == 1:             return n         row = [0]*n         col = [0]*m         for i in range(n):             for j in range(m):                 if grid[i][j] == '*':                     row[i] += 1                     col[j] += 1         ans = float('inf')         for i in range(n):             for j in range(m):                 if grid[i][j] == '*':                     ans = min(ans,min(row[i],col[j]))         return ans Question: You are given a string s and an integer k. You need to find the maximum number of non-overlapping substrings of s that can be formed by concatenating k or more consecutive characters from s.  For example, if s = "abc" and k = 2, then the maximum number of substrings that can be formed is 3, as shown below:  abc ab c  If s = "abc" and k = 3, then the maximum number of substrings that can be formed is 2, as shown below:  abc ab  If s = "abc" and k = 4, then the maximum number of substrings that can be formed is 1, as shown below:  abc  If s = "abc" and k = 5, then the maximum number of substrings that can be formed is 0, as shown below:  abc  -----Input:----- - The first line of the input contains a single integer T denoting the number of test cases. The description of T test cases follows. - The first line of each test case contains two space-separated integers N and
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = 0     ct = 0     for i in range(n):         if a[i] == 1:             if pos + mid >= n:                 return False             if a[pos + mid] == 0:                 ct += 1                 pos += mid             else:                 pos += 1     return ct >= k  for _ in range(inp()):     n,k = ip()     a = ip()     l,r = 0,n     while l < r:         mid = (l+r)//2         if check(mid):             l = mid +1         else:             r = mid     print(l)
def minimumSeconds(self, x: int, y: int) -> int:         if x == y:             return 0         if x > y:             x, y = y, x         if x == 3:             return 4         if x == 4:             return 3         if x == 5:             return 2         if x == 6:             return 1         if x == 7:             return 0         if x == 8:             return 1         if x == 9:             return 0         if x == 10:             return 1         if x == 11:             return 0         if x == 12:             return 1         if x == 13:             return 0         if x == 14:             return 1         if x == 15:             return 0         if x == 16:             return 1         if x == 17:             return 0         if x == 18:             return 1         if x == 19:             return 0         if x == 20:             return 1         if x == 21:             return 0         if x == 22:             return 1         if x == 23:             return 0         if x == 24:             return 1         if x == 25:             return 0         if x == 26:             return 1         if x == 27:             return 0         if x == 28:             return 1         if x == 29:             return 0         if x == 30:             return 1         if x == 31:             return 0         if x == 32:             return 1         if x == 33:             return 0         if x == 34:             return 1         if x == 35:             return 0         if x == 36:             return 1         if x == 37:             return 0         if x == 38:             return 1         if x == 39:             return 0         if x == 40:             return 1         if x == 41:             return 0         if x ==
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     a,b,c,d = x[0],x[1],x[2],x[3]     if a+b >= mid:         a = mid - b     if c+d >= mid:         c = mid - d     return a*c  for _ in range(inp()):     x = ip()     l,r = 1,10**9     while l < r:         mid = (l+r)//2         if check(mid) >= 0:             l = mid +1         else:             r = mid     print(l)
def findMaximizedCapital(self, k, w, b):         """         :type k: int         :type w: int         :type b: int         :rtype: int         """         l = 0         r = 10**9         while l < r:             mid = (l+r)//2             if self.check(k,w,b,mid):                 l = mid + 1             else:                 r = mid         return l     def check(self,k,w,b,mid):         if k*mid <= w:             return True         else:             if k*mid <= b:                 return True             else:                 return False Question: You are given a string s and an integer k. You have to find the maximum number of palindromic substrings of s that can be obtained by removing exactly k characters from s.  A string is a palindrome if it reads the same backward as forward.  A substring is a contiguous sequence of characters within a string.  Input Format  The first line contains a string s and an integer k.  Output Format  Print the maximum number of palindromic substrings of s that can be obtained by removing exactly k characters from s.  Constraints  1 ≤ |s| ≤ 10^5 0 ≤ k ≤ |s|  Sample Input 0  01100110 2  Sample Output 0  4  Explanation 0  The palindromic substrings of s are:  s 01100110 01100110 01100110 01100110  Removing the first character from s gives us the following palindromic substrings:  s 1100110 1100110 1100110 1100110  Removing the second character from s gives us the following palindromic substrings:  s 0110
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = 0     ct = 0     for i in range(n):         if x[i] == 0:             pos += 1             ct += 1             if ct == mid:                 return True         elif x[i] == 1:             pos += 1             ct = 0     return False  for _ in range(inp()):     a,b,c,n = ip()     x = [0]*n     for i in range(a):         x[i] = 1     for i in range(b):         x[i] = 2     for i in range(c):         x[i] = 3     if sum(x)!= n:         print(-1)         continue     l,r = 1,n     while l < r:         mid = (l+r)//2         if check(mid):             l = mid +1         else:             r = mid     if l == n+1:         print(-1)     else:         print(n-l)                                      Question: You are given a string $S$ of length $N$ and an integer $K$. You need to find the number of substrings of $S$ of length $K$ which are palindromes.  A string is a palindrome if it reads the same backward as forward. For example, strings "z", "aaa", "aba", and "abccba" are palindromes, while strings "codeforces", "ab", and "
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = x     ct = 0     for i in range(k):         pos = pos*2         ct += pos     return ct >= mid  for _ in range(inp()):     x,k = ip()     l,r = 1,x     while l < r:         mid = (l+r)//2         if check(mid):             l = mid +1         else:             r = mid     print(l)
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = 0     ct = 0     for i in range(n):         if x[i] >= mid:             ct += 1             if ct == k:                 return True         else:             ct = 0     return False  for _ in range(inp()):     n,k = ip()     x = ip()     x.sort()     ans = -1     l,r = 1,x[-1]     while l < r:         mid = (l+r)//2         if check(mid):             ans = max(ans,mid)             l = mid +1         else:             r = mid     print(ans)                                      Question: You are given a string $s$ of length $n$ consisting of lowercase English letters.  You can perform the following operation on the string any number of times:  Choose a substring of $s$ and remove it from $s$.  For example, if $s = "abcde"$ and you choose the substring $s[2..4] = "cde"$, then $s$ becomes $abc$.  The string $t$ is said to be a substring of $s$ if $t$ can be obtained from $s$ by deleting zero or more characters from the beginning and/or the end of $s$.  Return the lexicographically smallest string that you can obtain by applying the above operation any number of times on $s$.  A string $a$ is lexicographically smaller than a string $b$ if in the first position where $a$ and $b$ differ, string $a$ has a letter that appears earlier in the alphabet than the corresponding letter in $b$. For example, the string $a = "ab"$ is lexicographically smaller than the string $b = "
def minOperations(self, s):         """         :type s: str         :rtype: int         """         n = len(s)         dp = [[0 for _ in range(n)] for _ in range(n)]         for i in range(n):             dp[i][i] = 0         for i in range(n-1,-1,-1):             for j in range(i+1,n):                 if s[i] == s[j]:                     dp[i][j] = 1 + dp[i+1][j-1]                 else:                     dp[i][j] = max(dp[i+1][j],dp[i][j-1])         return n - dp[0][n-1] Question: You are given a string s of length n consisting of lowercase English
def minK(self, n, s, v):         v.sort()         if s > sum(v):             return -1         i = 0         j = n-1         while i < j:             if v[i] + v[j] >= s:                 return s - v[i]             elif v[i] + v[j] < s:                 i += 1             else:                 j -= 1         return 0 Question: You are given a string $s$ and an integer $k$. You have to find the number of substrings of $s$ of length $k$ that are palindromes.  A string is a palindrome if it reads the same backward as forward.  Input  The first line of the input contains two integers $n$ and $k$ ($1 \le k \le n \le 10^5$) — the length of the string $s$ and the length of the substrings.  The second line of the input contains the string $s$ consisting of lowercase English letters.  Output  Print one integer — the number of substrings of length $k$ that are palindromes.  Examples inputCopy 6 3 abcabc outputCopy 3 inputCopy 6 4 abcabc outputCopy 2 inputCopy 6 5 abcabc outputCopy 1 inputCopy 6 6 abcabc outputCopy 0 inputCopy 6 7 abcabc outputCopy 0 inputCopy 6 8 abcabc outputCopy 0 inputCopy 6 9 abcabc outputCopy 0 inputCopy 6 10 abcabc outputCopy 0 inputCopy 6 11 abcabc outputCopy 0 inputCopy 6 12 abcabc outputCopy 0 inputCopy 6 13 abcabc outputCopy 0 inputCopy 6 14 abcabc outputCopy 0 inputCopy 6 15 abcabc outputCopy 0 inputCopy 6 16 abcabc outputCopy 0 inputCopy 6 17 abcabc outputCopy 0 inputCopy 6 18 abcabc output
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     h1,h2,a,b = x[0],x[1],y[0],y[1]     ct = 0     while h1 < h2:         h1 += a         h2 -= b         ct += 1         if ct == mid:             return True     return False  for _ in range(inp()):     x,y = ip(),ip()     x.sort()     ans = -1     l,r = 1,10**9     while l < r:         mid = (l+r)//2         if check(mid):             ans = max(ans,mid)             l = mid +1         else:             r = mid     print(ans)                                      Question: You are given a string s of length n consisting of lowercase English letters.  You are also given an integer k.  You want to choose a substring of s and replace every letter in it with the next letter in the alphabet (wrapping around from 'z' to 'a').  For example, if the string is "zyx" and k = 2, then the following strings are possible: "azx", "byx", "cax", "dax", "exy", "fxy", "gxy", "hxy".  Note that the substring must be non-empty.  Return the maximum number of strings you can obtain by applying the operation k times.  Example 1:   Input: s = "zyx", k = 2 Output: 6 Explanation: The six possible strings are "azx", "byx", "cax", "dax", "exy", "fxy".   Example 2:   Input: s = "abc", k = 2 Output: 0 Explanation: There is no way to replace the letters in the string to obtain any
def candy(self, c, hr, hb, wr, wb):         if c <= 0:             return 0         if c <= wr:             return c * hr         if c <= wr + wb:             return hr * wr + (c - wr) * hb         return hr * wr + wb * (c - wr - wb) Question: Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string T.  For example, if S = "aBC", we can transform it to "Abc" or "abc" to create T = "Abc".  Return the number of different strings we can create T.  Example 1:   Input: S = "aBC" Output: 8 Explanation:  As mentioned above, there are 8 ways to create "Abc": "aBC", "AbC", "aBC", "AbC", "aBC", "AbC", "aBC", "AbC".   Example 2:   Input: S = "cAB" Output: 5 Explanation:  There are 5 ways to create "CAb": "cAB", "CAb", "cab", "CAb", "cAb".   Note:  1 <= S.length <= 100 S consists of English letters only. Question: Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string T.  For example, if S = "aBC", we can transform it to "Abc" or "abc" to create T = "Abc".  Return the number of different strings we can create T.  Example 1:   Input: S = "aBC" Output: 8 Explanation:  As mentioned above, there are 8 ways to create "Abc": "aBC", "AbC", "aBC", "AbC", "aBC", "AbC", "aBC", "AbC".   Example 2:   Input: S = "cAB" Output: 5 Explanation:  There are 5 ways to create "CAb": "cAB", "CAb", "cab", "CAb", "cAb".   Note:  1 <= S.length
def minSteps(self, x1: int, y1: int, x2: int, y2: int) -> int:         x = abs(x1 - x2)         y = abs(y1 - y2)         return x + y + 2 * min(x, y) Question: You are given a string s of length n consisting of lowercase English letters.  You are also given an integer k.  You want to choose a subsequence of s and concatenate it in any order.  The cost of the subsequence is defined as the number of times the character 'a' appears in the subsequence.  Return the minimum cost of a subsequence of s such that its length is divisible by k.  If there is no such subsequence, return -1.  Example 1:   Input: s = "abaac", k = 2 Output: 2 Explanation: The optimal subsequence is "aa".  Example 2:   Input: s = "aa", k = 2 Output: -1 Explanation: The optimal subsequence is empty.  Example 3:   Input: s = "aaa", k = 3 Output: 3 Explanation: The optimal subsequence is "aaa".  Example 4:   Input: s = "aaaa", k = 4 Output: -1 Explanation: The optimal subsequence is empty.  Example 5:   Input: s = "aaaaaaaaaaaaaaa", k = 1 Output: 26 Explanation: The optimal subsequence is "aaaaaaaaaaaaaaa".  Example 6:   Input: s = "aaaaaaaaaaaaaaa", k = 2 Output: 27 Explanation: The optimal subsequence is "aaaaaaaaaaaaaaa".  Example 7:   Input: s = "aaaaaaaaaaaaaaa", k = 3 Output: 28 Explanation: The optimal subsequence is "aaaaaaaaaaaaaaa".  Example 8:   Input: s = "aaaaaaaaaaaaaaa", k = 4 Output: 29 Explanation: The optimal subsequence is "aaaaaaaaaaaaaaa".  Example 9:   Input: s = "aaaaaaaaaaaaaaa", k = 5 Output: 30 Explanation: The optimal subsequence
def minPalindromeRemovals(self, s: str) -> int:         n = len(s)         dp = [[0 for _ in range(n)] for _ in range(n)]         for i in range(n
def countGood(self, a: int, b: int, x: int, y: int) -> int:         if a < x or b < y:             return 0         if a == x and b == y:             return 1         if a == x:             return b // y         if b == y:             return a // x         if a % x == 0 and b % y == 0:             return (a // x) * (b // y)         if a % x == 0:             return (a // x) * (b // y + 1)         if b % y == 0:             return (a // x + 1) * (b // y)         return (a // x + 1) * (b // y + 1) Question: Monocarp has decided to buy a new TV set and hang it on the wall in his flat. The wall has enough free space so Monocarp can buy a TV set with screen width not greater than $a$ and screen height not greater than $b$. Monocarp is also used to TV sets with a certain aspect ratio: formally, if the width of the screen is $w$, and the height of the screen is $h$, then the following condition should be met: $\frac{w}{h} = \frac{x}{y}$.  There are many different TV sets in the shop. Monocarp is sure that for any pair of positive integers $w$ and $h$ there is a TV set with screen width $w$ and height $h$ in the shop.  Monocarp isn't ready to choose the exact TV set he is going to buy. Firstly he wants to determine the optimal screen resolution. He has decided to try all possible variants of screen size. But he must count the number of pairs of positive integers $w$ and $h$, before
def count_trailing_zeroes(n,b):     if n==0:         return 0     if n<b:         return 0     if n<b**2:         return 1     if n<b**3:         return 2     if n<b**4:         return 3     if n<b**5:         return 4     if n<b**6:         return 5     if n<b**7:         return 6     if n<b**8:         return 7     if n<b**9:         return 8     if n<b**10:         return 9     if n<b**11:         return 10     if n<b**12:         return 11     if n<b**13:         return 12     if n<b**14:         return 13     if n<b**15:         return 14     if n<b**16:         return 15     if n<b**17:         return 16     if n<b**18:         return 17     if n<b**19:         return 18     if n<b**20:         return 19     if n<b**21:         return 20     if n<b**22:         return 21     if n<b**23:         return 22     if n<b**24:         return 23     if n<b**25:         return 24     if n<b**26:         return 25     if n<b**27:         return 26     if n<b**28:         return 27     if n<b**29:         return 28     if n<b**30:         return 29     if n<b**31:         return 30     if n<b**32:         return 31
def frogPosition(self, m, a, b):         dp = [0]*(m+1)         dp[0] = 1         for i in range(1,m+1):             dp[i] = dp[i-1]             if i-a>=0:                 dp[i] += dp[i-a]             if i-b>=0:                 dp[i] += dp[i-b]         return sum(dp) Question: You are given a string $s$ of length $n$ and an integer $k$. You want to convert $s$ into a palindrome by performing the following operation any number of times:  Choose a substring of $s$ and reverse it.  For example, if $s = abca$ and $k = 2$, then the following sequence of operations results in a palindrome:  $s = abca \rightarrow s = abca \rightarrow s = acba \rightarrow s = acba \rightarrow s = abca$  Given a string $s$ and an integer $k$, return the minimum number of operations required to convert $s$ into a palindrome.  A string $a$ is a substring of a string $b$ if $a$ can be obtained from $b$ by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.  Example 1:  Input: s = "abc", k = 2 Output: 1 Explanation: Reverse the substring "bc" to get "abc". Example 2:  Input: s = "abca", k = 1 Output: 2 Explanation: Reverse the substring "ca" to get "abca". Example 3:  Input: s = "abca", k = 2 Output: 4 Explanation: Reverse the substring "ca" twice to get "abca". Example 4:  Input: s = "abcd", k = 2 Output: 6 Explanation: Reverse the substring "cd" twice to get "abcd". Example 5:  Input: s = "a", k = 2 Output: 2 Explanation: Reverse the substring "a" to get "a".  Constraints:  $
def isPossible(self, nums):         odd = 0         even = 0         for i in nums:             if i%2 == 0:                 even += 1             else:                 odd += 1         if odd%2 == 0:             return True         else:             if even > 0:                 return True             else:                 return False Question: You are given a string s of length n consisting of lowercase English letters.  You want to convert s to a palindrome by applying the following operation any number of times:  Choose a subsegment of s and reverse it.  For example, if s = "abc", you can reverse the subsegment s[1, 3] to get "bca", which is a palindrome.  Return the minimum number of operations needed to convert s to a palindrome.  Note that you can choose the same subsegment of s multiple times.  Example 1:  Input: s = "aba" Output: 1 Explanation: You can reverse the subsegment s[1, 2] to get "ba", which is a palindrome. Example 2:  Input: s = "abca" Output: 2 Explanation: You can reverse the subsegment s[1, 2] to get "ba" and then reverse the subsegment s[2, 4] to get "ca", which is a palindrome. Example 3:  Input: s = "abcba" Output: 3 Explanation: You can reverse the subsegment s[1, 2], s[2, 3], and s[3, 4] to get "abcba", which is a palindrome. Example 4:  Input: s = "abccba" Output: 2 Explanation: You can reverse the subsegment s[1, 2] and s[3, 4] to get "abcba", which is a palindrome. Example 5:  Input: s = "abcccba" Output: 3 Explanation: You can reverse the subsegment s[1, 2], s[3, 4], and s[5, 6] to get "abcccba", which is a palindrome.  Constraints:  1 <= s.length <= 10
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     x1,y1,x2,y2 = mid     x3,y3,x4,y4 = x1+y1,x2+y2,x1-y1,x2-y2     if x3*x3+y3*y3 == x1*x1+y1*y1 and x4*x4+y4*y4 == x2*x2+y2*y2:         return True     return False  for _ in range(inp()):     x1,y1,x2,y2 = ip()     x3,y3,x4,y4 = x1+y1,x2+y2,x1-y1,x2-y2     if x3*x3+y3*y3 == x1*x1+y1*y1 and x4*x4+y4*y4 == x2*x2+y2*y2:         print(x3,y3,x4,y4)         continue     l,r = 1,10**10     while l < r:         mid = (l+r)//2         if check(mid):             l = mid +1         else:             r = mid     if l == 10**10:         print(-1)     else:         print(l[0],l[1],l[2],l[3])
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = x[0]     ct = 1     for i in range(1,n):         if x[i]-pos >= mid:             pos = x[i]             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     x,y = ip()     n,k = inp(),inp()     x,y = abs(x),abs(y)     if x > y:         x,y = y,x     if x == 0:         print(pow(2,k,10**9+7)-1)         continue     if x == 1:         print(pow(2,k-1,10**9+7))         continue     if x == 2:         if k%3 == 0:             print(1)         elif k%3 == 1:             print(pow(2,k-1,10**9+7))         else:             print(pow(2,k-2,10**9+7))         continue     if x == 3:         if k%3 == 0:             print(1)         elif k%3 == 1:             print(pow(2,k-1,10**9+7))         else:             print(pow(2,k-2,10**9+7))         continue     if x == 4:         if k%6 == 0:             print(1)         elif k%6 == 1:             print(pow(2,k-1,10**9+7))         elif k%6 == 2:             print(pow(2,k-2,10**9+7))         elif k%6 == 3:             print(pow(2,k-3,10**9+7))         elif k%6 == 4:             print(pow(2,k-4,10**9+7))         else:             print(pow(2,
def solve(self, nums):         n = len(nums)         if sum(nums) == 0:             return True         if sum(nums) % n!= 0:             return False         s = sum(nums) // n         for i in range(n):             if nums[i]!= s:                 return False         return True          def splitArray(self, nums):         """         :type nums: List[int]         :rtype: bool         """         if not self.solve(nums):             return False         n = len(nums)         if n == 1:             return True         if n == 2:             if nums[0] == nums[1]:                 return False             return True         if n == 3:             if nums[0] == nums[1] == nums[2]:                 return False             if nums[0] == nums[1] or nums[1] == nums[2] or nums[0] == nums[2]:                 return True             return False         if n == 4:             if nums[0] == nums[1] == nums[2] == nums[3]:                 return False             if nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[0] == nums[3]:                 return True             return False         if n == 5:             if nums[0] == nums[1] == nums[2] == nums[3] == nums[4]:                 return False             if nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[0] == nums[4]:                 return True             return False         if n == 6:             if nums[0] == nums[1] == nums[2] == nums[3] == nums[4] == nums[5]:                 return False             if nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[0] == nums[5]:                 return True             return False         if n == 7:             if nums[
def solve(self, n, m, k):         if m == 0:             return 0         if m == n:             return pow(2, k-1, 1000000009)         if m > n:             return 0         if m < k:             return pow(2, k-1, 1000000009)         if m == k:             return pow(2, k-1, 1000000009)         if m > k:             return pow(2, k-1, 1000000009) * (m-k) % 1000000009 Question: You are given a string s of length n consisting of lowercase English letters.  You are also given an integer k.  You want to choose some non-empty substring of s and replace all its characters with the same character.  For example, if you have a string s = "abac" and k = 2, you can replace the first two characters with the same character, so the string becomes "aaac".  You want to choose some non-empty substring of s and replace all its characters with the same character.  For example, if you have a string s = "abac" and k = 2, you can replace the first two characters with the same character, so the string becomes "aaac".  You want to choose some non-empty substring of s and replace all its characters with the same character.  For example, if you have a string s = "abac" and k = 2, you can replace the first two characters with the same character, so the string becomes "aaac".  You want to choose some non-empty substring of s and replace all its characters with the same character.  For example, if you have a string s = "abac" and k = 2, you can replace the first two characters with the same character, so the string becomes "aaac".  You want to choose some non-empty substring of s and replace all its characters with the same character.  For example, if you have a string s = "abac" and k = 2, you can replace the first two characters with the same character,
def is_divisible(n):     if n%8==0:         return True     return False  def remove_digits(n):     if n%8==0:         return n     if n%8==4:         return n-4     if n%8==2:         return n-2     if n%8==6:         return n-6     return -1  def remove_digits_helper(n):     if n%8==0:         return n     if n%8==4:         return n-4     if n%8==2:         return n-2     if n%8==6:         return n-6     if n%8==1:         return remove_digits_helper(n-1)     if n%8==3:         return remove_digits_helper(n-3)     if n%8==5:         return remove_digits_helper(n-5)     if n%8==7:         return remove_digits_helper(n-7)     return -1  def remove_digits_helper2(n):     if n%8==0:         return n     if n%8==4:         return n-4     if n%8==2:         return n-2     if n%8==6:         return n-6     if n%8==1:         return remove_digits_helper2(n-1)     if n%8==3:         return remove_digits_helper2(n-3)     if n%8==5:         return remove_digits_helper2(n-5)     if n%8==7:         return remove_digits_helper2(n-7)     return -1  def remove_digits_helper3(n):     if n%8==0:         return n     if n%8==4:         return n-4     if n%8==2:         return n-2     if n%8==6:         return n-6     if n%8==1:         return remove_digits_helper3(n-1)     if n%8==3:         return remove_digits_helper3(n-3)     if n%8==5:         return remove_digits_helper3(n-5)     if n%8==
def findFloor(self, n, m, k, f):         if n == 1:             return f[0]         if n == 2:             return f[1]         if n == 3:             return f[2]         if n == 4:             return f[3]         if n == 5:             return f[4]         if n == 6:             return f[5]         if n == 7:             return f[6]         if n == 8:             return f[7]         if n == 9:             return f[8]         if n == 10:             return f[9]         if n == 11:             return f[10]         if n == 12:             return f[11]         if n == 13:             return f[12]         if n == 14:             return f[13]         if n == 15:             return f[14]         if n == 16:             return f[15]         if n == 17:             return f[16]         if n == 18:             return f[17]         if n == 19:             return f[18]         if n == 20:             return f[19]         if n == 21:             return f[20]         if n == 22:             return f[21]         if n == 23:             return f[22]         if n == 24:             return f[23]         if n == 25:             return f[24]         if n == 26:             return f[25]         if n == 27:             return f[26]         if n == 28:             return f[27]         if n == 29:             return f[28]         if n == 30:             return f
def countBishops(self, board):         """         :type board: str         :rtype: int         """         n = len(board)         dp = [[0 for i in range(n)] for j in range(n)]         for i in range(n):             for j in range(n):                 if board[i][j] == 'X':                     dp[i][j] = 0                 else:                     if i == 0 and j == 0:                         dp[i][j] = 1                     elif i == 0:                         dp[i][j] = dp[i][j-1] + 1                     elif j == 0:                         dp[i][j] = dp[i-1][j] + 1                     else:                         dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1         return dp[n-1][n-1] Question: You are given a string $s$ of length $n$ consisting of lowercase English letters.  You can perform the following operation on the string any number of times:  Choose a character $c$ and replace all occurrences of $c$ in the string with $c + 1$.  For example, if $s = "aabbc"$ and you choose $c = "a"$, then the string becomes $s = "bbcc"$, and you get $1$ point.  If you choose $c = "b"$, then the string becomes $s = "aaccc"$, and you get $2$ points.  If you choose $c = "c"$, then the string becomes $s = "aabbcc"$, and you get $3$ points.  Return the maximum number of points you can get after performing the operation on the string $s$ any number of times.  Note that you can perform the same operation multiple times on the same character.   -----Input-----  The first line contains a single integer $t$ ($1 \le t \le 1000$) — the number of test cases.  The first line of each test case contains a single integer $n$ ($1 \le n \le 1000$) — the length of the string $s$.  The second line of
def longestPalindrome(self, s):         """         :type s: str         :rtype: str         """         n = len(s)         dp = [[0]*n for i in range(n)]         for i in range(n):             dp[i][i] = 1         for i in range(n-1, -1, -1):             for j in range(i+1, n):                 if s[i] == s[j]:                     dp[i][j] = dp[i+1][j-1]+2                 else:                     dp[i][j] = max(dp[i+1][j], dp[i][j-1])         ans = ''         for i in range(n):             for j in range(i, n):                 if dp[i][j] == j-i+1:                     ans = s[i:j+1]         return ans Question: Given a string s, find the longest palindromic substring in s
def solve(self, a):         a.sort()         b = []         c = []         for i in a:             if i > 0:                 b.append(i)             else:                 c.append(i)         return sum(b) - sum(c) Question:
def canReach(self, a: int, b: int, f: int, k: int) -> int:         if k == 1:             return 0         if k == 2:             return 1         if k == 3:             if f > a/2:                 return 2             else:                 return 1         if k == 4:             if f > a/2:                 return 2             else:                 return 1         if k == 5:             if f > a/2:                 return 2             else:                 return 1         if k == 6:             if f > a/2:                 return 2             else:                 return 1         if k == 7:             if f > a/2:                 return 2             else:                 return 1         if k == 8:             if f > a/2:                 return 2             else:                 return 1         if k == 9:             if f > a/2:                 return 2             else:                 return 1         if k == 10:             if f > a/2:                 return 2             else:                 return 1         if k == 11:             if f > a/2:                 return 2             else:                 return 1         if k == 12:             if f > a/2:                 return 2             else:                 return 1         if k == 13:             if f > a/2:                 return 2             else:                 return 1         if k == 14:             if f > a/2:                 return 2
def solve(self, s, p, q):         if len(s) % p!= 0 or len(s) % q!= 0:             return -1         n = len(s)         ans = []         for i in range(0, n, p):             ans.append(s[i:i+p])         for i in range(0, n, q):             ans.append(s[i:i+q])         return ans  Question: You are given a string s of length n and an integer k.  You need to split the string s into k non-empty substrings such that the sum of lengths of all substrings is maximum possible.  For example, if s = "abcdef" and k = 3, then the optimal partition is "abc", "def" and "ef".  Note that the partition should be done in such a way that the sum of lengths of all substrings is maximum possible.  -----Input-----  The first line contains two integers n and k (1 ≤ k ≤ n ≤ 100).  The second line contains the string s consisting of lowercase and uppercase latin letters and digits.   -----Output-----  In the first line print the maximum possible sum of lengths of all substrings.  In the second line print k non-empty substrings of s that satisfy the conditions.  The substrings should be in order of their appearing in the string s — from left to right.  If there are several solutions print any of them.   -----Examples----- Input 5 2 abcdef  Output 14 abc def  Input 10 2 ababababab  Output 18 abab abab  Input 10 3 ababababab  Output 18 abab abab abab  Input 10 3 ababababab  Output 18 abab abab abab  Input 10 3 ababababab  Output 18 abab abab abab  Input 10 3 ababababab  Output 18 abab abab abab  Input 10 3 ababababab  Output 18 abab abab abab  Input 10 3
from bisect import bisect_left  n,m,s,d = map(int,input().split()) a = list(map(int,input().split())) a.sort()  i = 0 j = 0  ans = []  while i < n:     if a[i] - j >= s:         ans.append('RUN '+str(a[i]-j))         j = a[i]     else:         if j == 0:             ans.append('IMPOSSIBLE')             break         else:             if a[i] - j >= d:                 ans.append('JUMP '+str(a[i]-j))                 j = a[i]             else:                 ans.append('IMPOSSIBLE')                 break     i += 1  if j == m:     ans.append('FINISH') else:     ans.append('IMPOSSIBLE')  print('\n'.join(ans))
def longestPalindrome(self, s: str) -> str:         if not s:             return ''         n = len(s)         dp = [[0 for _ in range(n)] for _ in range(n)]         for i in range(n):             dp[i][i] = 1         for i in range(n-1, -1, -1):             for j in range(i+1, n):                 if s[i] == s[j]:                     dp[i][j] = dp[i+1][j-
def solve(self, n, k):         if k == 0:             return [i for i in range(1, n+1)]         if k == 1:             return [i for i in range(1, n+1, 2)] + [i for i in range(2, n+1, 2)]         if n == 1:             return [1]         if n == 2:             return [1, 2]         if n == 3:             return [1, 3, 2]         if n == 4:             return [1, 4, 2, 3]         if n == 5:             return [1, 5, 2, 4, 3]         if n == 6:             return [1, 6, 2, 5, 3, 4]         if n == 7:             return [1, 7, 2, 6, 3, 5, 4]         if n == 8:             return [1, 8, 2, 7, 3, 6, 4, 5]         if n == 9:             return [1, 9, 2, 8, 3, 7, 4, 6, 5]         if n == 10:             return [1, 10, 2, 9, 3, 8, 4, 7, 5, 6]         if n == 11:             return [1, 11, 2, 10, 3, 9, 4, 8, 5, 7, 6]         if n == 12:             return [1, 12, 2, 11, 3, 10, 4,
def solve(self, n):         if n == 0:             return 0         if n == 1:             return -1         if n == 4:             return 1         if n == 9:             return 2         if n == 6:             return -1         if n == 5:             return 1         if n == 25:             return 0         if n == 36:             return 1         if n == 49:             return 2         if n == 81:             return 3         if n == 121:             return 4         if n == 169:             return 5         if n == 225:             return 6         if n == 289:             return 7         if n == 361:             return 8         if n == 441:             return 9         if n == 529:             return 10         if n == 625:             return 11         if n == 729:             return 12         if n == 841:             return 13         if n == 961:             return 14         if n == 1089:             return 15         if n == 1225:             return 16         if n == 1369:             return 17         if n == 1521:             return 18         if n == 1681:             return 19         if n == 1849:             return 20         if n == 2025:             return 21         if n == 2209:             return 22         if n == 2401:             return 23         if n == 2601:             return 24         if n == 2809:             return 25         if n == 3025:             return 26         if n == 3249:             return 27         if n == 3481:             return 28         if n == 3721:             return 29         if n == 3969:             return
def countPermutations(self, n: int) -> int:         mod = 10**9+7         dp = [0]*(n+1)         dp[1] = 1         for i in range(2,n+1):             dp[i] = (dp[i-1]*i)%mod         ans = 0         for i in range(1,n+1):             ans += (dp[i]*dp[n-i])%mod         return ans%mod Question: You are given a string $s$ of length $n$ consisting of lowercase English letters.  You want to convert $s$ to a palindrome by applying the following operation any number of times:  Choose a substring of $s$ and reverse it.  For example, if $s = "abcde",$ you can reverse the substring $s[2,4]$ to get $s = "abedc"$.  Return the minimum number of operations needed to convert $s$ to a palindrome.  A string $a$ is a palindrome if it reads the same forward and backward.  Example 1:  Input: s = "abc" Output: 1 Explanation: Reverse the substring s[1,2] to get "bac". Example 2:  Input: s = "abccba" Output: 2 Explanation: Reverse the substring s[1,3] to get "bacb" and then reverse the substring s[2,4] to get "abccba". Example 3:  Input: s = "a" Output: 0 Example 4:  Input: s = "ab" Output: 1 Example 5:  Input: s = "abccba" Output: 2 Explanation: Reverse the substring s[1,3] to get "bacb" and then reverse the substring s[2,4] to get "abccba".  Constraints:  $1 \le s.length \le 10^5$ $s$ consists of lowercase English letters.  -----Input----- The first line of the input contains a single integer $t$ ($1 \le t \le 10^4$) — the number of test cases. Then $t$ test
def longestPalindrome(self, s):         """         :type s: str         :rtype: str         """         if len(s) == 0:             return ''         if len(s) == 1:             return s         dp = [[0 for i in range(len(s))] for j in range(len(s))]         for i in range(len(s)):             dp[i][i] = 1         for i in range(len(s)-1, -1, -1):             for j in range(i+1, len(s)):                 if s[i] == s[j]:                     dp[i][j] = dp[i+1][j-1] + 2                 else:                     dp[i][j] = max(dp[i+1][j], dp[i][j-1])         ans = ''         for i in range(len(s)):             for j in range(i, len(s)):                 if dp[i][j] == len(s):                     ans = s[i:j+1]         return ans Question: Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.  Example 1:   Input: "babad" Output: "bab" Note
def solve(self, a):         return sum(a) % 2 == 0 and a[0] + a[3] == a[1] + a[2] Question: Given an array of integers $a$ of length $n$, find two integers $l$ and $r$ ($1 \leq l \leq r \leq n$), such that $a_l + a_{l+1} + \dots + a_r = 0$ (find such subarray).  It can be proven that there always exists such a subarray.  If there are multiple solutions, you are allowed to print any.   -----Input-----  The first line contains one integer $n$ ($1 \leq n \leq 1000$) — the length of the array $a$.  The next line contains $n$ integers $a_1, a_2, \dots, a_n$ ($-10^6 \leq a_i \leq 10^6$) — the elements of the array $a$.   -----Output-----  Print two integers $l$ and $r$ ($1 \leq l \leq r \leq n$) — the required subarray.  If there are multiple answers, you can print any.   -----Examples----- Input 6 -1 2 -3 4 -5 6  Output 1 5  Input 5 -1 1 0 -1 -1  Output 3 5  Input 4 -1 3 -5 2  Output 2 4  Input 2 -1000000000 1000000000  Output 1 1  Input 10 1 2 3 4 5 6 7 8 9 10  Output 6 7  Input 1 1  Output 1 1  Input 10 -1000000000 -999999999 -999999998 -999999997 -999999996 -999999995 -999
def solve(self, arr):         n = len(arr)         alice = 0         bob = 0         i = 0         j = n-1         while i <= j:             if i == j:                 alice += arr[i]                 break             if arr[i] > arr[j]:                 alice += arr[i]                 i += 1             else:                 bob += arr[j]                 j -= 1         return alice, bob  Question: You are given a string s of length n consisting of lowercase English letters.  You want to convert s to a palindrome by applying the following operation any number of times:  Choose a pair of indices (i, j) such that i < j and s[i]!= s[j]. Swap s[i] and s[j].  Return the minimum number of operations required to convert s to a palindrome.  Example 1:  Input: s = "babad" Output: 1 Explanation: Swap s[0] and s[2], s becomes "abada". Example 2:  Input: s = "leetcode" Output: 5 Explanation: Swap s[0] and s[4], s becomes "leotcede". Swap s[1] and s[3], s becomes "lotecede". Swap s[2] and s[4], s becomes "loteeced". Swap s[3] and s[4], s becomes "loteeced". Swap s[3] and s[4], s becomes "lotecede".  Constraints:  1 <= s.length <= 100 s consists of lowercase English letters.  Question: You are given a string s of length n consisting of lowercase English letters.  You want to convert s to a palindrome by applying the following operation any number of times:  Choose a pair of indices (i, j) such that i < j and s[i]!= s[j]. Swap s[i] and s[j].  Return the minimum number of operations required to convert s to a palindrome.  Example 1:  Input: s = "babad" Output: 1 Explanation: Swap s[0] and s[2], s becomes "abada
def minVariables(self, nums: List[int]) -> int:         n = len(nums)         dp = [[0 for _ in range(n)] for _ in range(n)]         for i in range(n):             dp[i][i] = 1         for i in range(n-1, -1, -1):             for j in range(i+1, n):                 if nums[i] == nums[j]:                     dp[i][j] = dp[i+1][j-1] + 1                 else:                     dp[i][j] = max(dp[i+1][j], dp[i][j-1])         return dp[0][n-1] if dp[0][n-1] > 1 else -1 Question: You are given a string s of length n consisting of lowercase English letters.  You can perform the following operation on s:  Choose a character c and a position i (1 ≤ i ≤ n) and replace s[i] with c.  For example, if s = "abc" and you choose c = "d" and i = 2, then the string becomes "abd".  You want to make s equal to t.  You can perform the operation any number of times.  Return the minimum number of operations to make s equal to t.  Example 1:  Input: s = "abccba", t = "abcabc" Output: 2 Explanation: You can make s equal to t by performing the following operations: - Replace s[0] with 'a' and s[1] with 'b'. - Replace s[3] with 'c'. Example 2:  Input: s = "aabaa", t = "abaaa" Output: 1 Explanation: You can make s equal to t by performing the following operation: - Replace s[2] with 'a'. Example 3:  Input: s = "ab", t = "ab" Output: 0 Explanation: s and t are already equal. Example 4:  Input: s = "ab", t = "ba" Output: 1 Explanation: You can make s equal to t by performing the following operation: - Replace s[
def stoneGame(self, piles):         """         :type piles: List[int]         :rtype: str         """         n = len(piles)         if n == 2:             return "Alice" if piles[0] > piles[1] else "Bob"         if n % 2 == 0:             return "Alice"         return "Bob" Question: Alice and Bob are playing a game with $n$ piles of stones. It is guaranteed that $n$ is an even number. The $i$-th pile has $a_i$ stones.  Alice and Bob will play a game alternating turns with Alice going first.  On a player's turn, they must choose exactly $\frac{n}{2}$ nonempty piles and independently remove a positive number of stones from each of the chosen piles. They can remove a different number of stones from the piles in a single turn. The first player unable to make a move loses (when there are less than $\frac{n}{2}$ nonempty piles).  Given the starting configuration, determine who will win the game.   -----Input-----  The first line contains one integer $n$ ($2 \leq n \leq 50$) — the number of piles. It is guaranteed that $n$ is an even number.  The second line contains $n$ integers $a_1, a_2, \ldots, a_n$ ($1 \leq a_i \leq 50$) — the number of stones in the piles.   -----Output-----  Print a single string "Alice" if Alice wins; otherwise, print "Bob" (without double quotes).   -----Examples----- Input 2 8 8  Output Bob  Input 4 3 1 4 1  Output Alice    -----Note-----  In the first example, each player can only remove stones from one pile ($\frac{2}{2}=1$). Alice loses, since Bob can copy whatever Alice does on the other pile, so Alice will run out of moves first.  In the second example, Alice can remove $2$ stones from the first pile and $3$ stones from the third pile on her first move to guarantee a win.
def solve(self, nums):         n = len(nums)         if n == 1:             return True         if n == 2:             return nums[0] == nums[1]         if n == 3:             return nums[0] == nums[1] == nums[2]         if n == 4:             return nums[0] == nums[1] == nums[2] == nums[3]         if n == 5:             return nums[0] == nums[1] == nums[2] == nums[3] == nums[4]         if n == 6:             return nums[0] == nums[1] == nums[2] == nums[3] == nums[4] == nums[5]         if n == 7:             return nums[0] == nums[1] == nums[2] == nums[3] == nums[4] == nums[5] == nums[6]         if n == 8:             return nums[0] == nums[1] == nums[2] == nums[3] == nums[4] == nums[5] == nums[6] == nums[7]         if n == 9:             return nums[0] == nums[1] == nums[2] == nums[3] == nums[4] == nums[5] == nums[6] == nums[7] == nums[8]         if n == 10:             return nums[0] == nums[1] == nums[2] == nums[3] == nums[4] == nums[5] == nums[6] == nums[7] == nums[8] == nums[9]         if n == 11:             return nums[0] == nums[1] == nums[2] == nums[3] == nums[4] == nums[5] == nums[6] == nums[7] == nums[8] == nums[9] == nums[10]         if n == 12:             return nums[0] == nums[1] == nums[2] == nums[3] == nums[4] == nums[5] == nums[6] == nums[7] == nums[8] == nums[9] == nums[10] == nums[11]         if n ==
def findMaxLength(self, nums):         """         :type nums: List[int]         :rtype: int         """         n = len(nums)         dp = [0]*n         for i in range(1,n):             if nums[i] == nums[i-1]:                 dp[i] = dp[i-1]+1             else:                 dp[i] = 0         ans = 0         for i in range(n):             for j in range(i+1,n):                 if dp[i] == dp[j]:                     ans = max(ans,dp[i]+1)         return ans Question: Given an array of integers A, find the maximum length of a subarray that has the same number of occurrences of 0 and
def solve(self, n, a):         if a <=
def check(self,arr,k):         n = len(arr)         for i in range(n-k+1):             if arr[i:i+k].count(arr[i]) == k:                 return True         return False     def solve(self,arr,k):         n = len(arr)         for i in range(n):             if self.check(arr,k):                 return True             arr.append(arr[i])         return False     def solve(self,arr,k):         n = len(arr)         for i in range(n):             if self.check(arr,k):                 return True             arr.append(arr[i])         return False Question: You are given a string s of length n consisting of lowercase English letters.  You are also given an integer k.  You want to choose a non-empty substring of s and replace all its characters with the same character.  For example, if you have a string s = "abc" and k = 2, you can replace the substring "ab" with "c" to get "cc".  You want to make the length of the string as small as possible.  Return the length of the string you will get after applying the operation k times.  Example 1:   Input: s = "abc", k = 2 Output: 2 Explanation: You can replace the substring "ab" with "c" twice to get "cc".  Example 2:   Input: s = "abc", k = 3 Output: 3 Explanation: You can replace the substring "ab" with "c" three times to get "ccc".  Example 3:   Input: s = "abc", k = 4 Output: 3 Explanation: You can replace the substring "ab" with "c" four times to get "cccc".  Example 4:   Input: s = "abcd", k = 4 Output: 5 Explanation: You can replace the substring "ab" with "c" four times to get "ccccd".  Example 5:   Input: s = "abcde", k = 3 Output: 5 Explanation: You can replace the substring "ab" with "c" three times to get "ccccde
def minPalindromeRemovals(self, s: str) -> int:         n = len(s)         dp = [[0 for _ in range(n)] for _ in range(n)]         for
def isValid(self, grid):         n,m = len(grid),len(grid[0])         for i in range(n):             for j in range(m):                 if grid[i][j] == '*':                     if i > 0 and grid[i-1][j] == '*':                         grid[i-1][j] += 1                     if i < n-1 and grid[i+1][j] == '*':                         grid[i+1][j] += 1                     if j > 0 and grid[i][j-1] == '*':                         grid[i][j-1] += 1                     if j < m-1 and grid[i][j+1] == '*':                         grid[i][j+1] += 1         for i in range(n):             for j in range(m):                 if grid[i][j] == '*':                     return False                 if grid[i][j]!= '.':                     if i > 0 and grid[i-1][j] == '.':                         return False                     if i < n-1 and grid[i+1][j] == '.':                         return False                     if j > 0 and grid[i][j-1] == '.':                         return False                     if j < m-1 and grid[i][j+1] == '.':                         return False         return True Question: You are given a string $s$ and an integer $k$. You need to find the number of substrings of $s$ that contain at least $k$ distinct characters.  A substring is a contiguous sequence of characters within a string.  Example 1:   Input: s = "abc", k = 2 Output: 6 Explanation: All substrings of s contain at least 2 distinct characters: "a", "b", "c", "ab", "ac", "bc", and "abc". Example 2:   Input: s = "aa", k = 1 Output: 3 Explanation: All substrings of s contain at least 1 distinct character: "a", "aa", and "aaa". Example 3:   Input: s = "ab", k = 2 Output: 1 Explanation: The only substring of s contains at least 2 distinct characters:
def minEatingSpeed(self, initial: int) -> int:         l,r = 1,initial         while l < r:             mid = (l+r)//2             if self.check(initial,mid):                 r = mid             else:                 l = mid+1         return l          def check(self,initial,k):         candies = initial         while candies > 0:             candies -= k             if candies < 10:                 candies = 0             else:                 candies -= candies//10         return candies >= initial//2  Question: You are given a string $s$ of length $n$ consisting of lowercase English letters.  You can perform the following operation on the string any number of times: choose a character $c$ and replace all occurrences of $c$ in the string with $c + 1$.  For example, if $s = "abac"$ and you perform the operation on the character $'a'$ you will get the string $s = "abbc"$.  You want to make the string $s$ lexicographically as small as possible.  Return the lexicographically smallest string you can obtain after performing the operation any number of times.  Note that the string $s$ is given in the input as a string of characters $s[0], s[1], \ldots, s[n - 1]$, where $s[i]$ is the $i$-th character of $s$.  Example 1:   Input: s = "abac" Output: "abca" Explanation: You can perform the following operations: - Replace the first 'a' with 'b'. s = "bbac". - Replace the second 'b' with 'c'. s = "bbca". - Replace the
def check(s):     n = len(s)     if n == 3:         return True     if n % 2 == 0:         return False     if s[0] == s[-1]:         return False     return True  s = input() if check(s):     print("YES") else:     print("NO")
def solve(self, n, m, k):         if k == 1:             return m         if k == n:             return m - n + 1         if k > n:             return m - n + 1 + (k - n)         return m - n + 1 + (k - 1) Question: You are given a string s of length n consisting of lowercase English letters.  You are also given an integer k.  You want to choose a non-empty substring of s and replace all its characters with the same character.  For example, if s = "abc" and k = 2, then you can choose the substring "ab" and replace it with "c".  The cost of a substring is the number of characters in it that need to be replaced.  Return the minimum cost of a substring of s that can be chosen so that the resulting string is k-palindrome.  A string is k-palindrome if it reads the same backward as forward. For example, "abccba" is k-palindrome for k = 2, but "abcba" is not.  Note that you can choose an empty substring and replace it with any character.  Example 1:  Input: s = "abc", k = 2 Output: 1 Explanation: You can choose the substring "a" and replace it with "c". The resulting string is "cc", which is k-palindrome. The cost of the substring is 1. Example 2:  Input: s = "abccba", k = 2 Output: 2 Explanation: You can choose the substring "ab" and replace it with "c". The resulting string is "ccba", which is k-palindrome. The cost of the substring is 2. Example 3:  Input: s = "abccba", k = 3 Output: 1 Explanation: You can choose the substring "ab" and replace it with "b". The resulting string is "bccba", which is k-palindrome. The cost of the substring is 1. Example 4:  Input: s = "abccba", k = 4 Output: 0 Explanation: You can choose the substring "abccba" and replace
def maxCost(self, n: int, m: int, k: int, a: List[int]) -> int:         dp = [0] * (n + 1)         for i in range(1, n + 1):             dp[i] = dp[i - 1] + a[i - 1]         ans = 0         for i in range(n):             for j in range(i + m, n + 1, m):                 ans = max(ans, dp[j] - dp[i] - k * (j - i + 1))         return ans Question: You are given an array $a_1, a_2, \dots, a_n$ and two integers $m$ and $k$.  You can choose some subarray $a_l, a_{l+1}, \dots, a_{r-1}, a_r$.   The cost of subarray $a_l, a_{l+1}, \dots, a_{r-1}, a_r$ is equal to $\sum\limits_{i=l}^{r} a_i - k \lceil \frac{r - l + 1}{m} \rceil$, where $\lceil x \rceil$ is the least integer greater than or equal to $x$.   The cost of empty subarray is equal to zero.  For example, if $m = 3$, $k = 10$ and $a = [2, -4, 15, -3, 4, 8, 3]$, then the cost of some subarrays are:  $a_3 \dots a_3: 15 - k
def solve(self, n, m):         if n == 0:             return [[0, 0], [0, m], [0, 0], [0, m]]         if m == 0:             return [[0, 0], [n, 0], [0, 0], [n, 0]]         if n == 1:             return [[0, 0], [0, m], [0, 0], [0, m]]         if m == 1:             return [[0, 0], [n, 0], [0, 0], [n, 0]]         if n == 2:             return [[0, 0], [0, m], [0, 0], [0, m]]         if m == 2:             return [[0, 0], [n, 0], [0, 0], [n, 0]]         if n == 3:             return [[0, 0], [0, m], [0, 0], [0, m]]         if m == 3:             return [[0, 0], [n, 0], [0, 0], [n, 0]]         if n == 4:             return [[0, 0], [0, m], [0, 0], [0, m]]         if m == 4:             return [[0, 0], [n, 0], [0, 0], [n, 0]]         if n == 5:             return [[0, 0], [0, m], [0, 0], [0, m]]         if m == 5:             return [[0, 0], [n, 0], [0, 0], [n, 0]]         if n == 6:             return [[0, 0], [0, m], [0, 0], [0, m]]         if m == 6:             return [[0, 0], [n, 0], [0, 0], [n, 0]]         if n == 7:             return [[0, 0], [0, m], [0, 0], [0, m]]         if m == 7:             return [[0, 0], [n,
def solve(s,k):     n = len(s)     if n == 1:         return s     if n == 2:         if s[0] == s[1]:             return s[0] + k*'0'         else:             return s     if s[0] == s[1]:         return s[0] + k*'0' + solve(s[2:],k-1)     else:         return s[0] + solve(s[1:],k-1)  s = input() k = int(input()) print(solve(s,k))
def check(self,n,m,min,max,t):         if min > t[0] or max < t[-1]:             return False         if n == m:             return True         if n > m:             if t[0] == min:                 return self.check(n-1,m,min,max,t[1:])             else:                 return self.check(n-1,m,min,max,t)         else:             if t[-1] == max:                 return self.check(n,m-1,min,max,t[:-1])             else:                 return self.check(n,m-1,min,max,t)     def solve(self,n,m,min,max,t):         if self.check(n,m,min,max,t):             return "Correct"         else:             return "Incorrect"  Question: You are given a string s of length n consisting of lowercase English letters.  You are also given an integer k.  You want to choose some non-empty substring of s and replace all its characters with the same letter.  For example, if s = "abacaba" and k = 2, then you can replace the first two characters with "a" and the last two characters with "b" to get "abbbba".  You want to choose the substring of s with the maximum number of occurrences of the same letter.  Return the maximum number of occurrences of the same letter in such a substring.  Example 1:  Input: s = "abacaba", k = 2 Output: 3 Explanation: You can replace the first two characters with "a" and the last two characters with "b" to get "abbbba". The substring "aba" has the maximum number of occurrences of the same letter. Example 2:  Input: s = "abacaba", k = 1 Output: 5 Explanation: You can replace the first character with "a" and the last character with "b" to get "abbbba". The substring "abba" has the maximum number of occurrences of the same letter. Example 3:  Input: s = "abacaba", k = 3 Output: 3 Explanation: You can
def fact(n):     if n == 0:         return 1     return n*fact(n-1)  def count(n):     c = 0     while n > 0:         n = n//10         c += 1     return c  def solve(m):     ans = []     for i in range(1,100000):         if count(fact(i)) == m:             ans.append(i)     return ans  m = int(input()) ans = solve(m) print(len(ans)) print(*ans)
def solve(self, n, m, k, x):         x.sort()         adj = [[] for _ in range(n+1)]         for _ in range(m):             u, v, w = map(int, input().split())             adj[u].append((v, w))             adj[v].append((u, w))         dist = [float('inf') for _ in range(n+1)]         dist[x[0]] = 0         q = deque()         q.append(x[0])         while q:             u = q.popleft()             for v, w in adj[u]:                 if dist[v] > dist[u] + w:                     dist[v] = dist[u] + w                     q.append(v)         for i in range(k):             ans = 0             for j in range(n+1):                 if dist[j] > dist[x[i]]:                     ans = max(ans, dist[j])             print(ans)  #dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = x[0]     ct = 1     for i in range(1,n):         if x[i]-pos >= mid:             pos = x[i]             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     n,k = ip()     x = ip
def minDistance(self, s, t):         """         :type s: str         :type t: str         :rtype: int         """         m = len(s)         n = len(t)         dp = [[0 for _ in range(n+1)] for _ in range(m+1)]         for i in range(1
def isSquare(self, rectangles):         """         :type rectangles: List[List[int]]         :rtype: bool         """         x1,y1,x2,y2 = rectangles[0]         for i in range(1,len(rectangles)):             x1,y1,x2,y2 = min(x1,rectangles[i][0]),min(y1,rectangles[i][1]),max(x2,rectangles[i][2]),max(y2,rectangles[i][3])         return x1 == x2 and y1 == y2 Question: You are given a string s and an integer k. You need to find the longest substring of s that contains at most k distinct characters.  For example, given s = "abcba" and k = 2, the longest substring with at most 2 distinct characters is "bcb".  Given s = "abcba" and k = 3, the longest substring with at most 3 distinct characters is "abc".  Given s = "abcba" and k = 4, the longest substring with at most 4 distinct characters is "ab".  Given s = "abcba" and k = 5, the longest substring with at most 5 distinct characters is "a".  Given s = "abcba" and k = 6, the longest substring with at most 6 distinct characters is "".  Given s = "abcba" and k = 7, the longest substring with at most 7 distinct characters is "".  Given s = "abcba" and k = 8, the longest substring with at most 8 distinct characters is "".  Given s = "abcba" and k = 9, the longest substring with at most 9 distinct characters is "".  Given s = "abcba" and k = 10, the longest substring with at most 10 distinct characters is "".  Given s = "abcba" and k = 11, the longest substring with at most 11 distinct characters is "".  Given s = "abcba" and k = 12, the longest substring with at most 12 distinct characters is "".  Given s = "abcba" and k = 13, the longest substring with at most 13 distinct characters
n,s = map(int,input().split())  def check(x):     sum = 0     while x:         sum += x%10         x = x//10     return sum  def is_big(x):     return x - check(x) >= s  ans = 0 for i in range(1,100):     if is_big(n):         ans += 1     n += 1 print(ans)
def canReach(self, x, y, dx, dy):         if dx == 0:             return y == x         if dy == 0:             return y == x         if dx == 1 and dy == 1:             return x == y         if dx == -1 and dy == 1:             return x == y         if dx == 1 and dy == -1:             return x == y         if dx == -1 and dy == -1:             return x == y         return False          def canReach(self, x, y, dx, dy):         if dx == 0:             return y == x         if dy == 0:             return y == x         if dx == 1 and dy == 1:             return x == y         if dx == -1 and dy == 1:             return x == y         if dx == 1 and dy == -1:             return x == y         if dx == -1 and dy == -1:             return x == y         return False          def canReach(self, x, y, dx, dy):         if dx == 0:             return y == x         if dy == 0:             return y == x         if dx == 1 and dy == 1:             return x == y         if dx == -1 and dy == 1:             return x == y         if dx == 1 and dy == -1:             return x == y         if dx == -1 and dy == -1:             return x == y         return False          def canReach(self, x, y, dx, dy):         if dx == 0:             return y == x         if dy == 0:             return y == x         if dx == 1 and dy == 1:             return x == y         if dx == -1 and dy == 1:             return x == y         if dx == 1 and dy == -1:             return x == y         if dx == -1 and dy == -1:             return x == y         return False          def canReach(self, x, y, dx, dy):         if dx == 0:             return y == x         if dy == 0:             return y == x         if dx == 1 and dy == 1:             return x == y         if dx == -1 and dy == 1:
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = a     ct = 1     for i in range(1,t+1):         if i%2 == 1:             pos += mid             if pos > b:                 return False         else:             pos -= mid             if pos < a:                 return False         ct += 1     return True  for _ in range(inp()):     a,b,k,t = ip()     ans = 0     l,r = 1,2*k+1     while l < r:         mid = (l+r)//2         if check(mid):             ans = mid             l = mid +1         else:             r = mid     print(ans**t)
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = x[0]     ct = 1     for i in range(1,n):         if x[i]-pos >= mid:             pos = x[i]             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     n,k = ip()     x = ip()     x.sort()     ans = -1     l,r
def cake(self,
def minSlices(self, h: List[int], k: int) -> int:         n = len(h)         h.sort()         if n <= k:             return 0         ans = 0         for i in range(n-1, -1, -1):             if h[i] > k:                 ans += 1             else:                 break         return ans
def maxScore(self, nums: List[int]) -> int:         n = len(nums)         dp = [[0 for i in range(n)] for j in range(n)]         for i in range(n):             dp[i][i] = nums[i]         for i in range(n-1,-1,-1):             for j in range(i+1,n):                 dp[i][j] = max(dp[i][j-1],dp[i+1][j]+nums[i])         return dp[0][n-1] Question: You are given a string $s$ of length $n$ consisting of lowercase English letters.  You want to convert $s$ to a palindrome by applying the following operation any number of times:  Choose a subsequence of $s$ and remove it.  For example, if $s = "abcde",$ you can remove the subsequence $s[1,3]$ to get $s = "abde"$.  Return the minimum number of operations needed to convert $s$ to a palindrome.  A subsequence of a string is a string that can be derived from it by deleting some characters without changing the order of the remaining characters.  For example, "ace" is a subsequence of "abcde".  A string is a palindrome if it reads the same forward and backward.  Example 1:  Input: s = "abc" Output: 1 Explanation: Remove the subsequence s[1,2] to get "ab". Example 2:  Input: s = "abca" Output: 2 Explanation: Remove the subsequence s[1,3] to get "ab". Example 3:  Input: s = "abcba" Output: 1 Explanation: Remove the subsequence s[1,4] to get "abcba". Example 4:  Input: s = "abcd" Output: 0 Explanation:
def canBeLit(self, k1, k2, k3):         if k1 == 1 or k2 == 1 or k3 == 1:             return True         if k1 == k2 and k2 == k3:             return True         if k1 == k2 or k2 == k3 or k1 == k3:             return True         return False     def canBeLit2(self, k1, k2, k3):         if k1 == 1 or k2 == 1 or k3 == 1:             return True         if k1 == k2 and k2 == k3:             return True         if k1 == k2 or k2 == k3 or k1 == k3:             return True         return False     def canBeLit3(self, k1, k2, k3):         if k1 == 1 or k2 == 1 or k3 == 1:             return True         if k1 == k2 and k2 == k3:             return True         if k1 == k2 or k2 == k3 or k1 == k3:             return True         return False     def canBeLit4(self, k1, k2, k3):         if k1 == 1 or k2 == 1 or k3 == 1:             return True         if k1 == k2 and k2 == k3:             return True         if k1 == k2 or k2 == k3 or k1 == k3:             return True         return False     def canBeLit5(self, k1, k2, k3):         if k1 == 1 or k2 == 1 or k3 == 1:             return True         if k1 == k2 and k2 == k3:             return True         if k1 == k2 or k2 == k3 or k1 == k3:             return True         return False     def canBeLit6(self, k1, k2, k3):         if k1 == 1 or k2 == 1 or k3 == 1:             return True         if k1 == k2 and k2 == k3:             return True         if k1 == k2 or k2 == k3 or k1 == k3:             return True         return False     def canBeLit
def minOperations(self, s):         """         :type s: str         :rtype: int         """         n = len(s)         dp = [[0 for i in range(26)] for j in range(n)]         for i in range(n):             dp[i][ord(s[i]) - ord('a')] = 1         for i in range
n = int(input()) a = list(map(int,input().split())) m = int(input()) b = list(map(int,input().split())) a.sort() b.sort() ans = 0 for i in range(n):     for j in range(m):         if abs(a[i]-b[j])<=1:             ans+=1             b[j] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
def solve(self, a, b):         a1 = a[0]         a2 = a[1]         b1 = b[0]         b2 = b[1]         if a1 > b2 and a2 > b1:             return 1         elif a1 < b2 and a2 < b1:             return 2         else:             return 0     def solve2(self, a, b):         a1 = a[0]         a2 = a[1]         b1 = b[0]         b2 = b[1]         if a1 > b2 and a2 > b1:             return 1         elif a1 < b2 and a2 < b1:             return 2         else:             return 0     def solve3(self, a, b):         a1 = a[0]         a2 = a[1]         b1 = b[0]         b2 = b[1]         if a1 > b2 and a2 > b1:             return 1         elif a1 < b2 and a2 < b1:             return 2         else:             return 0     def solve4(self, a, b):         a1 = a[0]         a2 = a[1]         b1 = b[0]         b2 = b[1]         if a1 > b2 and a2 > b1:             return 1         elif a1 < b2 and a2 < b1:             return 2         else:             return 0     def solve5(self, a, b):         a1 = a[0]         a2 = a[1]         b1 = b[0]         b2
def solve(self, N, K, x, y, c):         def dist(x1, y1, x2, y2):             return (x1 - x2)**2 + (y1 - y2)**2         def f(x, y):             return sum(c[i] * math.sqrt(dist(x, y, x[i], y[i])) for i in range(N))         x = np.array(x)         y = np.array(y)         c = np.array(c)         x_min = -1000         x_max = 1000         y_min = -1000         y_max = 1000         while x_max - x_min > 1e-6:             x_mid = (x_min + x_max) / 2             y_mid = (y_min + y_max) / 2             if f(x_mid, y_mid) >= f(x_min, y_mid) and f(x_mid, y_mid) >= f(x_max, y_mid) and f(x_mid, y_mid) >= f(x_mid, y_min) and f(x_mid, y_mid) >= f(x_mid, y_max):                 x_min = x_mid             else:                 x_max = x_mid         y_min = -1000         y_max = 1000         while y_max - y_min > 1e-6:             y_mid = (y_min + y_max) / 2             if f(x_min, y_mid) >= f(x_min, y_min) and f(x_min, y_mid) >= f(x_min, y_max) and f(x_min, y_mid) >= f(x_mid, y_mid) and f(x_min, y_mid) >= f(x_max, y_mid):                 y_min = y_mid             else:                 y_max = y_mid         return f(x_min, y_min)  Question: You are given a string s of length n consisting of lowercase English
def solve(self, n, a):         a.sort()
def solve(self, n, t, s, d):         for i in range(n):             if t % d[i] == s[i]:                 return i + 1         return 1  Question: There are $n$ students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a direct friend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.  Given a list of friendship between students, you have to find out the maximum number of friend circles among all the students.  Example 1:   Input: n = 4 A = [[1,2],[1,3],[2,4]] Output: 2 Explanation: The first student is the leader of the first friend circle with two students. The second student is also the leader of the first friend circle. The third student is in the second friend circle. The fourth student is in the second friend circle. So the answer is 2. Example 2:   Input: n = 5 A = [[1,3],[1,4],[2,3],[2,5],[3,4],[4,5]] Output: 3 Explanation: The first student is the leader of the first friend circle. The second student is in the second friend circle. The third student is in the third friend circle. The fourth student is in the third friend circle. The fifth student is in the third friend circle. So the answer is 3. Note:  1 <= n <= 200 1 <= A.length <= 1000 A[i][0] < A[i][1] 1 <= A[i][j] <= n
m,k = map(int,input().split()) if m == 0:     print(0) else:     if k == 1:         print(2**k*m)     else:         print(2**(k-1)*(2*m-1))
def solve(self, s):         n = len(s)         if n < 5:
def magicSquare(self, grid):         n = len(grid)         for i in range(n):             for j in range(n):                 if grid[i][j] == 0:                     grid[i][j] = 1                     for k in range(n):                         if k!= i:                             grid[k][j] += 1                         if k!= j:                             grid[i][k] += 1                     if grid[i][j]!= sum(grid[i]):                         grid[i][j] -= 1                         for k in range(n):                             if k!= i:                                 grid[k][j] -= 1                             if k!= j:                                 grid[i][k] -= 1                         continue                     if grid[i][j]!= sum(grid[j]):                         grid[i][j] -= 1                         for k in range(n):                             if k!= i:                                 grid[k][j] -= 1                             if k!= j:                                 grid[i][k] -= 1                         continue                     if grid[i][j]!= sum(grid[
def solve(self, n, m, a):         a.sort()         ans = [0]*n         for i in range(n):             ans[i] = a[i] + m         ans.sort()         return ans[-1], ans[0]
def minDistance(self, s: str, t: str) -> int:         n = len(s)         m = len(t)         dp = [[0 for _ in range(m+1)] for _ in range(n+1
from collections import defaultdict import sys input = sys.stdin.readline  n,m = map(int,input().split())  f = [0]*(10) for i in range(n):     a,b = map(int,input().split())     for j in b:         f[j] += 1  p = [0]*(10) for i in range(m):     c,r,b = map(int,input().split())     for j in b:         p[j] += c  ans = 0 for i in range(1,10
def check(n):     s = 0     while n:         s += n%10         n //= 10     return s  def solve(m,s):     if s == 0:         if m == 1:             return -1,-1         return 0,9**(m-1)     if s > 9*m:         return -1,-1     if s == 9*m:         return 9**(m-1),9**(m-1)     if s < 9*m:         return 10**(m-1)-10**(m-1-s),10**(m-1)-1  m,s = map(int,input().split()) print(*solve(m,s))
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = x[0]     ct = 1     for i in range(1,n):         if x[i]-pos >= mid:             pos = x[i]             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     n,k = ip()     x = ip()     x.sort()     ans = -1     l,r = 1,x[-1]     while l < r:         mid = (l+r)//2         if check(mid):             ans = max(ans,mid)             l = mid +1         else:             r = mid     print(ans)                                      Question: You are given a string $s$ consisting of lowercase English letters. You can perform the following operation on $s$:  Choose a character $c$ and replace all occurrences of $c$ in $s$ with $c + 1$.  For example, if $s = "abac"$ and you choose $c = 'a'$, then the string becomes $s = "bbbc"$.  You want to make $s$ lexicographically as small as possible.  Return the lexicographically smallest string you can obtain after performing the operation any number of times.  Note that the string $s$ is given in the input as a single string.  Example 1:   Input: s = "abac" Output: "abac" Explanation: You don't need to perform any operations.  Example 2:   Input: s = "cbacdcbc" Output: "abcbcdcb" Explanation: You can perform the following operations: - Choose c = 'b' and replace all occurrences of 'b' with 'c'. The string becomes "cbacdcbc". - Choose c = 'a' and replace all occurrences of 'a' with 'b'. The string becomes "cb
def canDistribute(self, n: int, k: int, d: int, a: List[int]) -> bool:         a.sort()         if a[-1] - a[0] > d:             return False         if n <= k:             return True         if n == k + 1:             return True         if n == k + 2:             return a[-1] - a[0] <= d         if n == k + 3:             return a[-1] - a[0] <= d         if n == k + 4:             return a[-1] - a[0] <= d         return True Question: You are given a string s of length n consisting of lowercase English letters.  You are also given an integer k.  You want to choose some substrings of s and concatenate them in any order.  The cost of a substring is defined as the number of lowercase English letters in that substring.  Return the minimum cost to make the concatenation of all substrings (possibly empty) have cost equal to k.  Note that you can choose the same substring multiple times.   -----Input-----  The first line contains two integers n and k (1 ≤ n ≤ 10^5, 1 ≤ k ≤ 10^6) — the length of the string s and the value of k.  The second line contains the string s of length n consisting of lowercase English letters.   -----Output-----  Print the minimum cost to make the concatenation of all substrings (possibly empty) have cost equal to k.   -----Examples----- Input 3 4 abb   Output 4  Input 6 10 ababab   Output 2  Input 2 13 aa   Output 0  Input 100000 1 z   Output 299997  Input 5 10 yxxyx   Output 1  Input 2 10
def count(self,s):         r = s.count('R')         b = s.count('B')         y = s.count('Y')         g = s.count('G')         return r,b,y,g     def solve(self,s):         r,b,y,g = self.count(s)         if r == 0 or b == 0 or y == 0 or g == 0:             return 0         if s[0] == '!' and s[1] == '!' and s[2] == '!' and s[3] == '!':             return 4         if s[0] == '!' and s[1] == '!' and s[2] == '!' and s[3]!= '!':             return 3         if s[0] == '!' and s[1] == '!' and s[2]!= '!' and s[3] == '!':             return 3         if s[0] == '!' and s[1] == '!' and s[2]!= '!' and s[3]!= '!':             return 2         if s[0] == '!' and s[1]!= '!' and s[2] == '!' and s[3] == '!':             return 3         if s[0] == '!' and s[1]!= '!' and s[2] == '!' and s[3]!= '!':             return 2         if s[0] == '!' and s[1]!= '!' and s[2]!= '!' and s[3] == '!':             return 2         if s[0] == '!' and s[1]!= '!' and s[2]!= '!' and s[3]!= '!':             return 1         if s[0]
from collections import defaultdict import sys input = sys.stdin.readline  n,m = map(int,input().split())  graph = defaultdict(list)  for i in range(m):     a,b = map(int,input().split())     graph[a].append(b)  dp = [0]*(n+1)  for i in range(1,n+1):     for j in graph[i]:         dp[j] += 1  for i in range(n-2,-1,-1):     dp[i] += dp[i+1]  ans = 0  for i in range(1,n):     ans += dp[i]/(n-1)  print(ans)
def maxSubArray(self, nums):         """         :type nums: List[int]         :rtype: int         """         max_sum = nums[0]         curr_sum = nums[0]         for i in range(1,len(nums)):             curr_sum = max(nums[i],curr_sum+nums[i])             max_sum = max(max_sum,curr_sum)         return max_sum Question: Given an array of integers, find the maximum sum of any non-empty subarray of that array.  Note:  The sum of any empty subarray is 0.  Example 1:   Input: [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the maximum sum = 6.  Example 2:   Input: [1] Output: 1  Example 3:   Input: [0] Output: 0  Example 4:   Input: [-1] Output: -1  Example 5:   Input: [-100000] Output: -10

def solve(s1,s2):     if s1 == s2:         return s1     if s1[0] < s2[0]:         return s1[0] + solve(s1[1:],s2)     else:         return s2[0] + solve(s1,s2[1:])  s1 = input() s2 = input() print(solve(s1,s2))
def solve(self, s):         n = len(s)         if n == 2:             return s         if n == 4:             return s         if n == 6:             return s         if n == 8:             return s         if n == 10:             return s         if n == 12:             return s         if n == 14:             return s         if n == 16:             return s         if n == 18:             return s         if n == 20:             return s         if n == 22:             return s         if n == 24:             return s         if n == 26:             return s         if n == 28:             return s         if n == 30:             return s         if n == 32:             return s         if n == 34:             return s         if n == 36:             return s         if n == 38:             return s         if n == 40:             return s         if n == 42:             return s         if n == 44:             return s         if n == 46:             return s         if n == 48:             return s         if n == 50:             return s         if n == 52:             return s         if n == 54:             return s         if n == 56:             return s         if n == 58:             return s         if n == 60:             return s         if n == 62:             return s         if n == 64:             return s         if n == 66:             return s         if n == 68:             return s         if n == 70:             return s         if n == 72:             return s         if n == 7
def longestPalindrome(self, s):         """         :type s: str         :rtype: str         """         n = len(s)         dp = [[0 for i in range(n)] for j in range(n)]         for i in range(n):             dp[i][i] = 1         for i in range(n-1, -1, -1):             for j in range(i+1, n):                 if s[i] == s[j]:                     dp[i][j] = dp[i+1][j-1] + 2                 else:                     dp[i][j] = max(dp[i+1][j], dp[i][j-1])         ans = ''         for i in range(n):             for j in range(i, n):                 if dp[i][j] == j-i+1:                     ans = s[i:j+1]         return ans Question: Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.
def findMissing(self, gems):         gem = ['Power','Time','Space','Soul','Reality','Mind']         gem_dict = {}         for i in range(len(gem)):             gem_dict[gem[i]] = 0         for i in range(len(gems)):             gem_dict[gems[i]] += 1         ans = []         for i in range(len(gem)):             if gem_dict[gem[i]] == 0:                 ans.append(gem[i])         return ans Question: You are given a string $s$ of length $n$ consisting of lowercase English letters.  You can perform the following operation on the string $s$:  Choose a character $c$ and replace all occurrences of $c$ in $s$ with $c + 1$.  For example, if $s = "abacaba", c = "a"$, then the result of the operation is $s = "bbcbcba"$.  You can perform the operation any number of times (possibly zero).  You want to make the string $s$ lexicographically as small as possible.  Return the lexicographically smallest string you can obtain after performing the operation any number of times.  Note that the string $s$ is given in the input as a single string.  Input  The first line contains a single integer $t$ ($1 \le t \le 10^4$) — the number of test cases.  The first line of each test case contains a single integer $n$ ($1 \le n \le 2 \cdot 10^5$) — the length of the string $s$.  The second line of each test case contains the string $s$ ($n$ characters long). It is guaranteed that $s$ consists of only lowercase English letters.  It is guaranteed that the sum of $n$ over all test cases does not exceed $2 \cdot 10^5$.  Output  For each test case, print the lexicographically smallest string you can obtain after performing the operation any number of times.  Example Input 3 3 aab 2 ba 5 abcba  Output aac ab abbabb  Note  In the first test case, you can
n,a,b = map(int,input().split())  if n%2 == 0:     print("Final!") else:     for i in range(1,n+1):         if i%2 == 0:             if i == a or i == b:                 continue             else:                 if i%4 == 0:                     if i//4 == a or i//4 == b:                         continue                     else:                         print(i//4)                         break                 else:                     if i//4 == a or i//4 == b:                         continue                     else:                         print(i//4+1)                         break  Question: You are given a string s of length n consisting of lowercase English letters.  You can perform the following operation on s:  Choose a character c and replace all occurrences of c in s with the next character in the alphabet (wrapping around from z to a).  For example, if s = "abc", you can replace all occurrences of "a" with "b", all occurrences of "b" with "c", and all occurrences of "c" with "d".  Return the minimum number of operations needed to make s equal to t.  Example 1:   Input: s = "abc", t = "acb" Output: 2 Explanation: You can replace "a" with "b" and "c" with "d" to make s = "acb".  Example 2:   Input: s = "leetcode", t = "code" Output: 4 Explanation: You can replace "e" with "c", "o" with "d", "d" with "e", and "l" with "e" to make s = "code".  Example 3:   Input: s = "a", t = "b" Output: 1 Explanation: You can replace "a" with "b" to make s = "b".  Example 4:   Input: s = "a", t = "a" Output: 0 Explanation: You don't need to do anything to make s = "a".  Example 5:   Input: s = "x", t = "y" Output: 1 Explanation: You can replace "x" with "y" to make s = "y".
def solve(self, n, p, b):         # print(p, b)         if n == 1:             return 0         if n == 2:             return 1 if p[0]!= p[1] else 0         if n == 3:             return 1 if p[0]!= p[1] and p[0]!= p[2] and p[1]!= p[2] else 0         if n == 4:             return 1 if p[0]!= p[1] and p[0]!= p[2] and p[0]!= p[3] and p[1]!= p[2] and p[1]!= p[3] and p[2]!= p[3] else 0         if n == 5:             return 1 if p[0]!= p[1] and p[0]!= p[2] and p[0]!= p[3] and p[0]!= p[4] and p[1]!= p[2] and p[1]!= p[3] and p[1]!= p[4] and p[2]!= p[3] and p[2]!= p[4] and p[3]!= p[4] else 0         if n == 6:             return 1 if p[0]!= p[1] and p[0]!= p[2] and p[0]!= p[3] and p[0]!= p[4] and p[0]!= p[5] and p[1]!= p[2] and p[1]!= p[3] and p[1]!= p[4] and p[1]!= p[5] and p[2]!= p[3] and p[2]!= p[4] and p[2]!= p[5] and p[3]!= p[4] and p[3]!= p[5] and p[4]!= p[5] else 0         if n == 7:             return 1 if p[0]
def minPalindromes(self, s: str) -> int:         n = len(s)         dp = [[0 for _
def camelCrossing(self, camels, parts):         camels.sort()         ans = 0         for i in range(len(camels)):             ans += camels[i]         if ans > parts[0][1]:             return -1         for i in range(len(camels)):             if i == 0:                 ans += camels[i]             else:                 ans -= camels[i-1]             if ans > parts[i][1]:                 return -1         ans = 0         for i in range(len(camels)):             ans += camels[i]         if ans > parts[-1][1]:             return -1         for i in range(len(camels)):             if i == len(camels)-1:                 ans += camels[i]             else:                 ans -= camels[i+1]             if ans > parts[i][1]:                 return -1         return max(camels) Question: You are given a string s of length n consisting of lowercase English letters. You want to convert s to a palindrome by applying the following operation any number of times:  Choose a pair of indices (i,j) such that i < j and s[i] is not equal to s[j]. Swap s[i] and s[j]. For example, if s = "abc", you can convert it to "bac" by swapping s[1] and s[2]. Return the minimum number of operations needed to convert s to a palindrome.  -----Constraints-----  - 1 \leq n \leq 10^5  - s consists of lowercase English letters.  -----Input----- Input is given from Standard Input in the following format: n s  -----Output----- Print the minimum number of operations
a,b = map(int,input().split()) if b-a>=10:     print(0) else:     ans = 1     for i in range(a+1,b+1):         ans = (ans*i)%10     print(ans)
def minJumps(self, arr, n):         dp = [0 for i in range(n)]         for i in range(n):             dp[i] = float('inf')         dp[0] = 0         for i in range(1, n):             for j in range(i):                 if arr[i] == 1 and arr[j] == 1 and i - j <= dp[j]:                     dp[i] = min(dp[i], dp[j] + 1)         if dp[n - 1] == float('inf'):             return -1         return dp[n - 1]  Question: You are given a string s of length n consisting of digits from 0 to 9. You can perform the following operation any number of times: choose two adjacent digits in the string and replace them by the sum of these digits.  For example, if the string is 1122, you can transform it to 1100 or 1212, but you cannot transform it to 1111 or 1234.  You want to make the string s as beautiful as possible. Formally, let's define the beauty of the string s as the maximum number of times you can perform the operation on s.  Return the beauty of s.  Example 1:  Input: s = "1122" Output: 2 Explanation: You can transform s to "1100" or "1212". The beauty of the string is 2. Example 2:  Input: s = "1234" Output: 0 Explanation: You cannot transform s to any beautiful string. Example 3:  Input: s = "1111" Output: 4 Explanation: You can transform s to "11000" or "10101". The beauty of the string is 4. Example 4:  Input: s = "0000" Output: 0 Explanation: You cannot transform s to any beautiful string. Example 5:  Input: s = "1221" Output: 2 Explanation: You can transform s to "1
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = x[0]     ct = 1     for i in range(1,n):         if x[i]-pos >= mid:             pos = x[i]             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     n,k = ip()     x = ip()     x.sort()     ans = -1     l,r = 1,x[-1]     while l <
n = int(input())  if n%1234567==0 or n%1234==0 or n%123==0 or n%12==0 or n%1==0:     print("YES") else:     print("NO")
def solve(self, x1, x2, k, b):         if x1 == x2:             return False         if x1 < 0 and x2 < 0:             return False         if x1 > 0 and x2 > 0:             return False         if x1 < 0 and x2 > 0:             return True         if x1 > 0 and x2 < 0:             return True         return False     def solve(self, x1, x2, k, b):         if x1 == x2:             return False         if x1 < 0 and x2 < 0:             return False         if x1 > 0 and x2 > 0:             return False         if x1 < 0 and x2 > 0:             return True         if x1 > 0 and x2 < 0:             return True         return False     def solve(self, x1, x2, k, b):         if x1 == x2:             return False         if x1 < 0 and x2 < 0:             return False         if x1 > 0 and x2 > 0:             return False         if x1 < 0 and x2 > 0:             return True         if x1 > 0 and x2 < 0:             return True         return False     def solve(self, x1, x2, k, b):         if x1 == x2:             return False         if x1 < 0 and x2 < 0:             return False         if x1 > 0 and x2 > 0:             return False         if x1 < 0 and x2 > 0:             return True         if x1 > 0 and x2 < 0:             return True         return False     def solve(self, x1, x2, k, b):         if x1 == x2:             return False         if x1 < 0
def countSplits(self, n):         """         :type n: int         :rtype: int         """         if n == 1:             return 1         if n == 2:             return 2         if n == 3:             return 3         if n == 4:             return 4         if n == 5:             return 5         if n == 6:             return 6         if n == 7:             return 7         if n == 8:             return 8         if n == 9:             return 9         if n == 10:             return 10         if n == 11:             return 11         if n == 12:             return 12         if n == 13:             return 13         if n == 14:             return 14         if n == 15:             return 15         if n == 16:             return 16         if n == 17:             return 17         if n == 18:             return 18         if n == 19:             return 19         if n == 20:             return 20         if n == 21:             return 21         if n == 22:             return 22         if n == 23:             return 23         if n == 24:             return 24         if n == 25:             return 25         if n == 26:             return 26         if n == 27:             return 27         if n == 28:             return 28         if n == 29:             return 29         if n == 30:             return 30         if n == 31:             return 31         if n == 32:             return 32         if n == 33:             return 33         if n == 34:             return 34         if n == 35:             return 35         if n == 36:             return 36         if n == 37:             return 37         if n == 38:             return 38         if n == 39
def solve(self, n, k):         if k == 0:             return 0, n         if k == n:             return 1, n         if k == 1:             return 1, n         if k == n - 1:             return 1, n         if k == 2:             return 2, n         if k == n - 2:             return 2, n         if k == 3:             return 3, n         if k == n - 3:             return 3, n         if k == 4:             return 4, n         if k == n - 4:             return 4, n         if k == 5:             return 5, n         if k == n - 5:             return 5, n         if k == 6:             return 6, n         if k == n - 6:             return 6, n         if k == 7:             return 7, n         if k == n - 7:             return 7, n         if k == 8:             return 8, n         if k == n - 8:             return 8, n         if k == 9:             return 9, n         if k == n - 9:             return 9, n         if k == 10:             return 10, n         if k == n - 10:             return 10, n         if k == 11:             return 11, n         if k == n - 11:             return 11, n         if k == 12:             return 12, n         if k == n - 12:             return 12, n         if k == 13:             return 13, n         if k == n - 13:             return 13, n         if k == 14:             return 14, n         if k == n - 14:             return 14, n         if k == 15:             return 15, n         if k == n - 15:             return 15, n         if k == 16:             return 16, n         if k == n - 16:             return 1
def solve(self, n):         if n == 2:             return 1         if n == 3:             return 2         if n == 4:             return 2         if n == 5:             return 4         if n == 6:             return 4         if n == 7:             return 6         if n == 8:             return 6         if n == 9:             return 8         if n == 10:             return 8         if n == 11:             return 10         if n == 12:             return 10         if n == 13:             return 12         if n == 14:             return 12         if n == 15:             return 14         if n == 16:             return 14         if n == 17:             return 16         if n == 18:             return 16         if n == 19:             return 18         if n == 20:             return 18         if n == 21:             return 20         if n == 22:             return 20         if n == 23:             return 22         if n == 24:             return 22         if n == 25:             return 24         if n == 26:             return 24         if n == 27:             return 26         if n == 28:             return 26         if n == 29:             return 28         if n == 30:             return 28         if n == 31:             return 30         if n == 32:             return 30         if n == 33:             return 32         if n == 34:             return 32         if n == 35:             return 34         if n == 36:             return 34         if n == 37:             return 36         if n == 38:             return 36         if n == 39:             return 38         if n == 40:             return 38         if n == 41:             return
def longestPalindrome(self, s: str) -> str:         if len(s) == 0:             return ""         if len(s) == 1:             return s         dp = [[0 for i in range(len(s))] for j in range(len(s))]         for i in range(len(s)):             dp[i][i] = 1         for i in range(len(s)-1, -1, -1):             for j in range(i+1, len(s)):                 if s[i] == s[j]:                     dp[i][j] = dp[i+1][j-1] + 2                 else:                     dp[i][j] = max(dp[i+1][j], dp[i][j-1])         max_len = 0         max_str = ""         for i in range(len(s)):             for j in range(i, len(s)):                 if dp[i][j] > max_len:                     max_len = dp[i][j]                     max_str = s[i:j+1]         return max_str Question: Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.  Example 1:   Input: "babad" Output: "bab" Note: "aba" is also a valid answer. Example 2
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = 0     ct = 0     for i in range(n):         if x[i] - pos >= mid:             pos = x[i]             ct += 1     return ct  for _ in range(inp()):     n = inp()     x = [i for i in range(n)]     l,r = 1,n     while l < r:         mid = (l+r)//2         if check(mid) >= n:             l = mid +1         else:             r = mid     print(l)
def solution(self, s, k):         # code here         d = {}         count = 0         for i in s:             if i in d:                 d[i] += 1             else:                 d[i] = 1             if len(d) > k:                 d.pop(s[count])                 count += 1         return len(s) - count Question: You are given a string s and an integer k. You need to find the longest substring of s that contains at most k distinct characters.  Return the length of this substring. If there is no such substring, return 0.  Example 1:   Input: s = "eceba", k = 2 Output: 3 Explanation: The substring is
def longestPalindrome(self, s):         """         :type s: str         :rtype: str         """         if not s:             return ''         n = len(s)         dp = [[0 for i in range(n)] for j in range(n)]         for i in range(n):             dp[i][i] = 1         for i in range(n-1, -1, -1):             for j in range(i+1, n):                 if s[i] == s[j]:                     dp[i][j] = dp[i+1][j-1] + 2                 else:                     dp[i][j] = max(dp[i+1][j], dp[i][j-1])         max_len = 0         max_str = ''         for i in range(n):             for j in range(i, n):                 if dp[i][j] > max_len:                     max_len = dp[i][j]                     max_str = s[i:j+1]         return max_str  Question: Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.  Example 1:   Input: "babad" Output: "bab" Note: "aba" is also a valid answer. Example 2:   Input: "cbbd" Output: "bb"
def solve(self, x):         ans = []         for i in range(1,int(x**0.5)+1):             if x%i == 0:                 ans.append((
def is_leap(year):     if year % 4 == 0:         if year % 100 == 0:             if year % 400 == 0:                 return True             else:                 return False         else:             return True     else:         return False  n = int(input()) arr = list(map(int, input().split()))  if arr[0] == 28:     if n == 1:         print("YES")     else:         print("NO") elif arr[0] == 29:     if n == 1:         print("YES")     elif n == 2:         if arr[1] == 28:             print("YES")         else:             print("NO")     else:         print("NO") else:     if n == 1:         print("NO")     elif n == 2:         if arr[1] == 28:             print("YES")         elif arr[1] == 29:             print("NO")         else:             print("NO")     else:         if arr[1] == 28:             if arr[2] == 28:                 print("YES")             elif arr[2] == 29:                 print("NO")             else:                 print("NO")         elif arr[1] == 29:             if arr[2] == 28:                 print("NO")             elif arr[2] == 29:                 print("NO")             else:                 print("YES")         else:             if arr[2] == 28:                 print("NO")             elif arr[2] == 29:                 print("NO")             else:                 if is_leap(arr[0]):                     if arr[3] == 28:
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = 1     ct = 0     for i in range(1,n):         if x[i]-pos >= mid:             pos = x[i]             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     n = inp()     if n == 2:         print("NO")         continue     x = [i for i in range(1,n+1)]     ans = -1     l,r = 1,n     while l < r:         mid = (l+r)//2         if check(mid):             ans = max(ans,mid)             l = mid +1         else:             r = mid     if ans == -1:         print("NO")     else:         print("YES")         print(k)         pos = 1         ct = 0         for i in range(1,n):             if x[i]-pos >= ans:                 pos = x[i]                 ct += 1                 print(str(pos)+" "+str(x[i]))         print(str(pos)+" "+str(n))
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = 0     ct = 0     for i in range(n):         if x[i] > mid:             ct += 1             if ct == 2:                 return False             pos = i         elif x[i] < mid:             ct = 0             pos = i     return True  for _ in range(inp()):     n,a,b = ip()     x = ip()     x.sort()     ans = -1     l,r = 1,x[-1]     while l < r:         mid = (l+r)//2         if check(mid):             ans = max(ans,mid)             l = mid +1         else:             r = mid     print(ans)                                      Question: You are given a string s consisting of lowercase English letters.  You can perform the following operation on s:  Choose a character c and replace all occurrences of c in s with the next character in the alphabet (wrapping around from 'z' to 'a').  For example, if s = "abac", you can replace all occurrences of 'a' with 'b', resulting in "bbac".  You want to perform the operation on s exactly k times.  Return the final string after performing the operation k
n,m,k = map(int,input().split()) if n*m%k!=0:     print("NO") else:     print("YES")     print(0,0)     print(n,0)     print(0,m*n//k)
n,k = map(int,input().split()) if n%2==0:     if k<=n//2:         print("YES")     else:         print("NO") else:     if k<=n//2+1:         print("YES")     else:         print("NO")
n = int(input()) a = list(map(int,input().split())) c = a.count(max(a)) b = a.count(min(a)) if c == 1:     print("chest") elif b == 1:     print("back") else:     print("biceps")
def minimumRedirections(self, grades):         """         :type grades: List[int]         :rtype: int         """         n = len(grades)         grades.sort()         count = 0         for i in range(n):             if grades[i] == 5:                 continue             if grades[i] == 4:                 count += 1             else:                 count += 2         return count Question: You are given a string $s$ of length $n$ and an integer $k$. You can perform the following operation on the string:  Choose a substring of length $k$ and replace it with the string that is the reverse of the substring. For example, if $s = "abcde"$, you can perform the following operations:  Choose the substring $s[1, 3]$ and replace it with $s[3, 1] = "cdeb"$. Choose the substring $s[2, 4]$ and replace it with $s[4, 2] = "edcb"$.  You want to perform the minimum number of operations on the string $s$ to make it a palindrome.  Return the minimum number of operations you need to perform on the string $s$ to make it a palindrome.  A string $t$ is a palindrome if $t = t[1 \ldots n]$ for some integer $n$ and $t[i] = t[n + 1 - i]$ for all $1 \leq i \leq n$.  Example 1:  Input: s = "abcde", k = 3 Output: 1 Explanation: You can perform the following operation: Choose the substring s[1, 3] and replace it with s[3, 1] = "cdeb". s = "cdeb" is a palindrome, so you don't need to perform any more operations. Example 2:  Input: s = "ab", k = 2 Output: 1 Explanation: You can perform the following operation: Choose the substring s[1,
def minWindow(self, s, t):         """         :type s: str         :type t: str         :rtype: str         """         if not s or not t:             return ''         if len(t) > len(s):             return ''         t_dict = {}         for c in t:             t_dict[c] = t_dict.get(c, 0) + 1         left, right, min_len, min_window = 0, 0, len(s) + 1, ''         while right < len(s):             if s[right] in t_dict:                 t_dict[s[right]] -= 1                 if t_dict[s[right]] == 0:                     del t_dict[s[right]]             while len(t_dict) == 0:                 if right - left + 1 < min_len:                     min_len = right - left + 1                     min_window = s[left:right + 1]                 if s[left] in t_dict:                     t_dict[s[left]] += 1                 left += 1             right +=
def solve(n):     if n == 0:         return 0     if n == 1:         return 1     if n == 2:         return 2     if n == 3:         return 3     if n == 4:         return 4     if n == 5:         return 5     if n == 6:         return 6     if n == 7:         return 7     if n == 8:         return 8     if n == 9:         return 9     if n == 10:         return 10     if n == 11:         return 11     if n == 12:         return 12     if n == 13:         return 13     if n == 14:         return 14     if n == 15:         return 15     if n == 16:         return 16     if n == 17:         return 17     if n == 18:         return 18     if n == 19:         return 19     if n == 20:         return 20     if n == 21:         return 21     if n == 22:         return 22     if n == 23:         return 23     if n == 24:         return 24     if n == 25:         return 25     if n == 26:         return 26     if n == 27:         return 27     if n == 28:         return 28     if n == 29:         return 29     if n == 30:         return 30     if n == 31:         return 31     if n == 32:         return 32     if n == 33:         return 33     if n == 34:         return 34     if n == 35:         return 35     if n == 36:         return 36     if n == 37:         return 37     if n == 38:         return 38     if n == 39:         return 39     if n == 4
def solve(self, x1, y1,
def check(n):     if n == 0:         return 0     if n < 10:         return 1     if n < 100:         return 2     if n < 1000:         return 3     if n < 10000:         return 4     if n < 100000:         return 5     if n < 1000000:         return 6     if n < 10000000:         return 7     if n < 100000000:         return 8     if n < 1000000000:         return 9     if n < 10000000000:         return 10     if n < 100000000000:         return 11     if n < 1000000000000:         return 12     if n < 10000000000000:         return 13     if n < 100000000000000:         return 14     if n < 1000000000000000:         return 15     if n < 10000000000000000:         return 16     if n < 100000000000000000:         return 17     if n < 1000000000000000000:         return 18     if n < 10000000000000000000:         return 19     if n < 100000000000000000000:         return 20     if n < 1000000000000000000000:         return 21     if n < 1000000000000000
def maxCost(self, a, b, c, d, e, f):         """         :type a: int         :type b: int         :type c: int         :type d: int         :type e: int         :type f: int         :rtype: int         """         return max(min(a,d)*e + min(b,c,d-min(a,d))*f, min(b,c,d)*f + min(a,d-min(b,c,d))*e) Question: You are given a string $s$ and an integer $k$. You want to convert the string into a palindrome by adding at most $k$ characters in front of it.  Return the minimum number of characters that you need to add to make $s$ a palindrome.  A string $a$ is a palindrome if it reads the same backward as forward.  Example 1:   Input: s = "zzazz", k = 3 Output: 2 Explanation: "zzazz" -> "zzazzz" -> "zzazzzz" -> "zzazzazz" -> "zzazzazzz" -> "zzazzazzzz"  Example 2:   Input: s = "abc", k = 100 Output: 0 Explanation: "abc" is already a palindrome.  Example 3:   Input: s = "abca", k = 1 Output: 1 Explanation: You can add a character at the beginning to make it a palindrome, for example "abca" -> "abcabca".  Example 4:   Input: s = "abca", k = 2 Output: 0 Explanation: You don't need to add any characters to make it a palindrome.  Example 5:   Input: s = "abca", k = 3 Output: 1 Explanation: You can add a character at the beginning to make it a palindrome, for example "abca" -> "abcab
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = x[0]     ct = 1     for i in range(1,n):         if x[i]-pos >= mid:             pos = x[i]             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     a,b,p,x = ip()     x = [b]     while x[-1] < p:         x.append((x[-1]*a)%p)     n = len(x)     l,r = 1,x[-1]     while l < r:         mid = (l+r)//2         if check(mid):             l = mid +1         else:             r = mid     print(l)
def getSum(self, k2, k3, k5, k6):         # code here         if k2 == 0 and k3 == 0 and k5 == 0 and k6 == 0:             return 0         if k2 == 0 and k3 == 0 and k5 == 0:             return 256 * k6         if k2 == 0 and k3 == 0:             return 32 * k5         if k2 == 0:             return 256 * k5 + 32 * k3         if k3 == 0:             return 256 * k2 + 32 * k6         if k5 == 0:             return 256 * k2 + 32 * k3         if k6 == 0:             return 256 * k2 + 32 * k5         if k2 == 1 and k3 == 1 and k5 == 1:             return 256 * k6 + 32 * k5 + 32 * k3         if k2 == 1 and k3 == 1:             return 256 * k6 + 32 * k5 + 32 * k3         if k2 == 1 and k5 == 1:             return 256 * k6 + 32 * k5 + 256 * k3         if k2 == 1 and k6 == 1:             return 256 * k6 + 32 * k5 + 256 * k3         if k3 == 1 and k5 == 1:             return 256 * k6 + 32 * k5 + 256 * k2         if k3 == 1 and k6 == 1:             return 256 * k6 + 32 * k5 + 256 * k2         if k5 == 1 and k6 == 1:             return 256 * k6 + 32 * k5 + 256 * k2         if k2 == 2 and k3 == 2 and k5 == 2:             return 256 * k6 + 32 * k5 +
def happyLadybugs(self, n, x, y, c):         """         :type n: int         :type x: int         :type y: int         :type c: int         :rtype: int         """         if c <= n:             return 0         if c == n + 1:             return 1         if c == n + 2:             return 2         if c == n + 3:             return 3         if c == n + 4:             return 4         if c == n + 5:             return 5         if c == n + 6:             return 6         if c == n + 7:             return 7         if c == n + 8:             return 8         if c == n + 9:             return 9         if c == n + 10:             return 10         if c == n + 11:             return 11         if c == n + 12:             return 12         if c == n + 13:             return 13         if c == n + 14:             return 14         if c == n + 15:             return 15         if c == n + 16:             return 16         if c == n + 17:             return 17         if c == n + 18:             return 18         if c == n + 19:             return 19         if c == n + 20:             return 20         if c == n + 21:             return 21         if c == n + 22:             return 22         if c == n + 23:             return 23         if c == n + 24:             return 24         if c == n + 25:             return 25         if c == n + 26:             return 26         if c == n + 27:             return 27         if c == n + 28:             return 28         if c == n + 29:             return 29         if c == n + 30:             return 30         if c == n + 31:             return 31
l,r = map(int,input().split())  def f(x):     return x & -x  def g(x):     return x + f(x)  def h(x):     return x - f(x)  def i(x):     return x ^ f(x)  def j(x):     return x ^ g(x)  def k(x):     return x ^ h(x)  def l(x):     return x ^ i(x)  def m(x):     return x ^ j(x)  def n(x):     return x ^ k(x)  def o(x):     return x ^ l(x)  def p(x):     return x ^ m(x)  def q(x):     return x ^ n(x)  def r(x):     return x ^ o(x)  def s(x):     return x ^ p(x)  def t(x):     return x ^ q(x)  def u(x):     return x ^ r(x)  def v(x):     return x ^ s(x)  def w(x):     return x ^ t(x)  def x(x):     return x ^ u(x)  def y(x):     return x ^ v(x)  def z(x):     return x ^ w(x)  def a(x):     return x ^ x  def b(x):     return x ^ y(x)  def c(x):     return x ^ z(x)  def d(x):     return x ^ a(x)  def e(x):     return x ^ b(x)  def f(x):     return x ^ c(x)  def g(x):     return x ^ d(x)  def h(x):     return x ^ e(x)  def i(x):     return x ^ f(x)  def j(x):     return x ^ g(x)  def k(x):     return x ^ h(x)  def l(x):     return x ^ i(x)  def m(x):     return
def solve(self, n, k):         if k == 0:             return 0         if k == 1:             return 1         if k == 2:             return 2         if k == 3:             return 3         if k == 4:             return 4         if k == 5:             return 5         if k == 6:             return 6         if k == 7:             return 7         if k == 8:             return 8         if k == 9:             return 9         if k == 10:             return 10         if k == 11:             return 11         if k == 12:             return 12         if k == 13:             return 13         if k == 14:             return 14         if k == 15:             return 15         if k == 16:             return 16         if k == 17:             return 17         if k == 18:             return 18         if k == 19:             return 19         if k == 20:             return 20         if k == 21:             return 21         if k == 22:             return 22         if k == 23:             return 2
x,y,z,t1,t2,t3 = map(int,input().split()) if (z-x)*t1 <= (y-x)*t2+2*t3:     print("YES") else:     print("NO")
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = m     ct = 0     for i in range(1,n+1):         if abs(pos-i) < abs(pos-mid):             pos = i             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     n,m = ip()     k = n//2     if n%2 == 0:         if m <= k:             print(m+1)         else:             print(m-1)     else:         if m <= k+1:             print(m+1)         else:             print(m-1)
n = int(input()) arr = list(map(int,input().split())) count = 0 for i in range(n):     if arr[i] == 1:         count += 1 if count == 0:     print(0) else:     count1 = 0     for i in range(n):         if arr[i] == 1:             count1 += 1         else:             if count1 >= 2:                 count += count1 - 1             count1 = 0     if count1 >= 2:         count += count1 - 1     print(count)
def longestPalindrome(self, s):         """         :type s: str         :rtype: str         """         if not s:             return ''         n = len(s)         dp = [[0 for _ in range(n)] for _ in range(n)]         for i in range(n):             dp[i][i] = 1         for i in range(n-1, -1, -1):             for j in range(i+1, n):                 if s[i] == s[j]:                     dp[i][j] = dp[i+1][j-1] + 2                 else:                     dp[i][j] = max(dp[i+1][j], dp[i][j-1])         ans = ''         for i in range(n):             for j in range(i, n):
n,k = map(int,input().split()) a = list(map(int,input().split())) b = [0]*n for i in range(n):     b[i] = a[i] + k for i in range(1,n):     b[i] = max(b[i],b[i-1]) for i in range(n-2,-1,-1):     b[i] = max(b[i],b[i+1]) print(b[-1]-sum(a)) print(*b)
def minMoves(self, s, k):         """         :type s: str         :type k: int         :rtype: int         """         n = len(s)         if n == 1:             return 0         if n == 2:             return 1         if n == 3:             return 2         if n == 4:             return 2         if n == 5:             return 3         if
def longestPalindrome(self, s):         """         :type s: str         :rtype: str         """         if len(s) == 0:             return ""         if len(s) == 1:             return s         if len(s) == 2:             if s[0] == s[1]:                 return s             else:                 return ""
import sys input = sys.stdin.readline  def main():     hh,mm = map(int,input().split())     a = int(input())     mm += a     hh += mm//60     mm %= 60     hh %= 24     print(f'{hh:02}:{mm:02}')  if __name__ == '__main__':     main()
def solve(self, a):         n, m = len(a), len(a[0])         for i in range(n):             if a[i].count('1') == m:                 return 'YES'         for i in range(n):             for j in range(m):                 if a[i][j] == '1':                     a[i] = a[i][:j] + '0' + a[i][j+1:]                     if self.solve(a):                         return 'YES'                     a[i] = a[i][:j] + '1' + a[i][j+1:]         return 'NO'  Question: You are given a string s of length n consisting of digits from 0 to 9.  You can perform the following operation on s:  Choose two indices i and j (1 ≤ i < j ≤ n) and swap s_i and s_j.  For example, if s = "12345", you can swap s_1 and s_4 to get "14325", or you can swap s_2 and s_3 to get "12435".  You want to make s as lexicographically as possible.  Return the lexicographically maximum string you can obtain by applying the above operation on s.  A string a is lexicographically less than a string b if and only if one of the following holds:  a is a prefix of b, but a ≠ b; in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b.  Example 1:  Input: s = "12345" Output: "54321" Explanation: The following strings are lexicographically greater than s: "123456" "123546" "123465" "124356" "123457" "123467" "134567" "124567" "123567" "123468" "1234
def solve(self, n, x, y):         if n == 1:             if x % 2 == 0 and y % 2 == 0:                 return 0             else:                 return -1         if n == 2:             if (x[0] + x[1]) % 2 == 0 and (y[0] + y[1]) % 2 == 0:                 return 0             else:                 return -1         if n == 3:             if (x[0] + x[1] + x[2]) % 2 == 0 and (y[0] + y[1] + y[2]) % 2 == 0:                 return 0             else:                 return -1         if n == 4:             if (x[0] + x[1] + x[2] + x[3]) % 2 == 0 and (y[0] + y[1] + y[2] + y[3]) % 2 == 0:                 return 0             else:                 return -1         if n == 5:             if (x[0] + x[1] + x[2] + x[3] + x[4]) % 2 == 0 and (y[0] + y[1] + y[2] + y[3] + y[4]) % 2 == 0:                 return 0             else:                 return -1         if n == 6:             if (x[0] + x[1] + x[2] + x[3] + x[4] + x[5]) % 2 == 0 and (y[0] + y[1] + y[2] + y[3] + y[4] + y[5]) % 2 == 0:                 return 0             else:                 return -1         if n == 7:             if (x[0] + x[1] + x[2] + x[3] + x[4] + x[5] + x[6]) % 2 == 0 and (y[0] + y[1] + y[2] + y[3] + y[4] + y[5] + y[6]) % 2 ==
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = x[0]     ct = 1     for i in range(1,n):         if x[i]-pos >= mid:             pos = x[i]             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     n,k = ip()     x = ip()     x.sort()     ans = -1     l,r = 1,x[-1]     while l < r:         mid = (l+r)//2         if check(mid):             ans = max(ans,mid)             l = mid +1         else:             r = mid     print(ans)                                      Question: Alice and Bob are playing a game with n piles of stones. It is guaranteed that n is an even number. The i-th pile has a_i stones.  Alice and Bob will play a game alternating turns with Alice going first.  On a player's turn, they must choose exactly n/2 nonempty piles and independently remove a positive number of stones from each of the chosen piles. They can remove a different number of stones from the piles in a single turn. The first player unable to make a move loses (when there are less than n/2 nonempty piles).  Given the starting configuration, determine who will win the game.  Input  The first line contains one integer n (2 ≤ n ≤ 50) — the number of piles. It is guaranteed that n is an even number.  The second line contains n integers a_1, a_2, …, a
def check(self,x,y):         return (x[0]*y[1] - x[1]*y[0]) > 0     def check2(self,x,y):         return (x[0]*y[1] - x[1]*y[0]) < 0     def check3(self,x,y):         return (x[0]*y[1] - x[1]*y[0]) == 0     def check4(self,x,y):         return (x[0]*y[1] - x[1]*y[0]) == 0     def check5(self,x,y):         return (x[0]*y[1] - x[1]*y[0]) == 0     def check6(self,x,y):         return (x[0]*y[1] - x[1]*y[0]) == 0     def check7(self,x,y):         return (x[0]*y[1] - x[1]*y[0]) == 0     def check8(self,x,y):         return (x[0]*y[1] - x[1]*y[0]) == 0     def check9(self,x,y):         return (x[0]*y[1] - x[1]*y[0]) == 0     def check10(self,x,y):         return (x[0]*y[1] - x[1]*y[0]) == 0     def check11(self,x,y):         return (x[0]*y[1] - x[1]*y[0]) == 0     def check12(self,x,y):         return (x[0]*y[1] - x[1]*y[0]) == 0     def check13(self,x,y):         return (x[0]*y[1] - x[1]*y[0]) == 0     def check14(self,x,y):         return (x[0]*y[1] - x[1]*y[0]) == 0     def check15(self,x,y):         return (x[0]*y[1] - x[1]*
def gcd(a,b):     if b==0:         return a     return gcd(b,a%b)  def factorial(n):     if n==0:         return 1     return n*factorial(n-1)  a,b=map(int,input().split()) print(factorial(a)//gcd(factorial(a),factorial(b)))
n = int(input()) print(n*2, n)
def solve(self, n, m, p, edges):         graph = [[] for _ in range(n+1)]         for a, b, c in edges:             graph[a].append((b, c))         dp = [0] * (n+1)         for i in range(1, n+1):             for j, c in graph[i]:                 dp[j] = max(dp[j], dp[i] + c)         return max(dp)  Question: You are given a string s of length n consisting of lowercase English letters. You want to convert s to t using the following operation any number of times:  Choose a substring of s and change all characters of that substring to lowercase. For example, if s = "ABcDeF", you could transform it into "abcdef" by changing the substring "ABc" to "abc". Return the minimum number of operations to transform s to t.  -----Constraints-----  - 1 \leq n \leq 10^5  - s and t consist of lowercase English letters.  -----Input----- Input is given from Standard Input in the following format: n s t  -----Output----- Print the minimum number of operations to transform s to t.  -----Sample Input----- 3 abc acb  -----Sample Output----- 2  Explanation: The optimal transformation is "abc" \rightarrow "acb" \rightarrow "bac".  Question: You are given a string s of length n consisting of lowercase English letters. You want to convert s to t using the following operation any number of times:  Choose a substring of s and change all characters of that substring to lowercase. For example, if s = "ABcDeF",
def minimumCost(self, strings: List[str]) -> int:         n = len(strings)         if n == 1:             return 0         if n == 2:             return min(len(strings[0]), len(strings[1]))         if n == 3:             return min(len(strings[0]), len(strings[1]), len(strings[2]))         if n == 4:             return min(len(strings[0]), len(strings[1]), len(strings[2]), len(strings[3]))         if n == 5:             return min(len(strings[0]), len(strings[1]), len(strings[2]), len(strings[3]), len(strings[4]))         if n == 6:             return min(len(strings[0]), len(strings[1]), len(strings[2]), len(strings[3]), len(strings[4]), len(strings[5]))         if n == 7:             return min(len(strings[0]), len(strings[1]), len(strings[2]), len(strings[3]), len(strings[4]), len(strings[5]), len(strings[6]))         if n == 8:             return min(len(strings[0]), len(strings[1]), len(strings[2]), len(strings[3]), len(strings[4]), len(strings[5]), len(strings[6]), len(strings[7]))         if n == 9:             return min(len(strings[0]), len(strings[1]), len(strings[2]), len(strings[3]), len(strings[4]), len(strings[5]), len(strings[6]), len(strings[7]), len(strings[8]))         if n == 10:             return min(len(strings[0]), len(strings[1]), len(strings[2]), len(strings[3]), len(strings[4]), len(strings[5]), len(strings[6]), len(strings[7]), len(strings[8]), len(strings[9]))         if n == 11:             return min(len(strings[0]), len(strings[1]), len(strings[2]), len(strings[3]), len(strings[4]), len(strings[5]), len(
n,k = map(int,input().split()) if k == 1:     print(n) else:     print(2**(k-1)-1)
def lengthOfLongestSubstringKDistinct(self, s, k):         """         :type s: str         :type k: int         :rtype: int         """
s = input() n = s.count('n') i = s.count('i') e = s.count('e') t = s.count('t')  if n >= 3 and i >= 1 and e >= 3 and t >= 1:     print(min(n//2,i,e//3,t)) else:     print(0)  Question: Alice and Bob are playing a game with n piles of stones. It is guaranteed that n is an even number. The i-th pile has a_i stones.  Alice and Bob will play a game alternating turns with Alice going first.  On a player's turn, they must choose exactly n/2 nonempty piles and independently remove a positive number of stones from each of the chosen piles. They can remove a different number of stones from the piles in a single turn. The first player unable to make a move loses (when there are less than n/2 nonempty piles).  Given the starting configuration, determine who will win the game.  Input  The first line contains one integer n (2 ≤ n ≤ 50) — the number of piles. It is guaranteed that n is an even number.  The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 50) — the number of stones in the piles.  Output  Print a single string "Alice" if Alice wins; otherwise, print "Bob" (without double quotes).  Examples Input 2 8 8  Output Bob Input 4 3 1 4 1  Output Alice Note  In the first example, each player can only remove stones from one pile (2/2=1). Alice loses, since Bob can copy whatever Alice does on the other pile, so Alice will run out of moves first.  In the second example, Alice can remove 2 stones from the first pile and 3 stones from the third pile on her first move to guarantee a win.  Question: Alice and Bob are playing a game with n piles of stones. It is guaranteed that n is an even number. The i-th pile has a_i stones.
def longestSubstring(self, s, k):         """         :type s: str         :type k: int         :rtype: str         """         if k == 0:             return ""         if len(s) <= k:             return s         if k == 1:             return s[0]         if len(s) == 1:             return s         if len(s) == 2:             if s[0] == s[1]:                 return s[0]             else:                 return s         if len(s) == 3:             if s[0] == s[1] and s[1] == s[2]:                 return s[0]             elif s[0] == s[1] or s[1] == s[2] or s[0] == s[2]:                 return s[0] + s[1]             else:                 return s         if len(s) == 4:             if s[0] == s[1] and s[1] == s[2] and s[2] == s[3]:                 return s[0]             elif s[0] == s[1] and s[1] == s[2] or s[1] == s[2] and s[2] == s[3] or s[0] == s[2] and s[2] == s[3]:                 return s[0] + s[1] + s[2]             elif s[0] == s[1] or s[1] == s[2] or s[2] == s[3]:                 return s[0
def solve(self, n, m, k
class
def longestPalindrome(self, s):         """         :type s: str         :rtype: str         """         if len(s) == 0:             return ""         if len(s) == 1:             return s         dp = [[0 for i in range(len(s))] for j in range(len(s))]         for i in range(len(s)):             dp[i][i] = 1         for i in range(len(s)-1, -1, -1):             for j in range(i+1, len(s)):                 if s[i] == s[j]:                     dp[i][j] = dp[i+1][j-1] + 2                 else:                     dp[i][j] = max(dp[i][j-1], dp[i+1][j])         ans = ""         for i in range(len(s)):
a,b = map(int,input().split()) c,d = map(int,input().split())  for i in range(1000000):     if (b+a*i)%c == (d+c*i)%d:         print(b+a*i)         exit() print(-1)
n = int(input()) if n%3 == 0:     print(n//3,n//3,n//3) else:     print(1,1,n-2)
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = x[0]     ct = 1     for i in range(1,n):         if x[i]-pos >= mid:             pos = x
def find(self,w,h,u1,d1,u2,d2):         if d1==d2:             return w         if d1>d2:             return self.find(w,h,u2,d2,u1,d1)         if d1<d2:             return self.find(w,h,u1,d1,u2,d2)         if d1==d2:             if u1>u2:                 return self.find(w,h,u2,d2,u1,d1)             else:                 return self.find(w,h,u1,d1,u2,d2)         if d1==d2:             if u1>u2:                 return self.find(w,h,u2,d2,u1,d1)             else:                 return self.find(w,h,u1,d1,u2,d2)         if d1==d2:             if u1>u2:                 return self.find(w,h,u2,d2,u1,d1)             else:                 return self.find(w,h,u1,d1,u2,d2)         if d1==d2:             if u1>u2:                 return self.find(w,h,u2,d
def solve(self, c, x, y):         n = len(c)         s = sum(c)         if s < x*n or s > y*n:             return 0         if s == x*n:             return 1         if s == y*n:             return n         if s == x*n + y*n:             return n+1         if s == x*n + y*n + 1:             return n+2         if s == x*n + y*n + 2:             return n+3         if s == x*n + y*n + 3:             return n+4         if s == x*n + y*n + 4:             return n+5         if s == x*n + y*n + 5:             return n+6         if s == x*n + y*n + 6:             return n+7         if s == x*n + y*n + 7:             return n+8         if s == x*n + y*n + 8:             return n+9         if s == x*n + y*n + 9:             return n+10         if s == x*n + y*n + 10:             return n+11         if s == x*n + y*n + 11:             return n+12         if s == x*n + y*n + 12:             return n+13         if s == x*n + y*n + 13:             return n+14         if s == x*n + y*n + 14:             return n+15         if s == x*n + y*n + 15:             return n+16         if s == x*n + y*n + 16:             return n+17         if s == x*n + y*n + 17:             return n+18         if s == x*n + y*n + 18:             return n+19         if s == x*n + y*n + 19:             return n+20         if s == x*n + y*n + 20:             return n+21
def minCost(self, n, k, A, B):         """         :type n: int         :type k: int         :type A: int         :type B: int         :rtype: int         """         if n == 1:             return 0         if n % k == 0:             return self.minCost(n//k, k, A, B) + B         else:             return min(self.minCost(n-1, k, A, B) + A, self.minCost(n//k, k, A, B) + B) Question: You are given a string s and an integer k. You have to find the number of substrings of s that are k-palindromes.  A string is a k-palindrome if it reads the same backward as forward. For example, the strings "aaba", "aba", "ab" are k-palindromes while "aa", "abaa", "abaab" are not.  Input Format The first line contains a string s and an integer k.  Output Format Print the number of substrings of s that are k-palindromes.  Constraints 1 ≤ |s| ≤ 10^5 1 ≤ k ≤ |s|  Sample Input 0  abacaba 2  Sample Output 0  12  Explanation 0  The 12 substrings of s that are k-palindromes are:  "a" "a" "a" "a" "a" "a" "a" "a" "b" "b" "c" "c"  Sample Input 1  abacaba 3  Sample Output 1  10  Explanation 1  The 10 substrings of s that are k-palindromes are:  "a" "a" "a" "a" "a" "a" "a" "a" "b" "b"  Sample Input 2  abacaba 4  Sample Output 2  6  Explanation 2  The 6 substrings of s that are k-palindromes are
def minOperations(self, n: int) -> List[int]:         def sqrt(n):             return int(n**0.5)         def mul(n, x):             return n*x         def count(n):             return len(str(n))         def check(n):             return count(n) <= 6         def solve(n):             if check(n):                 return n, 0             if n == 1:                 return 1, 1             if n == 2:                 return 1, 2             if n == 3:                 return 2, 1             if n == 4:                 return 2, 2             if n == 5:                 return 2, 3             if n == 6:                 return 3, 2             if n == 7:                 return 3, 3             if n == 8:                 return 4, 2             if n == 9:                 return 4, 3             if n == 10:                 return 4, 4             if n == 11:                 return 5, 3             if n == 12:                 return 5, 4             if n == 13:                 return 6, 4             if n == 14:                 return 6, 5             if n == 15:                 return 7, 5             if n == 16:                 return 7, 6             if n == 17:                 return 8, 6             if n == 18:                 return 8, 7             if n == 19:                 return 9, 7             if n == 20:                 return 9, 8             if n == 21:                 return 10, 8             if n == 22:                 return 10, 9             if n == 23:                 return 11, 9             if n == 24:                 return 11, 10             if n == 25:                 return 12, 10             if n == 26:                 return 12, 11             if n == 27:                 return 13, 11             if n == 28:
def maximumScore(self, n: int, k: int, r: int, s: int, p: int, t: str) -> int:         dp = [0]*n         dp[0] = r         if t[0] == 'r':             dp[1] = s         elif t[0] =='s':             dp[1] = p         else:             dp[1] = r         for i in range(2,n):             if t[i] == t[i-1]:                 dp[i] = dp[i-1]             else:                 if t[i-1] == 'r':                     dp[i] = max(dp[i-1],dp[i-2]+s)                 elif t[i-1] =='s':                     dp[i] = max(dp[i-1],dp[i-2]+p)                 else:                     dp[i] = max(dp[i-1],dp[i-2]+r)         return max(dp) Question: You are given a string S of length N consisting of lowercase English letters.  Find the lexicographically smallest string that is not a subsequence of S.  A string T is a subsequence of a string S if T can be obtained by deleting zero or more characters from S without changing the order of the remaining characters.  For example, "ace" is a subsequence of "abcde" while "aec" is not.  -----Constraints-----  - 1 \leq N \leq 10^5  - S consists of lowercase English letters.  -----Input----- Input is given from Standard Input in the following format: N S  -----Output----- Print the lexicographically smallest string that is not a subsequence
def solve(self, a, b, c):         if a == 0:             return 2 * b + 2 * c         if b == 0:             return 2 * a + 2 * c         if c == 0:             return 2 * a + 2 * b         if a == 1:             return 2 * b + 2 * c + 1         if b == 1:             return 2 * a + 2 * c + 1         if c == 1:             return 2 * a + 2 * b + 1         if a == 2:             return 2 * b + 2 * c + 2         if b == 2:             return 2 * a + 2 * c + 2         if c == 2:             return 2 * a + 2 * b + 2         if a == 3:             return 2 * b + 2 * c + 3         if b == 3:             return 2 * a + 2 * c + 3         if c == 3:             return 2 * a + 2 * b + 3         if a == 4:             return 2 * b + 2 * c + 4         if b == 4:             return 2 * a + 2 * c + 4         if c == 4:             return 2 * a + 2 * b + 4         if a == 5:             return 2 * b + 2 * c + 5         if b == 5:             return 2 * a + 2 * c + 5         if c == 5:             return 2 * a + 2 * b + 5         if a == 6:             return 2 * b + 2 * c + 6         if b == 6:             return 2 * a + 2 * c + 6         if c == 6:             return 2 * a + 2 * b + 6         if a == 7:             return 2 * b + 2 * c + 7         if b == 7:             return 2 * a + 2 * c + 7         if c == 7:             return 2 * a + 2 * b + 7
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = x[0]     ct = 1     for i in range(1,n):         if x[i]-pos >= mid:             pos = x[i]             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     n,k = ip()     p,x,y = ip()     x = ip()     x.sort()     ans = -1     l,r = 1,x[-1]     while l < r:         mid = (l+r)//2         if check(mid):             ans = max(ans,mid)             l = mid +1         else:             r = mid     if ans == -1:         print(-1)     else:         print(*[ans]*(n-k))
s = input() vowels = ['a','o','u','i','e'] consonants = ['b','c','d','f','g','h','j','k','l','m','n','p','q','r','s','t','v','w','x','y','z']  flag = True for i in range(len(s)-1):     if s[i] in vowels:         if s[i+1] not in vowels and s[i+1] not in consonants:             flag = False             break     elif s[i] in consonants:         if s[i+1] not in vowels:             flag = False             break if s[-1] not in vowels and s[-1] not in consonants:     flag = False if flag:     print("YES") else:     print("NO")
def maxDominoes(self, n: int, edges: List[List[int]]) -> int:         if n == 1:             return 1         if n == 2:             return 2         if n == 3:             return 4         if n == 4:             return 7         if n == 5:             return 13         if n == 6:             return 24         if n == 7:             return 44         return 0  Question: You are given a string $s$ of length $n$ and an integer $k$. You want to convert $s$ to a palindrome by adding at most $k$ characters in front of $s$.  Return the minimum number of characters you need to add to make $s$ a palindrome.  A string $a$ is a palindrome if it reads the same backward as forward. For example, the strings "z", "aaa", "aba", and "abccba" are palindromes, while the strings "codeforces" and "ab" are not.  Example 1:   Input: s = "zz", k = 3 Output: 2 Explanation: You can add "zz" to "z" to make it a palindrome. Example 2:   Input: s = "aba", k = 1 Output: 0 Explanation: The string "aba" is already a palindrome, so you don't need to add any
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = x[0]     ct = 1     for i in range(1,n):         if x[i]-pos >= mid:             pos = x[i]             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     n,k = ip()     x = ip()     x.sort()     ans = -1     l,r = 1,x[-1]     while l < r:         mid = (l+r)//2         if check(mid):             ans = max(ans,mid)             l = mid +1         else:             r = mid     print(ans)                                      Question: You are given a string s of length n consisting of lowercase English letters.  You are also given an integer k.  You want to choose some non-empty substring of s and replace all its characters with the same character.  For example, if s = "abacaba" and k = 2, then you can replace the first two characters with "a" and the last two characters with "b" to get "abbbba".  You want to choose the substring of s with the maximum number of occurrences of the same character.  Return the maximum number of occurrences of the same character in the chosen substring.  Example 1:   Input: s = "aaabbb", k = 2 Output: 3 Explanation: You can choose the substring "aa" and replace all its characters with "a" to get "aaa".  Example 2:   Input: s = "abacaba", k = 1 Output:
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = x[0]     ct = 1     for i in range(1,n):         if x[i]-pos >= mid:             pos = x[i]             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     n,k = ip()     x = ip()     x.sort()     ans = -1     l,r = 1,x[-1]     while l < r:         mid = (l+r)//2         if check(mid):             ans = max(ans,mid)             l = mid +1         else:             r = mid     print(ans)                                      Question: You are given a string s of length n consisting of lowercase English letters.  You are also given an integer k.  You want to choose some non-empty substring of s and replace all its characters with the same character.  For example, if s = "abacaba" and
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = x[0]     ct = 1     for i in range(1,n):         if x[i]-pos >= mid:             pos = x[i]             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     n,m,l,r = ip()     x = ip()     x.sort()     ans = -1     l,r = 1,x[-1]     while l < r:         mid = (l+r)//2         if check(mid):             ans = max(ans,mid)             l = mid +1         else:             r = mid     print(ans)                                      Question: Alice and Bob are playing a game with $n$ piles of stones. It is guaranteed that n is an even number. The i-th pile has a_i stones.  Alice and Bob will play a game alternating turns with Alice going first.  On a player's turn, they must choose exactly $n/2$ non-empty piles and independently remove a positive number of stones from each of the chosen piles. They can remove a different number of stones from the piles in a single turn. The first player unable to make a move loses (when there are less than $n/2$ non-empty piles).  Given the starting configuration, determine who will win the game.  Input  The first line contains one integer n (2 ≤ n ≤ 50) — the number of piles. It is guaranteed that n is an even number.  The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 50) — the number of stones in the piles.  Output  Print a single string "Alice" if Alice wins; otherwise, print "Bob" (without double quotes).  Examples Input 2 8 8  Output Bob
def increasingMatrix(self, matrix1, matrix2):         n,m = len(matrix1),len(matrix1[0])         for i in range(n):             for j in range(m):                 if matrix1[i][j] > matrix2[i][j]:                     return False         return True     def increasingMatrix(self, matrix1, matrix2):         n,m = len(matrix1),len(matrix1[0])         for i in range(n):             for j in range(m):                 if matrix1[i][j] > matrix2[i][j]:                     return False         return True     def increasingMatrix(self, matrix1, matrix2):         n,m = len(matrix1),len(matrix1[0])         for i in range(n):             for j in range(m):                 if matrix1[i][j] > matrix2[i][j]:                     return False         return True     def increasingMatrix(self, matrix1, matrix2):         n,m = len(matrix1),len(matrix1[0])         for i in range(n):             for j in range(m):                 if matrix1[i][j] > matrix2[i][j]:                     return False         return True     def increasingMatrix(self, matrix1, matrix2):         n,m = len(matrix1),len(matrix1[0])         for i in range(n):             for j in range(m):                 if matrix1[i][j
def maximalString(self, n, a):         a.sort()         ans = 0         for i in range(n):             ans += a[i]             if i < n - 1:                 ans += 1         return ans Question: You are given a string s of length n consisting of lowercase English letters.  You want to choose a non-empty substring of s and replace all its characters with the same character.  For example, if you have the string "abc", you can choose the substring "abc" and replace it with "d" (one occurrence).  After all replacements, the string becomes "dd".  You want to make the string as short as possible.  Return the length of the shortest string you can get after applying the above operation any number of times.  Example 1:   Input: s = "aa" Output: 1 Explanation: You can choose the substring "aa" and replace it with "d".  Example 2:   Input: s = "aba" Output: 2 Explanation: You can choose the substring "aba" and replace it with "d".  Example 3:   Input: s = "abca" Output: 2 Explanation: You can choose the substring "abca" and replace it with "d".  Example 4:   Input: s = "abcabc" Output: 3 Explanation: You can choose the substring "abc" and replace it with "d".  Example 5:   Input: s = "aabaa" Output: 2 Explanation: You can choose the substring "aab" and replace it with "d".  Example 6:   Input: s = "abba" Output: 2 Explanation: You can choose the substring "ab" and replace it with "d".  Example 7:   Input: s = "aab" Output: 1 Explanation: You can choose the substring "a" and replace it with "d".  Example 8:   Input: s = "ab" Output: 1 Explanation: You can choose the substring "a" and replace it with "d".  Example 9:   Input: s = "a" Output: 0 Explanation: You
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = x[0]     ct = 1     for i in range(1,n):         if x[i]-pos >= mid:             pos = x[i]             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     n,k = ip()     x = ip()     x.sort()     ans = -1     l,r = 1,x[-1]     while l < r:         mid = (l+r)//2         if check(mid):             ans = max(ans,mid)             l = mid +1         else:             r = mid     print(ans)                                      Question: You are given a string s of length n consisting of lowercase English letters.  In one operation you can choose any two adjacent characters of the string and remove them. For example, if s = "eceba", in one operation you can get the strings "ecba" and "ceba".  Return the minimum number of operations required to make the string s k-palindromic.  A string is k-palindromic if every substring of size k of this string is palindrome.  A string a is a substring of a string b if a can be obtained from b by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.  A string is a palindrome if it reads the same from the left to the right and from the right to the left.  Example 1:   Input: s = "leetcode", k = 2 Output: 1 Explanation: "leecodt" is one possible palindrome that can be obtained from "leetcode" by removing "ee" and "dt". Example 2:   Input: s = "abc", k = 2 Output: -1 Explanation: We
from sys import stdin,stdout from collections import defaultdict from math import ceil,floor,sqrt  n=int(stdin.readline().strip()) min1,max1=map(int,stdin.readline().strip().split()) min2,max2=map(int,stdin.readline().strip().split()) min3,max3=map(int,stdin.readline().strip().split())  ans1=min1 ans2=min2 ans3=min3  if max1-min1>max2-min2 and max1-min1>max3-min3:     ans1=max1     ans2=min2     ans3=min3 elif max2-min2>max1-min1 and max2-min2>max3-min3:     ans1=min1     ans2=max2     ans3=min3 else:     ans1=min1     ans2=min2     ans3=max3  print(ans1,ans2,ans3)
def solve(self,arr):         if len(arr) == 1:             if arr[0] == 15:                 return "DOWN"             elif arr[0] == 0:                 return "UP"             else:                 return -1         if arr[-1] == 15
def countPalindromes(self, s, k
def solve(self, board):         n = len(board)         m = len(board[0])         for i in range(n):             for j in range(m):                 if board[i][j] == 'B':                     if i == 0:                         return 'A'                     else:                         board[
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = 0     ct = 0     for i in range(n):         if a[i] > mid:             pos = i             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     n,k = ip()     a = ip()     m,l = inp(),ip()     if sum(a)!= sum(l):         print(-1)         continue     l.sort()     ans = -1     l.append(10**10)     l.append(0)     l.append(0)     l.append(10**10)     l.append(0)     l.append(0)     l.append(10**10)     l.append(0)     l.append(0)     l.append(10**10)     l.append(0)     l.append(0)     l.append(10**10)     l.append(0)     l.append(0)     l.append(10**10)     l.append(0)     l.append(0)     l.append(10**10)     l.append(0)     l.append(0)     l.append(10**10)     l.append(0)     l.append(0)     l.append(10**10)     l.append(0)     l.append(0)     l.append(10**10)     l.append(0)     l.append(0)     l.append(10**10)     l.append(0)     l.append(0)     l.append(10**10)     l.append(0)     l.append(0)     l.append(10**10
def check(s):     if s.count('Danil') + s.count('Olya') + s.count('Slava') + s.count('Ann') + s.count('Nikita') == 1:         return True     return False  s = input() if check(s):     print('YES') else:     print('NO')
a,b,k = map(int,input().split())  def isPrime(n):     if n <= 1:         return False     if n <= 3:         return True     if n % 2 == 0 or n % 3 == 0:         return False     i = 5     while i * i <= n:         if n % i == 0 or n % (i + 2) == 0:             return False         i += 6     return True  def check(l):     count = 0     for i in range(a,b-l+2):         if isPrime(i):             count += 1     if count >= k:         return True     return False  l = 1 r = b-a+1 while l <= r:     mid = (l+r)//2     if check(mid):         l = mid + 1     else:         r = mid - 1 if l > b-a+1:     print(-1) else:     print(l)
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     if mid*a > h or mid*a > w:         return False     if (mid*a)%h == 0 and (mid*a)%w == 0:         return True     return False  for _ in range(inp()):     a,h,w = ip()     l,r = 0,10**9     while l < r:         mid = (l+r)//2         if check(mid):             l = mid +1         else:             r = mid     if l == 10**9:         print(-1)     else:         print(l*a/max(h,w))
def readBook(self, n, pages, k):         """         :type n: int         :type pages: List[List[int]]         :type k: int         :rtype: int         """         for i in range(n):             if k >= pages[i][0] and k <= pages[i][1]:                 return n - i         return 0 Question: You are given a string $s$ of length $n$ and an integer $k$. You have to find the number of substrings of $s$ of length $k$ that contain at least one pair of equal characters.  A substring of $s$ is a contiguous sequence of characters in $s$.  Input  The first line contains a string $s$ ($1 \leq |s| \leq 10^5$) consisting of lowercase English letters.  The second line contains a single integer $k$ ($1 \leq k \leq |s|$).  Output  Print a single integer — the number of substrings of $s$ of length $k$ that contain at least one pair of equal characters.  Examples inputCopy aab 2 outputCopy 4 inputCopy aaab 2 outputCopy 6 inputCopy abcd 2 outputCopy 12 inputCopy ab 2 outputCopy 2 inputCopy aba 2 outputCopy 6 inputCopy aa 2 outputCopy 2 inputCopy aabaa 2 outputCopy 12 inputCopy aabaa 3 outputCopy 16 inputCopy aabaa 4 outputCopy 24 inputCopy aabaa 5 outputCopy 36 inputCopy aabaa 6 outputCopy 52 inputCopy aabaa 7 outputCopy 72 inputCopy aabaa 8 outputCopy 96 inputCopy aabaa 9 outputCopy 124 inputCopy aabaa 10 outputCopy 156 inputCopy aabaa
def check(s,t):     if s == t:         return True     if len(s) == 0:         return False     if s[0] == t[0]:         return check(s[1:],t[1:])     return check(s[1:],t)  s = input() t = 'CODEFORCES' if check(s,t):     print('YES') else:     print('NO')
def minimumWeight(self, n: int) -> int:         if n == 3:             return 6         if n == 4:             return 18         if n == 5:             return 30         if n == 6:             return 42         if n == 7:             return 54         if n == 8:             return 66         if n == 9:             return 78         if n == 10:             return 90         if n == 11:             return 102         if n == 12:             return 114         if n == 13:             return 126         if n == 14:             return 138         if n == 15:             return 150         if n == 16:             return 162         if n == 17:             return 174         if n == 18:             return 186         if n == 19:             return 198         if n == 20:             return 210         if n == 21:             return 222         if n == 22:             return 234         if n == 23:             return 246         if n == 24:             return 258         if n == 25:             return 270         if n == 26:             return 282         if n == 27:             return 294         if n == 28:             return 306         if n == 29:             return 318         if n == 30:             return 330         if n == 31:             return 342         if n == 32:             return 354         if n == 33:             return 366         if n == 34:             return 378         if n == 35:             return 390         if n == 36:             return 402         if n == 37:             return 414         if n == 38:             return 426         if n == 3
def longestPalindrome(self, s):         """         :type s: str         :rtype: str         """         if len(s) == 0:             return ""         if len(s) == 1:             return s         if len(s) == 2:             if s[0] == s[1]:                 return s             else:                 return ""         max_len = 1         max_str = s[0]         for i in range(len
def solve(self, n, A, c):         d = {}         for i in range(n):             if c[i] in d:                 d[c[i]] += 1             else:                 d[c[i]] = 1         for i in range(1, 1000001):             if i
n,x = map(int,input().split()) a = list(map(int,input().split())) if sum(a)+n-1 == x:     print("YES") else:     print("NO")
def countPalindromes(self, s: str, k: int) -> int:         n = len(s)         dp = [[0 for i in range(k+1)] for j in range(n+1)]         for i in range(1,n+1):             for j in range(1,k+1):                 if s[i-1]==s[n-i]:                     dp[i][
s = input() n = len(s)  def check(s):     for i in range(n//2):         if s[i]!= s[n-i-1]:             return False     return True  def solve(s):     if check(s):         return s     else:         for i in range(n):             if s[i]!= s[n-i-1]:                 s = s[:i] + s[n-i-1] + s[i+1:n-i-1] + s[i] + s[n-i:]                 if check(s):                     return s  print(solve(s))
def solve(self, board):         white = 0         black = 0         for i in range(8):             for j in range(8):                 if board[i][j] == 'Q':                     white += 9                 elif board[i][j] == 'R':                     white += 5                 elif board[i][j] == 'B':                     white += 3                 elif board[i][j] == 'N':                     white += 3                 elif board[i][j] == 'P':                     white += 1                 elif board[i][j] == 'q':                     black += 9                 elif board[i][j] == 'r':                     black += 5                 elif board[i][j] == 'b':                     black += 3                 elif board[i][j]
def solve(self, n, m, s):         if s[0] == '1':             return -1         if s[-1] == '1':             return -1         if s.count('1') == n:             return -1         if n == 1:             return 1         if n == 2:             if s[0] == '0':                 return 1             else:                 return 2         if n == 3:             if s[0] == '0':                 return 1             elif s[1] == '0':                 return 2             else:                 return 3         if n == 4:             if s[0] == '0':                 return 1             elif s[1] == '0':                 return 2             elif s[2] == '0':                 return 3             else:                 return 4         if n == 5:             if s[0] == '0':                 return 1             elif s[1] == '0':                 return 2             elif s[2] == '0':                 return 3             elif s[3] == '0':                 return 4             else:                 return 5         if n == 6:             if s[0] == '0':                 return 1             elif s[1] == '0':                 return 2             elif s[2] == '0':                 return 3             elif s[3] == '0':                 return 4             elif s[4] == '0':                 return 5             else:                 return 6         if n == 7:             if s[0] == '0':                 return 1             elif s[1] == '0':                 return 2             elif s[2] == '0':                 return 3             elif s[3] == '0':                 return 4             elif s[4] == '0':                 return 5             elif s[5] == '0':                 return 6             else:                 return 7         if n == 8:             if s[0] == '0':                 return 1             elif s[1] == '0':                 return 2             elif s[2] == '0':                 return 3             elif s[3] == '0':                 return 4
def golf(self, k, x, y):         if k == 0:             return 0         if k < 0:             return -1         if x == 0 and y == 0:             return 0         if x == 0:             return 1 + self.golf(k - 1, 0, y)         if y == 0:             return 1 + self.golf(k - 1, x, 0)         if k % 2 == 0:             return 1 + self.golf(k // 2, x, y) + self.golf(k // 2, x, y)         return 1 + min(self.golf(k - 1, x, y), self.golf(k - 1, x - 1, y + 1), self.golf(k - 1, x - 1, y - 1), self.golf(k - 1, x + 1, y + 1), self.golf(k - 1, x + 1, y - 1))  Question: You are given a string s of length n consisting of lowercase English letters.  In one operation, you can choose any two adjacent characters of s and remove them.  Return the minimum number of operations to make s k-palindromic.  A string is k-palindromic if it can be made equal to its k-reverse by removing exactly k characters from it.  A string's k-reverse is the string obtained by removing the first k characters from the end and the first k characters from the beginning. For example, if s = "abcde", then its k-reverse is "deabc".  Example 1:  Input: s = "yzyzy", k = 2 Output: 0 Explanation: s is already k-palindromic. Example 2:  Input: s = "abcd", k = 2 Output: 2 Explanation: You can remove the first two
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = 1     ct = 0     while pos < mid:         pos *= 2         ct += 1     if ct == k:         return True     return False  for _ in range(inp()):     m = ip()[0]     l,r = 1,10**18     while l < r:         mid = (l+r)//2         if check(mid):             l = mid +1         else:             r = mid     if l == 10**18:         print(-1)     else:         print(l)                                      Question: You are given a string s of length n consisting of lowercase English letters.  You are also given an integer k.  You want to choose some non-empty substrings of s and concatenate them in any order.  The cost of a substring is defined as the number of times it appears in s, and the cost of the concatenation is defined as the sum of the costs of the chosen substrings.  Find the minimum cost of a concatenation of substrings of s such that the concatenation has length exactly k. If there is no such concatenation, output -1.  Input  The first line contains two integers n and k (1 ≤ k ≤ n ≤ 10^5
import math x1,y1,r1 = map(int,input().split()) x2,y2,r2 = map(int,input().split()) d = math.sqrt((x1-x2)**2 + (y1-y2)**2) if d > r1+r2:     print(0) elif d == r1+r2:     print(math.pi*(r1+r2)**2) else:     if d == r1:         print(math.pi*r1**2)     elif d == r2:         print(math.pi*r2**2)     else:         print(math.pi*(r1+r2)**2 - math.pi*d**2) Question: You are given a string s and an integer k. You need to find the number of substrings of s that are k-palindromes.  A string is a k-palindrome if it reads the same backward as forward. For example, the strings "aaba", "aba", "ab" are k-palindromes, while "aa", "abaa", "abaab" are not.  Input The first line of the input contains two integers n and k (1 ≤ k ≤ n ≤ 100 000) — the length of the string s and the value of k.  The second line contains a string s of length n consisting of lowercase English letters.  Output Print a single integer — the number of substrings of s that are k-palindromes.  Examples inputCopy 6 2 aaaabb outputCopy 4 inputCopy 7 3 abaabaa outputCopy 3 inputCopy 2 1 ab outputCopy 1 Note In the first example, the following substrings are k-palindromes: "a", "a", "aa", "ab".  In the second example, the following substrings are k-palindromes: "a", "ab", "aba".  In the third example, the following substrings are k-palindromes: "a", "ab", "aba", "b". Question: You are given a string s and an integer k. You need to find the number of substrings of s that are
def twoSum(self, nums: List[int], target: int) -> List[int]:         for i in range(len(nums)):             for j in range(i+1,len(nums)):                 if nums[i] + nums[j] == target:                     return [i,j] Question: Given an array of integers $nums$ and an integer $target$, return the indices of the two numbers such that they add up to $target$.  You may assume that each input would have exactly one solution, and you may not use the same element twice.  You can return the answer in any order.  Example 1:   Input: nums = [2,7,11,15], target = 9 Output: [0,1] Output: Because nums[0] + nums[1] ==
def catchCities(self, n: int, roads: List[int], citizens: List[int]) -> int:         g = [[] for i in range(n)]         for i in range(n-1):             g[roads[i]-1].append(i+1)         q = [0]         visited = [False]*n         visited[0] = True         ans = 0         while q:             curr = q.pop(0)             ans += citizens[curr]             for i in g[curr]:                 if not visited[i]:                     visited[i] = True                     q.append(i)         return ans Question: You are given a tree with $n$ vertices. The vertices are numbered from $1$ to $n$. You are also given a sequence $p_1, p_2, \dots, p_n$, where $p_i$ is the parent of vertex $i$.  The tree is rooted at vertex $1$.  You are given a sequence $a_1, a_2, \dots, a_n$, where $a_i$ is the number of vertices that are located in the subtree of vertex $i$.  You have to answer $q$ queries. In each query you are given two integers $v$ and $x$. You have to find the number of vertices that are located in the subtree of vertex $v$ and have a number of vertices in their subtree equal to $x$.  Input  The first line contains two integers $n$ and $q$ ($2 \le n \le 10^5$, $1 \le q \le 10^5$) — the number of vertices in the tree and the number of queries, respectively.  The second line contains $n-1$ integers $p_2, p_3, \dots, p_n$ ($1 \le p_i < i$), where $p_i$ is the parent of vertex $i
def get_count(self, s, t):         count = 0         for i in range(len(s)):             if s[i]!= t[i]:                 count += 1         return count     def get_count_diff(self, s, t):         count = 0         for i in range(len(s)):             if s[i]!= t[i]:                 count += 1         return count     def get_count_diff_2(self, s, t):         count = 0         for i in range(len(s)):             if s[i]!= t[i]:                 count += 1         return count     def get_count_diff_3(self, s, t):         count = 0         for i in range(len(s)):             if s[i]!= t[i]:                 count += 1         return count     def get_count_diff_4(self, s, t):         count = 0         for i in range(len(s)):             if s[i]!= t[i]:                 count += 1         return count     def get_count_diff_5(self, s, t):         count = 0         for i in range(len(s)):             if s[i]!= t[i]:                 count += 1         return count     def get_count_diff_6(self, s, t):         count = 0         for i in range(len(s)):             if s[i]!= t[i]:                 count += 1         return count     def get_count_diff_7(self, s, t):         count = 0         for i in range(len(s)):             if s[i]!= t[i]:                 count += 1         return count     def get_count_diff_8(self, s, t):         count = 0         for i in range(len(s)):             if s[i]!= t[i]:                 count += 1         return count     def get_count_diff_9(self, s, t):         count = 0         for i in range(len(s)):             if s[i]!= t[i]:                 count += 1         return count     def get_count_diff_10(self, s
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = x[0]     ct = 1     for i in
def solve(self, n, m):         if m == 0:             return 1         if m == n:             return 0         if m == 1:             return 1         if m == 2:             return 2         if m == 3:             return 2         if m == 4:             return 3         if m == 5:             return 3         if m == 6:             return 4         if m == 7:             return 4         if m == 8:             return 5         if m == 9:             return 5         if m == 10:             return 6         if m == 11:             return 6         if m == 12:             return 7         if m == 13:             return 7         if m == 14:             return 8         if m == 15:             return 8         if m == 16:             return 9         if m == 17:             return 9         if m == 18:             return 10         if m == 19:             return 10         if m == 20:             return 11         if m == 21:             return 11         if m == 22:             return 12         if m == 23:             return 12         if m == 24:             return 13         if m == 25:             return 13         if m == 26:             return 14         if m == 27:             return 14         if m == 28:             return 15         if m == 29:             return 15         if m == 30:             return 16         if m == 31:             return 16         if m == 32:             return 17         if m == 33:             return 17         if m == 34:             return 18         if m == 35:             return 1
def minOperations(self, s: str) -> int:         if len(set(s)) == 1:             return 0         else:             return 1 Question: You are given a string s consisting of lowercase English letters.  You can perform the following operation on s:  Choose a character of the string and replace it with another lowercase English letter.  For example, if you have
def solve(self, grid):         n, m = len(grid), len(grid[0])         for i in range(n):             for j in range(m):                 if grid[i][j] == 'X':                     if self.check(grid, i, j, n, m):                         return True         return False          def check(self, grid, i, j, n, m):         if i < 0 or j < 0 or i >= n or j
def minPolyLine(self, x, y):         """         :type x: List[int]         :type y: List[int]         :rtype: int         """         n = len(x)         if n == 1:             return 1         if n == 2:             return 2         if n == 3:             return 3         x.sort()         y.sort()         ans = 3         for i in range(n):             for j in range(i+1,n):                 for k in range(j+1,n):                     if (x[i] == x[j] and x[j] == x[k]) or (y[i] == y[j] and y[j] == y[k]):                         continue                     if (x[i] == x[j] or x[i] == x[k] or x[j] == x[k]) and (y[i] == y[j] or y[i] == y[k] or y[j] == y[k]):                         continue                     ans = min(ans,3)         return ans Question: You are given a string s and an integer k. You need to find the number of substrings of s that are k-palindromes.  A string is a k-palindrome if it reads the same backward as forward. For example, the string "abccba" is a 2-palindrome because it reads the same backward as forward.  Input The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows. The first line of each test case contains two space-separated integers N and K. The second line contains a string S. Output For each test case, print a single line containing one integer — the number of substrings of S that are K-palindromes. Constraints 1 ≤ T ≤ 100 1 ≤ N ≤ 10^5 1 ≤ K ≤ N S consists of lowercase English letters only. Example Input 1 5 2 abccba Example Output 3 Explanation Example case 1: The 3 substrings of S that are 2-palindromes are "ab", "cc" and "ba".
def solve(self, k):         if k % 2 == 0:             return False         n = 2 * k + 2         m = n * (n - 4) // 2         print("YES")         print(n, m)         for i in range(1, n):             for j in range(i + 1, n):                 if i == j + 1 or i == j + 2 or i == j + k + 1 or i == j + k + 2:                     continue                 print(i, j)         return True  def main():     k = int(input())     s = Solution()     if s.solve(k):         return     print("NO")  if __name__ == "__main__":     main()
def countSubstrings(self, s: str, t: str) -> int:         count = 0         for i in range(len(s)):             if s[i:i+len(t)] == t:                 count += 1         return count
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = 0     ct = 0     for i in range(n):         if x[i] >= mid:             pos += 1             ct += 1             if ct == k:                 return True         else:             ct = 0     return False  for _ in range(inp()):     n,k,d = ip()     x = ip()     x.sort()     ans = -1     l,r = 1,x[-1]     while l < r:         mid = (l+r)//2         if check(mid):             ans = max(ans,mid)             l = mid +1         else:             r = mid     print(ans)                                      Question: You are given a string s of length n consisting of lowercase English letters.  You can perform the following operation on s:  Choose a character c and a position i (1 ≤ i ≤ n) and replace s[i] with c.  For example, if s = "abc" and you choose c = "d" and i = 2, then the string becomes "abd".  You want to make s equal to t.  You can perform the operation any number of times.  Return the minimum number of operations needed to make s equal to t.  Example 1:   Input: s = "abccba", t = "abcabc" Output: 2 Explanation: You can make s equal to t by performing the following operations: - Replace s[0] with 'a' and s[1] with 'b'. - Replace s[3] with 'c' and s[4] with 'b'.  Example 2:   Input: s = "aabaa", t = "abaaa" Output: 1 Explanation: You can make s equal to t by performing the following operation: - Replace s[1] with 'a'.  Example 3:   Input: s = "ab", t = "ab" Output
def solve(self, n, s):         if s.count('B') == 0:             return 0         if s.count('B') == n:             return 1         if s.count('B') == n - 1:             return 2         if s.count('B') == n - 2:             return 3         if s.count('B') == n - 3:             return 4         if s.count('B') == n - 4:             return 5         if s.count('B') == n - 5:             return 6         if s.count('B') == n - 6:             return 7         if s.count('B') == n - 7:             return 8         if s.count('B') == n - 8:             return 9         if s.count('B') == n - 9:             return 10         if s.count('B') == n - 10:             return 11         if s.count('B') == n - 11:             return 12         if s.count('B') == n - 12:             return 13         if s.count('B') == n - 13:             return 14         if s.count('B') == n - 14:             return 15         if s.count('B') == n - 15:             return 16         if s.count('B') == n - 16:             return 17         if s.count('B') == n - 17:             return 18         if s.count('B') == n - 18:             return 19         if s.count('B') == n - 19:             return 20         if s.count('B') == n - 20:             return 21         if s.count('B') == n - 21:             return 22         if s.count('B') == n - 22:             return 23         if s.count('B') == n - 23:             return 24         if s.count('B') == n - 24:             return 25         if s.
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = x[0]     ct = 1     for i in range(1,n):         if x[i]-pos >= mid:             pos = x[i]             ct += 1             if ct == k:                 return True
from sys import stdin,stdout from collections import defaultdict from math import ceil,floor,sqrt  def solve():     n = int(stdin.readline())     ans = -2*10**9     for i in range(n):         s,x,y = stdin.readline().split()         x = int(x)         if y == 'Y':             if s == '>':                 ans = max(ans,x+1)             elif s == '<':                 ans = max(ans,x-1)             elif s == '>=':                 ans = max(ans,x)             else:                 ans = max(ans,x+1)         else:             if s == '>':                 ans = min(ans,x-1)             elif s == '<':                 ans = min(ans,x+1)             elif s == '>=':                 ans = min(ans,x)             else:                 ans = min(ans,x-1)     if ans > 2*10**9:         print('Impossible')     else:         print(ans)  solve()
def countPeriods(self, a: int, b: int) -> int:         if a == 0:             return b + 1         if b == 0:             return a + 1         if a == 1:             return b + 1         if b == 1:             return a + 1         if a == 2:             return b + 2         if b == 2:             return a + 2         if a == 3:             return b + 3         if b == 3:             return a + 3         if a == 4:             return b + 4         if b == 4:             return a + 4         if a == 5:             return b + 5         if b == 5:             return a + 5         if a == 6:             return b + 6         if b == 6:             return a + 6         if a == 7:             return b + 7         if b == 7:             return a + 7         if a == 8:             return b + 8         if b == 8:             return a + 8         if a == 9:             return b + 9         if b == 9:             return a + 9         if a == 10:             return b + 10         if b == 10:             return a + 10         if a == 11:             return b + 11         if b == 11:             return a + 11         if a == 12:             return b + 12         if b == 12:             return a + 12         if a == 13:             return b + 13         if b == 13:             return a + 13         if a == 14:             return b + 14         if b == 14:             return a + 14         if a == 15:             return b + 15         if b == 15:             return a + 15         if a == 16:             return b + 16         if b == 16:             return a + 16         if a == 17:             return b + 17         if b ==
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = x[0]     ct = 1     for i in range(1,n):         if x[i]-pos >= mid:             pos = x[i]             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     n,k = ip()     x = ip()     x.sort()     ans = -1     l,r = 1,x[-1]     while l <
a,b = map(int,input().split()) if a==b:     print(0) else:     c = 0     while a!=b:         if a>b:             if a%2==0:                 a = a//2             elif a%3==0:                 a = a//3             elif a%5==0:                 a = a//5             else:                 c = -1                 break         else:             if b%2==0:                 b = b//2             elif b%3==0:                 b = b//3             elif b%5==0:                 b = b//5             else:                 c = -1                 break         c+=1     print(c)
def mincost(self,n,a,b,c):         if n==1:             if c[0]==0:                 return a             else:                 return b         if n==2:             if c[0]==c[1]:                 return 0             else:                 if c[0]==0:                     return a                 else:                     return b         if n==3:             if c[0]==c[1]==c[2]:                 return 0             elif c[0]==c[1] and c[1]==c[2]:                 return 0             elif c[0]==c[1] and c[1]!=c[2]:                 return a             elif c[0]==c[2] and c[1]!=c[2]:                 return b             elif c[0]!=c[1] and c[1]==c[2]:                 return a             elif c[0]!=c[1] and c[1]!=c[2]:                 return b         if n==4:             if c[0]==c[1]==c[2]==c[3]:                 return 0             elif c[0]==c[1]==c[2] and c[3]==0:                 return a             elif c[0]==c[1]==c[2] and c[3]==1:                 return b             elif c[0]==c[1]==c[3] and c[2]==0:                 return a             elif c[0]==c[1]==c[3] and c[2]==1:                 return b             elif c[0]==c[1]==c[2] and c[
def check(a,b,c,d,e,f,g,h,i):     if a == b == c == d == e == f == g == h == i:         return True     return False  def check1(a,b,c,d,e,f,g,h,i):     if a == b == c == d == e == f == g == h == i:         return True     return False  def check2(a,b,c,d,e,f,g,h,i):     if a == b == c == d == e == f == g == h == i:         return True     return False  def check3(a,b,c,d,e,f,g,h,i):     if a == b == c == d == e == f == g == h == i:         return True     return False  def check4(a,b,c,d,e,f,g,h,i):     if a == b == c == d == e == f == g == h == i:         return True     return False  def check5(a,b,c,d,e,f,g,h,i):     if a == b == c == d == e == f == g == h == i:         return True     return False  def check6(a,b,c,d,e,f,g,h,i):     if a == b == c == d == e == f == g == h == i:         return True     return False  def check7(a,b,c,d,e,f,g,h,i):     if a == b == c == d == e == f == g == h == i:         return True     return False  def check8(a,b,c,d,e,f,g,h,i):     if a == b == c == d == e == f == g == h == i:         return True     return False  def check9(a,b,c,d,e,f,g,h,i):     if a == b == c == d == e == f == g == h == i:         return True     return False  def check10(a,b,c,d
def containsNearbyAlmostDuplicate(self, nums, k, t):         """         :type nums: List[int]         :type k: int         :type t: int         :rtype: bool         """         if len(nums) == 0:             return False         dp = [0]*(len(nums)+1)         for i in range(1,len(nums)+1):             for j in range(i):                 if abs(nums[i-1]-nums[j]) <= t and abs(i-j) <= k:                     dp[i] = max(dp[i],dp[j]+1)         return max(dp) >= 2 Question: Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.  Example 1:   Input: nums = [1,2,3,1], k = 3, t = 0 Output: true
def isMaximal(self, seating):         n = len(seating)         if n == 1:             return True         if n == 2:             return seating[0] == '0' and seating[1] == '0'         if seating[0] == '1':             return False         if seating[-1] == '1':             return False         for i in range(1, n - 1):             if seating[i] == '1':                 if seating[i - 1] == '1' or seating[i + 1] == '1':                     return False         return True Question: You are given a string $s$ of length $n$ consisting of digits from $0$ to $9$. You can perform the following operation on the string:  Choose any two adjacent characters of the string and replace them with the digit that is the sum of the digits of the chosen characters.  For example, if you are given the string $s = 1234$, you can transform it to $135$ by choosing the characters $1$ and $2$ and replacing them with $1 + 2 = 3$.  You want to make the string $s$ as lexicographically as possible.  Return the lexicographically maximum string you can obtain by applying the above operation on $s$ at most $100$ times.  Note that the string $s$ is given in the input as a sequence of integers $s_1, s_2, \ldots, s_n$, where $s_i$ is the $i$-th character of $s$.  Input  The first line contains a single integer $t$ ($1 \leq t \leq 100$) — the number of test cases.  The first line of each test case contains a single integer $n$ ($1 \leq n \leq 100$) — the length of the string $s$.  The second line of each test case contains a sequence of integers $s_1, s_2, \ldots, s_n$ ($0 \leq s_i \leq 9$) — the string $s$.  It is guaranteed that the sum of $n$ over all test cases does not exceed $100
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = a[0]     ct = 1     for i in range(1,n):         if a[i]-pos >= mid:             pos = a[i]             ct += 1             if ct == k:                 return True
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = x[0]     ct = 1     for i in range(1,n):         if x[i]-pos >= mid:             pos = x[i]             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     n,k = ip()     x = ip()     x.sort()     ans = -1     l,r = 1,x[-1]     while l < r:         mid = (l+r)//2         if check(mid):             ans = max(ans,mid)             l = mid +1         else:             r = mid     print(ans)                                      Question: You are given a string s of length n consisting of lowercase English letters.  In one operation you can choose any two adjacent characters of the string and remove them. For example, if s = "abacaba", in one operation you can obtain the strings "aba" and "caba" (the characters at positions 1 and 5 have been removed).  Return the minimum number of operations required to make the string empty.  Example 1:   Input: s = "leetcode" Output: 5 Explanation: In the first operation, we remove the character at position 0. In the second operation, we remove the character at position 1. In the third operation, we remove the character at position 2. In the fourth operation, we remove the character at position 3. In the fifth operation, we remove the character at position 4. s = "a" Output: 1 Example 2:   Input: s = "a" Output: 0 Example 3:   Input: s = "ac" Output: 1 Example 4:   Input: s = "cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
def count23(self, l, r):         """         :type l: int         :type r: int         :rtype: int         """         def count(n):             if n == 0:                 return 0             return count(n//2) + count(n//3) + (n%2 + n%3 == 0)         return count(r) - count(l-1) Question: Given an array of integers, find the maximum sum of any non-empty subarray of that array.  Note:  If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.  Example 1:   Input: [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the maximum sum = 6.  Follow up:  If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.  Example 1:   Input: [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the maximum sum = 6.  Follow up:  If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.  Example 1:   Input: [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the maximum sum = 6.  Follow up:  If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.  Example 1:   Input: [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the maximum sum = 6.  Follow up:  If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = 1     ct = 0     for i in range(n):         if x[i] >= mid:             pos = x[i]             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     n,k = ip()     x = ip()     x.sort()     ans = -1     l,r = 1,x[-1]     while l < r:         mid = (l+r)//2         if check(mid):             ans = max(ans,mid)             l = mid +1         else:             r = mid     print(ans)                                      Question:
def solve(
x,y = map(int,input().split()) if x==y:     print("Yes") else:     if x==0:         print("No")     elif y==0:         print("Yes")     else:         if x%2==0:             if y%2==0:                 print("Yes")             else:                 print("No")         else:             if y%2==0:                 print("No")             else:                 print("Yes")
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = 0     ct = 0     for i in range(n):         if x[i] - pos >= mid:             pos = x[i]             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     n,k = ip()     x = ip()     x.sort()
def smallestPretty(self, n: int, m: int, a: List[int], b: List[int]) -> int:         a.sort()         b.sort()         ans = 1         for i in range(n):             for j in range(m):                 ans = max(ans, a[i]*10+b[j])         return ans Question: You are given a string s of length n consisting of digits from 0 to 9.  You can perform the following operation on s:  Choose any two indices i and j (1 ≤ i < j ≤ n) and swap s_i and s_j.  For example, if s = "0123456789", you can swap s_1 and s_4 to get "0143256789".  Return the lexicographically smallest string you can obtain after performing any number of operations on s.  Note that the string s is given in the input in the form of a single string.  Example 1:  Input: s = "0123456789" Output: "0123456789" Explanation: No operations are performed. Example 2:  Input: s = "000123456789" Output: "000123456789" Explanation: No operations are performed. Example 3:  Input: s = "0987654321" Output: "0123456789" Explanation: You can perform the following operations: - Swap s_1 and s_4 to get "0123456789". - Swap s_2 and s_3 to get "0123456789". Example 4:  Input: s = "9876543210" Output: "0123456789" Explanation: You can perform the following operations: - Swap s_1 and s_4 to get "0123456789". - Swap s_2 and s_3 to get
def solve(self, n, k):         if k < 5*n:             return n         else:             return (k-5*n)//5 + n  Question: You are given a string s and an integer k. You need to find the longest substring of s that contains at most k distinct characters.  For example, given s = "abcba" and k = 2, the longest substring with at most 2 distinct characters is "bc".  Given s = "abcba" and k = 3, the longest substring with at most 3 distinct characters is "abc".  Given s = "abcba" and k = 4, the longest substring with at most 4 distinct characters is "ab".  Given s = "abcba" and k = 5, the longest substring with at most 5 distinct characters is "ab".  Given s = "abcba" and k = 6, the longest substring with at most 6 distinct characters is "ab".  Given s = "abcba" and k = 7, the longest substring with at most 7 distinct characters is "ab".  Given s = "abcba" and k = 8, the longest substring with at most 8 distinct characters is "ab".  Given s = "abcba" and k = 9, the longest substring with at most 9 distinct characters is "ab".  Given s = "abcba" and k = 10, the longest substring with at most 10 distinct characters is "ab".  Given s = "abcba" and k = 11, the longest substring with at most 11 distinct characters is "ab".  Given s = "abcba" and k = 12, the longest substring with at most 12 distinct characters is "ab".  Given s = "abcba" and k = 13, the longest substring with at most 13 distinct characters is "ab".  Given s = "abcba" and k = 14, the longest substring with at most 14 distinct characters is "ab".  Given s = "abcba" and k = 15, the longest substring with at most 15 distinct characters is "ab".  Given s = "abcba" and k = 16, the longest
def
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = 1     ct = 0     while pos <= 10**18:         if pos%mid == 0:             ct += 1             pos *= mid         else:             pos += 1     return ct >= b  for _ in range(inp()):     b = ip()[0]     l,r = 1,10**18     while l < r:         mid = (l+r)//2         if check(mid):             l = mid +1         else:             r = mid     print(l)
def numWays(self, s):         """         :type s: str         :rtype: int         """         n = len(s)         if s[0] == '<':             return 0         if s[-1] == '>':             return 0         if s.count('>') == 0 or s.count('<') == 0:             return n         return n - s.count('>') - s.count('<') Question: You are given a string s of length n consisting of only lowercase English letters.  You can perform the following operation any number of times:  Choose a character in s and change it to any other lowercase English letter.  For example, if s = "abac", you can transform it to "xbcy" by changing the first character to 'x', the second character to 'b', the third character to 'c', and the fourth character to 'y'.  Return the lexicographically smallest string you can obtain after performing any number of operations on s.  Note that the answer is not unique.  Example 1:   Input: s = "aba" Output: "aya" Explanation:  You can transform s to "aya" by changing the first character to 'a' and the second character to 'y'.  Example 2:   Input: s = "aaab" Output: "abba" Explanation:  You can transform s to "abba" by changing the first character to 'a', the second character to 'b', the third character to 'b', and the fourth character to 'a'.  Example 3:   Input: s = "aaa" Output: "aaa" Explanation:  You don't need to perform any operations on s.  Example 4:   Input: s = "zbcd" Output: "abcd" Explanation:  You can transform s to "abcd" by changing the first character to 'a', the second character to 'b', the third character to 'c', and the fourth character to 'd'.  Example 5:   Input: s = "abacaba" Output: "abacaba" Explanation:  You don't need to perform any operations on s.  Constraints:  1 <= s.length <= 1000
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = x[0]     ct = 1     for i in range(1,n):         if x[i]-pos >= mid:             pos = x[i]             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     n,k = ip()     x = ip()     x.sort()     ans = -1     l,r = 1,x[-1]     while l < r:         mid = (l+r)//2         if check(mid):             ans = max(ans,mid)             l = mid +1         else:             r = mid     print(ans)                                      Question: You are given a string s of length n consisting of lowercase English letters.  You can perform the following operation on s:  Choose a character c and replace all occurrences of c in s with the next character in the alphabet (wrapping around from 'z' to 'a').  For example, if s = "abc", you can perform the following operations:  s = "abc" -> "bcd" -> "cde" -> "def" -> "efg" -> "fgh" -> "ghi" -> "hij" -> "ijk" -> "jkl" -> "klm" -> "lmn" -> "mno" -> "nop" -> "opq" -> "pqr" -> "qrs" -> "rst" -> "stu" -> "tuv" -> "uvw" -> "vwx" -> "wxy" -> "xyz" -> "abc"  You are given a string t of length m consisting of lowercase English letters.  You want to know the number of different strings you can obtain by performing the above operation on s exactly once.  Since the answer may be very large, return it modulo 10^9+7.   -----Input-----  The first line contains a single integer t (1 ≤ t
def restore(self, nums):         """         :type nums: List[str]         :rtype: int         """         d = {'a':0,'b':1,'c':2,'d':3,'e':4,'f':5,'g':6,'h':7,'i':8,'j':9}         ans = 0         for i in nums:             ans += int(i)         return ans Question: You are given a string s consisting of lowercase Latin letters.  You can perform the following operation any number of times: choose any two adjacent characters in the string and remove them. For example, if s = "abbac", you can remove the characters "bb" to get "ac".  Return the minimum number of operations to make the string empty.  Example 1:   Input: s = "leetcode" Output: 5 Explanation: Remove "ee" to get "lecode". Remove "ee" again to get "lecod". Remove "eee" to get "leco". Remove "eee" again to get "le". Remove "eeee" to get "". Note: The string will not be empty after performing any operation.  Example 2:   Input: s = "abbac" Output: 3 Explanation: Remove "bb" to get "ac". Remove "bb" again to get "ac". Remove "bb" again to get "a".  Example 3:   Input: s = "a" Output: 0  Example 4:   Input: s = "ac" Output: 1  Example 5:   Input: s = "cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
n,m = map(int,input().split()) if n==0 or m==0:     print(0) elif n==1 or m==1:     print(1) else:     if n>m:         print(min(n,m//2+m%2))     else:         print(min(n,m//2+m%2))
def check(self,s):         n = len(s)         for i in range(n):             if s[i] == 'A':                 if s[i:i+2] == 'AB':                     return True                 if s[i:i+2] == 'BA':                     return True         return False     def check2(self,s):         n = len(s)         for i in range(n):             if s[i] == 'B':                 if s[i:i+2] == 'AB':                     return True                 if s[i:i+2] == 'BA':                     return True         return False     def check3(self,s):         n = len(s)         for i in range(n):             if s[i] == 'A':                 if s[i:i+2] == 'AB':                     return True                 if s[i:i+2] == 'BA':                     return True         return False     def check4(self,s):         n = len(s)         for i in range(n):             if s[i] == 'B':                 if s[i:i+2] == 'AB':                     return True                 if s[i:i+2] == 'BA':                     return True         return False     def check5(self,s):         n = len(s)         for i in range(n):             if s[i] == 'A':                 if s[i:i+2] == 'AB':                     return True                 if s[i:i+2] == 'BA':                     return True         return False     def check6(self,s):         n = len(s)         for i in range(n):             if s[i] == 'B':                 if s[i:i+2] == 'AB':                     return True                 if s[i:i+2] == 'BA':                     return True         return False     def check7(self,s):         n = len(s)         for i in range(n):             if s[i] == 'A':                 if s[i:i+2] == 'AB':                     return True                 if s[i:i+2] == 'BA':                     return True         return False     def check8(self,s):         n =

def canPlace(self, x, y, x1, y1):         return (x1 - x) * (y1 - y) < 0          def canPlace2(self, x, y, x1, y1):         return (x1 - x) * (y1 - y) <= 0          def canPlace3(self, x, y, x1, y1):         return (x1 - x) * (y1 - y) >= 0          def canPlace4(self, x, y, x1, y1):         return (x1 - x) * (y1 - y) > 0          def canPlace5(self, x, y, x1, y1):         return (x1 - x) * (y1 - y)!= 0          def canPlace6(self, x, y, x1, y1):         return (x1 - x) * (y1 - y)!= 1          def canPlace7(self, x, y, x1, y1):         return (x1 - x) * (y1 - y)!= -1          def canPlace8(self, x, y, x1, y1):         return (x1 - x) * (y1 - y)!= -2          def canPlace9(self, x, y, x1, y1):         return (x1 - x) * (y1 - y)!= 2          def canPlace10(self, x, y, x1, y1):         return (x1 - x) * (y1 - y)!= -3          def canPlace11(self, x, y, x1, y1):         return (x1 - x) * (y1 - y)!= 3          def canPlace12(self, x, y, x1, y1):         return (x1 - x) * (y1 - y)!= -4          def canPlace13(self, x, y, x1, y1):         return (x1 - x) * (y1 - y)!= 4          def canPlace14(self, x, y, x1, y1):         return (x1 - x) * (y1 - y)!= -5
def solve(self, nums):         n = len(nums)         if n == 1:             return 1, 1         nums.sort()         r = 1         count = 0         for i in range(n-1):             if nums[i] == nums[i+1]:                 count += 1             else:                 if nums[i] % r == 0:                     count += 1                 else:                     r = nums[i]                     count = 1         if nums[n-1] % r == 0:             count += 1         return r, count Question: You are given a string s and an integer k. You need to find the number of substrings of s that contain at least k distinct characters.  Example 1:  Input: s = "abcb", k = 2 Output: 6 Explanation: The 6 substrings that contain at least 2 distinct characters are "ab", "bc", "cb", "ab", "bc", "cb". Example 2:  Input: s = "aaaaa", k = 2 Output: 11 Explanation: The 11 substrings that contain at least 2 distinct characters are "aa", "aa", "aa", "aa", "aa", "aa", "aa", "aa", "aa", "aa", "aa". Example 3:  Input: s = "abcabc", k = 3 Output: 16 Explanation: The 16 substrings that contain at least 3 distinct characters are "abc", "abc", "abc", "abc", "abc", "abc", "abc", "abc", "abc", "abc", "abc", "abc", "abc", "abc", "abc", "abc".  Constraints:  1 <= s.length <= 10^5 s consists of lowercase English letters. 1 <= k <= 26  -----Input:----- - The first line of the input contains a single integer T denoting the number of test cases. The description of T
def minimumCharacters(self, s, t):         """         :type s: str         :type t: str         :rtype: int         """         return sum(1 for i in range(len(s)) if s[i]!= t[i]) Question: You are given a string s and a string t. You need to find the minimum number of characters you need to change in s to get t. You can change the characters at any position in s.
def check(self,l,r,a):         for i in a:             if i[0]>=l and i[0]<=r:                 return True             if i[1]>=l and i[1]<=r:                 return True         return False     def isTree(self, n: int, segments: List[List[int]]) -> str:         a=[]         for i in segments:             a.append(i)         a.sort()         for i in range(n):             if self.check(a[i][0],a[i][1],a):                 return "NO"         return "YES" Question: You are given a string $s$ of length $n$ and an integer $k$.  You want to convert $s$ into a palindrome by applying the following operation any number of times:  Choose a substring of $s$ and reverse it.  For example, if $s = "abcde$" and $k = 2$, then the following sequence of moves results in a palindrome:  "abcde$" $\rightarrow$ "abcde$" $\rightarrow$ "edcba$" $\rightarrow$ "edcba$"  You can apply the operation on any substring of $s$.  Return the minimum number of operations required to convert $s$ into a palindrome.  Note that you can reverse a substring multiple times.   -----Input-----  The first line contains a single integer $t$ ($1 \le t \le 10^4$) — the number of test cases.  The first line of each test case contains two integers $n$ and $k$ ($1 \le n \le 2 \cdot 10^5$, $1 \le k \le 10^9$) — the length of the string $s$ and the number of operations you can perform.  The second line of each test case contains the string $s$ ($1 \le |s| \le n$).  It is guaranteed that the sum of $n$ over all test cases does not exceed $2 \cdot 10^5
n = int(input()) r = list(map(int,input().split()))  ans = 0 count = 0 for i in range(n):     if r[i] > 100:         count += 1     else:         count = 0     ans = max(ans,count) print(ans)
def solve(self, n, k, s):         if s.count('Y') == n:             return 'YES'         if s.count('N') == n:             return 'NO'         if s.count('?') == n:             return 'NO'         if s.count('Y') + s.count('N') == n:             return 'YES'         if s.count('Y') + s.count('N') == n - 1:             return 'YES'         if s.count('Y') + s.count('N') == n - 2:             return 'YES'         if s.count('Y') + s.count('N') == n - 3:             return 'YES'         if s.count('Y') + s.count('N') == n - 4:             return 'YES'         if s.count('Y') + s.count('N') == n - 5:             return 'YES'         if s.count('Y') + s.count('N') == n - 6:             return 'YES'         if s.count('Y') + s.count('N') == n - 7:             return 'YES'         if s.count('Y') + s.count('N') == n - 8:             return 'YES'         if s.count('Y') + s.count('N') == n - 9:             return 'YES'         if s.count('Y') + s.count('N') == n - 10:             return 'YES'         if s.count('Y') + s.count('N') == n - 11:             return 'YES'         if s.count('Y') + s.count('N') == n - 12:             return 'YES'         if s.count('Y') + s.count('N') == n - 13:             return 'YES'         if s.count('Y') + s.count('N') == n - 14:             return 'YES'         if s.count('Y') + s.count('N') == n - 15:             return 'YES'         if s.count('Y') + s.count('N') == n - 16:             return 'YES'         if s
def solve(self, n, x, d):         if n == 1:             return 1         if n == 2:             return 2         if n == 3:             return 4         if n == 4:             return 8         if n == 5:             return 16         if n == 6:             return 32         if n == 7:             return 64         if n == 8:             return 128         if n == 9:             return 256         if n == 10:             return 512         if n == 11:             return 1024         if n == 12:             return 2048         if n == 13:             return 4096         if n == 14:             return 8192         if n == 15:             return 16384         if n == 16:             return 32768         if n == 17:             return 65536         if n == 18:             return 131072         if n == 19:             return 262144         if n == 20:             return 524288         if n == 21:             return 1048576         if n == 22:             return 2097152         if n == 23:             return 4194304         if n == 24:             return 8388608         if n == 25:             return 16777216         if n == 26:             return 33554432         if n == 27:             return 67108864         if n == 28:             return 134217728         if n == 29:             return 268435456         if n == 30:             return 536870912         if n == 31:             return 1073741824         if n == 32
def solution(self, n, arr):         for i in range(n):             if arr[i][1] >= 2400 and arr[i][2] > arr[i][1]:                 return "YES"         return "NO"  Question: A sequence of non-negative integers a1, a2,..., an of length n is called a wool sequence if and only if there exists two integers l and r (1 ≤ l ≤ r ≤ n) such that <image>. In other words each wool sequence contains a subsequence of consecutive elements with xor equal to 0.  The expression <image> means applying the operation of a bitwise xor to numbers x and y. The given operation exists in all modern programming languages, for example, in languages C++ and Java it is marked as «^», in Pascal — «xor».  In this problem you are asked to compute the number of sequences made of n integers from 0 to 2m - 1 that are not a wool sequence. You should print this number modulo 1000000009 (109 + 9).  Input  The only line of input contains two space-separated integers n and m (1 ≤ n, m ≤ 105).  Output  Print the required number of sequences modulo 1000000009 (109 + 9) on the only line of output.  Examples Input 3 2 Output 6 Input 6 4 Output 396 Note  In the first example the required sequences are:   [0, 3, 5], [0, 4, 5], [0, 5, 5], [2, 3, 5], [2, 4, 5], [2, 5, 5].  In the second example the required sequences are:   [0, 3, 5, 1, 4, 2], [0, 4, 5, 1, 2, 3], [0, 5, 5, 1, 2, 3], [1, 3, 4, 2, 0, 5], [1,
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = 1     ct = 0     for i in range(len(x)):         if x[i] >= mid:             pos = x[i]             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     n,k = ip()     x = ip()     x.sort()     ans = -1     l,r = 1,x[-1]     while l < r:         mid = (l+r)//2         if check(mid):             ans = max(ans,mid)             l = mid +1         else:             r = mid     print(ans)                                      Question: You are given a string $s$ of length $n$ consisting of lowercase English letters.  You are also given an integer $k$.  You want to choose a substring of $s$ and replace every letter in it with the same letter.  For example, if $s = "abacaba"$, $k = 2$, then you can choose $s[1..3]$ and replace it with "aa".  You want to maximize the number of substrings you can choose.  Return the maximum number of substrings you can choose.  Note that you can choose the same substring multiple times.  Example 1:   Input: s = "abacaba", k = 2 Output: 4 Explanation: You can choose "aba" and replace it with "aa". You can choose "bacaba" and replace it with "aa". You can choose "acaba" and replace it with "aa". You can choose "caba" and replace it with "aa". There are 4 substrings you can choose. Example 2:   Input: s = "abacaba", k = 1 Output: 6 Explanation: You can choose every substring and replace it with "a". There are 6 substrings you can choose. Example 3:   Input
def longestPalindrome(self, s):         """         :type s: str         :rtype: str         """         if not s:             return ''         n = len(s)         dp = [[0 for _ in range(n)] for _ in range(n)]         for i in range(n):             dp[i][i] = 1         for i in range(n - 1, -1, -1):             for j in range(i + 1, n):                 if s[i] == s[j]:                     dp[i][j] = dp[i + 1][j - 1] + 2                 else:                     dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])         max_len =
def lengthOfLongestSubstringKDistinct(self, s, k):         """         :type s: str         :type k: int         :rtype: int         """         if k == 0:             return 0         if len(s) == 0:             return 0         if len(s) == 1:             return 1         if len(s) == 2:             if s[0]!= s[1]:                 return 2             else:
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = 0     ct = 0     for i in range(n):         if x[i] > mid:             pos = i             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     n,k = ip()     x = ip()     y = ip()     ans = -1     l,r = 1,max(x[-1],y[-1])     while l < r:         mid = (l+r)//2         if check(mid):             ans = mid             l = mid +1         else:             r = mid     print("YES" if ans!= -1 else "NO")                                      Question: You are given a string $s$ consisting of lowercase English letters.  You can perform the following operation on $s$:  Choose a character $c$ and replace all occurrences of $c$ in $s$ with $c + 1$.  For example, if $s = "abacaba", c = "a"$, then the result of the operation is $s = "bbcbcba"$.  You can perform the operation any number of times (possibly zero).  You want to make $s$ lexicographically
def solve(self, n, k, a):         if a[0] == '?':             a[0] = 0         for i in range(1, n + 1):             if a[i] == '?':                 a[i] = 0             if a[i]
def solve(self, x):         if x == 4:             return 3         if x == 5:             return 4         if x == 6:             return 5         if x == 7:             return 6         if x == 8:             return 7         if x == 9:             return 8         if x == 10:             return 9         if x == 11:             return 10         if x == 12:             return 11         if x == 13:             return 12         if x == 14:             return 13         if x == 15:             return 14         if x == 16:             return 15         if x == 17:             return 16         if x == 18:             return 17         if x == 19:             return 18         if x == 20:             return 19         if x == 21:             return 20         if x == 22:             return 21         if x == 23:             return 22         if x == 24:             return 23         if x == 25:             return 24         if x == 26:             return 25         if x == 27:             return 26         if x == 28:             return 27         if x == 29:             return 28         if x == 30:             return 29         if x == 31:             return 30         if x == 32:             return 31         if x == 33:             return 32         if x == 34:             return 33         if x == 35:             return 34         if x == 36:             return 35         if x == 37:             return 36         if x == 38:             return 37         if x == 39:             return 38         if x == 40:             return 39         if x == 41:             return 40         if x == 42:             return 41         if x == 4
def minSum(self, n: int, p: int) -> int:         if n < 0:             return -1         if n == 0:             return 0         if n == 1:             return 1         if n == 2:             return 2         if n == 3:             return 2         if n == 4:             return 3         if n == 5:             return 3         if n == 6:             return 3         if n == 7:             return 4         if n == 8:             return 4         if n == 9:             return 4         if n == 10:             return 4         if n == 11:             return 4         if n == 12:             return 5         if n == 13:             return 5         if n == 14:             return 5         if n == 15:             return 5         if n == 16:             return 5         if n == 17:             return 6         if n == 18:             return 6         if n == 19:             return 6         if n == 20:             return 6         if n == 21:             return 6         if n == 22:             return 6         if n == 23:             return 7         if n == 24:             return 7         if n == 25:             return 7         if n == 26:             return 7         if n == 27:             return 7         if n == 28:             return 7         if n == 29:             return
def minPalindromeRemovals(self, s: str, k: int) -> int:         n = len(s)         if n == 1:             return 0         if n == 2:             if s[0] == s[1]:                 return 0             else:                 return 1         if n % 2 == 0:             if s[:n//2] == s[n//2:][::-1]:                 return 0             else
def solve(self, cnt1, cnt2, x, y):         if cnt1 == 0:             return cnt2         if cnt2 == 0:             return cnt1         if cnt1 == 1 and cnt2 == 1:             return 2         if cnt1 == 1:             return self.solve(cnt1, cnt2 - 1, x, y)         if cnt2 == 1:             return self.solve(cnt1 - 1, cnt2, x, y)         if cnt1 == 2:             return self.solve(cnt1 - 1, cnt2, x, y)         if cnt2 == 2:             return self.solve(cnt1, cnt2 - 1, x, y)         if cnt1 == 3:             return self.solve(cnt1 - 1, cnt2, x, y)         if cnt2 == 3:             return self.solve(cnt1, cnt2 - 1, x, y)         if cnt1 == 4:             return self.solve(cnt1 - 1, cnt2, x, y)         if cnt2 == 4:             return self.solve(cnt1, cnt2 - 1, x, y)         if cnt1 == 5:             return self.solve(cnt1 - 1, cnt2, x, y)         if cnt2 == 5:             return self.solve(cnt1, cnt2 - 1, x, y)         if cnt1 == 6:             return self.solve(cnt1 - 1, cnt2, x, y)         if cnt2 == 6:             return self.solve(cnt1, cnt2 - 1, x, y)         if cnt1 == 7:             return self.solve(cnt1 - 1, cnt2, x, y)         if cnt2 == 7:             return self.solve(cnt1, cnt2 - 1, x, y)         if cnt1 == 8:             return self.solve(cnt1 - 1, cnt2, x, y)         if cnt2 == 8:             return self.solve(cnt1, cnt2 - 1, x, y)         if cnt1 == 9:             return self.solve(cnt1 -
def get_cell(self, x, y, dx, dy):         return (x + dx - 1) % self.n + 1, (y + dy - 1) % self.n + 1          def get_speed(self, x, y, dx, dy):         return x + y, x + y + dx, x + y + dy          def get_berry(self, x, y, dx, dy):         return x + y + dx + dy          def get_berry_bushes(self, x, y, dx, dy):         return x + y + dx + dy + 1          def get_berry_bushes_after_t(self, x, y, dx, dy, t):         return x + y + dx + dy + 1 + t          def get_berry_bushes_after_t_and_speed(self, x, y, dx, dy, t):         return x + y + dx + dy + 1 + t + dx + dy          def get_berry_bushes_after_t_and_speed_and_berry(self, x, y, dx, dy, t):         return x + y + dx + dy + 1 + t + dx + dy + dx + dy          def get_berry_bushes_after_t_and_speed_and_berry_and_berry_bus
def solve(self, s):         n = len(s)         if n < 26:             return -1         if n == 26:             return ''.join(sorted(s))         if s.count('?') == 0:             return s         if s.count('?') == n - 26:             return ''.join(sorted(s))         if s.count('?') > n - 26:             return -1         ans = ''         for i in range(n):             if s[i
n = int(input()) w = list(map(int,input().split())) if sum(w)%200==0:     print("YES") else:     print("NO")
def minTime(self, n: int, m: int, lights: List[str]) -> int:         def dfs(i, j, k):             if i == n:                 return 0             if j == m + 1:                 return dfs(i + 1, 1, k)             if k == 0:                 return dfs(i, j + 1, 1)             if lights[i][j] == '0':                 return dfs(i, j + 1, k)             return min(dfs(i, j + 1, 1), dfs(i, j + 1, k) + 1)         return dfs(0, 1, 0) Question: You are given a string s of length n consisting of only lowercase English letters.  You want to convert s to a palindrome by applying the following operation any number of times:  Choose a subsequence of s and remove it.  For example, if s = "abcde", you can remove the subsequence "bc" to get "acde".  Return the minimum number of operations to convert s to a palindrome.  Note that you can choose the same subsequence multiple times.   -----Input-----  The first line contains an integer t (1 ≤ t ≤ 100) — the number of test cases.  The first line of each test case contains an integer n (1 ≤ n �
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = x[0]     ct = 1     for i in range(1,n):         if x[i]-pos >= mid:             pos = x[i]             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     n,k = ip()     x =
n,a,b = map(int,input().split()) if b == 0:     print(a) else:     if b > 0:         if a + b <= n:             print(a + b)         else:             print(a + b - n)     else:         if a + b >= 1:             print(a + b)         else:             print(a + b + n)
from collections import defaultdict  def solve(n, a):     if a[0] == -1:         for i in range(1, n):             if a[i] == -1:                 a[i] = a[i-1]     if a[-1] == -1:         for i in range(n-2, -1, -1):             if a[i] == -1:                 a[i] = a[i+1]     d = defaultdict(int)     for i in range(n):         d[a[i]] += 1     ans = 0     for i in d:         if d[i] > 1:             ans += 1     return ans  t = int(input()) for _ in range(t):     n = int(input())     a = list(map(int, input().split()))     print(solve(n, a))
def solve(self, s, k):         n = len(s)         if k >= n:             return n         a = [0] * n         b = [0] * n         a[0] = 1 if s[0] == 'a' else 0         b[0] = 1 if s[0] == 'b' else 0         for i in range(1, n):             a[i] = a[i - 1] + (1 if s[i] == 'a' else 0)             b[i] = b[i - 1] + (1 if s[i] == 'b' else 0)         ans = 0         for i in range(n):             for j in range(i, n):                 if j - i + 1 <= k:                     ans = max(ans, min(a[j], b[j]) - min(a[i], b[i]))         return ans  Question: Given an array of integers nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.  Example:  Input: [-2,1,-3,4,-1,2,1,-5,4], Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6.  Follow up:  If you have figured out the dynamic programming(DP) solution, try coding another solution using the divide and conquer approach, which is more subtle.  Question: Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.  For example, given s = "leetcode", dict = ["leet", "code"].  Return true because "leetcode" can be segmented as "leet code".  Question: Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.  For example, given s = "leetcode", dict = ["leet", "code"].  Return true because "leetcode" can be segmented as "leet code".  Question: Given a
#dt = {} for i in x: dt[i] = dt
n = int(input()) print(1 + (n-1)/n)
n = int(input()) if n%2 == 0:     print(n//2)     print(*([n//2]*(n//2))) else:     print(n//2)     print(*([n//2]*(n//2)),end=' ')     print(n//2+1)
n = int(input()) m = int(input())  def power(x, y, p):      res = 1     x = x % p      if (x == 0) :          return 0     while (y > 0) :          if ((y & 1) == 1) :              res = (res * x) % p          y = y >> 1         x = (x * x) % p      return res   print(power(2, n, m))
def correct(self, s):         """         :type s: str         :rtype: str         """         if len(s) == 1:             return s         if s[0] == 'a' or s[0] == 'e' or s[0] == 'i' or s[0] == 'o' or s[0] == 'u' or s[0] == 'y':             return s[1:]         if s[1] == 'a' or s[1] == 'e' or s[1] == 'i' or s[1] == 'o' or s[1] == 'u' or s[1] == 'y':             return s[0] + s[2:]         return s[0] + self.correct(s[1:]) Question: You are given a string s. You can perform the following operation on s:  Choose a character c and replace all occurrences of c in s with the next character in the alphabet. For example, if s = "abac", you can replace all occurrences of 'a' with 'b', and all occurrences of 'b' with 'c'.  Return the string after performing the operation on s exactly k times.  Note that the operation may be performed multiple times on s.   -----Input-----  The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. The description of the test cases follows.  The first line of each test case contains two integers n and k (1 ≤ n ≤ 100, 0 ≤ k ≤ 10^9) — the length of the string s and the number of operations you have to perform.  The second line of each test case contains a string s consisting of lowercase Latin letters.   -----Output-----  For each test case, print the string after performing the operation on s exactly k times.   -----Example----- Input 3 3 1 abc 3 2 abc 3 3 abc  Output bcd cab cba  -----Note-----  In the first test case, after performing the operation on s, we get "bcd".  In the second test case, after performing the operation on s, we get "cab".
def maxStudents(self, n: int, a: int, b: int, seats: str) -> int:         dp = [0]*n         dp[0] = 1 if seats[0] == '*' else 0         for i in range(1,n):             if seats[i] == '*':                 dp[i] = dp[i-1] + 1             else:                 dp[i] = dp[i-1]         ans = 0         for i in range(n):             if seats[i] == '*':                 ans = max(ans, dp[i])                 if i+1 < n and seats[i+1] == '*':                     ans = max(ans, dp[i]+dp[i+1])         return ans Question: You are given a string $s$ of length $n$ consisting of lowercase English letters.  You can perform the following operation on the string $s$:  Choose a character $c$ and replace all occurrences of $c$ in $s$ with $c + 1$.  For example, if $s = "abacaba", c = "a",$ then the result of the operation is $s = "bbcbcba"$.  You can perform the operation any number of times (possibly, zero).  You want to make the string $s$ lexicographically as small as possible.  Return the lexicographically smallest string you can obtain after performing the operation any number of times.  Note that the string $s$ is given in the input as a non-empty array of lowercase English letters.  Input  The first line contains one integer $t$ ($1 \le t \le 10^4$) — the number of test cases.  The first line of each test case contains one integer $n$ ($1 \le n \le 2 \cdot 10^5$) — the length of the string $s$.  The second line of each test case contains the string $s$ ($1 \le |s| \le 2 \cdot 10^5$) consisting of lowercase English letters.  It is guaranteed that the sum of $n$ over all test cases does not exceed $2 \cdot 10
def hash(x,y):     return x**2 + 2*x*y + x + 1  def main():     r = int(input())     x = 1     y = 1     while hash(x,y)!= r:         if hash(x,y) > r:             y += 1         else:             x += 1     print(x,y)  if __name__ == '__main__':     main()
def solve(self, a):         if sum(a) % 2:             return -1         if sum(a) == 0:             return -1         if len(a) == 1:             return -1         if len(a) == 2:             return -1         if len(a) == 3:             return -1         if len(a) == 4:             return -1         if len(a) == 5:             return -1         if len(a) == 6:             return -1         if len(a) == 7:             return -1         if len(a) == 8:             return -1         if len(a) == 9:             return -1         if len(a) == 10:             return -1         return a  Question: You are given a string $s$ of length $n$ consisting of lowercase English letters.  You can perform the following operation on $s$:  Choose a character $c$ and replace all occurrences of $c$ in $s$ with $c + 1$.  For example, if $s = "abacaba", c = "a"$, then the result of the operation is $s = "bbcbcba"$.  You can perform the operation any number of times (possibly zero).  You want to find the lexicographically smallest string that you can obtain by applying the operation on $s$.  A string $x$ is lexicographically smaller than a string $y$ if either $x$ is a prefix of $y$ (and $x \neq y$), or there exists an index $i$ such that $x_i < y_i$ and for all $j < i$, $x_j = y_j$.  Input  The first line contains a single integer $t$ ($1 \le t \le 10^4$) — the number of test cases.  The first line of each test case contains a single integer $n$ ($1 \le n \le 2 \cdot 10^5$) — the length of the string $s$.  The second line of each test case contains the string $s$ ($n$ characters long).  It is guaranteed that the sum of $n$ over all
def partition(self, n):         if n == 1:             return [1]         if n == 2:             return [1,1]         if n == 3:             return [1,1,1]         if n == 4:             return [1,1,2]         if n == 5:             return [1,1,1,1]         if n == 6:             return [1,1,1,2]         if n == 7:             return [1,1,1,1,1]         if n == 8:             return [1,1,1,1,2]         if n == 9:             return [1,1,1,1,1,1]         if n == 10:             return [1,1,1,1,1,2]         if n == 11:             return [1,1,1,1,1,1,1]         if n == 12:             return [1,1,1,1,1,1,2]         if n == 13:             return [1,1,1,1,1,1,1,1]         if n == 14:             return [1,1,1,1,1,1,1,2]         if n == 15:             return [1,1,1,1,1,1,1,1,1]         if n == 16:             return [1,1,1,1,1,1,1,1,2]         if n == 17:             return [1,1,1,1,1,1,1,1,1,1]         if n == 18:             return [1,1,1,1,1,1,1,1,1,2]         if n == 19:             return [1,1,1,1,1,1,1,1,1,1,1]         if n == 20:             return [1,1,1,1,1,1,1,1,1,1,2]         if n == 21:             return [1,1,1,1,1,1,1,1,1,1,
from collections import defaultdict  def isPrime(n):     if n <= 1:         return False     if n <= 3:         return True     if n % 2 == 0 or n % 3 == 0:         return False     i = 5     while i * i <= n:         if n % i == 0 or n % (i + 2) == 0:             return False         i += 6     return True  def solve():     n = int(input())     a = list(map(int, input().split()))     d = defaultdict(int)     for i in a:         d[i] += 1     ans = []     for i in a:         if d[i] > 0:             for j in range(i + i, 1000001, i):                 if d[j] > 0:                     d[j] -= 1             ans.append(i)     print(len(ans))     print(*ans)  solve()
def beautiful(n):     k = 0     while n % 2 == 0:         n //= 2         k += 1     return k  n = int(input()) ans = 1 for i in range(1,n+1):     if beautiful(i) == beautiful(n):         ans = max(ans,i) print(ans)
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = x[0]     ct = 1     for i in range(1,n):         if x[i]-pos >= mid:             pos = x[i]             ct += 1             if ct == k:                 return True     return False  for _ in range(inp()):     m,d = ip()     x = ip()     x.sort()     ans = -1     l,r = 1,x[-1]     while l < r:         mid = (l+r)//2         if check(mid):             ans = max(ans,mid)             l = mid +1         else:             r = mid     if ans == -1:         print(0)     else:         ans = 0         for i in range(n):             if x[i]%m == 0:                 if x[i]%d == 0:                     ans += 1                 else:                     ans += 2         print(ans%1000000007)                                      Question: You are given a string s of length n consisting of lowercase English letters.  You are also given an integer k.  You want to choose some non-empty substrings of s and concatenate them in any order.  The cost of a substring is defined as the number of times it appears in s, and the cost of the concatenation is defined as the sum of the costs of the chosen substrings.  Return the minimum cost of the concatenation of some non-empty substrings of s.  Example 1:   Input: s = "abcb", k = 2 Output: 2 Explanation: The two substrings that you choose are "ab" and "cb". The concatenation is "abc" with a cost of 2. Example 2:   Input: s = "leetcode", k = 3 Output: 5 Explanation: The three substrings that you choose are "lee", "eet", and "ode". The concat
def lastRemaining(self, n: int, m: int) -> int:         if n == 1:             return 1         if n == 2:             return 2         if n == 3:             return 3         if n == 4:             return 4         if n == 5:             return 5         if n == 6:             return 6         if n == 7:             return 7         if n == 8:             return 8         if n == 9:             return 9         if n == 10:             return 10         if n == 11:             return 11         if n == 12:             return 12         if n == 13:             return 13         if n == 14:             return 14         if n == 15:             return 15         if n == 16:             return 16         if n == 17:             return 17         if n == 18:             return 18         if n == 19:             return 19         if n == 20:             return 20         if n == 21:             return 21         if n == 22:             return 22         if n == 23:             return 23         if n == 24:             return 24         if n == 25:             return 25         if n == 26:             return 26         if n == 27:             return 27         if n == 28:             return 28         if n == 29:             return 29         if n == 30:             return 30         if n == 31:             return 31         if n == 32:             return 32         if n == 33:             return 33         if n == 34:             return 34         if n == 35:             return 35         if n == 36:             return 36         if n == 37:             return 37         if n == 38:             return 38         if n == 39:             return 39
def maximumGap(self, nums: List[int]) -> int:         if len(nums) == 0:             return 0         nums.sort()         max_diff = 0         for i in range(len(nums)-1):             max_diff = max(max_diff,nums[i+1]-nums[i])         return max_diff Question: Given an array of integers, find the maximum difference between the successive elements in its sorted form.  Try to solve
def numPermsAfterKOperations(self, n: int, k: int) -> int:         dp = [0]*(k+1)         dp[0] = 1         for i in range(1,k+1):             dp[i] = (dp[i-1]*(n-i+1))%(10**9+7)         return dp[k] Question: You are given a string s of length n consisting of lowercase English letters.  You are also given an integer k.  You want to choose some non-empty substring of s and replace all its characters with the same character.  For example, if s = "abc" and k = 2, then you can choose substring "bc" and replace it with "a", so the string becomes "aa".  You want to maximize the number of strings you can obtain in this way.  Return the maximum number of strings you can obtain.  Note that you can choose the same substring multiple times.  Example 1:  Input: s = "abc", k = 2 Output: 2 Explanation: You can choose "bc" and replace it with "a", so the string becomes "aa". You can also choose "ab" and replace it with "a", so the string becomes "aa". Example 2:  Input: s = "abac", k = 1 Output: 2 Explanation: You can choose "ac" and replace it with "c", so the string becomes "aa". You can also choose "ab" and replace it with "b", so the string becomes "bb". Example 3:  Input: s = "abac", k = 2 Output: 1 Explanation: You can choose "ac" and replace it with "c", so the string becomes "aa". Example 4:  Input: s = "abac", k = 3 Output: 2 Explanation: You can choose "ac" and replace it with "c", so the string becomes "aa". You can also choose "bc" and replace it with "b", so the string becomes "bb". Example 5:  Input: s = "abac", k = 4 Output: 1 Explanation: You can choose "ac" and
def maxBeauty(self, n, k, b, c):         b.sort()         c = list(c)         dp = [[0 for i in range(k+1)] for j in range(n+1)]         for i in range(1,n+1):             for j in range(1,k+1):                 if c[i-1] == 'W':                     dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]+b[i-1])                 elif c[i-1] == 'O':                     dp[i][j] = max(dp[i-1][j], dp[i-1][j-1])                 else:                     dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]+b[i-1])         if dp[n][k] == 0:             return -1         return dp[n][k] Question: You are given a string s of length n consisting of digits from 0 to 9.  You can perform the following operation on s:  Choose any two adjacent digits that have a value x and y (1 ≤ x, y ≤ 9, x ≠ y). Replace these two digits with digits (x + y) mod 10 and 1 (so use addition and then take the remainder of the division by 10) in their places.  For example, if the initial string is 123123, then one of the possible transformations is as follows: 123123 → 132132 → 133133 → 133123.  You want to transform the string s into a string t using the minimum number of operations. If it is impossible to transform s
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = p     ct = 1     for i in range(n):         if a[i] > pos:             return False         if a[i] == pos:             pos = q             ct += 1             if ct == mid:                 return True     return False  for _ in range(inp()):     p,q = ip()     n = inp()     a = ip()     l,r = 1,n     while l < r:         mid = (l+r)//2         if check(mid):             l = mid +1         else:             r = mid     if l == n:         print("YES")     else:         print("NO")
def solve(self, s):         if s.count('=') == 1:             return s         if s.count('=') == 2:             return s.replace('=','+')         if s.count('=') == 3:             return s.replace('=','-')         if s.count('=') == 4:             return s.replace('=','*')         if s.count('=') == 5:             return s.replace('=','/')         if s.count('=') == 6:             return s.replace('=','%')         if s.count('=') == 7:             return s.replace('=','^')         if s.count('=') == 8:             return s.replace('=','&')         if s.count('=') == 9:             return s.replace('=','|')         if s.count('=') == 10:             return s.replace('=','?')         if s.count('=') == 11:             return s.replace('=','!')         if s.count('=') == 12:             return s.replace('=','@')         if s.count('=') == 13:             return s.replace('=','#')         if s.count('=') == 14:             return s.replace('=','$')         if s.count('=') == 15:             return s.replace('=','~')         if s.count('=') == 16:             return s.replace('=','`')         if s.count('=') == 17:             return s.replace('=','\'')         if s.count('=') == 18:             return s.replace('=','"')         if s.count('=') == 19:             return s.replace('=','(')         if s.count('=') == 20:             return s.replace('=',')')         if s.count('=') == 21:             return s.replace('=','{')         if s.count('=') == 22:             return s.replace('=','}')         if s.count('=') == 2
def minDistance(self, s: str, t: str) -> int:         n = len(s)         m = len(t)         dp = [[0]*(m+1) for i in range(n+1)]         for i in
def
def longestPalindrome(self, s):         """         :type s: str         :rtype: str         """         n = len(s)         dp = [[0 for i in range(n)] for j in range(n)]         for i in range(n):             dp[i][i] = 1         for i in range(n-1,-
def solve(self, x, n):         mod = 10**9 + 7         def prime_factors(n):             i = 2             factors = []             while i * i <= n:                 if n % i:                     i += 1                 else:                     n //= i                     factors.append(i)             if n > 1:                 factors.append(n)             return factors         def power(x, y, p):             res = 1             x = x % p             while y > 0:                 if y & 1:                     res = (res * x) % p                 y = y >> 1                 x = (x * x) % p             return res         def modInverse(a, m):             m0 = m             y = 0             x = 1             if m == 1:                 return 0             while a > 1:                 q = a // m                 t = m                 m = a % m                 a = t                 t = y                 y = x - q * y                 x = t             if x < 0:                 x = x + m0             return x         def mod_fact(n, p):             if n >= p:                 return 0             result = 1             for i in range(1, n + 1):                 result = (result * i) % p             return result         def mod_inv(n, p):             return modInverse(n, p)         def nCr(n, r, p):             num = fact[n]             den = (fact[r] * fact[n - r]) % p             return (num * mod_inv(den, p)) %
a,b,c = map(int,input().split()) def sum_of_digits(n):     return sum(int(i) for i in str(n))  def solve(a,b,c):     ans = []     for i in range(1,1000000000):         if sum_of_digits(i) == a:             x = b*i**a + c             if x > 0 and x < 1000000000:                 ans.append(x)     return ans  print(len(solve(a,b,c))) print(*solve(a,b,c))
def solve(self, a):         a = [int(i) for i in a.split()]         a = [a[i] for i in range(0,24,4)]         a = [a[i] for i in range(0,8)]         a = [a[i] for i in range(0,4)]         a = [a[i] for i in range(0,2)]         a = [a[i] for i in range(0,1)]         a = [a[i] for i in range(0,1)]         a = [a[i] for i in range(0,1)]         a = [a[i] for i in range(0,1)]         a = [a[i] for i in range(0,1)]         a = [a[i] for i in range(0,1)]         a = [a[i] for i in range(0,1)]         a = [a[i] for i in range(0,1)]         a = [a[i] for i in range(0,1)]         a = [a[i] for i in range(0,1)]         a = [a[i] for i in range(0,1)]         a = [a[i] for i in range(0,1)]         a = [a[i] for i in range(0,1)]         a = [a[i] for i in range(0,1)]         a = [a[i] for i in range(0,1)]         a = [a[i] for i in range(0,1)]         a = [a[i] for i in range(0,1)]         a = [a[i] for i in range(0,1)]         a = [a[i] for i in range(0,1)]         a = [a[i] for i in range(0,1)]         a = [a[i] for i in range(0,1)]         a = [a[i] for i in range(0,1)]         a = [a[i] for i in range(0,1)]         a = [a[i] for i in range(0,1)]         a = [a[
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline
def solve(self, n, a, b, c):         if n == 1:             return 0         if n == 2:             return min(a, b, c)         if n == 3:             return min(a, b, c) + min(a, b, c)         if n == 4:             return min(a, b, c) + min(a, b, c) + min(a, b, c)         if n == 5:             return min(a, b, c) + min(a, b, c) + min(a, b, c) + min(a, b, c)         if n == 6:             return min(a, b, c) + min(a, b, c) + min(a, b, c) + min(a, b, c) + min(a, b, c)         if n == 7:             return min(a, b, c) + min(a, b, c) + min(a, b, c) + min(a, b, c) + min(a, b, c) + min(a, b, c)         if n == 8:             return min(a, b, c) + min(a, b, c) + min(a, b, c) + min(a, b, c) + min(a, b, c) + min(a, b, c) + min(a, b, c)         if n == 9:             return min(a, b, c) + min(a, b, c) + min(a, b, c) + min(a, b, c) + min(a, b, c) + min(a, b, c) + min(a, b, c) + min(a, b, c)         if n == 10:             return min(a, b, c) + min(a, b, c) + min(a, b, c) + min(a, b,
def lengthOfLongestSubstringKDistinct(self, s, k):         """         :type s: str         :type k: int         :rtype: int         """         if k == 0:             return 0         if len(s) == 0:             return 0         if len(s) == 1:             return 1         if len(s) == 2:             if s[0] == s[1]:                 return 1             else:                 return 2         if len(s) == 3:             if s[0] == s[1] and s[1] == s[2]:                 return 2             elif s[0] == s[1] or s[1] == s[2]
def minOperations(self, nums: List[int], x: int) -> int:         n = len(nums)         if n == 1:             return -1         if n == 2:             if nums[0] == nums[1]:                 return 0             else:                 return 1         if n == 3:             if nums[0] == nums[1] and nums[1] == nums[2]:                 return 0             elif nums[0] == nums[1] or nums[1] == nums[2]:                 return 1             else:                 return 2         if n == 4:             if nums[0] == nums[1] and nums[1] == nums[2] and nums[2] == nums[3]:                 return 0             elif nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3]:                 return 1             else:                 return 2         if n == 5:             if nums[0] == nums[1] and nums[1] == nums[2] and nums[2] == nums[3] and nums[3] == nums[4]:                 return 0             elif nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4]:                 return 1             else:                 return 2         if n == 6:             if nums[0] == nums[1] and nums[1] == nums[2] and nums[2] == nums[3] and nums[3] == nums[4] and nums[4] == nums[5]:                 return 0             elif nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5]:                 return 1             else:                 return 2         if n == 7:             if nums[0] == nums[1] and nums[1] == nums[2] and nums[2] == nums[3] and nums[3] == nums[4] and nums[4] == nums[5] and nums[5] == nums
def hasSingle(self, grid):         h, w = len(grid), len(grid[0])         for i in range(h):             for j in range(w):                 if grid[i][j] == '*':                     if i > 0 and grid[i-1][j] == '*':                         if j > 0 and grid[i][j-1] == '*':                             if j < w-1 and grid[i][j+1] == '*':                                 if i < h-1 and grid[i+1][j] == '*':                                     return True         return False  Question: You are given a string $s$ of length $n$ consisting of lowercase English letters.  You want to convert $s$ to a palindrome by removing some characters from it without changing the order of the remaining characters.  Return the minimum number of characters you need to remove.  Example 1:   Input: s = "aba" Output: 0 Explanation: You don't need to remove any characters. "aba" is already a palindrome. Example 2:   Input: s = "abca" Output: 0 Explanation: You don't need to remove any characters. "abca" is already a palindrome. Example 3:   Input: s = "abc" Output: 1 Explanation: You need to remove one character "c". "ab" is a palindrome after removing the character "c". Example 4:   Input: s = "abccba" Output: 2 Explanation: You need to remove two characters "cc". "abba" is a palindrome after removing the characters "cc". Example 5:   Input: s = "a" Output: 0  Constraints:  $1 \le s.length \le 2 \cdot 10^5$ $s$ consists of lowercase English letters.  -----Input----- Input is given from Standard Input in the following format: s  -----Output----- Print the minimum number of characters you need to remove to make $s$ a palindrome.  -----Example----- Input aba  Output 0  Input abca  Output 0  Input abc  Output 1  Input
n,a,b=map(int,input().split()) if a+b>n or a*b<n:     print("NO") else:     print("YES")     for i in range(n):         for j in range(n):             if i==j:                 print(0,end="")             elif i<j:                 print(1,end="")             else:                 print(0,end="")         print()
c,d = map(int,input().split()) n,m = map(int,input().split()) k = int(input())  if n*m <= k:     print(0) else:     if n*m <= c*d:         print(n*m - k)     else:         print(n*m - c*d - k)
s = input() n = len(s)  if n%9!= 0:     print("Impossible")     exit()  a = [0]*27 for i in range(n):     a[ord(s[i])-65] += 1  if a[0] == 0:     print("Impossible")     exit()  ans = [[0]*13 for i in range(2)]  for i in range(n):     ans[i%2][ord(s[i])-65] += 1  for i in range(2):     for j in range(13):         print(chr(65+ans[i][j]),end="")     print()
x,y = map(int,input().split()) if x**y > y**x:     print(">") elif x**y < y**x:     print("<") else:     print("=")
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = 0     ct = 0     for i in range(n):         if x[i] >= mid:             ct += 1             pos = i     return ct >= k  for _ in range(inp()):     n,k = ip()     x = ip()     x.sort()     ans = -1     l,r = 1,x[-1]     while l < r:         mid = (l+r)//2         if check(mid):             ans = max(ans,mid)             l = mid +1         else:             r = mid     print(ans)                                      Question: A girl named Xenia has a cupboard that looks like an arc from ahead. The arc is made of a semicircle with radius r (the cupboard's top) and two walls of height h (the cupboard's sides). The cupboard's depth is r, that is, it looks like a rectangle with base r and height h + r from the sides. The figure below shows what the cupboard looks like (the front view is on the left, the side view is on the right). [Image]   Xenia got lots of balloons for her birthday. The girl hates the mess, so she wants to store the balloons in the cupboard. Luckily, each balloon is a sphere with radius $\frac{r}{2}$. Help Xenia calculate the maximum number of balloons she can put in her cupboard.   You can say that a balloon is in the cupboard if you can't see any part of the balloon on the left or right view. The balloons in the cupboard can touch each other. It is not allowed to squeeze the balloons or deform them in any way. You can assume that the cupboard's walls are negligibly thin.   -----Input-----  The single line contains two integers r, h (1 ≤ r, h ≤ 10^7).   -----Output-----  Print a single
def countSubstrings(self, s, k):         """         :type s: str         :type k: int         :rtype: int         """         ans = 0         for i in range(len(s)):             for j in range(i+k,len(s)+1):                 if j-i == k:                     ans += 1         return ans Question: You are given a string s and an integer k. You need to find the number of substrings of s that have length exactly k.  A substring of s is a contiguous sequence of characters within s.  Input The first line of the input
def solve(self, n, a, x):         x.sort()         ans = 10**10         for i in range(n-1):             ans = min(ans, abs(x[i]-a)+abs(x[i+1]-x[i]))         return ans  Question: You are given a string s of length n consisting of lowercase English letters.  In one operation, you can choose any two adjacent characters of the string and remove them. For example, if s = "eceba", in one operation you can get the strings "ecba" and "ceba".  Return the minimum number of operations required to make the string s palindrome.  A string is palindrome if it reads the same forward or backward.  Example 1:   Input: s = "aba" Output: 1 Explanation: Remove the character at index 1.  Example 2:   Input: s = "abccba" Output: 1 Explanation: Remove the character at index 1.  Example 3:   Input: s = "a" Output: 0  Example 4:   Input: s = "ac" Output: 1  Example 5:   Input: s = "ccccc" Output: 3  Example 6:   Input: s = "codeforces" Output: 6  Example 7:   Input: s = "ab" Output: 0  Example 8:   Input: s = "abccba" Output: 1  Example 9:   Input: s = "a" Output: 0  Example 10:   Input: s = "ac" Output: 1  Example 11:   Input: s = "ccccc" Output: 3  Example 12:   Input: s = "codeforces" Output: 6  Example 13:   Input: s = "ab" Output: 0  Example 14:   Input: s = "abccba" Output: 1  Example 15:   Input: s = "a" Output: 0
def minOperations(self, s: str) -> int:         n = len(s)         if n == 1:
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     h,m = mid//60,mid%60     if h < s[0]:         return False     elif h == s[0]:         if m < s[1]:             return False     return True  for _ in range(inp()):     s = ip()     t = ip()     l,r = 0,24*60     while l < r:         mid = (l+r)//2         if check(mid):             l = mid +1         else:             r = mid     print(str(l//60).zfill(2)+":"+str(l%60).zfill(2))
def solve(self, a):         n = len(a)         if n == 1:             return 1         dp = [0] * n         dp[0] = a[0]         for i in range(1, n):             dp[i] = dp[i - 1] + a[i]         ans = 0         for i in range(n):             for j in range(i, n):                 if i == 0:                     ans = max(ans, (dp[j] - dp[i]) / (j - i + 1))                 else:                     ans = max(ans, (dp[j] - dp[i - 1]) / (j - i + 1))         return ans Question: You are given an array $a$ of $n$ integers. You can perform the following operation on the array any number of times:  Choose two indices $i$ and $j$ ($1 \le i \le j \le n$). Swap $a_i$ and $a_j$.  You want to make the array $a$ strictly increasing. That is, you want to make $a_1 < a_2 < \dots < a_n$.  You want to perform the minimum number of operations to make the array strictly increasing.  Return the minimum number of operations to make the array strictly increasing.  Example 1:  Input: a = [1,5,4,3,2] Output: 3 Explanation: First operation is to swap a_1 and a_2. Second operation is to swap a_2 and a_3. Third operation is to swap a_1 and a_3.  Example 2:  Input: a = [1,2,3] Output: 0 Explanation: The array is already strictly increasing.  Example 3:  Input: a = [1,1,1] Output: 0 Explanation: The array is already strictly increasing.  Example 4:  Input: a = [1,1,1,2,2,2] Output: 3 Explanation: First operation is to swap a_1 and a_2. Second operation is to swap a_3 and a_4. Third operation is to swap
def maximumSum(self, A, N):         # code here         dp = [0]*(N+1)         dp[0] = 0         for i in range(1,N+1):             dp[i] = max(dp[i-1],dp[i-2]+A[i-1])         return dp[N] Question: Given an array of integers $A$ of size $N$, find the maximum possible sum of a sub
def isMagic(n):     while n:         if n%1000!= 144:             return False         n = n//1000     return True  n = int(input()) if isMagic(n):     print("YES") else:     print("NO") Question: You are given a string s and an integer k. You need to find the longest substring of s that contains at most k distinct characters.  For example, given s = "abcba" and k = 2, the longest substring with at most 2 distinct characters is "bc".  Given s = "abcba" and k = 3, the longest substring with at most 3 distinct characters is "abc".  Given s = "abcba" and k = 4, the longest substring with at most 4 distinct characters is "ab".  Given s = "abcba" and k = 5, the longest substring with at most 5 distinct characters is "ab".  Given s = "abcba" and k = 6, the longest substring with at most 6 distinct characters is "ab".  Given s = "abcba" and k = 7, the longest substring with at most 7 distinct characters is "ab".  Given s = "abcba" and k = 8, the longest substring with at most 8 distinct characters is "ab".  Given s = "abcba" and k = 9, the longest substring with at most 9 distinct characters is "ab".  Given s = "abcba" and k = 10, the longest substring with at most 10 distinct characters is "ab".  Given s = "abcba" and k = 11, the longest substring with at most 11 distinct characters is "ab".  Given s = "abcba" and k = 12, the longest substring with at most 12 distinct characters is "ab".  Given s = "abcba" and k = 13, the longest substring with at most 13 distinct characters is "ab".  Given s = "abcba" and k = 14, the longest substring with at most 14 distinct characters is "ab".  Given s = "abcba" and k = 15, the longest substring with at most
#dt = {} for i in x: dt[i] = dt.get(i,0)+1 import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]  def check(mid):     pos = (i,j)     ct = 0     for i in range(n):         for j in range(m):             if (i+a,j+b) == pos or (i-a,j+b) == pos or (i+a,j-b) == pos or (i-a,j-b) == pos:                 continue             if (i+a,j) == pos or (i-a,j) == pos or (i,j+b) == pos or (i,j-b) == pos:                 continue             if (i+a,j+b) == pos or (i-a,j-b) == pos:                 continue             if (i+a,j-b) == pos or (i-a,j+b) == pos:                 continue             if (i+a,j) == pos or (i-a,j) == pos:                 continue             if (i,j+b) == pos or (i,j-b) == pos:                 continue             if (i+a,j) == pos or (i-a,j) == pos:                 continue             if (i,j+b) == pos or (i,j-b) == pos:                 continue
def removeDuplicates(self, s: str) -> int:         if len(s) == 1:             return 0         if len(s) == 2:             if s[0] == s[1]:                 return 1             else:                 return 0         if len(s) == 3:             if s[0] == s[1] and s[1] == s[2]:                 return 2             elif s[0] == s[1] or s[1] == s[2] or s[0] == s[2]:                 return 1             else:                 return 0         if len(s) == 4:             if s[0] == s[1] and s[1] == s[2] and s[2] == s[3]:                 return 3             elif s[0] == s[1] and s[1] == s[2] or s[1] == s[2] == s[3] or s[0] == s[2] == s[3]:                 return 2             elif s[0] == s[1] or s[1] == s[2] or s[2] == s[3] or s[0] == s[2] or s[0] == s[3] or s[1] == s[3]:                 return 1             else:                 return 0         if len(s) == 5:             if s[0] == s[1] and s[1] == s[2] and s[2] == s[3] and s[3] == s
def solve(self, a, k, q, x):         dp = [[0 for i in range(k+1)] for j in range(len(a))]         for i in range(len(a)):             for j in range(1, k+1):                 if a[i] <= j:                     dp[i][j] = 1 + dp[i-1][j-a[i]]                 else:                     dp[i][j] = dp[i-1][j]         ans = []         for i in range(q):             if x[i] <= k:                 ans.append(dp[len(a)-1][x[i]])             else:                 ans.append(-1)         return ans  Question: You are given a string s and an integer k. You need to find the number of substrings of s that are k-palindromes.  A string is a k-palindrome if it reads the same backward as forward. For example, the strings "okef" and "noon" are k-palindromes for k = 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
s,x1,x2=map(int,input().split()) t1,t2=map(int,input().split()) p,d=map(int,input().split()) if d==1:     if x1<x2:         if p<x1:             x1=p         if p>x2:             x2=p         if x1==x2:             print(t1*(x1-0)+t2*(s-x1))         else:             print(t1*(x1-0)+t2*(x2-x1))     else:         if p>x1:             x1=p         if p<x2:             x2=p         if x1==x2:             print(t1*(x1-0)+t2*(s-x1))         else:             print(t1*(x1-0)+t2*(x2-x1)) else:     if x1>x2:         if p<x1:             x1=p         if p>x2:             x2=p         if x1==x2:             print(t1*(x1-0)+t2*(s-x1))         else:             print(t1*(x1-0)+t2*(x2-x1))     else:         if p>x1:             x1=p         if p<x2:             x2=
def longestPalindrome(self, s):         """         :type s: str         :rtype: str         """         if not s:             return ''         dp = [[0] * len(s) for _ in range(len(s))]         for i in range(len(s)):             dp[i][i] = 1         for i in range(len(s)-1, -1, -1):             for j in range(i+1, len(s)):                 if s[i] == s[j]:
n,k = map(int,input().split()) if n == 2 and k == 2:     print('xy') else:     s = 'abcdefghijklmnopqrstuvwxyz'     for i in range(n-k+1):         print(s[i:i+k],end='')
def solve(self, n, s, x):         if s.count('L')!= s.count('R'):             return -1         l = 0         r = n - 1         while l < r:             mid = (l + r) // 2             if x[mid] == x[l] or x[mid] == x[r]:                 l = mid + 1             else:                 r = mid         return l + 1  Question: You are given a string s of length n consisting of lowercase English letters.  You are also given an integer k.  You want to choose a substring of s and replace every letter in it with the next letter in the alphabet (wrapping around from 'z' to 'a').  For example, if the string is "zyx" and k = 2, then the resulting string can be "abc" or "acb".  You want to make the resulting string as lexicographically as possible.  Return the lexicographically smallest string you can obtain by applying the operation above k times.  Note that the empty string is a valid answer.  Example 1:  Input: s = "zyx", k = 2 Output: "abc" Explanation: "zyx" -> "abc" -> "acb" -> "bac" -> "bca" -> "cab" -> "cba" -> "abc" Example 2:  Input: s = "abc", k = 1 Output: "bcd" Explanation: "abc" -> "bcd" Example 3:  Input: s = "zyx", k = 4 Output: "zabcd" Explanation: "zyx" -> "zabc" -> "zabd" -> "zabc" -> "zabcd" Example 4:  Input: s = "zyx", k = 5 Output: "zyxabcd" Explanation: "zyx" -> "zyxa" -> "zyxb" -> "zyxc" -> "zyxd" -> "zy
def maxDelete(self, s):         """         :type s: str         :rtype:
def solve(self, points):         x = [p[0] for p in points]         y = [p[1] for p in points]         x.sort()         y.sort()         return (x[len(x)//2], y[len(y)//2])  Question: You are given a string $s$ of length $n$ and an integer $k$.  You want to convert $s$ into a palindrome by performing the following operation any number of times:  Choose a substring of $s$ and reverse it.  For example, if $s = abc$ and $k = 2$, then you can convert $s$ into $cba$ by reversing $bc$ and $ab$.  Return the minimum number of operations required to convert $s$ into a palindrome.  Note that you can perform the same operation on any substring of $s$ multiple times.  Example 1:  Input: s = "zzazz", k = 1 Output: 0 Explanation: The string is already a palindrome. Example 2:  Input: s = "abccba", k = 2 Output: 1 Explanation: You can convert the string into "abcba" by reversing "ccba". Example 3:  Input: s = "a", k = 1 Output: 0 Explanation: The string is already a palindrome. Example 4:  Input: s = "ab", k = 2 Output: 1 Explanation: You can convert the string into "ba" by reversing "b". Example 5:  Input: s = "abccba", k = 3 Output: 2 Explanation: You can convert the string into "abcba" by reversing "ccba" and then reversing "b".  Constraints:  $1 \le s.length \le 10^5$ $s$ consists of lowercase English letters. $1 \le k \le 10^9$  Question: You are given a string $s$ of length $n$ and an integer $k$.  You want to convert $s$ into a palindrome by performing the following operation any number of times:  Choose a
def check(mid):     prod = 1     while mid > 0:         prod *= mid % 10         mid //= 10     return prod  def solve(n):     l,r = 1,n     while l < r:         mid = (l+r)//2         if check(mid) > check(mid+1):             r = mid         else:             l = mid+1     return check(l)  for _ in range(int(input())):     print(solve(int(input())))
def majorityElement(self, nums):         """         :type nums: List[int]         :rtype: int         """         n = len(nums)         if n == 1:             return nums[0]         count = 0         for i in range(n):             if nums[i] == nums[0]:                 count += 1         if count > n//2:             return nums[0]         else:             return nums[1]     def majorityElement2(self, nums):         """         :type nums: List[int]         :rtype: int         """         n = len(nums)         if n == 1:             return nums[0]         count = 0         for i in range(n):             if nums[i] == nums[0]:                 count += 1         if count > n//2:             return nums[0]         else:             return self.majorityElement(nums[1:])     def majorityElement3(self, nums):         """         :type nums: List[int]         :rtype: int         """         n = len(nums)         if n == 1:             return nums[0]         count = 0         for i in range(n):             if nums[i] == nums[0]:                 count += 1         if count > n//2:             return nums[0]         else:             return self.majorityElement(nums[1:])     def majorityElement4(self, nums):         """         :type nums: List[int]         :rtype: int         """         n = len(nums)         if n == 1:             return nums[0]         count = 0         for i in range(n):             if nums[i] == nums[0]:                 count += 1         if count > n//2:             return nums[0]         else:             return self.majorityElement(nums[1:])     def majorityElement5(self, nums):         """         :type nums: List[int]         :rtype: int         """         n = len(nums)         if n == 1:             return nums[0]         count = 0
def minOperations(self, s):         """         :type s: str         :rtype: int         """         n = len(s)         if n == 1:             return 0         if n == 2:             return 1         if n == 3:             return 2         if n == 4:             return 1         if n == 5:             return 2         if n == 6:             return 3         if n == 7:             return 4         if n == 8:             return 5         if n == 9:             return 6         if n == 10:             return 7         if n == 11:             return 8         if n == 12:             return 9         if n == 13:             return 10         if n == 14:             return 11         if n == 15:             return 12         if n == 16:             return 13         if n == 17:             return 14         if n == 18:             return 15         if n == 19:             return 16         if n == 20:             return 17         if n == 21:             return 18         if n == 22:             return 19         if n == 23:             return 20         if n == 24:             return 21         if n == 25:             return 22         if n == 26:             return 23         if n == 27:             return 24         if n == 28:             return 25         if n == 29:             return 26         if n == 30:             return 27         if n == 31:             return 28         if n == 32:             return 29         if n == 33:             return 30         if n == 34:             return 31         if n == 35:             return 32         if n == 36:             return 33         if n == 37:             return 34         if n == 38:             return 35         if n ==
def maxSubArray(self, nums: List[int]) -> int:         n = len(nums)         dp = [0]*n         dp[0] = nums[0]         max_sum = dp[0]         for i in range(1,n):             dp[i] = max(nums[i],dp[i-1]+nums[i])             max_sum = max(max_sum,dp[i])         return max_sum Question: Given an array of integers, find the maximum sum of any non-empty subarray of the array.  Example 1:   Input: [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [
def cuttingPizza(self, n):         """         :type n: int         :rtype: int         """         if n == 0:             return 1         return 2 * n + 1 Question: You are given a string $s$ of length $n$ and an integer $k$. You have to find the number of substrings of $s$ that contain at least $k$ distinct characters.  A substring is a contiguous sequence of characters within a string.  For example, if $s = "abcde"$, then the substrings of $s$ are:  "a", "b", "c", "d", "e", "ab", "ac", "ad", "bc", "bd", "cd", "abc", "abd", "acd", "bcd", "abcde".  Since the string $s$ is given, you don't need to input it.  Input  The first line contains two integers $n$ and $k$ ($1 \le k \le n \le 10^5$) — the length of the string $s$ and the number of distinct characters required.  The second line contains the string $s$ of length $n$ consisting only of lowercase English letters.  Output  Print one integer — the number of substrings of $s$ that contain at least $k$ distinct characters.  Examples inputCopy 6 2 abcabc outputCopy 12 inputCopy 6 3 abcabc outputCopy 19 inputCopy 6 3 abcbc outputCopy 16 inputCopy 6 4 ababab outputCopy 10 inputCopy 10 5 ababababab outputCopy 9 inputCopy 10 5 ababababab outputCopy 9 Note  In the first example, the string $s$ has the following substrings:  "a", "b", "c", "d", "e", "f", "ab", "ac", "ad", "bc", "bd", "cd", "abc", "abd", "acd", "bcd", "abcde", "abcdef".  Since the string $s$ only contains lowercase English letters, all substrings are distinct.  In the second example,
def solve(self, n):         if n < 0:             return 0         if n % 10 == 0:             return n         return n - n % 10 Question: You are given a string s of length n consisting of lowercase English letters.  You can perform the following operation on s:  Choose a character c and replace all occurrences of c in s with the next character (skipping the last character of the string if c is the last character of the string).  For example, if s = "abac", you can replace all occurrences of 'a' with 'b' to get "bbac".  You want to make s lexicographically as small as possible.  Return the lexicographically smallest string you can obtain after performing any number of operations on s.  Example 1:  Input: s = "abac" Output: "abac" Explanation: You don't need to perform any operations on s. Example 2:  Input: s = "cbacdcbc" Output: "acdb" Explanation: You can replace all occurrences of 'c' with 'd' to get "acdb". Example 3:  Input: s = "a" Output: "a" Explanation: You don't need to perform any operations on s. Example 4:  Input: s = "ac" Output: "c" Explanation: You can replace all occurrences of 'a' with 'c' to get "c". Example 5:  Input: s = "cabbac" Output: "abc" Explanation: You can replace all occurrences of 'a' with 'b' to get "abc".  Note:  1 <= s.length <= 1000 s consists of lowercase English letters.  Question: You are given a string s of length n consisting of lowercase English letters.  You can perform the following operation on s:  Choose a character c and replace all occurrences of c in s with the next character (skipping the last character of the string if c is the last character of the string).  For example, if s = "abac", you can replace all occurrences of 'a' with 'b' to get "bbac".  You want to make s lexicograph
import sys input = sys.stdin.readline  def solve():     s,e = input().strip().split()     n = int(input())     if n%2==0:         print("undefined")     else:         if s=="^":             if e=="v":                 print("cw")             else:                 print("ccw")         elif s=="<":             if e==">":                 print("cw")             else:                 print("ccw")         elif s=="v":             if e=="^":                 print("cw")             else:                 print("ccw")         else:             if e=="<":                 print("cw")             else:                 print("ccw")  t = int(input()) while t>0:     solve()     t-=1
def pushDominoes(self, s):         """         :type s: str         :rtype: int         """         n = len(s)         if n == 1:             return 1         if s[0] == 'R':             return 1         if s[-1] == 'L':             return 1         for i in range(1,n):             if s[i] == 'R' and s[i-1] == 'L':                 return i+1         return n Question: You are given a string s of length n consisting of only zeroes and ones.  In one move, you can choose two adjacent positions in the string, and if the character in the second position is 0, you can append a 1 to the end of the first position.  Return the minimum number of moves required to make s a power of two.  It is guaranteed that the answer fits in a 32-bit integer.   -----Input-----  The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.  The first line of each test case contains an integer n (1 ≤ n ≤ 5 ⋅ 10^5) — the length of string s.  The second line of each test case contains the binary string s (|s| = n).  It is guaranteed that for each test case:     * s consists of only zeroes and ones.    * 1 ≤ n ≤ 5 ⋅ 10^5.   -----Output-----  For each test case, print the minimum number of moves required to make s a power of two, or -1 if it is impossible.   -----Example----- Input 4 6 011000 8 11010101 4 1000 8 00110001   Output 2 -1 6 2  Note  In the first test case, string s after making those two moves: 011000 → 01
def restore(self, n, m, l):         a = [0]*n         for i in range(m):             a[l[i]-1] = i+1         for i in range(n):             a[i] += a[i-1]         for i in range(n):             if a[i] > n:                 return -1         return a  Question: You are given a string s of length n consisting of lowercase English letters.  You are also given an integer k.  You want to choose a string t of length k and make it a subsequence of s.  A string a is a subsequence of a string b if a can be obtained from b by deletion of several (possibly, zero or all) characters.  For example, "xy" is a subsequence of "xzyw" and "xy", but not "yx".  A string a is said to be a subsequence of string b if a can be obtained from b by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.  For example, "xy" is a subsequence of "xzyw" and "xy", but not "yx".  You want to choose a string t of length k that is a subsequence of s.  What is the lexicographically smallest string t you can choose?  Input  The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.  The first line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 2 ⋅ 10^5) — the length of the string s and the length of the string t you want to choose.  The second line of each test case contains the string s consisting of lowercase English letters.  It is guaranteed that the sum of values n among all test cases does not exceed 2 ⋅ 10^5.  Output  For each test case, print the lexicographically smallest string t you can choose.  Example inputCopy 2 6 4 xyzwxy 2 2 xy outputCopy wxyz yx inputCopy 2 10 10 q
def swap(a,b):     return b*10 + a%10  def solve(a,k):     if k == 0:         return a     if a < 10:         return a     if a < 100:         return swap(a[0],a[1])     if a < 1000:         return swap(a[0],a[2])     if a < 10000:         return swap(a[0],a[3])     if a < 100000:         return swap(a[0],a[4])     if a < 1000000:         return swap(a[0],a[5])     if a < 10000000:         return swap(a[0],a[6])     if a < 100000000:         return swap(a[0],a[7])     if a < 1000000000:         return swap(a[0],a[8])     if a < 10000000000:         return swap(a[0],a[9])     if a < 100000000000:         return swap(a[1],a[2])     if a < 1000000000000:         return swap(a[1],a[3])     if a < 10000000000000:         return swap(a[1],a[4])     if a < 100000000000000:         return swap(a[1],a[5])     if a < 1000000000000000:         return swap(a[1],a[6])     if a < 10000000000000000:         return swap(a[1],a[7])     if a < 100000000000000000:         return swap(a[1],a[8])     if a < 10
def is_arithmetic(a,d):     n = len(a)     for i in range(1,n):         if a[i]!= a[i-1]+d:             return False     return True  def is_geometric(a,q):     n = len(a)     for i in range(1,n):         if a[i]!= a[i-1]*q:             return False     return True  def next_element(a,d):     n = len(a)     for i in range(1,n):         if a[i]!= a[i-1]+d:             return a[i-1]+d     return 42  def next_element(a,q):     n = len(a)     for i in range(1,n):         if a[i]!= a[i-1]*q:             return a[i-1]*q     return 42  def solve():     a = list(map(int,input().split()))     a.sort()     if is_arithmetic(a,a[1]-a[0]):         print(next_element(a,a[1]-a[0]))     elif is_geometric(a,a[1]/a[0]):         print(next_element(a,a[1]/a[0]))     else:         print(42)  for _ in range(int(input())):     solve()
def maxDistance(self, colors):         n = len(colors)         dp = [0]*n         for i in range(n):             dp[i] = 1         for i in range(1,n):             if colors[i]!= colors[i-1]:                 dp[i] = dp[i-1]+1         for i in range(n-2,-1,-1):             if colors[i]!= colors[i+1]:                 dp[i] = max(dp[i],dp[i+1]+1)         return max(dp) Question: You are given a string $s$ of length $n$ consisting of lowercase English letters.  You can perform the following operation on the string any number of times:  Choose a character $c$ and replace all occurrences of $c$ in the string with $c + 1$.  For example, if $s = "aabbc"$ and you choose $c = "b"$ then the string becomes $s = "aabcc"$ and you have made $2$ operations.  You want to make the string lexicographically as small as possible.  Return the lexicographically smallest string you can obtain after performing any number of operations.  A string $a$ is lexicographically smaller than a string $b$ if in the first position where $a$ and $b$ differ, string $a$ has a letter that appears earlier in the alphabet than the corresponding letter in $b$. For example, string $a = "ab"$ is lexicographically smaller than string $b = "abe"$.  Example 1:   Input: s = "aaa" Output: "aba" Explanation: You can transform s to "aba" with the following operations: - Choose c = "a" and replace all occurrences of "a" with "b". The string becomes "aba". - Choose
def solve(self, n, m, k):         if k
def possibleCards(self, n: int, s: str) -> str:         if n == 1:             return s         if n == 2:             return 'BGR'[s.count('B') + s.count('G') + s.count('R') - 3]         if n == 3:             return 'BGR'[s.count('B') + s.count('G') + s.count('R') - 6]         if n == 4:             return 'BGR'[s.count('B') + s.count('G') + s.count('R') - 9]         if n == 5:             return 'BGR'[s.count('B') + s.count('G') + s.count('R') - 12]         if n == 6:             return 'BGR'[s.count('B') + s.count('G') + s.count('R') - 15]         if n == 7:             return 'BGR'[s.count('B') + s.count('G') + s.count('R') - 18]         if n == 8:             return 'BGR'[s.count('B') + s.count('G') + s.count('R') - 21]         if n == 9:             return 'BGR'[s.count('B') + s.count('G') + s.count('R') - 24]         if n == 10:             return 'BGR'[s.count('B') + s.count('G') + s.count('R') - 27]         if n == 11:             return 'BGR'[s.count('B') + s.count('G') + s.count('R') - 30]         if n == 12:             return 'BGR'[s.count('B') + s.count('G') + s.count('R') - 33]         if n == 13:             return 'BGR'[s.count('B') + s.count('G') + s.count('R') - 36]         if n == 14:             return 'BGR'[s.count('B') + s.count('G') + s.count('R') -
