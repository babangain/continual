Provide a friendly representation :returns: Machine friendly representation :rtype: str
Get the channel sid from the channel

Get
Get an item from the list of resources :param unicode key: The index of the resource to fetch :returns
""" Initialize the InvitePage :param Version version: Version that contains the resource :param Response response: Response from the API :param service_sid: The SID of the Service that the resource is associated with :param channel_sid: The SID of the Channel the resource belongs to :returns: twilio.rest.chat.v
Initialize the InvitePage :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :
Build an instance of InviteInstance :param dict payload:
Download videos from a Vimeo channel :param str channel_id: Vimeo channel id :param str output_dir: Output directory :param bool merge: Merge all videos into one file :param bool info_only: Only print information of videos :param dict kwargs: Other parameters
Makes the requests to the Twilio Video API to get the next page of results. :param str target_url:


""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': payload.get('sid'), 'account_sid': payload.get('account_sid'), 'service_sid': payload.get('service_sid'), 'channel_sid': payload.get('channel_sid'), 'created_by': payload.get('created_by'), 'created_by_identity': payload.get('created_by_identity'), 'role_sid': payload.get('role_sid'), 'date_created': deserialize.iso8601_datetime(payload.get('date_created')), 'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')), 'url': payload.get('url'), } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': payload.get('sid'), } @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property def service_sid(self): """ :returns: The SID of the Service that the resource is associated with :rtype: unicode """ return self._properties['service_sid'] @property def channel_sid(self): """ :returns: The SID of the Channel the resource belongs to :rtype: unicode """ return self._properties['channel_sid'] @property def created_by(self): """ :returns: The identity of the User that created the resource :rtype: unicode """ return

Get the available streams :param dict kwargs: Optional arguments :returns: dict :rtype: dict
Get the srt json from the acfun api :param str vid: Acfun video id :returns: srt json :rtype: str

Provide a friendly representation :returns: Machine friendly representation :rtype: str
Retrieve a specific page of InviteInstance records from the API. Request is executed immediately :param str target_url: API-generated URL for the requested results page :returns: Page of InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage
Provide a friendly representation :returns: Machine friendly representation :rtype: str
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._version.account_sid, 'service_sid': service_sid, 'channel_sid': channel_sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'role_sid': role_sid, 'identity': identity, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self
Build an instance of InviteInstance :param dict payload:

下载课程

""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': None, 'service_sid': service_sid, 'channel_sid': channel_sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property
Generate an absolute URL for this Invite :returns: Absolute URL for this Invite :rtype: unicode Code
Get connection parameters from the configuration file :

nan
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._solution['account_sid'], 'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource
Fetch the next row of a query result set, returning a single sequence, or None when no more data is available. :returns: The next row of a query result set, or None :rtype: tuple
""" Initialize the CreateInviteInstance :param unicode service_sid: The SID of the Service to create the resource :param unicode channel_sid: The SID of the Channel the new resource belongs to :param unicode identity: The `identity` value that identifies the new resource's User :param unicode role_sid: The SID of the Role to assign to the new resource :param unicode ttl: An application-defined integer value that indicates how long, in seconds, the invite is valid. Can be an integer between 86400 and 2592000 (1 day and 30 days, respectively). By default, the invite is valid for 24 hours. :param unicode x_twilio_webhook_enabled: The X-Twilio-Webhook-Enabled HTTP request header :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(CreateInviteInstance, self).__init__() self._version = version self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'identity': identity, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) # Values of the request self._values = { 'role_sid': role_sid, 'ttl': ttl, 'x_twilio_webhook_enabled': x_twilio_webhook_enabled, } @property def service_sid(self): """ :returns: The SID of the Service to create the resource :rtype: unicode """ return self._properties['service_sid'] @property def channel_sid(self): """ :returns: The SID of the Channel the new resource belongs to :rtype: unicode """ return self._properties['channel_sid'] @property def sid(self): """ :returns: The unique string that identifies the resource

Get the connection schema :returns: str :rtype: str

Get the number of workers expected in gunicorn master process :param num_workers: number of workers in gunicorn master process :param num_workers_max: maximum number of workers in gunicorn master process :returns: number of workers expected :rtype: int
Generate an API-ready query string for the request. :returns: Twilio Request
Initialize the InviteContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel

Update an instance of InviteInstance :param dict body: A JSON string that represents an InviteInstance resource's state :param project_id: The SID of the Project that the resource is associated with :returns: True if update succeeds, False otherwise :rtype: bool
Get an instance. :param str project_id: Project ID :param str instance_id: Instance ID :returns: Instance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance

Build an instance of InviteInstance :param dict payload: Payload response from the API :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance

Returns a database instance. :param str instance: Instance name :param str project_id: Project ID :rtype: google.cloud.sql.db_instance.DatabaseInstance

Export an instance of a Service :param str instance: The SID of the Service Instance to export :param str body: The JSON string that specifies the export configuration :param str project_id: The SID of the Sync Project with the Service to export :rtype: dict :return: The response from the API """ try: response = self.get_conn().instances().export( project=project_id, instance=instance, body=body ).execute(num_retries=self.num_retries) operation_name = response["name"] self._wait_for_operation_to_complete(project_id=project_id, operation_name=operation_name) except HttpError as ex: raise AirflowException( 'Exporting instance {} failed: {}'.format(instance, ex.content) )
Download the cloud_sql_proxy if it is not already present.
Get the credentials from the file. :returns: dict :rtype: dict
Get the version of the SQL proxy binary from the file. :returns: The version of the SQL proxy binary from the file. :rtype: str
Get the connection parameters for the connection URI. :returns: The connection parameters :rtype: dict
""" Initialize the InviteList

""" Returns the instance specification for the Cloud SQL Proxy. :rtype: dict """ return { 'region': self.region, 'instance_name': self.instance_name, 'database_name': self.database_name, 'database_username': self.database_username, 'database_password': self.database_password, 'database_port': self.database_port, 'database_type': self.database_type, 'database_flags': self.database_flags, 'database_charset': self.database_charset, 'database_collation': self.database_collation, 'database_uri': self.database_uri, 'database_uri_override': self.database_uri_override, 'database_proxy_uri': self.database_proxy_uri, 'database_proxy_uri_override': self.database_proxy_uri_override, 'database_proxy_port': self.database_proxy_port, 'database_proxy_port_override': self.database_proxy_port_override, 'database_proxy_username': self.database_proxy_username, 'database_proxy_username_override': self.database_proxy_username_override, 'database_proxy_password': self.database_proxy_password, 'database_proxy_password_override': self.database_proxy_password_override, 'database_proxy_database_name': self.database_proxy_database_name, 'database_proxy_database_name_override': self.database_proxy_database_name_override, 'database_proxy_database_type': self.database_proxy_database_type, 'database_proxy_database_type_override': self.database_proxy_database_type_override, 'database_proxy_database_flags': self.database_proxy_database_flags, 'database_proxy_database_flags_override': self.database_proxy_database_flags_override, 'database_proxy_database_charset': self.database_proxy_database_charset, 'database_proxy_database_charset_override': self.database_proxy_database_charset_override, 'database_proxy_database_

Get the service name from the service sid :returns: The service name :rtype: unicode
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._solution['account_sid'], 'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource


Get the channel members from the channel sid :param str channel_sid: The channel sid :returns: The channel members :rtype: list
Get the channel sid from the channel name :param str channel_name: The channel name :returns: The channel sid :rtype: str

""" Initialize the ChatServiceInstance :returns: twilio.rest.chat.v2.service.ChatServiceInstance :rtype: twilio.rest.chat.v2.service.ChatServiceInstance """ super(ChatServiceInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': kwargs.get('account_sid'), 'friendly_name': kwargs.get('friendly_name'), 'attributes': kwargs.get('attributes'), 'reachability_enabled': deserialize.bool(kwargs.get('reachability_enabled')), 'typing_indicator_timeout': deserialize.integer(kwargs.get('typing_indicator_timeout')), 'consumption_report_interval': deserialize.integer(kwargs.get('consumption_report_interval')), 'notifications': NotificationList( self._version, service_sid=sid, ), 'users': UserList( self._version, service_sid=sid, ), 'channels': ChannelList( self._version, service_sid=sid, ), 'roles': RoleList( self._version, service_sid=sid, ), 'bindings': BindingList( self._version, service_sid=sid, ), 'webhooks': WebhookList( self._version, service_sid=sid, ), 'url': kwargs.get('

Return a boto3 connection. :rtype: boto3.client

""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': None, 'service_sid': service_sid, 'channel_sid': channel_sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Iterate over pages of results :returns: Page of InviteInstance :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Provide a friendly representation :returns: Machine friendly representation :rtype: str
""" Get the druid broker connection id :returns: str :rtype: str """ return self.druid_broker_conn_id Docstring
Makes a request and returns a Page object instance. :param str target_url: API-generated URL for the requested results page :param dict params: Parameters to pass to the API :param str method: HTTP method to use :param bool stream: Whether to stream the response to the client. Not supported for GET requests :param int timeout: HTTP request timeout :param int connect_timeout: Connection timeout :param str idempotency_key: Optional HTTP header to pass to the API :returns: Page :rtype: twilio.rest.base.page.Page

""" Iterate over pages of results :returns: Page of InviteInstance :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance] """ return self._version.page( method='GET', uri=self._uri,
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': None, 'service_sid': service_sid, 'channel_sid': channel_sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._version.account_sid, 'service_sid': service_sid, 'channel_sid': channel_sid, 'identity': identity, 'role_sid': role_sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': None, 'service_sid': service_sid, 'channel_sid': channel_sid, 'identity': identity, 'role_sid': role_sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """
Get the channel type from the channel_type parameter or the channel_name parameter. :returns: The channel type :rtype: str
""" Iterate over pages of InviteInstance :returns: Page of InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.Invite
Strip the SQL from the exception message :param str sql: The SQL to strip :returns: The stripped SQL :rtype: str
Generate a WSGI request for the InviteInstance :param unicode method: The HTTP method to use to fetch the InviteInstance :param unicode url: The absolute URL for the InviteInstance :param dict data: The data to include in the request's body :param dict headers: The HTTP request headers :returns: WSGI request object
Get the result set from the HQL string. :param str hql: The HQL string to get the result set from. :returns: The result set from the HQL string.
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Constructs a ChannelContext :param unique_name: The unique_name :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext

Create a new collection in the database. :param str collection_name: The name of the collection to create.
Returns the database table partition expiration days. :rtype: int
Create a table in the database :param str database_name: The name of the database :param str table_name: The name of the table :param dict table_schema: The schema of the table :returns: True if the table was created, False otherwise :rtype: bool

Get a document from a collection :param str collection_name: The name of the collection :param str document_id: The id of the document to get :param str database_name: The name of the database :returns: The document :rtype: dict
Insert a single document into the collection :param dict document: The document to insert :param str database_name: The name of the database :param str collection_name: The name of the collection :return: The created document :rtype: dict
Get the link to a document :param str database_name: The name of the database to get the document from :param str collection_name: The name of the collection to get the document from :param str document_id: The id of the document to get :returns: str :rtype: str Code
Get a document by query :param dict query: The query to use :param str database_name: The name of the database :param str collection_name: The name of the collection :returns: The document :rtype: dict
Get a database from the account :param str database_name: The name of the database to get :rtype: dict
Generate an API-ready query string for the request. :returns: Twilio-specific query string for this Request :rtype: unicode
Returns the function source archive url.
Returns a function with the given name from the specified project and location. :param str name: The name of the function which should be returned. :returns: The result of the operation. :rtype: dict
Return the function trigger http. :param bool function_trigger_http: Function trigger http :returns: Function trigger http :rtype: bool


Retrieve a single page of InviteInstance records from the API. Request is executed immediately :param str page_token: PageToken provided by the API :param int page_number: Page Number, this value is simply for client state :param int page_size: Number of records to return, defaults to 50
Returns a list of DepStatus objects for the task instance. :param TaskInstance ti: TaskInstance to get dependencies for :param Session session: Session to use for dependencies :param DepContext dep_context: DepContext to use for dependencies :rtype: list[DepStatus]
Setting option names depending on file format :param str config_file_name: Path to the config
session, _ = self._get_credentials(region_name) # Credentials are refreshable, so accessing your access key and # secret key separately can lead to a race condition. # See https://stackoverflow.com/a/36291428/8283373 return session.get_credentials().get_frozen_credentials()
Get cursor from connection string :param str conn_string: Connection string :returns: Cursor :rtype: Cursor
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def date_created(self): """ :returns: The ISO 8601 date and time in GMT when the resource was created :rtype: datetime """ return self._properties['date_created'] @property def date_updated(self): """ :returns: The ISO 860


Constructs a InviteContext
Launches a DagFileProcessorManager process. :param str dag_directory: The directory containing the DAGs :param list[str] file_paths: The file paths to the DAGs :param int max_runs: The maximum number of times to run the DAGs :param DagFileProcessorFactory processor_factory: The factory to use to create DagFileProcessor instances :param multiprocessing.connection.Connection child_signal_conn: The connection to the child process signal handler :param multiprocessing.Queue stat_queue: The queue to put stats into :param multiprocessing.Queue result_queue: The queue to put results into :param bool async_mode: Whether to run the DagFileProcessorManager in async mode or not :return: The DagFileProcessorManager process :rtype: multiprocessing.Process
""" Handle a message from the manager. :param str message: The message received from the manager. """ if message == DagParsingSignal.TERMINATE_MANAGER: self.log.info("Manager has terminated.") self._child_signal_conn.close() self._child_signal_conn = None self._child_process.terminate() self._child_process = None self._child_process_lock.release() self._child_process_lock = None self._child_process_event.set() self._child_process_event = None self._child_process_event_lock.release() self._child_process_event_lock = None self._child_process_event_lock.acquire() self._child_process_event.wait() self._child_process_event = None self._child_process_event_lock = None self._child_process_event_lock.acquire() self._child_process_event.set() self._child_process_event = None self._child_process_event_lock = None self._child_process_event_lock.acquire() self._child_process_event.wait() self._child_process_event = None self._child_process_event_lock = None self._child_process_event_lock.acquire() self._child_process_event.set() self._child_process_event = None self._child_process_event_lock = None self._child_process_event_lock.acquire() self._child_process_event.wait() self._child_process_event = None self._child_process_event_lock = None self._child_process_event_lock.acquire() self._child_process_event.set() self._child_process_event = None self._child_process_event_lock = None self._child_process_event_lock.acquire() self._child_process_event.wait() self._child_process_event = None self._child_process_event_lock = None self._child_process_event_lock.acquire() self._child_process_event.
Process a task from the queue. :param task_id: Task to process :type task_id: str
""" Wait for all tasks to finish. :return: None """ self.log.info("Waiting for all tasks to finish") self.log.info("Waiting for all tasks to finish") self.log.info("Waiting for all tasks to finish") self.log.info("Waiting for all tasks to finish") self.log.info("Waiting for all tasks to finish") self.log.info("Waiting for all tasks to finish") self.log.info("Waiting for all tasks to finish") self.log.info("Waiting for all tasks to finish") self.log.info("Waiting for all tasks to finish") self.log.info("Waiting for all tasks to finish") self.log.info("Waiting for all tasks to finish") self.log.info("Waiting for all tasks to finish") self.log.info("Waiting for all tasks to finish") self.log.info("Waiting for all tasks to finish") self.log.info("Waiting for all tasks to finish") self.log.info("Waiting for all tasks to finish") self.log.info("Waiting for all tasks to finish") self.log.info("Waiting for all tasks to finish") self.log.info("Waiting for all tasks to finish") self.log.info("Waiting for all tasks to finish") self.log.info("Waiting for all tasks to finish
Check if any of the files in the DAG directory have been modified since the last time we checked. :returns: A list of SimpleDag objects :rtype: list[SimpleDag]
Mark a file as processed. :param str file_path: Path to the file to mark as processed :return: None Code
Stop the thread that refreshes the list
""" Log the stats for the files that were processed :param list[str] file_paths: List of file paths that were processed """ self.logger.info('Processing stats for files: %s', file_paths) for file_path in file_paths: self.logger.info('File: %s', file_path) self.logger.info('Total lines: %s', self._file_stats[file_path]['total_lines']) self.logger.info('Total errors: %s', self._file_stats[file_path]['total_errors']) self.logger.info('Total warnings: %s', self._file_stats[file_path]['total_warnings']) self.logger.info('Total info: %s', self._file_stats[file_path]['total_info']) self.logger.info('Total debug: %s', self._file_stats[file_path]['total_debug']) self.logger.info('Total critical: %s', self._file_stats[file_path]['total_critical']) self.logger.info('Total fatal: %s', self._file_stats[file_path]['total_fatal']) self.logger.info('Total unknown: %s', self._file_stats[file_path]['total_unknown']) self.logger.info('Total ignored: %s', self._file_stats[file_path]['total_ignored']) self.logger.info('Total skipped: %s', self._file_stats[file_path]['total_skipped']) self.logger.info('Total ignored: %s', self._file_stats[file_path]['total_ignored']) self.logger.info('Total skipped: %s', self._file_stats[file_path]['total_skipped']) self.logger.info('Total ignored: %s', self._file_stats[file_path]['total_ignored']) self.logger.info('Total skipped: %s', self._file_stats[file_path]['total_skipped']) self.logger.info('Total ignored: %s', self._file_stats[file_path]['total_ignored']) self.logger.info('Total skipped: %
""" Iterate over pages of InviteInstance :returns: Page of InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage

Process files in the queue in a background thread :returns: True if files were processed, False otherwise :rtype: bool
Iterate over list of Invites and return a generator yielding one Invite instance each :returns: Generator that will yield up to limit results :rtype: list[twilio.rest.chat.v2.service.channel
Get the zombies :returns: list[airflow.models.dag.DAG] :rtype: list[airflow.models.dag.DAG]
Build an instance of MessageInstance :param dict payload: Payload response from the API :returns: twilio.rest.chat.v2.service.channel.message.MessageInstance :rtype: twilio.rest.chat.v2.service.channel.message.MessageInstance

Provide a friendly representation :returns: Machine friendly representation :rtype: str
Retrieve a single page of TransferJobInstance records from the API. Request is executed immediately :param str target_url: API-generated URL for the requested results page :param unicode project_id: The SID of the Project to fetch the TransferJobs from :returns: Page of TransferJobInstance :rtype: twilio.rest.chat.v2.service.channel.transfer_job.TransferJobPage

Get the channel sid from the channel unique name. :param str channel_unique_name

Build an instance of InviteInstance :param dict payload: Payload response from the API :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
Remove a user from the channel :param unicode identity: The identity of the User to remove from the Channel :returns: True if delete succeeds, False otherwise :rtype: bool
Provide a friendly representation :returns: Machine friendly representation :rtype: str

Build an instance of InviteInstance :param dict payload:
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': payload.get('sid'), 'account_sid': payload.get('account_sid'), 'service_sid': payload.get('service_sid'), 'channel_sid': payload.get('channel_sid'), 'identity': payload.get('identity'), 'role_sid': payload.get('role_sid'), 'date_created': deserialize.iso8601_datetime(payload.get('date_created')), 'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')), 'url': payload.get('url'), } # Context self._context = None

Remove a section from the config file if it is empty.
""" Build an instance of InviteInstance :param dict payload: Payload response from the API :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel
Get a connection to the Google Cloud Pub/Sub API. :returns: Google Cloud Pub/Sub API connection :rtype: googleapiclient.discovery.Resource
Get the credentials from the Google Cloud Platform API. :returns: Credentials :rtype:
Get a resource from the Google Cloud Platform API. :param str name: Name of the resource :returns: Google Cloud Platform resource :rtype: googleapiclient.discovery.Resource
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._solution['account_sid'], 'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'account_sid': account_sid, 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns:
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._solution['account_sid'], 'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'account_sid': account_sid, 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns
Retrieve a single page of InviteInstance records from the API. Request is executed immediately :param twilio.rest.chat.v2.service.channel.invite.InvitePage response: page from which to start retrieving the next page :returns: Page of InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage
Generate a payload for a
nan
""" Initialize the InvitePage :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage """ super(InvitePage, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) @property def has_previous_page(self): """ :returns: True if there is a previous page of results, False otherwise :rtype: bool """ return self._version.has_previous_page(self._uri) @property def previous_page_url(self): """ :returns: The URL of the previous page of results :rtype: unicode """ return self._version.previous_page_url(self._uri) @property def next_page_url(self): """ :returns: The URL of the next page of results :rtype: unicode """ return self._version.next_page_url(self._uri) @property def invites(self): """ :returns: A list of instances of Inv
Code
""" Lists MemberInstance records from the API as a list. Unlike stream(), this operation is eager and will load `limit` records
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': payload.get('sid'), 'account_sid': payload.get('account_sid'), 'service_sid': payload.get('service_sid'), 'channel_sid': payload.get('channel_sid'), 'identity': payload.get('identity'), 'role_sid': payload.get('role_sid'), 'date_created': deserialize.iso8601_datetime(payload.get('date_created')), 'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')), 'url': payload.get('url'), } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': payload.get('sid'), } @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property def service_sid(self): """ :returns: The SID of the Service that the resource is associated

Code

Return a connection to the service. :rtype: :class:`ibm_watson.natural_language_understanding_v1.NaturalLanguageUnderstandingV1`
Return a connection to the service. :rtype: :class:`ibm_watson.natural_language_understanding_v1.NaturalLanguageUnderstandingV1`
Get the template fields for a given object. :param env: Sphinx environment :type env: Sphinx environment :param fullname: Full name of the object :type fullname: str :returns: List of template fields :rtype: list

""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': payload.get('sid'), 'account_sid': payload.get('account_sid'), 'service_sid': payload.get('service_sid'), 'channel_sid': payload.get('channel_sid'), 'role_sid': payload.get('role_sid'), 'identity': payload.get('identity'), 'date_created': deserialize.rfc2822_datetime(payload.get('date_created')), 'date_updated': deserialize.rfc2822_datetime(payload.get('date_updated')), 'url': payload.get('url'), } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': payload.get('sid'), } @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property def service_sid(self): """ :returns: The SID of the Service that the resource is associated with :rtype: unicode """ return self._properties['service_sid'] @property def channel_sid(self): """ :returns: The SID of the Channel the resource belongs to :rtype: unicode """ return self._properties['channel_sid'] @property def role_sid(self): """ :returns: The SID of the Role assigned to the user when they join the Channel :rtype: unicode """ return self._properties['role_sid'] @property def identity(self):
nan


Converts a Twilio.IpMessaging.V2.InvitePage instance into a JSON object that can be turned into valid JSON in a Twilio request. :returns: JSON object representing this InvitePage :rtype: dict
Provide a friendly representation :returns: Machine friendly representation :rtype: str
""" Initialize the InvitePage :param Version version: Version that contains the resource :param service_sid: The SID of the Service that the resource is associated with :param channel_sid: The SID of the Channel the resource belongs to :param sid: The unique string that identifies the resource :param date_created: The ISO 8601 date and time in GMT when the resource was created :param date_updated: The ISO 8601 date and time in GMT when the resource was last updated :param by: The identity of the User who created the resource :param role_sid: The SID of the Role assigned to the User :param identity: The unique string that identifies the resource's User :param url: The absolute URL of the Page :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage """ super(InvitePage, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) # Page Parameters self._page_size = kwargs.get('page_size', limits.DEFAULT_PAGE_SIZE) self._limit = kwargs.get('limit') self._page_token = kwargs.get('page_token') #has a limit and a next_page_url self._has_next_page = True if self._limit is not None else False self._next_page_url = None if self._limit is not None else url # Filter results from the server self.path_account_sid = kwargs.get('path_account_sid', self._solution['service_sid']) self.by = by self.role_sid = role_sid self.identity = identity
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def date_created(self): """ :returns: The ISO 8601 date and time in GMT when the resource was created :rtype: datetime """ return self._properties['date_created'] @property def date_updated(self): """ :returns: The ISO 8601
Provide a friendly representation :returns: Machine friendly representation :rtype

Retrieve a specific page of InviteInstance records from the API. Request is executed immediately :param str target_url: API-generated URL for the requested results page :returns: Page of InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage
Code
Provide a friendly representation :returns: Machine friendly representation :rtype: str


Fetch a InviteInstance :param identity: The identity :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
This background task sends packets to the server.
Initialize the SyncListResource :param unicode service_sid: The SID of the Service to fetch the resource from :param unicode channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList
Get an item from the list of resources :param unicode key: The index of the resource to

Wait for job to finish :param str project_id: Project ID :param str job_id: Job ID :returns: Job :rtype: Job

Convenience method to access a single instance of InviteInstance :param str key: The index of the resource to fetch :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.

Set the default version for the model. :param str project_id: The project ID. :param str model_name: The name of the model. :param str version_name: The name of the version. :returns: The response from the API. :rtype: dict """ full_version_name = 'projects/{}/models/{}/versions/{}'.format( project_id, model_name, version_name) request = self._mlengine.projects().models().versions().setDefault( name=full_version_name, body={}) try: response = request.execute() self.log.info('Successfully set version:


Get a model. :param str project_id: The project that owns the model to get. :param str model_id: The ID of the model to get. :returns: The model. :rtype: dict
Get a model from the project. :param str project_id: The project ID. :param str model_name: The model name. :returns: A model. :rtype: dict """ if not model_name: raise ValueError("Model name must be provided and " "it could not be an empty string") full_model_name = 'projects/{}/models/{}'.format( project_id, model_name) request = self._mlengine.projects().models().get(name=full_model_name) try: return request.execute() except HttpError as e: if e.resp.status == 404: self.log.error('Model was not found: %s
Returns the table fields map reverse. :rtype: dict
Makes a request to the Twilio API :param str method: The HTTP method to use :param str url: The URL to request :param dict data: The data to send :param dict headers:
Build an instance of InviteInstance :param dict payload:
Get a list of all hook objects :return: The list of hook objects :rtype: list
""" :param response: :return: """ self.log.info('Received response: {}'.format(response)) self.log.info('Received response: {}'.format(response)) self.log.info('Received response: {}'.format(response)) self.log.info('Received response: {}'.format(response)) self.log.info('Received response: {}'.format(response)) self.log.info('Received response: {}'.format(response)) self.log.info('Received response: {}'.format(response)) self.log.info('Received response: {}'.format(response)) self.log.info('Received response: {}'.format(response)) self.log.info('Received response: {}'.format(response)) self.log.info('Received response: {}'.format(response)) self.log.info('Received response: {}'.format(response)) self.log.info('Received response: {}'.format(response)) self.log.info('Received response: {}'.format(response)) self.log.info('Received response: {}'.format(response)) self.log.info('Received response: {}'.format(response)) self.log.info('Received response: {}'.format(response)) self.log.info('Received response: {}'.format(response)) self.log.info('Received response: {}'.format(response)) self.log.info('Received response: {}'.format(response)) self.log.info('Received response: {}'.format(response)) self.log.info('Received response: {}'.format(response)) self.log.info('Received response: {}'.format(response)) self.log.info('Received response: {}'.format(response)) self.log.info('Received response: {}'.format(response)) self.log.info('Received response: {}'.format(response)) self.log.info('Received response: {}'.format(response)) self.log.info('Received response: {}'.format(response)) self.log.info('Received response: {}'.format(response)) self.log.info('Received response: {}'.format(response)) self.log.info('Received response: {}'.format(response)) self.log.info('Received response: {}'.format(response)) self.log.info('
Get cursor from connection id :param str schema: Schema :param str conn_id: Connection id :returns: Cursor :rtype: Cursor






Returns true if both instances are not equal, false otherwise :returns: True if both instances are not equal, false otherwise :rtype: bool


Retrieve a specific page of InviteInstance records from the API. Request is executed immediately :param str target_url: API-generated URL for the requested results page :returns: Page of InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': payload.get('sid'), 'account_sid': payload.get('account_sid'), 'service_sid': payload.get('service_sid'), 'channel_sid': payload.get('channel_sid'), 'identity': payload.get('identity'), 'role_sid': payload.get('role_sid'), 'date_created': deserialize.iso8601_datetime(payload.get('date_created')), 'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')), 'url': payload.get('url'), } # Context self._context = None self
Build an instance of InviteInstance :param dict payload:
""" Initialize the TaskInstance :param airflow.models.BaseOperator base_operator: The base operator :param airflow.utils.state state: The state of the task instance :param str run_id: The run_id of the task instance :param str task_id: The task_id of the task instance :param str dag_id: The dag_id of the task instance :param datetime start_date: The start_date of the task instance :param datetime end_date: The end_date of the task instance :param datetime execution_date: The execution_date of the task instance :param datetime try_number: The try_number of the task instance :param str hostname: The hostname of the task instance :param str unixname: The unixname of the task instance :param str pid: The pid of the task instance :param str pool: The pool of the task instance :param str queue: The queue of the task instance :param str operator: The operator of the task instance :param str queued_dttm: The queued_dttm of the task instance :param str start_date: The start_date of the task instance :param str end_date: The end_date of the task instance :param str try_number: The try_number of the task instance :param str hostname: The hostname of the task instance :param str unixname: The unixname of the task instance :param str pid: The pid of the task instance :param str pool: The pool of the task instance :param str queue: The queue of the task instance :param str operator: The operator of the task instance :param str queued_dttm: The queued_dttm of the task instance :param str start_date: The start_date of the task instance :param str end_date: The end_date of the task instance :param str try_number: The try_number of the task instance :param str hostname: The hostname of the task instance :param str unixname: The unixname of the task instance :param str pid: The pid of the task instance :param str pool: The pool of the task instance :param str queue: The queue of the
Get the result of the ingestion query :param str ingest_query_id: Ingestion query ID :returns: dict :rtype: dict
""" Initialize the InviteList :param unicode service_sid: The SID of the Service to fetch the resource from :param unicode channel_sid: The SID of the Channel the resource to fetch belongs to :param Version version: Version that contains the resource :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) # Components self._invites = None @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = InviteList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._invites def __repr__(self): """ Provide a friendly representation :returns: Machine friendly representation :rtype: str """ return '<Twilio.IpMessaging.V2.InviteList>' class InvitePage(Page): """ PLEASE NOTE that this class contains preview products that are subject to change. Use them with caution. If you currently do not have developer preview access, please contact <EMAIL>. """ def __init__(self, version, response, solution): """ Initialize the InvitePage :param Version version: Version that contains the resource :param Response response: Response from the API :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.invite
Build an instance of InviteInstance :param dict payload:

Get a list of task instances associated with this task. :param session: The database session to use. :type session: Session :rtype: list[airflow.models.taskinstance.TaskInstance]


Get a task instance associated with this dag run :param str task_id: Task ID :return: Task instance :rtype: airflow.models.TaskInstance
Get the next dagrun for this task instance. :param session: the database session :type session: Session :return: the next dagrun for this task instance :rtype: models.DagRun
Provide a friendly representation :returns: Machine friendly representation :rtype: str
""" Perform a request and return a Response object. :param str method: The HTTP method to use. :param str url: The URL to send the request to. :param dict params: The parameters to send with the request. :param dict data: The data to send with the request. :param dict headers: The headers to send with the request. :param bool stream: Whether to stream the response. :param int timeout: The timeout to use for the request. :param tuple auth: The HTTP Basic Auth credentials to use. :param bool allow_redirects: Whether to allow redirects. :param dict proxies: The proxies to use for the request. :param dict hooks: The hooks to use for the request. :param bool stream_decode_responses: Whether to stream the response content. :param bool verify: Whether to verify the server's SSL certificate. :param str cert: The path to the SSL client certificate file. :rtype: requests.Response """ if not isinstance(url, six.string_types): raise TypeError('url must be a string, not {}'.format( type(url).__name__)) if not isinstance(params, dict): raise TypeError('params must be a dict, not {}'.format( type(params).__name__)) if not isinstance(data, dict): raise TypeError('data must be a dict, not {}'.format( type(data).__name__)) if not isinstance(headers, dict): raise TypeError('headers must be a dict, not {}'.format( type(headers).__name__)) if not isinstance(stream, bool): raise TypeError('stream must be a bool, not {}'.format( type(stream).__name__)) if not isinstance(timeout, int): raise TypeError('timeout must be an int, not {}'.format( type(timeout).__name__)) if not isinstance(auth, tuple): raise TypeError('auth must be a tuple, not {}'.format( type(auth).__name__)) if not isinstance(allow_redirects
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': payload.get('sid'), 'account_sid': payload.get('account_sid'), 'service_sid': payload.get('service_sid'), 'channel_sid': payload.get('channel_sid'), 'role_sid': payload.get('role_sid'), 'identity': payload.get('identity'), 'date_created': deserialize.iso8601_datetime(payload.get('date_created')), 'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')), 'url': payload.get('url'), } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': payload.get('sid'), } @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property def service_sid(self): """ :returns: The SID of the Service that the resource is associated with :rtype: unicode """ return self._properties['service_sid'] @property def channel_sid(self): """ :returns: The SID of the Channel the resource belongs to :rtype: unicode """ return self._properties['channel_sid'] @property def role_sid(self): """ :returns: The SID of the Role assigned to the member :rtype: unicode """ return self._properties['role_sid'] @property def identity(self): """ :returns
""" Initialize the InviteList :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) def stream(self, limit=None, page_size=None): """ Streams InviteInstance records from the API as a generator stream. This operation lazily loads records as efficiently as possible until the limit is reached. The results are returned as a generator, so this operation is memory efficient. :param int limit: Upper limit for the number of records to return. stream() guarantees to never return more than limit. Default is no limit :param int page_size: Number of records to fetch per request, when not set will use the default value of 50 records. If no page_size is defined but a limit is defined, stream() will attempt to read the limit with the most efficient page size,

Returns the DagBag singleton :rtype: airflow.models.dagbag.DagBag
Lists InviteInstance records from the API as a list. Unlike stream(), this operation is eager and will load `limit` records into
""" Returns the next dag run for a given dag and execution date. :param dag: DAG :type dag: DAG :param execution_date: execution date :type execution_date: datetime :return: next dag run :rtype: DagRun """ # TODO: This is a bit of a hack. We should be able to get the next # execution date from the scheduler, but that's not exposed. # We should also be able to get the next execution date from the # database, but that's not exposed. # We should be able to get the next execution date from the # scheduler, but that's not exposed. # We should be able to get the next execution date from the # database, but that's not exposed. # We should be able to get the next execution date from the # scheduler, but that's not exposed. # We should be able to get the next execution date from the # database, but that's not exposed. # We should be able to get the next execution date from the # scheduler, but that's not exposed. # We should be able to get the next execution date from the # database, but that's not exposed. # We should be able to get the next execution date from the # scheduler, but that's not exposed. # We should be able to get the next execution date from the # database, but that's not exposed. # We should be able to get the next execution date from the # scheduler, but that's not exposed. # We should be able to get the next execution date from the # database, but that's not exposed. # We should be able to get the next execution date from the # scheduler, but that's not exposed. # We should be able to get the next execution date from the # database, but that's not exposed. # We should be able to get the next execution date from the # scheduler, but that's not exposed. # We should be able to get the next execution date from the # database, but that's not exposed. # We
Build an instance of InviteInstance :param dict payload:
""" Constructor :param str dag_id: DAG ID :param dag: DAG object :type dag: DAG :param datetime execution_date: Execution date :param bool ignore_dependencies: Ignore task dependencies :param bool ignore_first_depends_on_past: Ignore depends_on_past dependencies for the first task :param bool ignore_task_deps: Ignore task-specific dependencies :param bool ignore_ti_state: Ignore the previous TaskInstance state :param str pool: Specify a pool to use. This overrides the default pool :param int delay_on_limit_secs: Number of seconds to wait before considering the limit hit :param str pickle_id: Specify an ID for the pickled DAG object. This allows multiple DAG objects to be pickled and unpickled in the course of a single run :param bool raw: If True, don't execute the DAG but instead execute each task and their dependencies as though they were in sequence """ self.dag_id = dag_id self.root_dag = root_dag self.execution_date = execution_date self.ignore_dependencies = ignore_dependencies self.ignore_first_depends_on_past = ignore_first_depends_on_past self.ignore_task_deps = ignore_task_deps self.ignore_ti_state = ignore_ti_state self.pool = pool self.delay_on_limit_secs = delay_on_limit_secs self.pickle_id = pickle_id self.raw = raw self.kwargs = kwargs self.task_ids = [] self.task_group = None self.task_instances = {} self.downstream_task_ids = set() self.upstream_task_ids = set() self.queued_task_instances = [] self.queued_task_instances

Provide a friendly representation


Get the next page of results :param Response response: Response from the API :returns: Response from the API :rtype: Response
""" :param dict properties: A mapping of property names to values """ self._properties = properties if'sid' in properties: self._solution['sid'] = properties['sid'] if 'account_sid' in properties: self._solution['account_sid'] = properties['account_sid'] if'service_sid' in properties: self._solution['service_sid'] = properties['service_sid'] if 'channel_sid' in properties: self._solution['channel_sid'] = properties['channel_sid'] if 'identity' in properties: self._solution['identity'] = properties['identity'] if 'role_sid' in properties: self._solution['role_sid'] = properties['role_sid'] if 'date_created' in properties: self._solution['date_created'] = properties['date_created'] if 'date_updated' in properties: self._solution['date_updated'] = properties['date_updated'] if 'url' in properties: self._solution['url'] = properties['url'] if 'links' in properties: self._solution['links'] = properties['links'] if 'channel_sid' in properties: self._properties['channel_sid'] = properties['channel_sid'] if 'date_created' in properties: self._properties['date_created'] = deserialize.iso8601_datetime(properties['date_created']) if 'date_updated' in properties: self._properties['date_updated'] = deserialize.iso8601_datetime(properties['date_updated']) if 'url' in properties: self._properties['url'] = properties['url'] if 'links' in properties: self._properties['links'] = properties['links'] if 'identity' in properties: self._properties['identity'] = properties['identity'] if 'role_sid' in properties: self._properties['role_sid'] = properties['role_sid'] if 'try_number' in
Build an instance of InviteInstance :param dict payload: Payload response from the API :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance

Provide a friendly representation :returns: Machine friendly representation :rtype: str
""" Get new args for pickling. :return: The new args :rtype:
""" Provide a friendly representation
Lists InviteInstance records from the API as a list. Unlike stream(), this operation is eager and will load `limit` records into memory before returning. :param int limit: Upper limit for the number of records to return. list() guarantees never to return more than limit. Default is no limit :param int page_size: Number of records to fetch per request, when not set will use the default value of 50 records. If no page_size is defined but a limit is defined, list() will attempt to read the limit with the most efficient page size, i.e. min(limit, 1000) :returns: Generator that will yield up to limit results :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]

Convenience method to access an item of this instance. :param unicode key: The index of the requested resource :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
Returns true if both instances are not equal, false otherwise. :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance :returns: True if other is not a InviteInstance or it represents :rtype: bool
""" Initialize the InviteList :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) def stream(self, limit=None, page_size=None): """ Streams InviteInstance records from the API as a generator stream. This operation lazily loads records as efficiently as possible until the limit is reached. The results are returned as a generator, so this operation is memory efficient. :param int limit: Upper limit for the number of records to return. stream() guarantees to never return more than limit. Default is no limit :param int page_size: Number of records to fetch per request, when not set will use the default value of 50 records. If no page_size is defined but a limit is defined, stream() will attempt to read the limit with the most efficient page size,
Get the previous DagRun :param session: The database session :type session: sqlalchemy.orm.session.Session :returns: The previous DagRun :rtype: airflow.models.dagrun.DagRun Code


:returns: Number
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._solution['service_sid'], 'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource
Retrieve a specific page of InviteInstance records from the API. Request is executed immediately :param str target_url: API-generated URL for the requested results page :returns: Page of InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage
Waits for the operation to complete. :param str project_id: Project ID :param str operation_name: Operation name :param str zone: Zone
Get URL :param str path: Path :returns: str :rtype: str
Constructs a InviteContext :param sid: The SID that identifies the resource to fetch :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext
Gets the list of instance templates filtered by the filter. :param str project_id
List all Instance Group Manager resources in a zone. :param str zone: The zone name for this request. :param str project_id: Project ID for this request. :returns: A list of Instance Group Manager resources. :rtype: list[dict]
Waits for the operation to complete. :param str project_id: Project ID :param str operation_name: Operation name :param str zone: Zone
nan
Get the
Get the CORS configuration of a bucket :param bucket_name: The name of the bucket to get the CORS configuration of :type bucket_name: str :rtype: str
List all objects in a bucket. :param str bucket_name: The name
Code
""" Retrieve a list of all Messages in the Channel. :param list[str] index_attributes: The
Download a file from S3 to a file
Get a URL for an object in S3 :param str key: The key of the object to fetch. :param str bucket_name: The name of the bucket containing the object. :returns: The URL for the object. :rtype: str

Return the object :param str bucket_name: Name of the bucket :param str key: Key of the object :rtype: boto3.resource
""" Get a wildcard key from the bucket :param str wildcard_key: The wildcard key to fetch :param str bucket_name: The bucket name :param str delimiter: The delimiter to use :returns: The wildcard key :rtype: str """ if bucket_name is None: bucket_name = self.bucket_name if delimiter is None: delimiter = self.delimiter if not wildcard_key.startswith(delimiter): wildcard_key = delimiter + wildcard_key if not wildcard_key.endswith(delimiter): wildcard_key = wildcard_key + delimiter wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter) wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter) wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter) wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter) wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter) wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter) wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter) wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter) wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter) wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter) wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter) wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter) wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter) wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter) wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter) wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter) wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter) wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter) wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter) wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter) wildcard_key = wildcard_key.replace(delimiter + delimiter, delimiter)
Parse a S3 URL into bucket and key. :param str url: The S3 URL to parse. :returns: Tuple of bucket and key :rtype: tuple[str, str]

""" Load a JSON object into the bucket. :param dict json_data: The JSON object to store. :param str key: The key to store the JSON object under. :param str bucket_name:
Parse a URL into scheme, netloc, path, and query :param str url: URL :returns: tuple :rtype: tuple
""" Remove a file from S3 :param file_obj: File object to
Parses a s3:// url and returns the bucket name and key. :param str url: The s3:// url to parse. :rtype: tuple

Provide a friendly representation :returns: Machine friendly representation :rtype: str
Send an SMS message to a channel. :param body: The message body. :type body: str :param from_: The phone number to send the message from. :type from_: str :param kwargs: Additional keyword arguments. :type kwargs: dict :returns: The response from the API. :rtype: dict
Generate an API-ready query string for the request. :returns: Twilio Request :rtype: requests.Request
Provide a friendly representation :returns: Machine friendly representation :rtype: str

""" Loads plugins from the packages. :param list airflow_

""" Get the next run data for the task. :param Session session: The database session :rtype: tuple :return: (next_run_date, next_run_data) """ next_run_data = None next_run_date = None # If the task is paused, we should not schedule it if self.state == State.PAUSED: self.log.info("Task is paused, skipping") return next_run_date, next_run_data # If the task is paused, we should not schedule it if self.state == State.UP_FOR_RETRY: self.log.info("Task is up for retry, skipping") return next_run_date, next_run_data # If the task is paused, we should not schedule it if self.state == State.UP_FOR_RESCHEDULE: self.log.info("Task is up for reschedule, skipping") return next_run_date, next_run_data # If the task is paused, we should not schedule it if self.state == State.NONE: self.log.info("Task is not scheduled, skipping") return next_run_date, next_run_data # If the task is paused, we should not schedule it if self.state == State.SHUTDOWN: self.log.info("Task is shutting down, skipping") return next_run_date, next_run_data # If the task is paused, we should not schedule it if self.state == State.REMOVED: self.log.info("Task is removed, skipping") return next_run_date, next_run_data # If the task is paused, we should not schedule it if self.state == State.FAILED: self.log.info("Task is failed, skipping") return next_run_date, next_run_data # If the task is paused, we should not schedule it if self.state == State.SUCCESS: self.log.info("Task is success, skipping") return next_run_date, next_run_data # If the task is paused, we should not schedule it if self.state == State
Get a resource by sid :param str sid: Resource sid :returns: Resource :rtype: Resource
Get the content of the file :param str file_path: The path to the file :returns: bytes :rtype: bytes
""" Initialize the InviteList :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) def stream(self, limit=None, page_size=None): """ Streams InviteInstance records from the API as a generator stream. This operation lazily loads records as efficiently as possible until the limit is reached. The results are returned as a generator, so this operation is memory efficient. :param int limit: Upper limit for the number of records to return. stream() guarantees to never return more than limit. Default is no limit :param int page_size: Number of records to fetch per request, when not set will use the default value of 50 records. If no page_size is defined but a limit is defined, stream() will attempt to read the limit with the most efficient page size, i
""" Initialize the InviteList :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) def create(self, identity, role_sid=values.unset, type=values.unset, url=values.unset, ttl=values.unset): """ Create the InviteInstance :param unicode identity: The `identity` value that identifies the new resource's User :param unicode role_sid: The SID of the Role to assign to the new resource :param unicode type: The type of push notification to send to the new resource's User :param unicode url: The absolute URL of the new resource :param unicode ttl: The amount of time, in seconds, that the new resource is valid :returns: The created InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ data = values.of({ 'Identity': identity, 'RoleSid': role_sid, 'Type': type, 'Url': url, 'Ttl': ttl, }) payload = self._version.create( 'POST', self._uri, data=data, ) return InviteInstance( self._version, payload, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) def stream(self, limit=None, page_size=None): """ Streams InviteInstance records from the API as a generator stream. This operation lazily loads records as efficiently as possible until the limit is reached.
Cancel the query if it is running.
Get an item from the list of resources in the response. :returns: An instance of the resource at the given index, or None

Helper method to get the parameters from the args object :param Namespace args: Namespace object containing the

nan


Determine if the error is retryable. :param requests_exceptions.RequestException e: The exception. :returns:
Get a connection form field options values by its id :param str
""" Initialize the InviteList :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :param sid: The SID of the Invite resource to fetch :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) # Filters self._filters = {'dateCreated': date_created, 'dateUpdated': date_updated, 'by': by, 'from': from_, 'to': to, 'body': body, 'url': url, } self._limit = None self._page_size = None @property def date_created(self): """ :returns: The ISO 8601 date and time in GMT when the resource was created :rtype: datetime """ return self._properties['date_created'] @property def date_updated(self): """ :returns: The ISO 8601 date and time in GMT when the resource was last updated :rtype: datetime """ return self._properties['date_updated'] @property def by(self): """ :returns: The identity of the User that created the Invite :rtype: unicode """ return self._properties['by'] @property def from_(self): """ :returns: The identity of the User that received the Invite :rtype: unicode """ return self._properties['from'] @property
""" :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ return self._version.service(self._solution['service_sid']) \ .channel(self._solution['channel_sid']) \ .invite(self._solution['sid']) Doc
Build an instance of InviteInstance :param dict payload: Payload response from the API :returns: twilio.rest.chat.
Generate an absolute URL for the InviteInstance :returns: Absolute URL for the InviteInstance :rtype: unicode
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Get the object id from the object name :param str object_name: Object name to get the object id from :returns: Object id :rtype: str
Fetch the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
Build an instance of Inv
Constructs a InviteContext :param sid: A 34 character string that uniquely identifies this resource. :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext
:param str subject: The subject of the mail to search for :param str mail_folder: The folder to search in :param bool check_regex: Whether to search for the mail by subject or by regex :returns: True if the mail is found, False otherwise :rtype: bool
Retrieve mail attachments by name :param str name: The name of the attachment :param str mail_folder: The folder to search in :param bool check_regex: Whether to check the regex or not :param bool latest_only: Whether to return only the latest attachment :returns: A list of attachments :rtype: list[twilio.rest.chat.v2.service.channel.message.MessageInstance.AttachmentContext]
Retrieve the attachments of a specific email :param str name: The name of the email to download the attachments from :param str mail_folder: The folder to search for the email in :param bool check_regex: Whether to check the regex or not :param bool latest_only: Whether to download only the latest email or not :returns: A list of attachments :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]
:param str extension: The extension of the attachment to find :param bool check

Return a boto3 Firehose



Initialize the InvitePage :param Version version: Version that contains the resource :param service_sid: The SID of the Service that the resource is associated with :param channel_sid: The SID of the Channel the resource belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage

Enter the context


Get a blob from the container. :param str container_name: The name of the container. :param str blob_name: The name of the blob. :param bool is_prefix: Whether the blob_name is a prefix or not. :param bool ignore_if_missing
Returns true if both instances are equal, false otherwise :returns: true if both instances are equal, false otherwise :rtype: bool
Get the connection pool :returns: Connection pool :rtype: ConnectionPool
List files in a directory :param str path: Path to list files in :param bool nlst: Whether to list files in a non-recursive manner :returns: List of files in the directory :rtype: list[str]
Retrieve a list of files from the FTP server. :param str remote_path: The path to the directory on the FTP server. :param str local_path: The path to the directory on the local system. :returns: A list of file names retrieved from the FTP server. :rtype: list[str]
Get the channel sid from the channel unique name
Generate the Twilio-provided URL for this resource :returns: Twilio-provided URL for this resource :rtype: unicode

Get the form widget for the connection :returns: form widget :rtype: form widget

"""
""" Retrieve a list of all Messages for a Channel. :param str order: The sort order of the returned Messages. Can be: `asc` to sort ascending by creation time or `desc` to sort descending by creation time. :param unicode from_: The `identity` value of the User that created the Messages to read. :param int limit: Upper limit for the number of records to return. list() guarantees never to return more than limit. Default is no limit :param unicode before: The `sid` value of the Message to read before. :param unicode after: The `sid` value of the Message to read after. :param bool include_archived: Whether to include messages that are archived. :param unicode order: The sort order of the returned Messages. Can be: `asc` to sort ascending by creation time or `desc` to sort descending by creation time. :param unicode from_: The `identity` value of the User that created the Messages to read. :param int limit: Upper limit for the number of records to return. list() guarantees never to return more than limit. Default is no limit :param unicode before: The `sid` value of the Message to read before. :param unicode after: The `sid` value of the Message to read after. :param bool include_archived: Whether to include messages that are archived. :param unicode order: The sort order of the returned Messages. Can be: `asc` to sort ascending by creation time or `desc` to sort descending by creation time. :param unicode from_: The `identity` value of the User that created the Messages to read. :param int limit: Upper limit for the number of records to return. list() guarantees never to return more than limit. Default is no limit :param unicode before: The `sid` value of the Message to read before. :param unicode after: The `sid` value of the Message to read after. :param bool include_archived: Whether to include messages that are archived. :param unicode order: The sort order of the returned Messages. Can be: `



""" Initialize the InviteList :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) def stream(self, limit=None, page_size=None): """ Streams InviteInstance records from the API as a generator stream. This operation lazily loads records as efficiently as possible until the limit is reached. The results are returned as a generator, so this operation is memory efficient. :param int limit: Upper limit for the number of records to return. stream() guarantees to never return more than limit. Default is no limit :param int page_size: Number of records to fetch per request, when not set will use the default value of 50 records. If no page_size is defined but a limit is defined, stream() will attempt to read the limit with the most efficient page size, i.e. min(limit, 1000) :returns:
Generate an absolute URL for the InviteInstance :returns: Absolute URL for the InviteInstance :rtype: unicode
Delete a Google Cloud Storage bucket.
:param str bucket_name: The name of the bucket to list the objects from :returns: The contents of the object :rtype: str
Upload a file to the bucket
Return the object from the Google Cloud Storage API as a bytes

Return a new connection to the Google Cloud Storage API. :rtype: :class:`google.cloud.storage.client.Client`
:param str bucket_name: The name of the bucket to list objects from. :param str object_name: The name of the object to list. :param bool versions: If true, list the versions of all objects in the bucket. :param int max_results: The maximum number of items to return. :param str prefix: The prefix of the object names to list. :param str delimiter: The delimiter of the object names to list. :returns: A list of object names. :rtype: list[str]
Return a connection to the Google Cloud Storage API. :rtype: :class:`google.cloud.storage.client.Client`
Retrieve an object from the Google Cloud Storage bucket :param str bucket_name: The name of the bucket :param str object_name: The name of the object :rtype: google.cloud.storage.blob.Blob
Retrieve the ACL of an object in a bucket :param str bucket_name: The name of the bucket :param str object_name: The name of
Get a bucket. :param bucket_name: The name of the bucket to get. :type bucket_name: str :return: The bucket. :rtype: google.cloud.storage.bucket.Bucket
Delete a blob object.
Get the channel members from the channel sid :param str channel_sid: The channel sid :returns: The channel members :rtype: list
Constructs a InviteContext :param sid: The unique string that identifies the resource :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext


Get the content of a file from the S3 URL :param s3url: The input S3 URL :type s3url: str :returns: The content of the file from the S3 URL :rtype: str
Get the log streams for the channel :param sid: The sid :returns: The log streams for the channel :rtype: unicode


List transform jobs :param int max_results: The maximum number of results to return in this page :param str next_token: The token for the next set of results, or null if there are no more results :returns: A list of transform jobs :rtype: list
Update an endpoint :param str endpoint_
Describe a training job :param str job_name: Name of the training job :returns: dict :rtype: dict
""" Initialize the InviteList :param unicode service_sid: The SID of the Service to fetch the resource from :param unicode channel_sid: The SID of the Channel the resource to fetch belongs to :param Version version: Version that contains the resource :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) # Components self._client = client @property def client(self): """ :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext.client :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext.client """ if self._client is None: self._client = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._client def __call__(self, sid): """ Constructs a InviteContext :param sid: The SID that identifies the resource to fetch :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ return InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=sid, ) def __repr__(self): """ Provide a friendly representation :returns: Machine friendly representation :rtype: str """ return '<Twilio.IpMessaging.V2.InviteList>' class InvitePage(Page): """ PLEASE NOTE that this class contains preview products that are subject to change. Use
""" Describe the training job and read the logs. :param str job_name: Name of the training job :param dict positions: Map of stream name -> position :param list stream_names: List of log streams :param int instance_count: Number of instances used for training :param LogState state: Current state :param dict last_description: Last description of the training job :param float last_describe_job_call: Last time the training job was described :returns: tuple(LogState, dict, float) :rtype: tuple(LogState, dict, float) """ if state == LogState.TAILING: # Read the logs for stream_name in stream_names: self.log.info('Reading logs from stream: {}'.format(stream_name)) self.read_logs(job_name, stream_name, positions[stream_name]) # Describe the training job description = self.describe_training_job(job_name) self.log.info(secondary_training_status_message(description, positions)) # Update the positions for stream_name in stream_names: positions[stream_name] = description['ResourceConfig']['S3OutputPath'] # Check if the job is complete if description['TrainingJobStatus'] in self.non_terminal_states: return LogState.TAILING, description, last_describe_job_call # Check if the job is failed if description['TrainingJobStatus'] in self.failed_states: return LogState.COMPLETE, description, last_describe_job_call # Check if the job is completed if description['TrainingJobStatus'] == 'Completed': return LogState.COMPLETE, description, last_describe_job_call # Check if the job is stopped if description['TrainingJobStatus'] == 'Stopped': return LogState.COMPLETE, description, last_describe_job_call # Check if the job is stopped if description['TrainingJobStatus'] == 'Stopping': return LogState.COMPLETE, description, last_describe_job_call # Check if the job is in progress if description
""" Build an instance of InviteInstance :param dict payload: Payload response from the API :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.
"""Run migrations in 'online' mode. In this scenario we need to create an Engine and associate a connection with the context. """ connectable = engine_from_config( config.get_section(config.config_ini_section), prefix='sqlalchemy.', poolclass=pool.NullPool) with connectable.connect() as connection: context.configure( connection=connection, target_metadata=target
"""Run migrations in 'offline' mode. This configures the context with just a URL and not an Engine, though an Engine is acceptable here as well. By skipping the Engine creation we don't even need a DBAPI to be available. Calls to context.execute() here emit the given string to the
Delete an instance of InviteInstance :param instance_id: The unique string that identifies the resource :param project_id: The unique string that identifies the resource :returns: True if delete succeeds, False otherwise :rtype: bool
Update an Instance :param str instance_id: The unique string that identifies the resource :param str project_id: The unique string that identifies the resource :param timeout: The timeout for the operation :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: tw
Constructs a InviteContext :param sid: The SID that identifies the resource to fetch :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext


Get the Hive CLI environment variables :return: Hive CLI environment variables :rtype: dict

Load data from a file into a Hive table. :param str filepath: Path to the file to load. :param str table: Name of the table to load the data into. :param dict field_dict: Dictionary of field names and types. :param str delimiter: Delimiter to use for the file. :param str encoding: Encoding to use for the file. :param kwargs: Additional keyword arguments to pass to the underlying Hive client. :returns: The number of rows loaded. :rtype: int
Lists MessageInstance records from the API as a list.
Generate an instance of a resource from a response. :param twilio.rest.resources.base.InstanceResponse response: Response from API :returns: twilio.rest.resources.base.InstanceResource :rtype: twilio.rest.resources.base.InstanceResource
Get all named partitions
""" Initialize the InviteList :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) def stream(self, limit=None, page_size=None): """ Streams InviteInstance records from the API as a generator stream. This operation lazily loads records as efficiently as possible until the limit is reached. The results are returned as a generator, so this operation is memory efficient. :param int limit: Upper limit for the number of records to return. stream() guarantees to never return more than limit. Default is no limit :param int page_size: Number of records to fetch per request, when not set will use the default value of 50 records.

Provide a friendly representation :returns: Machine friendly representation :rtype: str
Get the results of a Hive query. :param str hql: The HiveQL query to execute. :param str schema: The schema to use for the query. :param int fetch_size: The number of rows to fetch at a time. :param dict hive_conf: A dictionary of Hive configuration options. :returns: A generator that yields the results of the query. :rtype: generator
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Generate an absolute URL for this Invite :returns: unicode :rtype: unicode
Retrieve a specific page of InviteInstance records from the API. Request is executed immediately :param str target_url: API-generated URL for the requested results page :returns: Page of InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage
Get method from Airflow connection :param method: :return: """ if not method: raise AirflowException('Dingding method is requests but get nothing, ' 'check you method configuration.') return method
获取钉钉消息发送地址 :returns: str :rtype: str
""" Initialize the InviteList :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) # Components self._invites = None @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = InviteList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._
Provide a friendly representation :returns: Machine friendly representation :rtype: str

Provide a friendly representation :returns: Machine friendly representation :rtype: str
Provide a friendly representation :returns: Machine friendly representation :rtype: str

Get the data of
Create a new table in the specified dataset. :param str project_id: The ID of the project to create the table in. :param str dataset_id: The ID of the dataset to create the table in. :param str table_id: The ID of the
Patch a table :param str dataset_id: The ID of the dataset containing this table :param str table_id: The ID of the table to update :param str project_id: The ID of the project containing this table :param str description: A user-friendly description of this table :param str expiration_time: The time when this table expires, in milliseconds since the epoch :param dict external_data_configuration: Additional properties to set for the external data source configuration of the table :param str friendly_name: A descriptive name for this table :param list labels: User-provided labels for this table :param list schema: Describes the schema of this table :param dict time_partitioning: Additional properties to set for the time-based partitioning of the table :param dict view: Additional properties to set for the view of the table :param bool require_partition_filter: If set to True, queries over this table require a partition filter

Insert data into a table. :param str insertion_dataset_table: The fully-qualified table name. :param dict insertion_dataset_table_schema: The schema of the table. :param list insertion_dataset_table_data: The data to insert. :param bool ignore_if_missing: If True, do not raise an exception if the table does not exist. :raises: Exception if the table does not exist and ignore_if_missing is False.

Grant dataset write access to the current project. :param str source_dataset: Source dataset to grant access to. :param str source_project: Source project to grant access to. :returns: Dataset resource :rtype: dict
Get a list of BigQuery tables :param str dataset_id: The dataset ID :param str project_id: The project ID :returns: list :rtype: list
Get the table id from the dataset name and table name :param str dataset_name: The dataset name :param str table_name: The table name :returns: The table id :rtype: str
Retrieve a list of all Invites belonging to the Channel :param int limit: Upper limit for the number of records to return. list() guarantees
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._solution['account_sid'], 'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'account_sid': account_sid, 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns:
Deletes the InviteInstance :param dict payload: A JSON payload for this Invite :returns: True if delete succeeds, False otherwise :rtype: bool
""" Initialize the InviteList :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) def stream(self, limit=None, page_size=None): """ Streams InviteInstance records from the API as a generator stream. This operation lazily loads records as efficiently as possible until the limit is reached. The results are returned as a generator, so this operation is memory efficient. :param int limit: Upper limit for the number of records to return. stream() guarantees to never return more than limit. Default is no limit :param int page_size: Number of records to fetch per request, when not set will use the default value of 50 records. If no page_size is defined but a limit is defined, stream() will attempt to read the limit with the most efficient page size, i.e. min(limit, 1000) :returns: Generator that will yield up to limit results :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance] """ limits = self._version.read_limits(limit, page_size) page = self.page(page_size=limits['page_size'], ) return self._version.stream(page, limits['limit'], limits['page_limit']) def list(self, limit=None, page_size=None): """ Lists InviteInstance records from the API as a list. Unlike stream(), this operation is eager and will load `limit` records into memory before returning.


Retrieve a list of queues :param int limit: Upper limit for the number of records to return. list() guarantees never to return more than limit. Default is no limit :param int page_size: Number of records to fetch per request, when not set will use the default value of 50 records. If

Provide a friendly representation :returns: Machine friendly representation :rtype: str
Provide a friendly representation
Parse arguments

Create path element :param str width: Width of the SVG container in pixels or percent :param str height: Height of the SVG container in pixels
Provide a friendly representation :param dict payload: Payload response from the API :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance

axis = {} if custom_format and format: axis['tickFormat'] = format elif format: axis['tickFormat'] = "d3.format(',%s')" % format if label: axis['axisLabel'] = "'" + label + "'" # Add new axis to list of axis self.axislist[name] = axis
Get database hook :returns: DatabaseHook :rtype: DatabaseHook
""" Initialize the InviteList :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) def create(self, identity, role_sid=values.unset, type=values.unset, url=values.unset, ttl=values.unset): """ Create a new InviteInstance :param unicode identity: The `identity` value that identifies the new resource's User :param unicode role_sid: The SID of the Role to assign to the new resource :param unicode type: The type of push notification to use. Can be: `gcm` or `apn`. :param unicode url: The URL we should call using the `notification_protocol` to send a notification when the Invite expires. :param unicode ttl: The amount of time, in seconds, that the invite is valid. Can be an integer between 86400 and 2592000 (1 day and 30 days, respectively). :returns: Newly created InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ data = values.of({ 'Identity': identity, 'RoleSid': role_sid, 'Type': type, 'Url': url, 'Ttl': ttl, }) payload = self._version.create( 'POST', self._uri, data=data, ) return InviteInstance( self._version, payload, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid
Provide a friendly representation :returns: Machine friendly representation :rtype: str




Get an item from the list of resources :param unicode key: The index of the resource to fetch
""" Initialize the InviteList :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) def create(self, identity, role_sid=values.unset, channel_sid=values.unset, **kwargs): """ Create the InviteInstance :param unicode identity: The `identity` value that identifies the new resource's User :param unicode role_sid: The SID of the Role to assign to the new resource :param unicode channel_sid: The SID of the Channel the new resource belongs to :returns: The created InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ data = values.of({ 'Identity': identity, 'RoleSid': role_sid, 'ChannelSid': channel_sid, }) payload = self._version.create( 'POST', self._uri, data=data, ) return InviteInstance( self._version, payload, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) def stream(self, limit=None, page_size=None): """ Streams InviteInstance records from the API as a generator stream. This operation lazily loads records as efficiently as possible until the limit is reached. The results are returned as a generator, so this operation is memory efficient. :param int limit: Upper limit for the number of records to return. stream() guarantees to never return more than limit. Default is no limit :param int page_size: Number of records to fetch per request, when not set will use the default value of 50 records. If no
Build an instance of InviteInstance :param dict payload: Payload response from the API :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
Retrieve a member :param str sid: The SID of the Member resource to fetch :returns: twilio.rest.chat.v2.service.channel.member.MemberInstance :rtype: tw

Get the connection pool max_overflow :returns
Build an instance of InviteInstance :param dict payload:

""" Build the OpsGenie payload :returns: dict :rtype: dict """ payload = { 'alias': self.alias, 'description': self.description, 'source': self.source, 'teams': self.teams, 'entity_selector': self.entity_selector, 'user_selector': self.user_selector, 'priority': self.priority, 'responders': self.responders, 'note': self.note, 'details': self.details, 'tags': self.tags, 'note_type': self.note_type, 'message_type': self.message_type, 'message_data': self.message_data, 'message_data_type': self.message_data_type, 'message_data_encoding': self.message_data_encoding, 'message_subject': self.message_subject, 'message_body': self.message_body, 'message_from': self.message_from, 'message_cc': self.message_cc, 'message_bcc': self.message_bcc, 'message_to': self.message_to, 'message_attachments': self.message_attachments, 'message_priority': self.message_priority, 'message_timeout': self.message_timeout, 'message_scheduled': self.message_scheduled, 'message_client_msg_id': self.message_client_msg_id, 'message_client_msg_ts': self.message_client_msg_ts, 'message_client_msg_seq': self.message_client_msg_seq, 'message_client_msg_channel': self.message_client_msg_channel, 'message_client_msg_tags': self.message_client_msg_tags, 'message_client_msg_alias': self.message_client_msg_alias, 'message_client_msg_description': self.message_client_msg_description, 'message_client_msg_source': self.message_client_msg_source, 'message_client_msg_teams': self.message_client_msg_teams, 'message_client_
Get the client type :param str client_type: The client type :returns: The client type :rtype: str
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._solution['account_sid'], 'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'account_sid': account_sid, 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns
Constructs a InviteContext :param unicode identity: The unique string that identifies the resource's User :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext

Fetch the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
Provide a friendly representation :returns: Machine friendly representation :rtype: str
""" Return a new connection to the Zendesk API :rtype: zendesk.client.Client """ return Client( self.username, self.password, subdomain=self.subdomain, api_url=self.api_url, headers=self.headers, timeout=self.timeout, verify=self.verify, proxies=self.proxies, user_agent=self.user_agent, user_agent_append=self.user_agent_append, user_agent_append_version=self.user_agent_append_version, user_agent_append_version_prefix=self.user_agent_append_version_prefix, user_agent_append_version_suffix=self.user_agent_append_version_suffix, user_agent_append_version_separator=self.user_agent_append_version_separator, user_agent_append_version_separator_prefix=self.user_agent_append_version_separator_prefix, user_agent_append_version_separator_suffix=self.user_agent_append_version_separator_suffix, user_agent_append_version_separator_suffix_separator=self.user_agent_append_version_separator_suffix_separator, user_agent_append_version_separator_suffix_separator_prefix=self.user_agent_append_version_separator_suffix_separator_prefix, user_agent_append_version_separator_suffix_separator_suffix=self.user_agent_append_version_separator_suffix_separator_suffix, user_agent_append_version_separator_suffix_separator_suffix_separator=self.user_agent_append_version_separator_suffix_separator_suffix_separator, user_agent_append_version_separator_suffix_separator_suffix_separator_prefix=self.user_agent_append_version_separator_suffix_separator_suffix_separator_prefix, user_agent_append_version_separator_suffix_separator_suffix_separator_suffix=self.user_agent_append_version_separator_suffix_separator_suffix_separator_suffix, user_agent_append_version_separator_suffix_separator_suffix_separator_suffix_separator

Get the schemas of all tables in a
Get the storage descriptor of a table :param str database_name: The database name :param str table_name: The table name :returns: A dict containing the storage descriptor of the table :rtype: dict
Build an instance of InviteInstance :param dict payload: Payload response from the API :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.


Build an instance of InviteInstance :param dict payload: Payload response from the API :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance

""" Initialize the InviteContext :param service_sid: The SID of the Service to create the resource under :param channel_sid: The SID of the Channel the new resource belongs to :param identity: The unique string that identifies the resource's User :param role_sid: The SID of the Role assigned to the new resource :param ttl: An integer representing how long, in seconds, the new resource should be retained in the Channel before being automatically deleted :param x_twilio_webhook_enabled: The X-Twilio-Webhook-Enabled HTTP request header :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ super(InviteContext, self).__init__(version) # Path Solution self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'identity': identity, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) # Headers self._headers = {'X-Twilio-Webhook-Enabled': x_twilio_webhook_enabled, } self._payload = { 'RoleSid': role_sid, 'Ttl': ttl, } def fetch(self, **kwargs): """ Fetch a InviteInstance :returns: Fetched InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ params = values.of({}) payload = self._version.fetch( 'GET', self._uri, params=params, headers=self._headers, ) return InviteInstance( self._version, payload, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], identity=self._solution['identity'], ) def delete(self, **kwargs): """ Deletes the InviteInstance :returns
Build an instance of InviteInstance :param dict payload: Payload response from the API :returns: twilio.rest.chat.v2.
Build an instance of InviteInstance :param dict payload: Payload response from the API :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
Get the list of files in the given path. :param str path: The path to the directory to list. :param bool ignore_copying: Whether to ignore copying files. :returns: A list of files in the given path. :
Get the Mongo conn id :returns: str :rtype: str
""" Get pool stats :param Session session: SQLAlchemy session :returns: dict :rtype: dict """ query = session.query( func.count(Channel.sid), func.count(Invite.sid), func.count(Message.sid), func.count(UserMessage.sid), func.count(Reaction.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func.count(File.sid), func


Initialize the InvitePage :param Version version: Version that contains the resource :param dict payload: A JSON response from the Twilio API :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage
Get an operation by id :param str operation_id: Id of the operation to get :param str project_id: Project ID to get operation from :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
Generate an absolute URL for this Invite :returns: Absolute
Get the cluster master version from the cluster proto. :param google.cloud.container_v1.types.Cluster cluster_proto
Create a cluster. :param cluster: The cluster to create. :type cluster: dict or Cluster :param project_id: The Google Cloud Platform project ID to use. :type project_id: str :param retry: A retry object used to retry requests. If ``None`` is specified, requests will not be retried. :type retry: google.api_core.retry.Retry :param timeout: The amount of time, in seconds, to wait for the request to complete. Note that if ``retry`` is specified, the timeout applies to each individual attempt. :type timeout: float :rtype: str :raises: :class:`google.api_core.exceptions.GoogleAPICallError` if the request failed for any reason. :raises: :class:`airflow.exceptions.AirflowException` if the request failed for any reason.
Fetch a cluster by name. :param str name: The name of the cluster to fetch. :param str project_id: The ID of the project that owns the cluster. :param google.api_core.retry.Retry retry: Designation of what errors, if any, should be retried. :param float timeout: The timeout for
:param str http_conn_
:returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service
""" Build the payload for Discord :returns: dict :rtype: dict """ payload = { 'username': self.username, 'avatar_url': self.avatar_url, 'embeds': [ { 'title': self.title, 'description': self.description, 'url': self.url, 'color': self.color, 'fields': self.fields, 'footer': self.footer, 'image': self.image, 'thumbnail': self.thumbnail, 'video': self.video, 'provider': self.provider, 'author': self.author, 'fields': self.fields, 'timestamp': self.timestamp, 'footer': self.footer, 'image': self.image, 'thumbnail': self.thumbnail, 'video': self.video, 'provider': self.provider, 'author': self.author, 'fields': self.fields, 'timestamp': self.timestamp, 'footer': self.footer, 'image': self.image, 'thumbnail': self.thumbnail, 'video': self.video, 'provider': self.provider, 'author': self.author, 'fields': self.fields, 'timestamp': self.timestamp, 'footer': self.footer, 'image': self.image, 'thumbnail': self.thumbnail, 'video': self.video, 'provider': self.provider, 'author': self.author, 'fields': self.fields, 'timestamp': self.timestamp, 'footer': self.footer, 'image': self.image, 'thumbnail': self.thumbnail, 'video': self.video, 'provider': self.provider, 'author': self.author, 'fields': self.fields, 'timestamp': self.timestamp, 'footer': self.footer, 'image': self.image, 'thumbnail': self.thumbnail, 'video': self.video, 'provider': self.provider, 'author': self.author, 'fields': self.fields, 'timestamp': self.timestamp, 'footer': self.footer, 'image': self.image, 'thumbnail': self.thumbnail
Decrypts data that was encrypted with a given key. :param str key_name: The resource name of the CryptoKey to use for decryption. Must be in the format ``projects/*/locations/*/keyRings/*/cryptoKeys/*``. :param bytes ciphertext: The data encrypted with the named CryptoKey. :param bytes authenticated_data: Optional data that must also be
""" Lists InviteInstance records from the API as


Generate an API-ready query string for the request. :returns: Twilio-specific query string for this request :rtype: unicode
Synthesize speech from input data :param str input_data: The input data to synthesize. :param str voice: The voice to use for synthesis. :param dict audio_config: The audio configuration to use for synthesis. :param int retry: The number of times to retry the synthesis request. :param int timeout: The number of seconds to wait for the synthesis request to complete. :returns: The synthesized audio data. :rtype: bytes
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._solution['account_sid'], 'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'account_sid': account_sid, 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns
Get the volume claims for the dags :returns: list[dict] :rtype: list[dict]
""" Get the pod spec for the worker pod :return: pod spec :rtype: dict """ pod_spec = { 'containers': [ { 'name': 'airflow-worker', 'image': self.kube_config.airflow_image, 'imagePullPolicy': 'IfNotPresent', 'env': self._get_environment(), 'command': [ 'airflow', 'worker', '--pid', '/tmp/airflow-worker.pid', '--log-file', '/tmp/airflow-worker.log', '--log-format', 'airflow.cfg', '--log-level', 'INFO', '--pool', self.kube_config.airflow_pool, '--hostname', self.kube_config.airflow_hostname, '--executor', 'LocalExecutor', '--max-workers', '1', '--max-failures', '1', '--queued-task-ttl', '300', '--queued-task-retry-delay', '300', '--queued-task-retry-limit', '3', '--queued-task-retry-exponential-multiplier', '2', '--queued-task-retry-exponential-max', '300', '--queued-task-retry-jitter', '0.1', '--queued-task-retry-limit-strategy', 'fixed', '--queued-task-retry-limit-strategy-fixed-limit', '10', '--queued-task-retry-limit-strategy-fixed-interval', '300', '--queued-task-retry-limit-strategy-fixed-jitter', '0.1', '--queued-task-retry-limit-strategy-fixed-exponential-multiplier', '2', '--queued-task-retry-limit-strategy-fixed-exponential-max', '300', '--queued-task-retry-limit-strategy-fixed-exponential-jitter', '0.1', '--queued-task-retry-limit-strategy-fixed-exponential-max-interval', '300', '--queued-task-retry-limit-strategy-fixed-exponent



Log a message. Code

""" Process a message from the queue :param Message message: Message to process """ if message.type == 'task_failure': self._process_task_failure(message) elif message.type == 'task_success': self._process_task_success(message) elif message.type == 'task_heartbeat': self._process_task_heartbeat(message) elif message.type == 'task_reschedule': self._process_task_reschedule(message) elif message.type == 'task_cancel': self._process_task_cancel(message) elif message.type == 'task_state_change': self._process_task_state_change(message) elif message.type == 'task_failure_reschedule': self._process_task_failure_reschedule(message) elif message.type == 'task_failure_cancel': self._process_task_failure_cancel(message) elif message.type == 'task_failure_reschedule_cancel': self._process_task_failure_reschedule_cancel(message) elif message.type == 'task_failure_reschedule_cancel_reschedule': self._process_task_failure_reschedule_cancel_reschedule(message) elif message.type == 'task_failure_reschedule_cancel_reschedule_cancel': self._process_task_failure_reschedule_cancel_reschedule_cancel(message) elif message.type == 'task_failure_reschedule_cancel_reschedule_cancel_reschedule': self._process_task_failure_reschedule_cancel_reschedule_cancel_reschedule(message) elif message.type == 'task_failure_reschedule_cancel_reschedule_cancel_reschedule_cancel': self._process_task_failure_reschedule_cancel_reschedule_cancel_reschedule_cancel(message) elif message.type == 'task_failure_reschedule_cancel_reschedule_cancel_reschedule_cancel_reschedule': self._process_task_failure_reschedule_cancel_reschedule_cancel_reschedule_cancel_reschedule(message) elif message.type == 'task_failure_reschedule_cancel_re

""" Process a message from the queue :param message: Message to process :type message: Message """ if message.type == 'invite': self.get_instance(message.payload).save() elif message.type == 'invite_accepted': self.get_instance(message.payload).accept() elif message.type == 'invite_rejected': self.get_instance(message.payload).reject() elif message.type == 'invite_canceled': self.get_instance(message.payload).cancel() elif message.type == 'invite_timeout': self.get_instance(message.payload).timeout() elif message.type == 'invite_removed': self.get_instance(message.payload).remove() elif message.type == 'invite_updated': self.get_instance(message.payload).update() elif message.type == 'invite_error': self.get_instance(message.payload).error() elif message.type == 'invite_deleted': self.get_instance(message.payload).delete() elif message.type == 'invite_replaced': self.get_instance(message.payload).replace() elif message.type == 'invite_invited': self.get_instance(message.payload).invite() elif message.type == 'invite_accepted_by_remote': self.get_instance(message.payload).accept_by_remote() elif message.type == 'invite_rejected_by_remote': self.get_instance(message.payload).reject_by_remote() elif message.type == 'invite_canceled_by_remote': self.get_instance(message.payload).cancel_by_remote() elif message.type == 'invite_timeout_by_remote': self.get_instance(message.payload).timeout_by_remote() elif message.type == 'invite_removed_by_remote': self.get_instance(message.payload).remove_by_remote() elif message.type == 'invite_updated_by_remote': self.get_instance(message.payload).update_by_remote() elif message.type == 'invite_error_by_remote':
""" Initialize the InviteList :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) def stream(self, limit=None, page_size=None): """ Streams InviteInstance records from the API as a generator stream. This operation lazily loads records as efficiently as possible until the limit is reached. The results are returned as a generator, so this operation is memory efficient. :param int limit: Upper limit for the number of records to return. stream() guarantees to never return more than limit. Default is no limit :param int page_size: Number of records to fetch per request, when not set will use the default value of 50 records.
""" Process the task instances for a given dag. :param dag: the dag to process :type dag: airflow.models.dag.DAG :param queue: the queue to put task instances into :type queue: list :param session: the database session :type session: sqlalchemy.orm.session.Session """ # update the state of the previously active dag runs dag_runs = DagRun.find(dag_id=dag.dag_id, state=State.RUNNING, session=session) active_dag_runs = [] for run in dag_runs: self.log.info("Examining DAG run %s", run) # don't consider runs that are executed in the future if run.execution_date > timezone.utcnow(): self.log.error( "Execution date is in future: %s", run.execution_date ) continue if len(active_dag_runs) >= dag.max_active_runs: self.log.info("Number of active dag runs reached max_active_run.") break # skip backfill dagruns for now as long as they are not really scheduled if run.is_backfill: continue # todo: run.dag is transient but needs to be set run.dag = dag # todo: preferably the integrity check happens at dag collection time run.verify_integrity(session=session) run.update_state(session=session) if run.state == State.RUNNING: make_transient(run) active_dag_runs.append(run) for run in active_dag_runs: self.log.debug("Examining active DAG run: %s", run) # this needs a fresh session sometimes tis get detached tis = run.get_task_instances(state=(State.NONE, State.UP_FOR_RETRY, State.UP_FOR_RESCHEDULE)) # this loop is quite slow as it uses are_dependencies_met for # every task (in ti.is_runnable). This is also called in # update_state above which has already checked these tasks for ti in tis: task = dag
Set
nan
Set the state of the given task instances to queued. :param list[airflow.models.TaskInstance] task_instances: The task instances to set to queued. :param list[airflow.utils.state.State] acceptable_states: The acceptable states to set the task instances to. :param Session session: The session to use. :return: A list of SimpleTaskInstance for the use of queuing them in the executor. :rtype: list[airflow.models.SimpleTaskInstance]
actually enqueue them :param SimpleDagBag simple_dag_bag: :param list[models.TaskInstance] simple_task_instances:
Enqueue task instance :param SimpleDagBag simple_dag_bag: SimpleDagBag :param SimpleTaskInstance simple_ti: SimpleTaskInstance
Set the following tasks to scheduled state :param session: SQLAlchemy ORM Session :type session: Session

""" Process a single task. :param DAG dag: DAG containing the task :param TaskInstanceBase task: Task to process :param list[tuple] ti_keys_to_schedule: List of tuples of the form (dag_id, task_id, execution_date) that should be scheduled """ # If the task is not ready to run, skip it if not task.are_dependencies_met( dep_context=DepContext(deps=QUEUE_DEPS, ignore_task_deps=True), session=self.session, verbose=True): self.log.info("Skipping %s due to dependencies", task) return # If the task is already scheduled, skip it if task.state == State.SCHEDULED: self.log.info("Skipping %s since it's already scheduled", task) return # If the task is already running, skip it if task.state == State.RUNNING: self.log.info("Skipping %s since it's already running", task) return # If the task is already queued, skip it if task.state == State.QUEUED: self.log.info("Skipping %s since it's already queued", task) return # If the task is already failed, skip it if task.state == State.FAILED: self.log.info("




""" Process backfill task instances :param ti_status: TIStatus object :type ti_status: TIStatus :param executor: executor object :type executor: BaseExecutor :param pickle_id: pickle id :type pickle_id: int :param start_date: start date :type start_date: datetime :param session: session :type session: Session :return: processed dag run dates :rtype: set """ processed_dag_run_dates = set() for dag_run in ti_status.to_run.values(): if dag_run.state == State.RUNNING: continue if dag_run.state == State.FAILED: continue if dag_run.state == State.UP_FOR_RETRY: continue if dag_run.state == State.SUCCESS: continue if dag_run.state == State.QUEUED: continue if dag_run.state == State.NONE: continue if dag_run.state == State.SHUTDOWN: continue if dag_run.state == State.REMOVED: continue if dag_run.state == State.NONE: continue if dag_run.state == State.NONE: continue if dag_run.state == State.NONE: continue if dag_run.state == State.NONE: continue if dag_run.state == State.NONE: continue if dag_run.state == State.NONE: continue if dag_run.state == State.NONE: continue if dag_run.state == State.NONE: continue if dag_run.state == State.NONE: continue if dag_run.state == State.NONE: continue if dag_run.state == State.NONE: continue if dag_run.state == State.NONE: continue if dag_run.state == State.NONE: continue if dag_run.state == State.NONE: continue if dag_run.state == State.NONE: continue if dag_run.state == State.NONE: continue if dag_

Execute the tasks for the given run dates. :param list[datetime.datetime] run_dates: The dates to execute the tasks for :param BackfillJob._DagRunTaskStatus ti_status: The status of the tasks :param BaseExecutor executor: The executor to use :param int pickle_id: The id of the pickle to use :param datetime.datetime start_date: The start date of the dag :param Session session: The session to use

Get a user channel by user sid and channel sid :param str user_sid: User sid :param str channel_sid: Channel sid :returns: UserChannel :rtype: UserChannel

Get the instance ID from the instance name :param str project_id: Project ID :param str instance_name: Instance name :returns: str :rtype: str
Provide a friendly representation :returns: Machine
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Get an instance IAM policy :param str instance_id: Instance ID :param str project_id: Project ID :returns: googleapiclient.discovery.Resource :rtype: googleapiclient.discovery.Resource
Build an instance of DatabaseInstance :param str instance_id: The unique ID of the Instance. :param str database_id: The unique ID of the Database. :param str project_id: The unique ID of the Project. :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
Get an instance for the specified project. :param str instance_id: The instance ID to use. :param str project_id: The project ID to use. If not set, the project_id from the connection is used. :rtype: :class:`google.cloud.spanner_v1.Instance` :returns: An instance for the specified project.
Get the table ID from the table name. :param str table_id: The table name. :returns: The table ID. :rtype: str
Get a database. :param str instance_id: The instance_id :param str database_id: The database_id :param str project_id

Provide a friendly representation :returns: Machine friendly representation :rtype: str
Retrieve a single page of InviteInstance records from the API. Request is executed immediately :param str target_url: API-generated URL for the requested results page :returns: Page of InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage
Get the column types from the table object. :

Get the path to the spark binary from the environment variable. :return: path to the spark binary :rtype: str
Submit the Spark application :param str application: The Spark application to submit :param kwargs: Additional arguments to pass to subprocess.Popen




nan



Get the channel sid from the channel sid :param str channel_sid: The channel sid :returns: The channel sid :rtype: str
Get the page of users from the response :param requests.Response response: Response from the API :returns: The page of users from the response :rtype: list[dict]
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Returns true if both instances are not equal, false otherwise :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
Provide a friendly representation :returns:
Provide a friendly representation :returns: Machine friendly representation :rtype: str
""" Iterate over pages of InviteInstance :returns: Generator that will yield up to limit results :rtype: list[twilio.rest.chat.v2.service.
Initialize a user in the database. :param str user_name: The name of the user to initialize. :param str user_email: The email of the user to initialize. :param str user_password: The password of the user to initialize. :param str user_role: The role of the user to initialize. :returns: The user instance. :rtype: twilio.rest.chat.v2.service.user.UserInstance
session = self.get_session role = session.query(sqla_models.Role)\ .filter(sqla_models.Role.name == role_name)\ .first() if role: self.log.info("Deleting role '%s'", role_name) session.delete(role) session.commit() else: raise AirflowException("Role named '{}' does not exist".format( role_name))

Retrieve a single role assigned to the user. :param friendly_name: The string that identifies the Role resources to fetch :returns: twilio.rest.chat.v2.service.user.user_role.UserRoleInstance :rtype: twilio.rest.chat.v2.service.user.user_role.UserRoleInstance
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Returns true if both instances are not equal :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance :returns: twilio.rest.chat.v2
Retrieve a list of users :param int limit: Upper limit for the number of records to return. list() guarantees never to return more than limit. Default is no limit :param int page_size: Number of records to fetch per request, when not set will use the default value of 50 records. If no page_size is defined but a limit is defined, list() will attempt to read the limit with the most efficient page size, i.e. min(limit, 1000) :returns: Generator that will yield up
Merge permission and view_menu into a single permission_view_menu :param str permission_name: Permission name :param str view_menu_name: View menu name
Code

Merge permission and view menu for all dag and role :returns: True if permission and view menu are merged, False otherwise :rtype: bool
Build an instance of InviteInstance :param dict payload:

Generate an absolute URL for this InviteList :returns: Absolute URL for this InviteList :rtype: unicode

Get the connection from the connection_id :param str conn_id: The connection id to use :returns: connection :rtype: connection
Get the connection from the connection id :param str conn_id: Connection id :returns: Connection :rtype: Connection
Return the content of a file in HDFS. :param str hdfs_path: The path to the file in HDFS. :returns: str :rtype: str
List the files in a directory. :param str path: The path to the directory. :param bool recursive: Whether to list files recursively. :param kwargs: Additional arguments to pass to the underlying :py:class:`pyarrow.hdfs.connect` function. :returns: A list of file paths. :rtype: list[str]
Get the connection pool verify ssl :returns: bool :rtype: bool
Get the connection pool :returns: ConnectionPool object :rtype: ConnectionPool


Get connection password from connection :returns: Connection password :rtype: str Code
Generate an API-ready query string for the request. :returns: Twilio Request :rtype: requests.Request
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._invites = None self._members = None self._messages = None self._webhooks = None @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = InviteList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._invites @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._
Get an item from the list of resources :param unicode key: The index of the resource to fetch :returns: twilio.rest.chat.v2.service

Provide a
Create the InviteInstance :param unicode identity: The `identity` value that identifies the new resource's User :param unicode role_sid: The SID of the Role to assign to the new resource :param unicode ttl: An application-defined string that uniquely identifies the resource :param unicode type: The type of push notification to send to the new resource's
Build an instance of InviteInstance :param dict payload: Payload response from the API :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
nan

Get a field from the hook's extra field. :param str field_name: The name of the field to get. :param default_value: The default value to return if the field is not found. :type default_value: object :return: The value of the field, or the default value if the field is not found. :rtype: object
Get service account info from a file. :returns: Service account info :rtype: dict


Initialize the InvitePage :param Version version: Version that contains the resource :param service_sid: The SID of the Service that the resource is associated with :param channel_sid: The SID of the Channel the resource belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage

Provide a friendly representation :returns: Machine friendly representation :rtype: str
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._members = None self._messages = None self._invites = None self._webhooks = None @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._messages = MessageList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._messages @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites =
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Pad the given PIL Image on all sides with the given "pad" value. :param img: PIL Image to be padded. :type img: PIL Image :param padding: Padding on each border. If a single int is provided this is used to pad all borders. If tuple of length 2 is provided this is the padding on left/right and top/bottom respectively. If a tuple of length 4 is provided this is the padding for the left, top, right and bottom borders respectively. :type padding: int or tuple :param fill: Pixel fill value for constant fill. Default is 0. If a tuple of length 3, it is used to fill R, G, B channels respectively. :type fill: int or tuple :param padding_mode: Type of padding. Should be: constant, edge, reflect or symmetric. Default is constant. :type padding_mode: str :return: Padded image. :rtype: PIL Image
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Get an item from the list of resources :param unicode key: The index of the resource to fetch :returns

""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def date_created(self): """ :returns: The ISO 8601 date and time in GMT when the resource was created :rtype: datetime """ return self._properties['date_created'] @property def date_updated(self): """ :returns: The ISO 8601

5 crop the image into 5 parts and center crop the image. :param img: PIL Image to be cropped. :param size: Desired output size of the crop. :return: 5 PIL Images. :rtype: tuple """ if isinstance(size, numbers.Number): size = (int(size), int(size)) else: assert len(size) == 2, "Please provide only two dimensions (h, w) for size." w, h = img.size crop_h, crop_w = size if crop_w > w or crop_h > h: raise ValueError("Requested crop size {} is bigger than input size {}".format(size, (h, w))) tl = img.crop((0, 0, crop_w, crop_h)) tr = img.crop((w - crop_w, 0, w, crop_h)) bl = img.crop((0, h - crop_h, crop_w, h)) br = img.
Get the channel sid from the channel name :param str channel_name: The channel name :returns: The channel sid :rtype: str
Initialize the InvitePage :param Version version: Version that contains the resource :param dict payload: A JSON response from the Twilio API :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage
Check if the input is a PIL Image. :param img: Image to be checked :type img: object :return: True if the input is a PIL Image, False otherwise :rtype: bool
Get the channel sid from the channel :param twilio.rest.chat.v2.channel.Channel channel: The channel :returns: The channel sid :rtype: str
Initialize the InvitePage :param Version version: Version that contains the resource :param Response response: Response from the API :param service_sid: The SID of the Service that the resource is associated with :param channel_sid: The SID of the Channel the resource belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Determine if an object is a numpy array
Convert an image to RGBA. :param img: PIL Image to be converted to RGBA. :type img: PIL Image :returns: PIL Image converted to RGBA. :rtype: PIL Image
Get an item from the list of resources in the response. :returns: An instance of the resource at the given index, or None if that index does not exist. :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
Get an object that represents the params to update on the resource :returns: dict :rtype: dict



""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def date_created(self): """ :returns: The RFC 2822 date and time in GMT when the resource was created :rtype: datetime """ return self._properties['date_created'] @property def date_updated(self): """ :returns: The RFC 282
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Build an instance of InviteInstance :param dict payload:
Lists InviteInstance records from the API as a list. Unlike stream(), this operation is eager and will load `limit` records into memory before returning. :param int limit: Upper limit for the number of records to return. list() guarantees never to return more than limit. Default is no limit :param int page_size: Number of records to fetch per request, when not set will use the default value of 50 records. If no page_size is defined but a limit is defined, list() will attempt to read the limit with the most efficient page size, i.e. min(limit, 1000) :returns: Generator that will yield up to limit results :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]


Get the contents of a URL :param str url: URL to fetch :


:param brightness: brightness range :type brightness: list[float] :param contrast: contrast range :type contrast: list[float] :param saturation: saturation range :type saturation: list[float] :param hue: hue range :type hue: list[float] :returns: transforms :rtype: torchvision.transforms.Compose
:param degrees: Range of degrees to select from. Should be a 2-element tuple containing the minimum and maximum values. :type degrees: tuple(float, float) :param translate: Range of translation to select from. Should be a 2-element tuple
""" Initialize the InviteList :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Marshaled Properties self._properties = { 'invites': payload.get('invites'), 'meta': payload.get('meta'), } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, } @property def invites(self): """ :returns: The list of Invites :rtype: unicode """ return self._properties['invites'] @property def meta(self): """ :returns: The response metadata :rtype: dict """ return self._properties['meta'] def __repr__(self): """ Provide a friendly representation :returns: Machine friendly representation :rtype: str """ return '<Twilio.IpMessaging.V2.InviteList>' class InvitePage(Page): """ PLEASE NOTE that this class contains preview products that are subject to change. Use them with caution. If you currently do not have developer preview access, please contact <EMAIL>. """ def __init__(self, version, response, solution): """ Initialize the InvitePage :param Version version: Version that contains the resource :param Response response: Response from the API :param service_sid: The SID of the Service that the resource is associated with :param channel_sid: The SID of the Channel the resource is associated with :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage """ super(InvitePage, self).__init__(version, response) # Path Solution self._solution = solution def get_instance(self, payload): """ Build an instance of InviteInstance :param dict payload: Payload response from the API :returns: twilio.rest.chat.
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._version.account_sid, 'service_sid': service_sid, 'channel_sid': channel_sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_


""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': payload.get('sid'), 'account_sid': payload.get('account_sid'), 'service_sid': payload.get('service_sid'), 'channel_sid': payload.get('channel_sid'), 'identity': payload.get('identity'), 'role_sid': payload.get('role_sid'), 'date_created': deserialize.iso8601_datetime(payload.get('date_created')), 'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')), 'url': payload.get('url'), } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': payload.get('sid'), } @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property def service_sid(self): """ :returns: The SID of the Service that the resource is associated with :rtype: unicode """ return self._properties['service_sid'] @property def channel_sid(self): """ :returns: The SID of the Channel the resource belongs to :rtype: unicode """ return self._properties['channel_sid'] @property def identity(self): """ :returns: The identity of the User that was invited to the Channel :rtype: unicode """ return self._properties['identity'] @property def role_sid(self): """ :
Get a list of channel users :param str channel_sid: The channel_sid :returns: list[twilio.rest.chat.v2.service.channel.ChannelUserInstance] :rtype: list[twilio.rest.chat.v2.service.channel.ChannelUserInstance]
Get the template context for a theme :param str templates_path: Path to the templates directory :param str theme: Theme to get the template context for :param str template: Template to get the context for :param dict context: Context to use
check if the searchQuery contain a bang, and create fitting autocompleter results :param str full_query: Full query string :returns: list -- List of autocompleter results :rtype: list
Initialize the InviteContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._invites = None self._members = None self._messages = None self._webhooks = None @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = InviteList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._invites @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._
"""Initialize the ChannelCumulativeStatisticsList :returns: twilio.rest.chat.v2.service.channel.channel_cumulative_statistics.ChannelCumulativeStatisticsList :rtype: twilio.rest.chat.v2.service.channel.channel_cumulative_statistics.ChannelCumulativeStatisticsList """ super(ChannelCumulativeStatisticsList, self).__init__(*args, **kwargs) # Path Solution self._solution = {'service_sid': self._version.service_sid, 'channel_sid': self._version.channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/CumulativeStatistics'.format(**self._solution) def stream(self, limit=None, page_size=None): """ Streams ChannelCumulativeStatisticsInstance records from the API as a generator stream. This operation lazily loads records as efficiently as possible until the limit is reached. The results are returned as a generator, so this operation is memory efficient. :param int limit: Upper limit for the number of records to return. stream() guarantees to never return more than limit. Default is no limit :param int page_size: Number of records to fetch per request, when not set will use the default value of 50 records. If no page_size is defined but a limit is defined, stream() will attempt to read the limit with the most efficient page size, i.e. min(limit, 1000) :returns: Generator that will yield up to limit results :rtype: list[twilio.rest.chat.v2.service.channel.channel_cumulative_statistics.ChannelCumulativeStatisticsInstance] """ limits = self._version.read_limits(limit, page_size) page = self.page(page_size=limits['page_size'], ) return self._version.stream(page, limits['limit'], limits['page_limit']) def list(self, limit=None, page_size=None): """ Lists ChannelCumulativeStatisticsInstance records from the API as a list. Unlike stream(), this operation is eager and will load `limit` records into memory before returning. :param int limit: Upper limit for the number of records

Fetch a ChannelInstance :param unicode channel_sid: The sid :returns: twilio.rest.chat.v2.service.channel.ChannelInstance :rtype: twilio.rest.chat.v2.service.channel.ChannelInstance
""" Initialize the InviteList :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) def create(self, identity, role_sid=values.unset, type=values.unset, url=values.unset, ttl=values.unset): """ Create a new InviteInstance :param unicode identity: The `identity` value that identifies the new resource's User :param unicode role_sid: The SID of the Role to assign to the new resource :param unicode type: The type of push notification to use. Can be: `gcm` or `apn` or `fcm` or `sms` :param unicode url: The URL we should call using the `type` property to send a push notification :param unicode ttl: An integer representing how long, in seconds, the notification should be retained. Can be an integer from 0 to 43200 (12 hours). :returns: Newly created InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ data = values.of({ 'Identity': identity, 'RoleSid': role_sid, 'Type': type, 'Url': url, 'Ttl': ttl, }) payload = self._version.create( 'POST', self._uri, data=data, ) return InviteInstance( self._version, payload, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) def stream(self
Get the description of the distribution. :param Distribution distribution: The distribution to get the description of. :returns: The description of the distribution. :rtype: str

""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._solution['account_sid'], 'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'by': by, 'role_sid': role_sid, 'identity': identity, 'url': url, } self._solution = { 'account_sid': account_sid, 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property def service_sid(self): """ :returns: The SID of the Service that the resource is associated with :rtype: unicode """ return self._properties['service_sid'] @property def channel_sid(self): """ :returns: The SID of the Channel the resource belongs to :rtype: unicode """ return self._properties['channel_sid'] @property def date_created(self): """ :returns: The RFC 282


Build an instance of InviteInstance :param dict payload: Payload response from the API :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
Returns True if x is a datetime.
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._invites = None self._members = None self._messages = None self._webhooks = None @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = InviteList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._invites @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._solution['account_sid'], 'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], 'identity': identity, 'role_sid': role_sid, 'last_consumed_message_index': last_consumed_message_index, 'last_consumption_timestamp': last_consumption_timestamp, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self


"""Deserialize a string identifier into a function. Args: identifier: A string identifier. Returns: A function. Raises: ValueError: If the identifier cannot be deserialized. """ if identifier.startswith('lambda'): return _deserialize_lambda(identifier) if identifier.startswith('lambda_'): return _deserialize_lambda(identifier[7:]) if identifier.startswith('partial_'): return _deserialize_partial(identifier[8:]) if identifier.startswith('partial'): return _deserialize_partial(identifier[7:]) if identifier.startswith('partial_'): return _deserialize_partial(identifier[8:]) if identifier.startswith('partial_'): return _deserialize_partial(identifier[8:]) if identifier.startswith('partial_'): return _deserialize_partial(identifier[8:]) if identifier.startswith('partial_'): return _deserialize_partial(identifier[8:]) if identifier.startswith('partial_'): return _deserialize_partial(identifier[8:]) if identifier.startswith('partial_'): return _deserialize_partial(identifier[8:]) if identifier.startswith('partial_'): return _deserialize_partial(identifier[8:]) if identifier.startswith('partial_'): return _deserialize_partial(identifier[8:]) if identifier.startswith('partial_'): return _deserialize_partial(identifier[8:]) if identifier.startswith('partial_'): return _deserialize_partial(identifier[8:]) if identifier.startswith('partial_'): return _deserialize_partial(identifier[8:]) if identifier.startswith('partial_'): return _deserialize_partial(identifier[8:]) if identifier.startswith('partial_'): return _deserialize_partial(identifier[8:]) if identifier.startswith('partial_'): return _deserialize_partial(identifier[8:]) if identifier.startswith('partial_'): return _deserialize_partial(identifier[8:]) if identifier.startswith('partial_'): return _deserialize_partial(identifier[8:]) if identifier.startswith('partial_'): return _deserialize_partial(identifier[8:]) if identifier.startswith('partial_'): return _deserialize_partial(identifier[8:]) if identifier.startswith('partial_'): return _deserialize_partial(identifier[8:]) if identifier.startswith
Returns the number of parameters in the distribution. :returns: Number of parameters in the distribution. :rtype: int
"""
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._solution['account_sid'], 'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'by': by, 'role_sid': role_sid, 'url': url, } self._solution = { 'account_sid': account_sid, 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property def service_sid(self): """ :returns: The SID of the Service that the resource is associated with :rtype: unicode """ return self._properties['service_sid'] @property def channel_sid(self): """ :returns: The SID of the Channel the resource belongs to :rtype: unicode """ return self._properties['channel_sid'] @property def date_created(self): """ :returns: The RFC 2822 date and time in GMT when the resource was created :
Provide a friendly representation :returns: Machine friendly representation :rtype: str

""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def date_created(self): """ :returns: The RFC 2822 date and time in GMT when the resource was created :rtype: datetime """ return self._properties['date_created'] @property def date_updated(self): """ :returns: The RFC 282


""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': payload.get('sid'), 'account_sid': payload.get('account_sid'), 'service_sid': payload.get('service_sid'), 'channel_sid': payload.get('channel_sid'), 'created_by': payload.get('created_by'), 'created_by_identity': payload.get('created_by_identity'), 'created_at': deserialize.iso8601_datetime(payload.get('created_at')), 'date_created': deserialize.iso8601_datetime(payload.get('date_created')), 'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')), 'url': payload.get('url'), } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': payload.get('sid'), } @property def sid(self) -> str: """ :returns: The unique string that identifies the resource :rtype: unicode """ return self._properties['sid'] @property def account_sid(self) -> str: """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property def service_sid(self) -> str: """ :returns: The SID of the Service that the resource is associated with :rtype: unicode """ return self._properties['service_sid'] @property def channel_sid(self) -> str: """ :returns: The SID of the Channel the resource is associated with :rtype: unicode """ return self._properties['channel_sid'] @property def created_by(self) -> str: """ :returns: The identity of
""" Initialize the InviteContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :param sid: The SID of the Invite resource to fetch :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ super(InviteContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites/{sid}'.format(**self._solution) # Dependents self._channel = None self._member = None # Context self._context = None self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: The unique string that identifies the resource :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._members = None self._messages = None self._invites = None self._webhooks = None @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._messages = MessageList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._messages @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites =
Get an item from the list of resources :param unicode key: The index of the resource to fetch :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance

Get the channel unique name from the channel_sid or channel_unique_name :param str channel_sid: The channel_sid :param str channel_unique_name: The channel_unique_name :returns: The channel unique name :rtype: str
Constructs a ChannelContext :param channel_sid: The SID of the Channel resource to fetch :returns: twilio.rest.chat.v2.service.channel.


""" Initialize the `tfd.LinearOperator` class. Args: kernel_posterior_fn: Python `callable` which returns a `tfd.LinearOperator` instance representing the posterior distribution over the kernel. kernel_posterior_tensor_fn: Python `callable` which returns a `Tensor` representing the posterior distribution over the kernel. kernel_prior_fn: Python `callable` which returns a `tfd.LinearOperator` instance representing the prior distribution over the kernel. kernel_divergence_fn: Python `callable` which returns a `Tensor` representing the divergence between the prior and posterior distributions over the kernel. bias_posterior_fn: Python `callable` which returns a `tfd.LinearOperator` instance representing the posterior distribution over the bias. bias_posterior_tensor_fn: Python `callable` which returns a `Tensor` representing the posterior distribution over the bias. bias_prior_fn: Python `callable` which returns a `tfd.LinearOperator` instance representing the prior distribution over the bias. bias_divergence_fn: Python `callable` which returns a `Tensor` representing the divergence between the prior and posterior distributions over the bias. name: Python `str` name prefixed to Ops created by this class. dtype: `tf.DType` of the `LinearOperator` instance. **kwargs: Additional keyword arguments passed to the `LinearOperator` constructor. """ self._kernel_posterior_fn = kernel_posterior_fn self._kernel_posterior_tensor_fn = kernel_posterior_tensor_fn self._kernel_prior_fn = kernel_prior_fn self._kernel_divergence_fn = kernel_divergence_fn self._bias_posterior_fn = bias_posterior_fn self._bias_posterior_tensor_fn = bias_posterior_tensor_fn
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._invites = None self._members = None self._messages = None self._webhooks = None @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = InviteList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._invites @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._

Code


""" Initialize the Distribution. :param args: Positional arguments for the base class. :param kwargs: Keyword arguments for the base class. """ super(Distribution, self).__init__(*args, **kwargs) self._validate_args() self._validate_sample() self._validate_log_prob() self._validate_entropy() self._validate_mean() self._validate_stddev() self._validate_variance() self._validate_sample_n() self._validate_log_prob_n() self._validate_entropy_n() self._validate_mean_n() self._validate_


# pylint: disable=g-statement-before-imports try: import tensorflow as tf except ImportError: # Print more informative error message, then reraise. print("\n\nFailed to import TensorFlow. Please note that TensorFlow is not " "installed by default when you install TensorFlow Probability. This " "is so that users can decide whether to install the GPU-enabled " "TensorFlow package. To use TensorFlow Probability, please install " "the most recent version of TensorFlow, by following instructions at " "https://tensorflow.org/install.\n\n") raise import distutils.version # # Update this whenever we need to depend on a newer TensorFlow release. # required_tensorflow_version = "1.13" if (distutils.version.LooseVersion(tf.__version__) < distutils.version.LooseVersion(required_tensorflow_version)): raise ImportError( "This version of TensorFlow Probability requires TensorFlow " "version >= {required}; Detected an installation of version {present}. " "Please upgrade TensorFlow to proceed.".format( required=required_tensorflow_version, present=tf.__version__))

@param Page response: Page response
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the new resource belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._members = None self._messages = None self._invites = None self._webhooks = None @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._messages = MessageList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._messages @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = Inv
""" Initialize the InviteList :param unicode service_sid: The SID of the Service to create the resource under :param unicode channel_sid: The SID of the Channel the new resource belongs to :param Version version: Version that contains the resource :param unicode friendly_name: A string to describe the resource :param unicode attributes: A valid JSON string that contains application-specific data :param unicode type: The type of push notification delivery mechanism to use :param datetime date_created: The ISO 8601 date and time in GMT when the resource was created :param datetime date_updated: The ISO 8601 date and time in GMT when the resource was last updated :param unicode created_by: The identity of the User that created the resource :param unicode url: The absolute URL of the resource :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) # Path Parameters self._properties = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) # Filters self._filters = {'friendly_name': friendly_name, 'attributes': attributes, 'type': type, 'date_created': deserialize.iso8601_datetime, 'date_updated': deserialize.iso8601_datetime, 'created_by': created_by, } self._limit = None self._page_size = None if url is not None: self._uri = url
""" Initialize the InviteList :param unicode service_sid: The SID of the Service to create the resource under :param unicode channel_sid: The SID of the Channel the new resource belongs to :param Version version: Version that contains the resource :param unicode friendly_name: A string to describe the resource :param unicode attributes: An optional string metadata field you can use to store any data you wish. :param unicode unique_name: An application-defined string that uniquely identifies the resource :param unicode type: The type of push notification delivery mechanism to use :param datetime date_created: The ISO 8601 date and time in GMT when the resource was created :param datetime date_updated: The ISO 8601 date and time in GMT when the resource was last updated :param unicode created_by: The identity of the User that created the resource :param unicode url: The absolute URL of the resource :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) # Path Parameters self._properties = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) # Options self._options = {'friendly_name': friendly_name, 'attributes': attributes, 'unique_name': unique_name, 'type': type, 'date_created': serialize.iso8601_datetime(date_created), 'date_updated': serialize.iso8




semilocal_linear_trend_transition_matrix(autoregressive_coef) # We want to write the following 2 x 2 matrix: # [[1., 1., ], # level(t+1) = level(t) + slope(t) # [0., ar_coef], # slope(t+1) = ar_coef * slope(t) # but it's slightly tricky to properly incorporate the batch shape of # autoregressive_coef. E.g., if autoregressive_coef has shape [4,6], we want # to return shape [4, 6, 2, 2]. We do this by breaking the matrix into its # fixed entries, written explicitly, and then the autoregressive_coef part # which we add in after using a mask to broadcast to the correct matrix shape. fixed_entries = tf.constant( [[1.,
Get the next batch of data from the queue. :param int batch_size: The number of samples to return. :returns: A tuple of (data, labels) where data is a list of numpy arrays and labels is a list of numpy arrays. :rtype: tuple
Generate a sequence of random numbers from a Halton sequence. The Halton sequence is a sequence of numbers that are uniformly distributed in the unit cube. The Halton sequence is constructed by starting with the first prime number, 2, and then constructing a sequence of prime numbers by multiplying the previous prime number by the next prime number. For example, the first 10 prime numbers are: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29. The Halton sequence is then constructed by starting with the first prime number, 2, and then constructing a sequence of prime numbers by multiplying the previous prime number by the next prime number. For example, the first 10 prime numbers are: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29. The Halton sequence is then constructed by starting with the first prime number, 2, and then constructing a sequence of prime numbers by multiplying the previous prime number by the next prime number. For example, the first 10 prime numbers are: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29. The Halton sequence is then constructed by starting with the first prime number, 2, and then constructing a sequence of prime numbers by multiplying the previous prime number by the next prime number. For example, the first 10 prime numbers are: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29. The Halton sequence is then constructed by starting with the first prime number, 2, and then constructing a sequence of prime numbers by multiplying the previous prime number by the next prime number. For example, the first 10 prime numbers are: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29. The Halton sequence is then constructed by starting with the first prime number, 2, and then constructing a sequence of



Returns a list

Prepare the arguments for the Hager-Zhang line search.


""" Perform an inner bisection search on the current interval. :param callable value_and_gradients_function: Function that returns the value and gradients of the function to be minimized. :param HagerZhangLineSearchResult curr_interval: Current interval to be searched. :param bool should_check_shrinkage: Whether to check for sufficient shrinkage. :param float f_lim: Limit on the function value. :returns: HagerZhangLineSearchResult :rtype: HagerZhangLineSearchResult """ def _inner_bisect_cond(curr_interval): return (curr_interval.converged | curr_interval.failed) & ( ~curr_interval.converged) def _inner_bisect_body(curr_interval): midpoint = (curr_interval.left.x + curr_interval.right.x) / 2.0 midpoint_result = value_and_gradients_function(midpoint) midpoint_f = midpoint_result.f midpoint_g = midpoint_result.g midpoint_x = midpoint_result.x midpoint_converged = _very_close(midpoint_f, curr_interval.left.f) midpoint_failed = midpoint_f > f_lim midpoint_converged = midpoint_converged | midpoint_failed midpoint_result = HagerZhangLineSearchResult( converged=midpoint_converged, failed=midpoint_failed, iterations=curr_interval.iterations + 1, func_evals=curr_interval.num_evals + 1, left=curr_interval.left, right=midpoint_result) def _do_check_shrinkage(): old_width = curr_interval.right.x - curr_interval.left.x new_width = midpoint_result.right.x - midpoint_result.left.x sufficient_shrinkage = new_width < old_width * 0.5 func_is_flat = ( _very_close



Lists ChannelInstance records from the API as a list. Unlike stream(), this operation is eager and will load `limit` records into memory before returning. :param int limit: Upper limit for the number of records to return. stream() guarantees to never return more than limit. Default is no limit :param int page_size: Number of records to fetch per request, when not


Returns the sample shape of the `Tensor`s that are the outputs of this `Distribution


""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the new resource belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._members = None self._invites = None self._messages = None self._webhooks = None @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = InviteList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._invites @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._messages
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid or self._properties['sid'], } self._properties = {'date_created': deserialize.rfc2822_datetime(date_created), 'date_updated': deserialize.rfc2822_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites/{sid}'.format(**self._solution) @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property def service_sid(self): """ :returns: The SID of the Service that the resource is associated with :rtype: unicode """ return self._properties['service_sid'] @property def channel_sid(self): """ :returns: The SID of the Channel the resource belongs to :rtype: unicode """ return self._properties['channel_sid'] @property def date_created(self): """ :returns: The RFC 2822 date and time in GMT when the resource was created :rtype: datetime """ return self._properties['date_created'] @property def date_updated(self): """ :returns: The RFC 2822 date and time in GMT when the resource was last updated :







Get the current state of the model and the gradients of the loss with respect to the current state. :param dict state_dict: The state dictionary. :returns: The current state of the model and the gradients of the loss with respect to the current state. :rtype: tuple[list[tf.Tensor], list[tf.Tensor]]
Pad x with zeros to have final_rank dimensions.

Code


""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._solution['account_sid'], 'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, } self._solution = { 'account_sid': account_sid, 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid']
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def date_created(self): """ :returns: The RFC 2822 date and time in GMT when the resource was created. :rtype: datetime """ return self._properties['date_created'] @property def date_updated(self): """ :returns: The RFC 28
Get the channel sid from the channel url :param str channel_url: The channel url :returns: The channel sid :rtype: str
Initialize the InvitePage :param Version version: Version that contains the resource :param Response response: Response from the
Returns the static value
Retrieve the channel unique name from the channel_sid or channel_unique_name :param str channel_sid: The channel_sid :param str channel_unique_name: The channel_unique_name :returns: The channel unique name :rtype: str
Get the channel sid from the channel_sid or channel_unique_name :param str channel_sid: The channel_sid :param str channel_unique_name: The channel_unique_name :returns: The channel sid :rtype: str
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._members = None self._messages = None self._invites = None self._webhooks = None self._last_read_message_index = None self._last_read_timestamp = None self._typing = None self._invites_invited = None self._invites_accepted = None self._invites_rejected = None self._invites_canceled = None self._invites_timeout = None self._invites_accepted_by_remote = None self._invites_rejected_by_remote = None self._invites_canceled_by_remote = None self._invites_timeout_by_remote = None self._webhooks_created = None self._webhooks_updated = None self._webhooks_deleted = None self._webhooks_bounced = None self._webhooks_bounced_unsubscribes = None self._webhooks_bounced_bounces = None self._webhooks_failed = None self._webhooks_succeeded = None self._webhooks_unsubscribes = None self._webhooks_unsubscribes_deletes = None self._webhooks_unsubscribes_bounces = None self._webhooks_unsubscribes_bounces_deletes = None self._webhooks_unsubscribes_failed = None self._webhooks_unsubscribes_succeeded = None self._webhooks_deleted_by

Get the next batch of data from the queue. :returns: A tuple of (batch_data, batch_labels) :rtype: tuple
Provide a friendly representation :returns: Machine friendly representation :rtype: str
""" Initialize the InviteList :param Version version: Version that contains the resource :param service_sid: The SID of the Service to read the resources from :param channel_sid: The SID of the Channel the resource to fetch belongs to :param sid: The SID of the Invite resource to fetch :param date_created: The ISO 8601 date and time in GMT when the resource was created :param date_updated: The ISO 8601 date and time in GMT when the resource was last updated :param by: The identity of the User that created the Invite :param from_: The identity of the User that created the Invite :param to: The identity of the User that the Invite is for :param order: The order to sort by :param limit: Upper limit for the number of records to return. list() guarantees never to return more than limit. Default is no limit :param page_size: Number of records to fetch per request, when not set will use the default value of 50 records. If no page_size is defined but a limit is defined, list() will attempt to read the limit with the most efficient page size, i.e. min(limit, 1000) :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) # Query Params self._query = {} if sid is not None: self._query['Sid'] = sid if date_created is not None: self._query['DateCreated
Compute the
Returns the default


Compute the KL divergence between two

nan
"""Construct a new Independent distribution. Args: dist_fn: Python callable that returns a distribution instance. validate_args: Python `bool`, default `False`. When `True` distribution parameters are checked for validity despite possibly degrading runtime performance. When `False` invalid inputs may silently render incorrect outputs. name: Python `str` name prefixed to Ops created by this class. """ self._dist_fn = dist_fn self._dist_fn_args = [] self._dist_fn_wrapped = [] self._validate_args = validate_args self._name = name self._dtype = None self._parameters = {} self._event_shape = () self._batch_shape = () self._sample_shape = () self._is_continuous = True self._is_reparameterized = False self._is_scalar_batch = True self._is_scalar_event = True self._batch_shape_tensor = None self._event_shape_tensor = None self._parameters_tensor = None self._sample_shape_tensor = None self._dtype_tensor = None self._allow_nan_stats = True self._reparameterization_type = reparameterization.FULLY_REPARAMETERIZED self._use_static_shape = False self._graph_parents = [] self._graph_parents_tensor = None self._graph_parents_static_shape = None self._graph_parents_dtype = None self._graph_parents_validate_args = None self._graph_parents_reparameterization_type = None self._graph_parents_use_static_shape = None self._graph_parents_allow_nan_stats = None self._graph_parents_name = None self._graph_parents_validate_args_tensor = None self._graph_parents_reparameterization_type_tensor = None self._graph_parents_use_static_shape_tensor = None self._graph_parents_allow_nan_stats_tensor = None self._graph_parents_name_tensor = None self._graph_parents_validate_args_static_shape = None self._

""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the new resource belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._members = None self._messages = None self._invites = None self._webhooks = None @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._messages = MessageList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._messages @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = Inv
""" Perform a request to the Twilio API and return the response. :param str method: HTTP method to use :param str path: Path to request :param dict params: Query parameters to include in the request :param dict payload: Request body parameters to include in the request :param str response_key: Key to use for the response body :param kwargs: Additional keyword arguments to pass to the request :returns: The response from the API :rtype: requests.Response """ if params is None: params = {} if payload is None: payload = {} if 'X-Twilio-Webhook-Enabled' not in params: params['X-Twilio-Webhook-Enabled'] = '1' if 'X-Twilio-Version' not in params: params['X-Twilio-Version'] = self.version if 'X-Twilio-Account-Sid' not in params: params['X-Twilio-Account-Sid'] = self.account_sid if 'X-Twilio-Auth-Token' not in params: params['X-Twilio-Auth-Token'] = self.auth_token if 'X-Twilio-Client' not in params: params['X-Twilio-Client'] = self.client if 'X-Twilio-Client-Version' not in params: params['X-Twilio-Client-Version'] = self.client_version if 'X-Twilio-Client-OS' not in params: params['X-Twilio-Client-OS'] = self.client_os if 'X-Twilio-Client-Language' not in params: params['X-Twilio-Client-Language'] = self.client_language if 'X-Twilio-Client-Platform' not in params: params['X-Twilio-Client-Platform'] = self.client_platform if 'X-Twilio-Client-Name' not in params: params['X-Twilio-Client-Name'] = self.client_name if 'X-Twilio-Client-Url' not in params: params['X-Twilio-Client
Get the channel sid for the given channel unique name :param str channel_unique_name: The channel unique name :returns: The channel sid :rtype: str
Get the channel sid from the channel url :param str channel_url: The channel url :returns: The channel sid :rtype: str
Get the channel sid from the channel url :param str channel_url: The channel url :returns: The channel sid :rtype: str
"""Construct MultivariateNormalDiag with batch shape [B1,..., Bb, k]. The parameters `loc` and `scale_diag` must have compatible shapes. E.g., `loc` is `[B1,..., Bb, k]` and `scale_diag` is `[B1,..., Bb, k]`. Args: loc: Floating-point `Tensor`. If this is set to `None`, `loc` is implicitly `0`. When specified, may have shape `[B1,..., Bb, k]` where `b >= 0` and `k` is the event size. scale_diag: Positive floating-point `Tensor`. When specified, may have shape `[B1,..., Bb, k]` where `b >= 0` and `k` is the event size. Overrides `scale`. validate_args: Python `Boolean`, default `False`. When `True` distribution parameters are checked for validity despite possibly degrading runtime performance. When `False` invalid inputs may silently render incorrect outputs. allow_nan_stats: Python `Boolean`, default `True`. When `True`, statistics (e.g., mean, mode, variance) use the value "`NaN`" to indicate the result is undefined. When `False`, an exception is raised if one or more of the statistic's batch members are undefined. name: Python `str` name prefixed to Ops created by this class. Raises: ValueError: if `loc` and `scale_diag` have incompatible shapes, or if not `scale_diag` is specified. """ parameters = dict(locals()) with tf.compat.v1.name_scope(name, values=[loc, scale_diag]) as name: dtype = dtype_util.common_dtype([loc, scale_diag], tf.float32) self._loc = tensor_util.convert_nonref_to_tensor( loc, name='loc', dtype=dtype) self._scale_diag = tensor_util.convert_nonref_to_tensor( scale_diag, name='scale_diag', dtype=dtype) super(MultivariateNormalDiag,

Initialize the parameters for an LSTM cell. Args: lstm_cell: An instance of `tf.nn.rnn_cell.LSTMCell`. output_layer: An instance of `tf.layers.Dense`. dimensions: The number of output dimensions. state_is_tuple: If `True`, accepted and returned states are n-tuples, where `n = len(cell.state_size)`. If `False`, the states are all concatenated into a single vector. name: The name of the cell.
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the new resource belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._members = None self._messages = None self._invites = None self._webhooks = None @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._messages = MessageList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._messages @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = Inv
Initialize the InviteContext :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext
Sample from the static posterior. :param features: (..., batch, timesteps, hidden) :param samples: number of samples to draw :return: (..., batch, timesteps, hidden)


Returns log_prob(value) in terms of log_prob(x) and log_det_jacobian(x). Args: value: float or double Tensor. Returns: log_prob: float Tensor with shape broadcastable to `batch_shape + event_shape`.
""" Initialize the Model. :param dict kwargs: The keyword arguments to initialize the Model. """ super(Model, self).__init__(*args, **kwargs) self._program = None self._inputs = None self._outputs = None self._input_shapes = None self._output_shapes = None self._input_dtypes = None self._output_dtypes = None self._input_names = None self._output_names = None self._input_tensors = None self._output_tensors = None self._input_placeholders = None self._output_placeholders = None self._input_feed_dict = None self._output_feed_dict = None self._input_feed_dict_list = None self._output_feed_dict_list = None self._input_feed_dict_dict = None self._output_feed_dict_dict = None self._input_feed_dict_list_dict = None self._output_feed_dict_list_dict = None self._input_feed_dict_list_list = None self._output_feed_dict_list_list = None self._input_feed_dict_list_list_dict = None self._output_feed_dict_list_list_dict = None self._input_feed_dict_list_list_list = None self._output_feed_dict_list_list_list = None self._input_feed_dict_list_list_list_dict = None self._output_feed_dict_list_list_list_dict = None self._input_feed_dict_list_list_list_list = None self._output_feed_dict_list_list_list_list = None self._input_feed_dict_list_list_list_list_dict = None self._output_feed_dict_list_list_list_list_dict = None self._input_feed_dict_list_list_list_list_list = None self._output_feed_dict_list_list_list_list_list = None self._input_feed_dict_list_list_list_list_list_dict = None
Convert a list of parameter values to a map. :param list param_vals: A list of parameter values. :returns: A map of parameter names to values. :rtype: dict


Get the channel unique name from the channel_sid or channel_unique_name :param str channel_sid: The channel_sid :param str channel_unique_name: The channel_unique_name :returns: The channel unique name :rtype: str
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Get an item from the list :param unicode key: The index of the resource to fetch :returns: twilio.
Initialize the InvitePage :param Version version: Version that contains the resource :param Response response: Response from the API :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel
Get an item from the list of resources :param unicode key: The index of the resource to fetch :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
Initialize the InvitePage :param Version version: Version that contains the resource :param Response response: Response from the API :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel


Initialize the InvitePage :param Version version: Version that contains the resource :param Response response: Response from the API :param service_sid: The

Provide a friendly representation :returns: Machine friendly representation :rtype: str
Get the channel sid from the channel attributes :param dict attributes: The channel attributes :returns: The channel sid :rtype: str


:param index_points: The index points to use for the KL divergence. If `None`, then the index points used to instantiate the `GaussianProcess` instance will be used. :type index_points: `None` or `np.ndarray` :returns: The index points to use for the KL divergence. If `None`, then the index points used to instantiate the `GaussianProcess` instance will be used. :rtype: `None` or `np.ndarray`

Flatten the state. :param state: A `tf.Tensor` of flattened state. :returns: A `tf.Tensor` of flattened state.
Compute the variational distribution. :returns: Variational distribution. :rtype: tf.Distribution



Pad the sample dimensions of `x` to match the shape of the distribution.

Splits a covariance matrix into a list of marginal covariance matrices. :param covariance: A `Tensor` of shape `[..., num_timesteps, num_timesteps]` representing the covariance matrix of the latent state space model. :type covariance: `tf.Tensor` :param latent_sizes: A list of integers representing the size of the latent state space model for each component. :type latent_sizes: `list` of `int` :returns: A list of `Tensor`s of shape `[..., num_timesteps, latent_size]` representing the marginal covariance matrices of the latent state space model.
"""Decompose the posterior marginals into the components. Args: model: A `tfd.JointDistributionCoroutine` instance. posterior_means: A `tf.Tensor` of shape `[num_timesteps, num_components]`. posterior_covs: A `tf.Tensor` of shape `[num_timesteps, num_components]`. parameter_samples: A `tf.Tensor` of shape `[num_samples, num_parameters]`. Returns: A `dict` of `tf.Tensor`s, where the keys are the names of the components and the values are the corresponding `tf.Tensor`s. """ # TODO(b/150911515): This is a temporary workaround to avoid the # `tf.TensorShape` error when using `tf.function`. # TODO(b/150911515): Remove this workaround once the error is fixed. posterior_means = tf.convert_to_tensor(value=posterior_means) posterior_covs = tf.convert_to_tensor(value=posterior_covs) parameter_samples = tf.convert_to_tensor(value=parameter_samples) # TODO(b/150911515): This is a temporary workaround to avoid the # `tf.TensorShape` error when using `tf.function`. # TODO(b/150911515): Remove this workaround once the error is fixed. posterior_means = tf.convert_to_tensor(value=posterior_means) posterior_covs = tf.convert_to_tensor(value=posterior_covs) parameter_samples = tf.convert_to_tensor(value=parameter_samples) # TODO(b/150911515): This is a temporary workaround to avoid the # `tf.TensorShape` error when using `tf.function`. # TODO(b/150911515): Remove this workaround once the error is fixed. posterior_means = tf.convert_to_tensor(value=posterior_means
"""Decompose the forecast distribution into its components. Args: model: An instance of `tfd.JointDistributionCoroutine`. forecast_latent_mean: A `Tensor` of shape `[num_posterior_draws, num_timesteps, num_components, num_features]`. forecast_latent_covs: A `Tensor` of shape `[num_posterior_draws, num_timesteps, num_components, num_features, num_features]`. parameter_samples: A `Tensor` of shape `[num_posterior_draws, num_timesteps, num_components, num_parameters]`. Returns: A `tfd.JointDistributionCoroutine` instance. """ # TODO(b/149115555): This is a temporary workaround to avoid a bug in # `tfd.JointDistributionCoroutine` where the `sample` method does not # support `sample_shape` argument. # TODO(b/149115555): Remove this workaround once the bug is fixed. if not isinstance(model, tfd.JointDistributionCoroutine): raise ValueError('`model` must be an instance of `tfd.JointDistributionCoroutine`.') # TODO(b/149115555): This is a temporary workaround to avoid a bug in # `tfd.JointDistributionCoroutine` where the `sample` method does not # support `sample_shape` argument. # TODO(b/149115555): Remove this workaround once the bug is fixed. if not isinstance(forecast_latent_mean, tf.Tensor): raise ValueError('`forecast_latent_mean` must be a `Tensor`.') # TODO(b/149115555): This is a temporary workaround to avoid a bug in # `tfd.JointDistributionCoroutine` where the `sample` method does not # support `sample_shape` argument. # TODO(b/149115555): Remove this workaround once the bug is fixed. if not isinstance(forecast_latent_covs,
Copied (with modifications) from: tensorflow/contrib/layers/python/ops/sparse_ops.py. with tf.compat.v1.name_scope(name, 'dense_to_sparse', [x, ignore_value]): x = tf.convert_to_tensor(value=x, name='x') if ignore_value is None: if x.dtype.base_dtype == tf.string: # Exception due to TF strings are converted to numpy objects by default. ignore_value = '' else: ignore_value = x.dtype.as_numpy_dtype(0) ignore_value = tf.cast(ignore_value, x.dtype, name='ignore_value') indices = tf.where(tf.not_equal(x, ignore_value), name='indices') return tf.SparseTensor( indices=indices, values=tf.gather_nd(x, indices, name='values'), dense_shape=tf.shape(input=x, out_type=tf.int64, name='dense_shape'))
Iterate over pages of Invites :returns: Page of InviteInstance :rtype: twilio.rest.chat.v2.service.channel
Provide a friendly representation :returns: Machine friendly representation :rtype: str
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the new resource belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._invites = None self._members = None self._messages = None self._webhooks = None @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = InviteList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._invites @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._messages

"""Constructs a `Sample` op. Args: distribution: The `Distribution` instance to sample from. sample_shape: 0D or 1D `int32` `Tensor`. Shape of the generated samples. seed:
Returns true if both instances are not equal, false otherwise :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
Returns true if both instances are not equal, true otherwise :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
""" Initialize the InviteList :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(*args, **kwargs) # Path Solution self._solution = {'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) def stream(self, limit=None, page_size=None): """ Streams InviteInstance records from the API as a generator stream. This operation lazily loads records as efficiently as possible until the limit is reached. The results are returned as a generator, so this operation is memory efficient. :param int limit: Upper limit for the number of records to return. stream() guarantees to never return more than limit. Default is no limit :param int page_size: Number of records to fetch per request, when not set will use the default value of 50 records. If no page_size is defined but a limit is defined, stream() will attempt to read the limit with the most efficient page size, i.e. min(limit, 1000) :returns: Generator that will yield up to limit results :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance] """ limits = self._version.read_limits(limit, page_size) page = self.page(page_size=limits['page_size'], ) return self._version.stream(page, limits['limit'], limits['page_limit']) def list(self, limit=None, page_size=None): """ Lists InviteInstance records from the API as a list. Unlike stream(), this operation is eager and will load `limit` records into memory before returning. :param int limit: Upper limit for the number of records to return. list() guarantees never to return more than limit. Default is no limit :param int page_size: Number of records
""" Args: x: A Tensor of shape [batch_size, input_units]. output_units: An integer, the number of units in the output. **condition_kwargs: Additional keyword arguments to pass to the template. Returns: A tuple of two Tensors, the first being the shift parameter and the second being the log scale parameter. """ if condition_kwargs: raise NotImplementedError( "Conditioning not implemented in the default template.") if tensorshape_util.rank(x.shape) == 1: x = x[tf.newaxis,...] reshape_output = lambda



""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the new resource belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._invites = None self._members = None self._messages = None self._webhooks = None @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = InviteList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._invites @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._messages



"""Computes the effective sample size of a single state. Args: state: A `Tensor` of shape `[num_steps, batch_size, state_size]`. filter_beyond_lag: A `Tensor` of shape `[num_steps, batch_size]`. filter_threshold: A `Tensor` of shape `[batch_size]`. Returns: A `Tensor` of shape `[batch_size]`. """ # Compute the effective sample size. ess = tf.reduce_sum(tf.cast(tf.greater(filter_beyond_lag, 0.), tf.float32), axis=0) # Compute the effective sample size of the state. ess_state = tf.reduce_sum(tf.cast(tf.greater(filter_threshold, 0.), tf.float32), axis=0) # Compute the effective sample size of the state. ess_state = tf.reduce_sum(tf.cast(tf.greater(filter_threshold, 0.), tf.float32), axis=0) # Compute the effective sample size of the state. ess_state = tf.reduce_sum(tf.cast(tf.greater(filter_threshold, 0.), tf.float32), axis=0) # Compute the effective sample size of the state. ess_state = tf.reduce_sum(tf.cast(tf.greater(filter_threshold, 0.), tf.float32), axis=0) # Compute the effective sample size of the state. ess_state = tf.reduce_sum(tf.cast(tf.greater(filter_threshold, 0.), tf.float32), axis=0) # Compute the effective sample size of the state. ess_state = tf.reduce_sum(tf.cast(tf.greater(filter_threshold, 0.), tf.float32), axis=0) # Compute the effective sample size of the state. ess_state = tf.reduce_sum(tf.cast(tf.greater(filter_threshold, 0.), tf.float32), axis=0) # Compute the effective sample size of the state.
Compute the effective sample size of a single state. :param states: A tensor of shape [N,...] where N is the number of samples. :param filter_beyond_lag: The maximum lag to use for filtering. If None, then the full sequence is used. :param filter_threshold: The threshold to use for filtering. If None, then no filtering is done. :returns: A tensor of shape [...] containing the effective sample size of the state. :rtype: tf.Tensor


Returns True if the object is not None, False otherwise. :param obj: The object to check. :returns: True if the object is not None, False otherwise. :rtype: bool
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._invites = None self._members = None self._messages = None self._webhooks = None @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = InviteList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._invites @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._members = None self._invites = None self._messages = None self._webhooks = None @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = InviteList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._invites @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._
Initialize the Mapping. :param x: Mapping to merge into this mapping. :type x: Mapping :param y: Mapping to merge into this mapping. :type y: Mapping :param ildj: Mapping to merge into this mapping. :type ildj: Mapping :param kwargs: Mapping to merge into this mapping. :type kwargs: Mapping :param mapping: Mapping to merge into this mapping. :type mapping: Mapping
Returns true if both instances are not equal, false otherwise. :param other: twilio.rest.ip_messaging.v2.service.channel.invite.InviteInstance :returns: twilio.rest.ip_messaging.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.ip_messaging.v2.service.channel.invite.InviteInstance
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Provide a friendly representation :returns: Machine friendly representation :rtype: str


Compute the increments by which we need to step the upper and lower bounds part of the doubling procedure. Args: batch_shape: Shape of the batch of points. max_doublings: Maximum number of doublings. step_size: Step size to use. seed: Python integer to seed the random number generator. Returns: left_increments: Shape (max_doublings+1,) + batch_shape. widths: Shape (max_doublings+1,) + batch_shape.
"""Tests whether a proposed point is accepted. Args: x_initial: Tensor of shape `x_proposed.shape` containing the initial position. target_log_prob: Python callable that takes a Tensor of shape `x_proposed.shape` and returns a Tensor of the same shape containing the log-probability of the point. decided: Boolean Tensor of shape `x_proposed.shape` indicating whether the point has already been decided. log_slice_heights: Tensor of shape `x_proposed.shape` containing the log-slice-heights of the point. x_proposed: Tensor of shape `x_proposed.shape` containing the proposed position. step_size: Scalar Tensor containing the step size. lower_bounds: Tensor of shape `x_proposed.shape` containing the lower bounds of the slice. upper_bounds: Tensor of shape `x_proposed.shape` containing the upper bounds of the slice. Returns: accept_res: Boolean Tensor of shape `x_proposed.shape` indicating whether the point is accepted. """ with tf.compat.v1.name_scope('test_acceptance'): # Compute the log-acceptance ratio. log_acceptance_ratio = target_log_prob(x_proposed) - target_log_prob( x_initial) # Compute the log-acceptance probability. log_acceptance_prob = log_acceptance_ratio - log_slice_heights # Compute the log-acceptance probability for the proposed point. log_acceptance_prob_proposed = log_acceptance_ratio - log_slice_heights( x_proposed) # Compute the log-acceptance probability for the initial point. log_acceptance_prob_initial = log_acceptance_ratio - log_slice_heights( x_initial) # Compute the log-acceptance probability for the proposed point. log_acceptance_prob_proposed = log_acceptance_ratio - log_slice_height

Provide a friendly representation :returns: Machine friendly representation :rtype: str
Returns the return value of a function.

2D convolutional layer with batch normalization and ReLU activation. :param tf.Tensor x: Input tensor. :param int filters: Number of filters. :param tuple kernel: Convolution kernel size. :param tuple stride: Convolution stride. :param tf.keras.layers.Layer kernel_posterior_fn: Kernel posterior distribution. :return: Output tensor. :rtype: tf.Tensor
Build a tree at the current state. :param value_and_gradients_fn: Python callable which computes the target log-density and its gradient with respect to the state. :param current_state: Current state. :param current_target_log_prob: Current target log-density. :param current_grads_target_log_prob: Current gradient of the target log-density with respect to the state. :param current_momentum: Current momentum. :param direction: Direction of the NUTS trajectory. :param depth: Depth of the current tree. :param step_size: Step size. :param log_slice_sample: Log-slice sample. :param seed: Python integer to seed the random number generator. :returns: A list of tensors corresponding to the state, target log- density, gradient of the target log-density with respect to the state, momentum, forward state, forward target log-density, forward gradient of the target log-density with respect to the state, forward momentum, reverse state, reverse target log-density, reverse gradient of the target log-density with respect to the state, number of states in the tree, and a boolean indicating whether to continue the NUTS trajectory. :rtype: list[tf.Tensor]




""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': None, 'service_sid': service_sid, 'channel_sid': channel_sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property
Returns a default loc/scale
Returns the default mean field normal distribution function.
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the new resource belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._members = None self._messages = None self._invites = None self._webhooks = None @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._messages = MessageList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._messages @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = Inv

Provide a friendly representation :returns: Machine friendly representation :rtype: str
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites/{sid}'.format(**self._solution) self._properties = {'sid': sid, 'identity': identity, 'role_sid': role_sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'url': url, 'links': links, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites/{sid}'.format(**self._solution) self._context = None self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid or self._properties['sid'], } @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def identity(self): """ :returns: The `identity` value that uniquely identifies the new resource's User. :rtype: unicode """ return self._properties['identity'] @property def role_sid(self): """ :returns: The SID of the Role assigned to the new resource. :rtype: unicode """ return self._properties['role_sid'] @property def date_created(self): """ :returns: The ISO 8601 date and time in GMT when the resource was created. :rtype: datetime """ return self._properties['date_created'] @property
Returns the shallow structure of `structure`.
Converts the given `value` to a `Tensor`. Args: value: A `Tensor`, `SparseTensor`, or `IndexedSlices`. dtype: Optional element type for the returned tensor. If missing, the type is inferred from the type of `value`. name: Optional name for the returned tensor. Returns: A `Tensor` with the same type as `value`. Raises: TypeError: If `value` cannot be converted to a `Tensor`.
""" Initialize the InvitePage :param Version version: Version that contains the resource :param service_sid: The SID of the Service that the resource is associated with :param channel_sid: The SID of the Channel the resource belongs to :param sid: The unique string that identifies the resource :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage """ super(InvitePage, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites{sid}'.format(**self._solution) # Path Parameters self._solution['service_sid'] = service_sid self._solution['channel_sid'] = channel_sid self._solution['sid'] = sid # Filters self._filter = None if identity is not None: self.filter = identity if role_sid is not None: self.filter = role_sid if date_created is not None: self.filter = date_created if date_updated is not None: self.filter = date_updated if url is not None: self.filter = url if links is not None: self.filter = links @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._

Get the channel sid from the channel url :param str channel_url: The channel url :returns: The channel sid :rtype: str

""" Initialize the InvitePage :param Version version: Version that contains the resource :param dict payload: A JSON response from the Twilio API :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage """ super(InvitePage, self).__init__(version, response=payload, solution=service_sid) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._context @property def invites(self): """ :returns: A list of instances of InviteInstance :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance] """ return self._proxy.invites @property def page_size(self): """ :returns: How many resources to return in each list page. The default is 50, and the maximum is 1000. :rtype: unicode """ return self._properties['page_size'] def __repr__(self): """ Provide a friendly representation :returns: Machine friendly representation :rtype: str """ return '<Twilio.IpMessaging.V2.InvitePage>' class InviteContext(InstanceContext): """ PLEASE NOTE that this class contains preview products that are subject to change. Use them with caution. If you currently do not have developer preview access, please contact <EMAIL>. """ def __init__(self, version, service_sid, channel_sid
Get the channel sid from the channel name :param str channel_name: The channel name :returns: The channel sid :rtype: str

"""Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the new resource belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._members = None self._invites = None self._messages = None self._webhooks = None @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = InviteList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._invites @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._messages =
Get the channel sid from the channel url :param str channel_url: The channel url :returns: The channel sid :rtype: str
""" Initialize the Bernoulli
"""Constructs a variable. Args: name: The name of the variable. shape: Shape of the variable. dtype: Type of the variable. initializer: Initializer instance (callable). regularizer: Regularizer instance (callable). trainable: If `True`, the default, also adds the variable to the graph collection `GraphKeys.TRAINABLE_VARIABLES` (see `tf.Variable`). constraint: Constraint instance (callable). **kwargs: Additional keyword arguments. Accepted values are `getter`, `collections`, `validate_shape`, `caching_device`, `expected_shape`, `use_resource`, and `synchronization`. """ self._name = name self._shape = shape self._dtype = dtypes.as_dtype(dtype) self._initializer = initializer self._regularizer = regularizer self._trainable = trainable self._constraint = constraint self._caching_device = kwargs.pop('caching_device', None) self._validate_shape = kwargs.pop('validate_shape', True) self._use_resource = kwargs.pop('use_resource', None) self._synchronization = kwargs.pop('synchronization', variables.VariableSynchronization.AUTO) self._aggregation = kwargs.pop('aggregation', variables.VariableAggregation.NONE) self._getter = kwargs.pop('getter', None) self._collections = kwargs.pop('collections', None) self._expected_shape = kwargs.pop('expected_shape', None) self._from_tensor = kwargs.pop('from_tensor', None) self._from_tensor_fn = kwargs.pop('from_tensor_fn', None) self._constraint_fn = kwargs.pop('constraint_fn', None) self._constraint_args = kwargs.pop('constraint_args', None) self._shape_fn = kwargs.pop('shape_fn', None) self._shape_fn_args = kwargs.pop('shape_fn_args', None) self._shape_out = kwargs.pop('shape_out', None) self._shape_out
""" Initialize the InviteList :param unicode service_sid: The SID of the Service to create the resource under :param unicode channel_sid: The SID of the Channel the new resource belongs to :param Version version: Version that contains the resource :param unicode friendly_name: A string to describe the resource :param unicode role_sid: The SID of the Role to assign to the new member :param unicode identity: The string that identifies the new resource's User :param unicode attributes: A valid JSON string that contains application-specific data :param unicode x_twilio_webhook_enabled: The X-Twilio-Webhook-Enabled HTTP request header :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) # Path Parameters self._properties = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) # Options self._options = {'friendly_name': friendly_name, 'role_sid': role_sid, 'identity': identity, 'attributes': attributes, 'x_twilio_webhook_enabled': x_twilio_webhook_enabled, } self._headers = {'X-Twilio-Webhook-Enabled': x_twilio_webhook_enabled, } @property def service_sid(self): """ :returns: The SID of the Service that the resource is associated with :rtype: unicode """ return self._properties['service_sid'] @property def channel


Compute the log acceptance correction for a single chain.
Calls `grad_fn` if it is not None, otherwise returns `None`.



"""Sample shape of the distribution.""" if x is None: return self.batch_shape, self.batch_shape if not isinstance(x, tf.Tensor): raise TypeError('`x` must be a `Tensor`.') if not tensorshape_util.is_fully_defined(x.shape): raise ValueError('`x` must have a fully-defined shape.') if not tensorshape_util.is_fully_defined(self.batch_shape): raise ValueError('`x` must have a fully-defined batch shape.') if tensorshape_util.rank(x.shape)!= tensorshape_util.rank( self.batch_shape): raise ValueError('`x` must have the same rank as `batch_shape`.') if tensorshape_util.rank(x.shape) == 0: raise ValueError('`x` must have at least one dimension.') if tensorshape_util.rank(x.shape) == 1: if tensorshape_util.dimension_value(x.shape[0])!= 1:


Initialize a JointDistributionCoroutine. :param model: A callable that returns a generator of JointDistribution instances. :param seed: A seed for the random number generator.
""" Lists MemberInstance records from the API as a list. Unlike stream(), this operation is eager and will load `limit` records


Fetch the next page of records :param Response response: The response from Twilio :returns: Page of InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._solution['account_sid'], 'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } self._solution = { 'account_sid': account_sid, 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property def service_sid(self): """ :returns: The SID of the Service that the resource is associated with :rtype: unicode """ return self._properties['service_sid'] @property def channel_sid(self): """ :returns: The SID of the Channel the resource belongs to :rtype: unicode """ return self._properties['channel_sid'] @property def date_created(self): """ :returns: The RFC 2822 date and time in GMT when the resource was created

"""Minimizes a scalar function by one step of gradient descent. Args: gradient_unregularized_loss: A `Tensor` of shape `[d0,..., dN]` containing the gradient of the unregularized loss function with respect to the variables. hessian_unregularized_loss_outer: A `Tensor` of shape `[d0,..., dN]` containing the outer product of the gradient of the unregularized loss function with respect to the variables. hessian_unregularized_loss_middle: A `Tensor` of shape `[d0,..., dN]` containing the middle product of the gradient of the unregularized loss function with respect to the variables. x_start: A `Tensor` of shape `[d0,..., dN]` containing the starting point for the optimization. l1_regularizer: A `Tensor` of shape `[d0,..., dN]` containing the L1 regularization coefficient. l2_regularizer: A `Tensor` of shape `[d0,..., dN]` containing the L2 regularization coefficient. maximum_full_sweeps: An `int` specifying the maximum number of full sweeps to perform. tolerance: A `float` specifying the tolerance for the optimization. learning_rate: A `float` specifying the learning rate for the optimization. Returns: A tuple of `Tensor`s containing the updated point, a `bool` indicating whether the optimization converged, and an `int` specifying the number of iterations performed. """ if learning_rate is None: learning_rate = 1.0 if l2_regularizer is None: l2_regularizer = tf.zeros_like(l1_regularizer) if maximum_full_sweeps < 1: raise ValueError('maximum_full_sweeps must be at least 1.') if
Use an exponential moving average to update the codebook. :param vector_quantizer: :param one_hot_assignments: :param codes: :param commitment_loss: :param decay: :return: """
Get an item from the list of resources :param unicode key: The index of the resource to fetch
Get the channel sid from the channel name :param str channel_name: The channel name :returns: The channel sid :rtype: str
"""Loads the MNIST dataset. Args: directory: The directory where the dataset is stored. split_name: The name of the split to load.
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._invites = None self._members = None self._messages = None self._webhooks = None @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = InviteList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._invites @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._
Returns the base dtype of the given dtype. Args: dtype: A `tf.DType` or a `tf.Tensor`. Returns: A `tf.DType`. """ dtype = tf.as_dtype(dtype) if hasattr(dtype, 'base_dtype'): return dtype.base_dtype return dtype


The SID of the Service that the resource is associated with
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._invites = None self._members = None self._messages = None self._webhooks = None @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = InviteList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._invites @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._invites = None self._members = None self._messages = None self._webhooks = None @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = InviteList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._invites @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._
Create a new channel instance :param unicode sid: A 34 character string that uniquely identifies this resource. :param unicode unique_name: An application-defined string that uniquely identifies the resource. It can be used in place of the resource's `sid`
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._members = None self._messages = None self._invites = None self._webhooks = None @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._messages = MessageList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._messages @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites =
Prepare the arguments for the Nelder-Mead algorithm.
""" Perform an inside contraction. :param callable objective_function: Objective function. :param tf.Tensor current_simplex: Current simplex. :param tf.Tensor current_objective_values: Current objective values. :param tf.Tensor face_centroid: Face centroid. :param int best_index: Index of best vertex. :param int worst_index: Index of worst vertex. :param float worst_objective_value: Objective value of worst vertex. :param float contraction: Contraction factor. :param float shrinkage: Shrinkage factor. :param bool batch_evaluate_objective: Whether to evaluate the objective function in a batch. :returns: (converged, next_simplex, next_objective_at_simplex, num_evaluations) :rtype: (tf.Tensor, tf.Tensor, tf.Tensor, int) """ with tf.compat.v1.name_scope('inside_contraction'): # Compute the centroid of the face opposite the worst vertex. face_centroid = tf.reduce_sum( input_tensor=current_simplex, axis=0) - current_simplex[worst_index] face_centroid /= tf.cast( tf.shape(current_simplex)[0] - 1, face_centroid.dtype.base_dtype) # Perform an inside contraction. next_simplex = tf.concat([ current_simplex[:worst_index], face_centroid, current_simplex[worst_index + 1:], ], axis=0) next_objective_at_simplex = objective_function(next_simplex) num_evaluations = 1 converged = ( (next_objective_at_simplex < worst_objective_value) & (next_objective_at_simplex >= best_objective_value)) return ( converged, next_simplex, next_objective_at_simplex, num



Evaluate the objective function for multiple points. :param callable objective_function: Objective function to be minimized :param numpy.ndarray simplex: Current simplex :param callable batch_evaluate_objective: Function to evaluate the objective function for multiple points


"""Prepares the arguments for the simplex method. Args: objective_function: A function that takes a vector of variables and returns a scalar value. initial_vertex: A vector representing the initial vertex. step_sizes: A list of scalar values representing the step sizes for each variable. objective_at_initial_vertex: A scalar value representing the objective function at the initial vertex. batch_evaluate_objective: A function that takes a list of vectors and returns a list of scalar values. Returns: A tuple of the following: - A vector representing the initial vertex. - A

Evaluate the objective function at multiple vertices. Args: objective_function: A callable that takes a single argument and returns a scalar. simplex_vertices: A tensor of shape [num_vertices, dim]. batch_evaluate_objective: A callable that takes a tensor of shape [batch_size, dim] and returns a tensor of shape [batch_size]. Returns: A tuple of (objective_at_simplex_vertices, num_evaluations).

Get the channel sid from the channel name :param str channel_name: The channel name :returns: The channel sid :rtype: str
""" Initialize the InvitePage :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :returns: twilio.rest.ip_messaging.v2.service.channel.invite.InvitePage :rtype: twilio.rest.ip_messaging.v2.service.channel.invite.InvitePage """ super(InvitePage, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) @property def page_size(self): """ :returns: How many resources to return in each list page. The default is 50, and the maximum is 1000. :rtype: unicode """ return self._properties['page_size']




Broadcasts a tensor to a given shape.
Get the channel sid or channel name or channel sid :param str channel_name: The channel name :returns: The channel sid or channel name or channel sid :rtype: str

""" Initialize the InviteList :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(*args, **kwargs) # Path Solution self._solution = {'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) def stream(self, limit=None, page_size=None): """ Streams InviteInstance records from the API as a generator stream. This operation lazily loads records as efficiently as possible until the limit is reached. The results are returned as a generator, so this operation is memory efficient. :param int limit: Upper limit for the number of records to return. stream() guarantees to never return more than limit. Default is no limit :param int page_size: Number of records to fetch per request, when not set will use the default value of 50 records. If no page_size is defined but a limit is defined, stream() will attempt to read the limit with the most efficient page size, i.e. min(limit, 1000) :returns: Generator that will yield up to limit results :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance] """ limits = self._version.read_limits(limit, page_size) page = self.page(page_size=limits['page_size'], ) return self._version.stream(page, limits['limit'], limits['page_limit']) def list(self, limit=None, page_size=None): """ Lists InviteInstance records from the API as a list. Unlike stream(), this operation is eager and will load `limit` records into memory before returning. :param int limit: Upper limit for the number of records to return. list() guarantees never to return more than limit. Default is no limit :param int page_size: Number of records
Provide a friendly representation :returns: Machine friendly representation :

"""Rotates the dimensions of `x` to the right or left. Args: x: `Tensor` or `RaggedTensor` with shape `[..., event_ndims, batch_shape]`. rotate_right: Python `bool
"""Rotate the dimensions of `x` to the right or left. Args: x: `Tensor` or `RaggedTensor` with shape `[..., event_ndims, batch_shape]`. rotate_right: Python `bool`. If `True`, rotate the dimensions to the right. If `False`, rotate the dimensions to the left. Returns: x: `Tensor` or `RaggedTensor` with shape `[..., batch_shape, event_ndims]`. """



Slice a list of parameters. Args: params: A list of parameters. param_event_ndims: The number of event dimensions in each parameter. slices: A list of slices. dist_batch_shape: The batch shape of the distribution. Returns: A list of sliced parameters.
Slice a single parameter. Args: param: A `Tensor` representing the parameter. param_event_ndims: The number of event dimensions in the parameter. slices: A `Tensor` representing the slices to apply. batch_shape: A `Tensor` representing the batch shape of the parameter. Returns: A `Tensor` representing the sliced parameter.
Converts a slice into a dictionary of parameters. Args: dist: A `Distribution` instance. params_event_ndims: A Python `int` representing the number of event dimensions. slices: A Python `list` of `slice` objects. Returns: params: A `dict` of parameters.
"""Applies a single step of slice overrides to a distribution. Args: dist: The distribution to apply the overrides to. params_event_ndims: The number of event dimensions in the distribution. slices: The slices to apply the overrides to. overrides: The overrides to apply. Returns: The distribution with the overrides applied. """ if not slices: return dist if not overrides: return dist if not isinstance(overrides, dict): raise ValueError('overrides must be a dict') if not isinstance(slices, tuple): raise ValueError('slices must be a tuple') if len(slices)!= params_event_ndims: raise ValueError('slices must have the same length as the number of ' 'event dimensions in the distribution') if not isinstance(dist, tfd.Distribution): raise ValueError('dist must be a tfd.Distribution') if not isinstance(dist.event_shape, tuple): raise ValueError('dist.event_shape must be a tuple') if not isinstance(dist.batch_shape, tuple): raise ValueError('dist.batch_shape must be a tuple') if not isinstance(dist.batch_shape_tensor(), tf.TensorShape): raise ValueError('dist.batch_shape_tensor() must be a tf.TensorShape') if not isinstance(dist.event_shape_tensor(), tf.TensorShape): raise ValueError('dist.event_shape_tensor() must be a tf.TensorShape') if not isinstance(dist.batch_shape_tensor().as_list(), list): raise ValueError('dist.batch_shape_tensor().as_list() must be a list') if not isinstance(dist.event_shape_tensor().as_list(), list): raise ValueError('dist.event_shape_tensor().as_list() must be a list') if not isinstance(dist.batch_shape_tensor().as_list(), list): raise ValueError('dist.batch_shape_tensor().as_list() must be a list') if not isinstance(dist.event_shape_tensor().as_list(), list): raise ValueError('dist.event_shape_tensor().as_list() must be a list') if not isinstance(
Apply a slice to a distribution. Args: dist: The distribution to apply the slice to. params_event_ndims: The number of event dimensions in the distribution's parameters. slices: A slice object. Returns: The distribution with the slice applied.
""" Fit one step of the gradient descent algorithm. :param model_matrix: Model matrix. :type model_matrix: tf.Tensor :param response: Response. :type response: tf.Tensor :param model: Model. :type model: tf.Tensor :param model_coefficients_previous: Model coefficients from previous step. :type model_coefficients_previous: tf.Tensor :param predicted_linear_response_previous: Predicted linear response from previous step. :type predicted_linear_response_previous: tf.Tensor :param l2_regularizer: L2 regularizer. :type l2_regularizer: tf.Tensor :param dispersion: Dispersion. :type dispersion: tf.Tensor :param offset: Offset. :type offset: tf.Tensor :param learning_rate: Learning rate. :type learning_rate: tf.Tensor :param fast_unsafe_numerics: Whether to use fast unsafe numerics. :type fast_unsafe_numerics: bool :returns: Model coefficients, predicted linear response. :rtype: tuple(tf.Tensor, tf.Tensor) """ model_coefficients_next = model_coefficients_previous - learning_rate * ( tf.matmul( tf.matmul( tf.transpose(model_matrix), model_matrix + l2_regularizer * tf.eye( tf.shape(model_matrix)[0], dtype=tf.float32)), model_coefficients_previous) - tf.matmul( tf.matmul( tf.transpose(model_matrix), model_matrix + l2_regularizer * tf.eye( tf.shape(model_matrix)[0], dtype=tf.float32)), predicted_linear_response_previous) + tf.matmul( tf.matmul( tf.transpose(model_matrix), model_matrix + l2_regularizer * tf.eye( tf.shape

""" Initialize the InviteInstance :returns: twilio.rest.ip_messaging.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.ip_messaging.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': payload.get('sid'), 'account_sid': payload.get('account_sid'), 'service_sid': payload.get('service_sid'), 'channel_sid': payload.get('channel_sid'), 'identity': payload.get('identity'), 'role_sid': payload.get('role_sid'), 'date_created': deserialize.iso8601_datetime(payload.get('date_created')), 'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')), 'url': payload.get('url'), } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': payload.get('sid'), } @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property def service_sid(self): """ :
nan
Returns a tuple of (args, all_static) where args is a list of (args, kwargs) tuples and all_static is a boolean indicating whether all args are static.
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Returns the static dtype of a tensor, if it has one.
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._members = None self._messages = None self._invites = None self._webhooks = None @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._messages = MessageList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._messages @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites =
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._solution['account_sid'], 'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'account_sid': account_sid, 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_

""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel to fetch the resource from :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._members = None self._messages = None self._invites = None self._webhooks = None self._last_read_message_index = None self._last_consumption_timestamp = None self._notifications = None self._post = None self._typing = None self._user = None @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._messages = MessageList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._messages @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service


Returns the event shape of the distribution. Returns: event_shape: `TensorShape`, the event shape of the


Send a packet to the server :param twilio.rest.chat.v2
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the new Member belongs to :returns: twilio.rest.chat.v2.service.channel.channel_context.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.channel_context.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._members = None self._messages = None self._invites = None self._webhooks = None @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._messages = MessageList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._messages @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None
Get the channel unique name from the channel_sid or channel_unique_name :param str channel_sid: The channel_sid :param str channel_unique_name: The channel_unique_name :returns: The channel unique name :rtype: str
nan
Get the channel unique name from the channel_sid or channel_unique_name :param str channel_sid: The channel_sid :param str channel_unique_name: The channel_unique_name :returns: The channel unique name :rtype: str
""" Initialize the InviteList :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(*args, **kwargs) # Path Solution self._solution = {'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) def stream(self, limit=None, page_size=None): """ Streams InviteInstance records from the API as a generator stream. This operation lazily loads records as efficiently as possible until the limit is reached. The results are returned as a generator, so this operation is memory efficient. :param int limit: Upper limit for the number of records to return. stream() guarantees to never return more than limit. Default is no limit :param int page_size: Number of records to fetch per request, when not set will use the default value of 50 records. If no page_size is defined but a limit is defined, stream() will attempt to read the limit with the most efficient page size, i.e. min(limit, 1000) :returns: Generator that will yield up to limit results :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance] """ limits = self._version.read_limits(limit, page_size) page = self.page(page_size=limits['page_size'], ) return self._version.stream(page, limits['limit'], limits['page_limit']) def list(self, limit=None, page_size=None): """ Lists InviteInstance records from the API as a list. Unlike stream(), this operation is eager and will load `limit` records into memory before returning. :param int limit: Upper limit for the number of records to return. list() guarantees never to return more than limit. Default is no limit :param int page_size: Number of records





Validates that `sample_shape` is a `TensorShape` and has rank at least 1.

""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel to fetch the resource from :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._invites = None self._members = None self._messages = None self._webhooks = None @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = InviteList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._invites @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._messages
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._invites = None self._members = None self._messages = None self._webhooks = None @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = InviteList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._invites @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._
""" Initialize the InviteList :param unicode service_sid: The SID of the Service to create the resource under :param unicode channel_sid: The SID of the Channel the new resource belongs to :param Version version: Version that contains the resource :param unicode friendly_name: A string to describe the new resource :param unicode role_sid: The SID of the Role to assign to the new member :param unicode identity: The string that identifies the new resource's User :param unicode attributes: A valid JSON string that contains application-specific data :param unicode x_twilio_webhook_enabled: The X-Twilio-Webhook-Enabled HTTP request header :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) # Values of this resource self._friendly_name = friendly_name self._role_sid = role_sid self._identity = identity self._attributes = attributes self._x_twilio_webhook_enabled = x_twilio_webhook_enabled # Headers self._headers = {'X-Twilio-Webhook-Enabled': x_twilio_webhook_enabled, } @property def friendly_name(self): """ :returns: The string that you assigned to describe the resource :rtype: unicode """ return self._friendly_name @property def role_sid(self): """ :returns: The SID of the Role to assign to the new member :rtype: unicode """ return self._role_sid @property def identity(self): """ :returns: The string that
Get an item from the list of resources :param unicode key: The index of the resource to fetch :returns
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the new resource belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._invites = None self._members = None self._messages = None self._webhooks = None @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = InviteList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._invites @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._messages
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._invites = None self._members = None self._messages = None self._webhooks = None @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = InviteList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._invites @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._

Get an item from the list of resources :param unicode key: The index of the resource to fetch :

""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the new resource belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._invites = None self._members = None self._messages = None self._webhooks = None @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = InviteList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._invites @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._messages



""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._invites = None self._members = None self._messages = None self._webhooks = None @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = InviteList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._invites @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._
Generate an absolute URL for this Invite :returns: Absolute URL for this Invite :
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._invites = None self._members = None self._messages = None self._webhooks = None @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = InviteList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._invites @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._


Broadcasting is not supported; unexpected batch shape. :param partial_batch_dist: Distribution with a partially-defined batch shape. :type partial_batch_dist: tf.contrib.distributions.Distribution :param full_sample_and_batch_shape: Full sample and batch shape of the distribution. :type full_sample_and_batch_shape: tf.TensorShape :param validate_args: Python `bool`, default `False`. When `True` distribution parameters are checked for validity despite possibly degrading runtime performance. When `False` invalid inputs may silently render incorrect outputs. :type validate_args: Python `bool` :returns: Full sample and batch shape of the distribution. :rtype: tf.TensorShape

Provide a friendly representation :returns: Machine friendly representation :rtype: str
Get the observation noise for the given timestep. :param int timestep: The timestep to get the observation noise for. :returns: The observation noise for the given timestep. :rtype: numpy.ndarray

Kalman filter update function. :param numpy.array filtered_mean: mean of the filtered distribution :param numpy.array filtered_cov: covariance of the filtered distribution :param numpy.array measurement_matrix: measurement matrix :param numpy.array measurement_noise: measurement noise :param numpy.array measurement: measurement :returns: updated mean and covariance :rtype: numpy.array, numpy.array





Get the transition matrix for a single timestep. :param tf.Tensor filtered_mean: The filtered mean of the state at the previous timestep. :param tf.Tensor filtered_cov: The filtered covariance of the state at the previous timestep. :param tf.Tensor predicted_mean: The predicted mean of the state at the previous timestep. :param tf.Tensor predicted_cov: The predicted covariance of the state at the previous timestep. :returns: tf.Tensor: The transition matrix for the current timestep.

""" Initialize the KalmanFilter :param int n_dim_obs: Dimension of the observation space :param int n_dim_state: Dimension of the state space :param int n_dim_process: Dimension of the process noise :param int n_dim_control: Dimension of the control input :param int n_dim_measurement: Dimension of the measurement noise :param bool log_likelihood: Whether to compute the log-likelihood :param bool log_posterior: Whether to compute the log-posterior :param bool log_marginal_likelihood: Whether to compute the log-marginal likelihood :param bool log_marginal_posterior: Whether to compute the log-marginal posterior :param bool log_marginal_likelihood_estimation: Whether to compute the log-marginal likelihood estimation :param bool log_marginal_posterior_estimation: Whether to compute the log-marginal posterior estimation :param bool log_marginal_likelihood_estimation_by_marginalization: Whether to compute the log-marginal likelihood estimation by marginalization :param bool log_marginal_posterior_estimation_by_marginalization: Whether to compute the log-marginal posterior estimation by marginalization :param bool log_marginal_likelihood_estimation_by_integration: Whether to compute the log-marginal likelihood estimation by integration :param bool log_marginal_posterior_estimation_by_integration: Whether to compute the log-marginal posterior estimation by integration :param bool log_marginal_likelihood_estimation_by_integration_and_marginalization: Whether to compute the log-marginal likelihood estimation by integration and marginalization :param bool log_marginal_posterior_estimation_by_integration_and_marginalization: Whether to compute the log-marginal posterior estimation by integration and marginalization :param bool log_marginal_likelihood_estimation_by_integration_and_marginalization_and_filtering: Whether to compute the log-marginal likelihood estimation by integration and marginalization and filtering :param bool log_marginal_posterior_estimation_by_


""" Lists ChannelWebhookInstance records from the API as a list. Unlike stream(), this operation



2D von Mises Fisher distribution.
Iterate over pages of results :returns: Page of InviteInstance :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Provide a friendly representation :returns: Machine friendly representation :rtype: str

:returns: Number of invites

""" Convenience method for accessing a single invited resource :param unicode key: The sid :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._invites = None self._members = None self._messages = None self._webhooks = None @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = InviteList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._invites @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._


""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._solution['account_sid'], 'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'by': by, 'role_sid': role_sid, 'identity': identity, 'url': url, } self._solution = { 'account_sid': account_sid, 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property def service_sid(self): """ :returns: The SID of the Service that the resource is associated with :rtype: unicode """ return self._properties['service_sid'] @property def channel_sid(self): """ :returns: The SID of the Channel the resource belongs to :rtype: unicode """ return self._properties['channel_sid'] @property def date_created(self): """ :returns: The RFC 282
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Provide a friendly representation :returns: Machine friendly representation :rtype: str
""" Initialize the InviteContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :param sid: The SID of the Invite resource to fetch :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ super(InviteContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites/{sid}'.format(**self._solution) # Dependents self._channel = None self._member = None # Context self._context = None self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: The unique string that identifies the resource :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': None, 'service_sid': service_sid, 'channel_sid': channel_sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property
Replaces the event shape in `input_tensorshape` with `event_shape_out`. Code
"""Validate that `event_shape_in` matches `event_shape_out`. Args: input_tensorshape: `TensorShape` of the input. event_shape_in: `TensorShape` of the event shape of the input. event_shape_out: `TensorShape` of the event shape of the output. Returns: `True` if `event_shape_in` matches `event_shape_out`, `False` otherwise. Raises: ValueError: if `event_shape_in` does not match `event_shape_out`. """ event_shape_in_ = tf.get_static_value(event_shape_in) if event_shape_in_ is None: return True event_shape_in_ = np.int32(


""" Build an instance of InviteInstance :param dict payload: Payload response from the API :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ return InviteInstance( self._version, payload, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel
"""Update the position and return the new state.""" position_delta = tf.where( state.failed, tf.zeros_like(position_delta), position_delta) position = state.position + position_delta objective_gradient = tf.where( state.failed, tf.zeros_like(objective_gradient), objective_gradient) objective_value = tf.where( state.failed, tf.zeros_like(objective_value), objective_value) converged = tf.reduce_all( input_tensor=tf.logical_or( tf.reduce_all( input_tensor=tf.math.is_nan(position), axis=-1), tf.reduce_all( input_tensor=tf.math.is_nan(objective_value), axis=-1), tf.reduce_all( input_tensor=tf.math.is_nan(objective_gradient), axis=-1), tf.reduce_all( input_tensor=tf.math.is_inf(position), axis=-1), tf.reduce_all( input_tensor=tf.math.is_inf(objective_value), axis=-1), tf.reduce_all( input_tensor=tf.math.is_inf(objective_gradient), axis=-1), tf.reduce_all( input_tensor=tf.math.is_finite(position), axis=-1), tf.reduce_all( input_tensor=tf.math.is_finite(objective_value), axis=-1), tf.reduce_all( input_tensor=tf.math.is_finite(objective_gradient), axis=-1), tf.reduce_all( input_tensor=tf.math.is_finite(position_delta), axis=-1), tf.reduce_all( input_tensor=tf.math.is_finite(objective_gradient), axis=-1), tf.reduce_all( input_tensor=tf.math.is_finite(objective_value), axis=-1), tf.reduce_all( input_tensor

""" Check if the position has converged. :param position: Current position. :param next_position: Next position. :param objective_value: Current objective value. :param next_objective: Next objective value. :param objective_gradient: Current objective gradient. :param grad_tolerance: Gradient tolerance. :param f_relative_tolerance: Relative tolerance for the objective function. :param x_tolerance: Tolerance for the position. :return: True if the position has converged, False otherwise. """ converged = tf.reduce_all( input_tensor=tf.math.is_finite(position) & tf.math.is_finite( next_position) & tf.math.is_finite(objective_value) & tf.math.is_finite(next_objective) & tf.math.is_finite( objective_gradient)) converged = converged & tf.reduce_all( input_tensor=tf.math.is_finite(position) & tf.math.is_finite( next_position) & tf.math.is_finite(objective_value) & tf.math.is_finite(next_objective) & tf.math.is_finite( objective_gradient)) converged = converged & tf.reduce_all( input_tensor=tf.math.is_finite(position) & tf.math.is_finite( next_position) & tf.math.is_finite(objective_value) & tf.math.is_finite(next_objective) & tf.math.is_finite( objective_gradient)) converged = converged & tf.reduce_all( input_tensor=tf.math.is_finite(position) & tf.math.is_finite( next_position) & tf.math.is_finite(objective_value) & tf.math.is_finite(next_objective) & tf.math.is_finite( objective_gradient)) converged = converged & tf.reduce_all( input_





Get the results of a replica. Args: replica_id: Replica id. Returns: A list of results.

Converts a channel_unique_name to a Channel resource's sid if it is a Channel resource's sid or a Channel resource's unique_name. :param str channel_unique_name: The channel_sid or unique_name of the Channel resource to fetch. :returns: The sid of the Channel resource. :rtype: str
Initialize the InvitePage :param Version version: Version that contains the resource :param dict payload: A JSON response from the Twilio API :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage
Get an item from the list of resources in the response. :returns: An instance of the resource at the given index, or None if
Transforms the state from the unconstrained space to the constrained space. Args: state_part: A `Tensor` representing the unconstrained state part. Returns: A `Tensor` representing the constrained state part.
""" Initialize the InvitePage :param Version version: Version that contains the resource :param dict payload: A JSON response from the Twilio API :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage """ super(InvitePage, self).__init__(version, response=payload, service_sid=service_sid, channel_sid=channel_sid) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._context @property def invites(self): """ :returns: The list of invites :rtype: unicode """ return self._properties['invites'] @property def has_more(self): """ :returns: True if this page has another page of items available, otherwise False :rtype: bool """ return self._properties['has_more'] @property def url(self): """ :returns: The URL of this page :rtype: unicode """ return self._properties['url'] def __repr__(self): """ Provide a friendly representation :returns: Machine friendly representation :rtype: str """ return '<Twilio.IpMessaging.V2.InvitePage>' class InviteContext(InstanceContext): """ PLEASE NOTE that this class contains preview products that are subject to change. Use them with caution. If you currently do not have developer preview access, please contact <EMAIL>. """ def __init__(self,
Compute the secant of two values. :param left: Left value :type left: float :param right: Right value :type right: float :returns: secant of left and right :rtype: float
Apply the `update` function on active branch members to squeeze their bracketing interval. :param callable value_and_gradients_function: Function that returns the value and gradients of the function to be minimized. :param _Secant2Result initial_args: Initial arguments. :param tf.Tensor val_c: Current value of `c`. :param tf.Tensor f_lim: Limit on the function value. :param float sufficient_decrease_param: Sufficient decrease parameter. :param float curvature_param: Curvature parameter. :returns: _Secant2Result :rtype: _Secant2Result

""" Initialize the InviteList :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the new resource belongs to :param version: Version that contains the resource :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) def create(self, identity, role_sid=values.unset, type=values.unset, ttl=values.unset, attributes=values.unset): """ Create the InviteInstance :param unicode identity: The `identity` value that identifies the new resource's User :param unicode role_sid: The SID of the Role to assign to the new resource :param unicode type: The type of push notification to use. Can be: `gcm` or `apn`. :param unicode ttl: The time-to-live of the notification, in seconds. :param unicode attributes: An optional string metadata field you can use to store any data you wish. :returns: The created InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ data = values.of({ 'Identity': identity, 'RoleSid': role_sid, 'Type': type, 'Ttl': ttl, 'Attributes': attributes, }) payload = self._version.create( 'POST', self._uri, data=data, ) return InviteInstance( self._version, payload, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) def stream(self, limit=None, page_size=None): """ Streams InviteInstance records from the API as a generator stream. This operation lazily loads
""" Bisection algorithm to find a minimum of a function. :param value_and_gradients_function: Function to be minimized. :type value_and_gradients_function: callable :param search_interval: Initial interval to search. :type search_interval: _IntermediateResult :param f_lim: Maximum value of the objective function. :type f_lim: float :returns: _IntermediateResult :rtype: _IntermediateResult """ already_stopped = search_interval.failed | search_interval.converged # If the slope at right end point is positive, step B1 in [2], then the given # initial points already bracket a minimum. bracketed = search_interval.right.df >= 0 # Bisection is needed, step B2, if right end point almost works as a new left # end point but the objective value is too high. needs_bisect = ( search_interval.right.df < 0) & (search_interval.right.f > f_lim) # In these three cases bracketing is already `stopped` and there is no need # to perform further evaluations. Otherwise the bracketing loop is needed to # expand the interval, step B3, until the conditions are met. initial_args = _IntermediateResult( iteration=search_interval.iterations, stopped=already_stopped | bracketed | needs_bisect, failed=search_interval.failed, num_evals=search_interval.func_evals, left=search_interval.left, right=search_interval.right) def _loop_cond(curr): return (curr.iteration < max_iterations) & ~tf.reduce_all(input_tensor=curr.stopped) def _loop_body(curr): # The loop maintains the invariant that curr.stopped is true if we have # either: failed, successfully bracketed, or not yet bracketed but needs # bisect. On the only remaining case, step B3 in [2]. case we need to # expand and update the left/right values appropriately. new_right = value_and_gradients_function(0.5 *
""" Bisection algorithm for finding the root of a function. Args: value_and_gradients_function: A callable that takes a single argument and returns a tuple of the value of the function and its gradient. bisect_args: A namedtuple containing the following fields: iteration: The current iteration number. stopped: A boolean tensor indicating whether the bisection algorithm should stop. failed: A boolean tensor indicating whether the bisection algorithm failed to converge. num_evals: The number of function evaluations performed. left: A namedtuple containing the following fields: x: The left endpoint of the interval. df: The derivative of the function at the left endpoint. f: The value of the function at the left endpoint. right: A namedtuple containing the following fields: x: The right endpoint of the interval. df: The derivative of the function at the right endpoint. f: The value of the function at the right endpoint. Returns: A namedtuple containing the following fields: iteration: The current iteration number. stopped: A boolean tensor indicating whether the bisection algorithm should stop. failed: A boolean tensor indicating whether the bisection algorithm failed to converge. num_evals: The number of function evaluations performed. x: The root of the function. df: The derivative of the function at the root. f: The value of the function at the root. """ def _bisect_step(bisect_args): """ Performs a single iteration of the bisection algorithm. Args: bisect_args: A namedtuple containing the following fields: iteration: The current iteration number. stopped: A boolean tensor indicating whether the bisect algorithm should stop. failed: A boolean tensor indicating whether the bisect algorithm failed to converge. num_evals: The number of function evaluations performed. left: A namedtuple containing the following fields: x: The left endpoint of the interval. df: The derivative of the function at the left endpoint. f: The value of the function at the left endpoint. right: A namedtuple containing the following fields: x: The right endpoint of


Update the current iterate at the start of the next iteration. :param val_c: Current value of the objective function :type val_c: Val




"""Construct a new Hamiltonian Monte Carlo transition kernel. Args: target_log_prob_fn: Python callable which takes an argument like `current_state` (or `*current_state` if it's a list) and returns its (possibly unnormalized) log-density under the target distribution. step_size: `Tensor` or Python `list` of `Tensor`s representing the step size for the leapfrog integrator. Must broadcast with the shape of `current_state`. Larger step sizes lead to faster progress, but too-large step sizes make rejection exponentially more likely. When possible, it's often helpful to match per-variable step sizes to the standard deviations of the target distribution in each variable. num_leapfrog_steps: Python `int` number of steps to run the leapfrog integrator for. Total progress per HMC step is roughly proportional to `step_size * num_leapfrog_steps`. step_size_update_fn: Python callable which takes a `Tensor` or Python `list` of `Tensor`s representing the current step size and returns a `Tensor` or Python `list` of `Tensor`s representing the new step size. If `None`, no step size adaptation will be performed. state_gradients_are_stopped: Python `bool` indicating whether gradients should be computed for the state variables. If `True`, gradients will not be computed for the state variables, and the returned kernel will not be differentiable. name: Python `str` name prefixed to Ops created by this function. Default value: `None` (i.e., 'hmc'). """ self._target_log_prob_fn = target_log_prob_fn self._step_size = step_size self._num_leapfrog_steps = num_leapfrog_steps self._step_size_update_fn = step_size_update_fn self._state_gradients_are
Bootstrap the results of the HMC kernel. :param init_state: Initial state of the chain. :type init_state: `~numpy.ndarray` :
ResNet block.

nan

Retrieve the service sid from the service_sid or service_unique_name :param str service_sid: Service sid :param str service_unique_name: Service unique name :returns: str :rtype: str

""" Initialize the InvitePage :param Version version: Version that contains the resource :param Response response: Response from the API :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage """ super(InvitePage, self).__init__(version, response) # Path Solution self._solution = {'service_sid': service
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Get the channel sid from the channel name :param str channel_name: The channel name :returns: The channel sid :rtype: str




Returns the


Create a sequence of actions. :param character: The character to use for


Returns the size of the kernel. :param stride: The stride of


Returns the number of dimensions of a tensor, or None if it's dynamic.
Get a member instance :param str identity: Identity :returns: twilio.rest.chat.v2.service.channel.member.MemberInstance :rtype: twilio.rest.chat.v2







Convert a list of parameter values to a map from parameter name to value. :param list param_vals: List of parameter values. :returns: dict :rtype: dict
Retrieve the channel sid from the channel_sid or channel_unique_name :param str channel_sid: The channel_sid :param str channel_unique_name: The channel_unique_name :returns: The channel sid :rtype: str
Initialize the KLReverse layer. :param int units: Positive integer, dimensionality of the output space. :param float alpha: Float, controls the amount of reconstruction error. :param bool self_normalized: Boolean, whether to normalize the input. :param str name: A name for the layer (string).
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._invites = None self._members = None self._messages = None self._webhooks = None @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = InviteList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._invites @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._
"""Initialize the ChannelInstance :returns: twilio.rest.chat.v2.service.channel.ChannelInstance :rtype: twilio.rest.chat.v2.service.channel.ChannelInstance """ super(ChannelInstance, self).__init__(*args, **kwargs) self._properties = {'account_sid': self._properties['account_sid'], 'created_by': self._properties['created_by'], 'created_by_identity': self._properties['created_by_identity'], 'created_by_role_sid': self._properties['created_by_role_sid'], 'created_by_role_identity': self._properties['created_by_role_identity'], 'created_by_user_sid': self._properties['created_by_user_sid'], 'created_by_user_identity': self._properties['created_by_user_identity'], 'created_by_user_friendly_name': self._properties['created_by_user_friendly_name'], 'created_by_user_avatar_url': self._properties['created_by_user_avatar_url'], 'created_by_user_attributes': self._properties['created_by_user_attributes'], 'created_by_user_url': self._properties['created_by_user_url'], 'created_by_user_links': self._properties['created_by_user_links'], 'created_by_user_channel_count': self._properties['created_by_user_channel_count'], 'created_by_user_last_consumed_message_index': self._properties['created_by_user_last_consumed_message_index'], 'created_by_user_last_consumed_timestamp': self._properties['created_by_user_last_consumed_timestamp'], 'created_by_user_last_seen_activity_at': self._properties['created_by_user_last_seen_activity_at'], 'created_by_user_notifications_count': self._properties['created_by_user_notifications_count'], 'created_by_user_notifications_last_read_at': self._properties['created_by_user_notifications_last_read_at'], 'created_by_user_notifications_last_
Computes the squared Hellinger distance between two distributions. The squared Hellinger distance between two distributions is defined as .. math:: H^2(p, q) = \\frac{1}{2} \\int_{\\mathbb{R}} \\sqrt{p(x) - q(x)}^2 dx where :math:`p` and :math:`q` are the input distributions. This function is only defined for distributions with positive support. Args: logu: A `Tensor` of type `float32`. The logarithm of the first distribution. name: A name for the operation (optional). Returns: A `Tensor` of type `float32`. The squared Hellinger distance between the distributions. Raises: ValueError: If the input distributions do not have positive support. Example: >>> p = tf.constant([0.1, 0.2, 0.3, 0.4]) >>> q = tf.constant([0.1, 0.2, 0.3, 0.4]) >>> tf.contrib.distributions.squared_hellinger(p, q) <tf.Tensor: shape=(), dtype=float32, numpy=0.0> >>> p = tf.constant([0.1, 0.2, 0.3, 0.4]) >>> q = tf.constant([0.1, 0.2, 0.3, 0.4]) >>> tf.contrib.distributions.squared_hellinger(p, q) <tf.Tensor: shape=(), dtype=float32, numpy=0.0> >>> p = tf.constant([0.1, 0.2, 0.3, 0.4]) >>> q = tf.constant([0.1, 0.2, 0.3, 0.4]) >>> tf.contrib.distributions.squared_hellinger(p, q) <tf.Tensor: shape=(), dtype=float32, numpy=0.0> >>> p = tf.constant([0.1, 0.2, 0.3, 0.4]) >>> q = tf.constant([0.1, 0
Initialize the Triangular distribution. :param float loc: Location parameter. :param float scale: Scale parameter. :param float c: Mode parameter.
""" Initialize the InviteList :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(*args, **kwargs) # Path Solution self._solution = {'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) def stream(self, limit=None, page_size=None): """ Streams InviteInstance records from the API as a generator stream. This operation lazily loads records as efficiently as possible until the limit is reached. The results are returned as a generator, so this operation is memory efficient. :param int limit: Upper limit for the number of records to return. stream() guarantees to never return more than limit. Default is no limit :param int page_size: Number of records to fetch per request, when not set will use the default value of 50 records. If no page_size is defined but a limit is defined, stream() will attempt to read the limit with the most efficient page size, i.e. min(limit, 1000) :returns: Generator that will yield up to limit results :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance] """ limits = self._version.read_limits(limit, page_size) page = self.page(page_size=limits['page_size'], ) return self._version.stream(page, limits['limit'], limits['page_limit']) def list(self, limit=None, page_size=None): """ Lists InviteInstance records from the API as a list. Unlike stream(), this operation is eager and will load `limit` records into memory before returning. :param int limit: Upper limit for the number of records to return. list() guarantees never to return more than limit. Default is no limit :param int page_size: Number of records
1 + 1/np.exp(x) element-wise.

""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the new resource belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._members = None self._messages = None self._invites = None self._webhooks = None @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._messages = MessageList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._messages @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = Inv
""" Initialize the ChannelContext :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(**kwargs) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._messages = MessageList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._messages @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = InviteList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._invites @property def webhooks(self): """ Access the webhooks :returns: twilio.rest.chat.v2.service
Initialize the InvitePage :param Version version: Version that contains the resource :param Response response: Response from the API :param service_sid: The SID of the Service that the resource is associated with :param channel_sid: The SID of the Channel the resource belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite
Get the channel unique name from the channel_sid or channel_unique_name :param str channel_sid: The channel_sid :param str channel_unique_name: The channel_unique_name :returns: The channel unique name :rtype: str
Compute the log-soosum of the input log-probabilities. :param logu: Log-probabilities. :returns: Log-soosum of the input log-probabilities. :rtype: tf.Tensor



Returns the mean of log_values in logspace. Args: log_values: Tensor of log values. Returns: Tensor of means.

Compute the search direction.
The easiest way to validate if the inverse Hessian is positive definite is to compute its Cholesky decomposition. :param tf.Tensor inv_hessian: The inverse Hessian to validate :returns: A list of control dependencies :rtype: list

The quadratic form: y^T.H.y; where H is the inverse Hessian and y is the gradient change.
nan


Get the channel unique name from the channel_sid or channel_unique_name :param str channel_sid: The channel_sid :param str channel_unique_name: The channel_unique_name :returns: The channel unique name :rtype: str
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._invites = None self._members = None self._messages = None self._webhooks = None @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = InviteList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._invites @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._members = None self._messages = None self._invites = None self._webhooks = None @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._messages = MessageList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._messages @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites =

Returns the initial state for the BFGS algorithm.
Returns the next state of the optimizer. Args: value_and_gradients_function: A function that returns the value of the objective function and its gradient. current_state: The current state of the optimizer. num_correction_pairs: The number of correction pairs to be used. tolerance: The tolerance for the optimization. Returns: The next state of the optimizer.


Pop the oldest element from the queue.

For the curious: I wonder whether it is possible and desirable to use a Cholesky decomposition-based algorithm for this, since the only matrices whose determinant this code cares about will be PSD. Didn't figure out how to code that in TensorFlow. Expert opinion is that it would be about twice as fast since Cholesky is roughly half the cost of Gaussian Elimination with Partial Pivoting. But this is less of an impact than the switch in _psd_mask.

""" Returns a batch of matrices with the same shape as sample_shape, and with the same correlation structure as a matrix with shape [dim, dim]. :param dim: The dimension of the matrix. :type dim: int :param sample_shape: The shape of the batch of matrices. :type sample_shape: Tuple[int] :param dtype: The data type of the matrices. :type dtype: tf.DType :param seed: The seed for the random number generator. :type seed: int :return: A batch of matrices with the same shape as sample_shape, and with the same correlation structure as a matrix with shape [
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Get the channel sid from the channel name :param str channel_name: The channel name :returns: The channel sid :rtype: str


Construct the mutated solution vectors. There is one for each member of the population. Args: population: A list of `Tensor`s representing the population. population_size: The size of the population. mixing_indices: A `Tensor` of indices into the population. differential_weight: A `Tensor` of differential weights. Returns: A list of `Tensor`s representing the mutated solution vectors.
Get the initial population and values
Ensures that x is a list. Args: x: A value. Returns: A list.
Find the best individual in the population. :param population: A list of individuals. :

Returns the best fitness in the population. :param list[float] population: A list of positions. :param callable fitness_fn: A function that takes a position and returns a fitness value. :returns: float :rtype: float




If tol is None, return 0. If tol is a Tensor, return it. If tol is a float, convert it to a Tensor with dtype matching dtype and return it. If validate_args is True, then assert that tol is non-negative. Args: tol: A Tensor or a Python `float`. dtype: The dtype of the returned Tensor. validate_args: Python `bool`, default `False`. If `True` distribution parameters are checked for validity despite possibly degrading runtime performance. When `True` distribution parameters may be checked for validity despite possibly degrading runtime performance. Returns: tol: A Tensor with the same dtype as `dtype`.
Create the InviteInstance :param unicode identity: The unique string that identifies the resource's User :param unicode role_sid: The SID of the Role assigned to the new member :param unicode ttl: An application-defined expiration date for the Invite. If an Invite expires, it is no longer valid and the member is removed from the Channel. If no value is
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the new resource belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._members = None self._invites = None self._messages = None self._webhooks = None @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = InviteList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._invites @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._messages

Get the user sid from the user identity :param str user_identity: The user identity :returns: The user sid :rtype: str
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the new resource belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._members = None self._messages = None self._invites = None self._webhooks = None @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._messages = MessageList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._messages @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = Inv

Initialize the VAE network. :param tf.keras.Model encoder_net: The encoder network. :param tf.keras.Model decoder_net: The decoder network. :param int latent_


Get the channel sid from the channel name :param str channel_name: The channel name :returns: str :rtype: str
Fetch a UserInstance :param unicode user_sid: The user_sid :returns: twilio.rest.chat.v2.service.user.UserInstance :rtype: twilio.rest.chat.v2.service.user.UserInstance
"""Asserts that the inputs satisfy the assertions required for the `lu_solve` op. Args: lower_upper: A `Tensor` of shape `[..., n, n]` whose inner-most 2 dimensions form an `n x n` lower triangular matrix. perm: A `Tensor` of shape `[..., n]` whose entries are indices into the first dimension of `lower_upper`. rhs: A `Tensor` of shape `[..., n, r]` whose inner
Initialize the InvitePage :param Version version: Version that contains the resource :param Response response: Response from the API :param service_sid: The SID of the Service that the resource is associated with :param channel_sid: The SID of the Channel the resource is associated with :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2


Construct the matrix [[M, N], [1, 0], [0, 1]] which would map the index (b, i, j) to (Mb + i, Nb + j). This effectively creates a block-diagonal matrix of dense shape [B * M, B * N]. Note that this transformation doesn't increase the number of non-zero entries in the SparseTensor.


Build an instance of InviteInstance :param dict payload:
TODO(b/67594795): Better support of dynamic shape. :param int num_blocks: Number of blocks to split the input into. :param int n_in: Number of input channels. :param int n_out: Number of output channels. :param str mask_type: Type of mask to use. :returns: List of slices. :rtype: List[Tuple[slice, slice]]
TODO(b/
Get or create a channel :param sid: Channel sid :returns: twilio.rest.chat.v2.service.channel.ChannelInstance :rtype: twilio.rest.chat.v2.service.channel.ChannelInstance




Forward pass. :param tf.Tensor inputs: Tensor of shape `[batch_size, event_size]`. :returns: Tensor of shape `[batch_size, event_size * self._params]`. :rtype: tf.Tensor

Get the next page of results :param Response response: Response from the API :returns: Page of results :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage




Compute depth of


The variational loss is a negative ELBO. The ELBO can be broken down into three terms: 1. a likelihood term 2. a trace term arising from the covariance of the posterior predictive kzx = self.kernel.matrix(self._inducing_index_points, observation_index_points) kzx_linop = tf.linalg.LinearOperatorFullMatrix(kzx) loc = (self._mean_fn(observation_index_points) + kzx_linop.matvec(self._kzz_inv_varloc, adjoint=True)) likelihood = independent.Independent( normal.Normal( loc=loc, scale=tf.sqrt(self._observation_noise_variance + self._jitter), name='NormalLikelihood'), reinterpreted_batch_ndims=1) obs_ll = likelihood.log_prob(observations) chol_kzz_linop = tf.linalg.LinearOperatorLowerTriangular(self._chol_kzz) chol_kzz_inv_kzx = chol_kzz_linop.solve(kzx) kzz_inv_kzx = chol_kzz_linop.solve(chol_kzz_inv_kzx, adjoint=True) kxx_diag = tf.linalg.diag_part( self.kernel.matrix( observation_index_points, observation_index_points)) ktilde_trace_term = ( tf.reduce_sum(input_tensor=kxx_diag, axis=-1) - tf.reduce_sum(input_tensor=chol_kzz_inv_kzx ** 2, axis=[-2, -1])) # Tr(SB) # where S = A A.T, A = variational_inducing_observations_scale # and B = Kzz^-1 Kzx Kzx.T Kzz^-1 # # Now Tr(SB) = Tr(A A.T Kzz^-1 Kzx Kzx.T Kzz^-1) # = Tr(A.T Kzz^-1 Kzx Kzx.T Kzz^-1 A) # = sum_ij (A.T Kzz
Solves the linear system `chol_sigma_inv @ kzx_obs`.

Get the channel sid from the channel sid :param str channel_sid: The channel sid :returns: The channel sid :rtype: str



If both input locations and observations are `None`, we consider this "empty" observation data.
Check that observation index points and observation counts broadcast.






Set the validation dataset. :param rdd: the validation dataset :param batch_size: batch size :param val_method: the validation method, "top1" or "top5" :return: self





Convert the given optimizer method to the corresponding BigDL optimizer. :param method: Optimizer method :return: BigDL optimizer
Load a pre-trained Bigdl model. :param path: The path containing the pre-trained model.
Evaluate the model on the given data. :param x: input data :param y: label data :param batch_size: batch size :return: loss value and accuracy :rtype: list[float]
Predicts the label of the input data. :param x: Input data. :type x: RDD :return: Predicted label. :rtype: RDD

Normalize the image by subtracting the mean and dividing by the standard deviation. :param image: image to normalize :param mean: mean to subtract :param std: standard deviation to divide by :

Convenience method to access members of the contained list :param unicode key: The index of the resource to fetch :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.
""" Initialize the InviteList :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) def stream(self, limit=None, page_size=None): """ Streams InviteInstance records from the API as a generator stream. This operation lazily loads records as efficiently as possible until the limit is reached. The results are returned as a generator, so this operation is memory efficient. :param int limit: Upper limit for the number of records to return. stream() guarantees to never return more than limit. Default is no limit :param int page_size: Number of records to fetch per request, when not set will use the default value of 50 records. If no page_size is defined but a limit is defined, stream() will attempt to read the limit with the most efficient page size, i.e. min(limit, 1000)

Provide a friendly representation :returns: Machine friendly representation :rtype: str

Convert a Spark RDD partition iterator to a Java RDD partition iterator.





Get the image frame from the image :param str url: The url to the image :param str float_key: The key to use for the float values :param bool to_chw: Whether to convert the image to CHW format :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance



""" Initialize the model. :param bmodel: the model to be wrapped :type bmodel: :class:`pyspark.mllib.regression.LinearRegressionModel` """ self.bmodel = bmodel self.input_dim = bmodel.weights.shape[0] self.output_dim = bmodel.weights.shape[1] self.intercept = bmodel.intercept self.weights = bmodel.weights.toArray() self.intercept = bmodel.intercept self.input_names = kwargs.get('input_names', None) self.output_names = kwargs.get('output_names', None) self.feature_names = kwargs.get('feature_names', None) self.feature_types = kwargs.get('feature_types', None) self.feature_importances = kwargs.get('feature_importances', None) self.feature_importances_std = kwargs.get('feature_importances_std', None) self.feature_importances_mean = kwargs.get('feature_importances_mean', None) self.feature_importances_std_mean = kwargs.get('feature_importances_std_mean', None) self.feature_importances_std_std = kwargs.get('feature_importances_std_std', None) self.feature_importances_std_mean_std = kwargs.get('feature_importances_std_mean_std', None) self.feature_importances_std_mean_std_mean = kwargs.get('feature_importances_std_mean_std_mean', None) self.feature_importances_std_mean_std_mean_std = kwargs.get('feature_importances_std_mean_std_mean_std', None) self.feature_importances_std_mean_std_mean_std_mean = kwargs.get('feature_importances_std_mean_std_mean_std_mean', None) self.feature_importances_std_mean_std_mean_std_mean_std = kwargs.get('feature_importances_std_mean_std_mean_std_mean_std', None) self.feature
Build an instance of InviteInstance :param dict payload:
Code


``` ### 2.2.8. 调用BigDL的API ```python



Provide a friendly representation :returns: Machine friendly representation :rtype: str
Load a pre-trained Caffe model. :param model: A bigdl model definition
""" Load weights from HDF5 file. :param filepath: path to the HDF5 file """ from bigdl.keras.converter import DefinitionLoader, WeightLoader kmodel, bmodel = DefinitionLoader.from_hdf5_path(filepath) WeightLoader.load_weights_from_kmodel(

加载权重 :param str def_json: 权重定义文件路径 :param str weights_hdf5: 权重文件路径 :param bool by_name: 是否按名称加载权重 :returns: keras.models.Model :rtype: keras.models.Model


Get the model parameters which containing: weight, bias, gradBias, gradWeight :return: dict(layername -> dict(parametername -> ndarray)) :rtype: dict(str -> dict(str -> ndarray))
Get the model parameters which containing: weight, bias, gradBias, gradWeight :return: dict(layername -> dict(parametername -> ndarray)) :rtype: dict(str -> dict(str -> ndarray))



""" Initialize the InvitePage :param Version version: Version that contains the resource :param dict payload: A JSON response from the Twilio API :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage """ super(InvitePage, self).__init__(version, response=payload, solution=service_sid) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._context @property def invites(self): """ :returns: A list of instances of InviteInstance :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance] """ return self._proxy.invites @property def page_size(self): """ :returns: How many resources to return in each list page. The default is 50, and the maximum is 1000. :rtype: unicode """ return self._properties['page_size'] @property def start(self): """ :returns: The index of the first resource to return in the response :rtype: unicode """ return self._properties['start'] @property def end(self): """ :returns: The index of the last resource in the response :rtype: unicode """ return self._properties['end'] @property def uri(self): """ :returns: The URI of the resource, relative to `https://chat.twilio



""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def date_created(self): """ :returns: The ISO 8601 date and time in GMT when the resource was created :rtype: datetime """ return self._properties['date_created'] @property def date_updated(self): """ :returns: The ISO 860
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._invites = None self._members = None self._messages = None self._webhooks = None @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = InviteList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._invites @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the new resource belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._invites = None self._members = None self._messages = None self._webhooks = None @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = InviteList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._invites @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._messages
Extracts all n-grams upto a given maximum order from an input segment.
""" Get the current UTC timestamp as a string :returns: UTC timestamp as a string :rtype: str """ return datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3] Docstring
Get the current timestamp in local string format with timezone. :returns: The current timestamp in local string format with timezone. :rtype: str
Makes the request and returns the response. :param str target_url: API-generated URL for the requested results page :returns: Response from the API :rtype: twilio.rest.resources.base.ResourcePage




Get an item from the list of resources in the response. :returns: An instance of the resource at the given index, or None if that

""" Get a session for the current thread. :returns: A session for the current thread. :rtype: tf.Session """ if not hasattr(thread_local,'session'): thread_local
Build an instance of InviteInstance :param dict payload: Payload response from the API :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :
Get the optimizer :returns: The optimizer :rtype:
:param float learning_rate: Learning rate :param float momentum: Momentum
Build an instance of InviteInstance :param dict payload: Payload response from the API :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Get the channel sid from the channel name :param str channel_name: The channel name :returns: The channel sid :rtype: str
Get an invite instance from the invite_sid :param str invite_sid: The invite_sid :returns: twilio.rest.chat.v2.service.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.invite.InviteInstance
Get the channel sid from the channel sid :param str channel_sid: The channel sid :returns: The channel sid :rtype: str
Get the channel sid from the channel instance or sid :param twilio.rest.chat.v2.service.channel.ChannelInstance channel_instance_or_sid: The channel instance or sid :returns: The channel sid :rtype: str
""" Build an instance of InviteInstance :param dict payload: Payload response from the API :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ return InviteInstance( self._version, payload, service_sid=self._solution['service_sid
"""Run the RNN cell on inputs, starting from the given state
Get the channel sid from the channel name :param str channel_name: The channel name :returns: The channel sid :rtype: str
Get the channel sid from the channel name :param str channel_name: The channel name :returns: The channel sid :rtype: str
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the new Member belongs to :returns: twilio.rest.chat.v2.service.channel.channel_context.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.channel_context.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._members = None self._messages = None self._invites = None self._webhooks = None @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._messages = MessageList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._messages @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None
Get the channel sid from the channel name :param str channel_name: The channel name :returns: The channel sid :rtype: str
Get the channel sid from the channel name :param str channel_name: The channel name :returns: The channel sid :rtype: str
Get the channel sid from the channel name :param str channel_name: The channel name :returns: The channel sid :rtype: str
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the new resource belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._members = None self._messages = None self._invites = None self._webhooks = None @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._messages = MessageList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._messages @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = Inv
Build a basic network :param word_outputs: Output layer for word embeddings :returns: Output layer for word embeddings :rtype: keras.layers.core.Dense

Build the network :param word_outputs: Output of the word embedding layer :type word_outputs: keras.layers.Layer :returns: keras.layers.Layer :rtype: keras.layers.Layer
Transform a single label into a format that can be used by the model. :param list label: Label :returns: Transformed label :rtype: np.ndarray
Transform batch of data to numpy array :param list data: list of data to transform :returns: numpy array of transformed data :rtype: numpy.ndarray

:param list[str] tags: List of tags to be encoded :param int bucket_length: Length of the vector to be returned. If not specified, defaults to the
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the new resource belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._members = None self._messages = None self._invites = None self._webhooks = None @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._messages = MessageList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._messages @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = Inv
Convenience method for accessing the first page of :func:`twilio.rest.chat.v2.service.channel.invite.InviteList.list` :param str key: The key-value pair of the resources to fetch :returns: twilio.rest.chat.v2.service.channel.invite.Invite
Get the client key from the environment. :returns: A PKey object. :rtype: crypto.PKey
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': payload.get('sid'), 'account_sid': payload.get('account_sid'), 'service_sid': payload.get('service_sid'), 'channel_sid': payload.get('channel_sid'), 'identity': payload.get('identity'), 'role_sid': payload.get('role_sid'), 'date_created': deserialize.rfc2822_datetime(payload.get('date_created')), 'date_updated': deserialize.rfc2822_datetime(payload.get('date_updated')), 'url': payload.get('url'), } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': payload.get('sid'), } @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property def service_sid(self): """ :returns: The SID of the Service that the resource is associated with :rtype: unicode """ return self._properties['service_sid'] @property def channel_sid(self): """ :returns: The SID of the Channel the resource belongs to :rtype: unicode """ return self._properties['channel_sid'] @property def identity(self): """ :returns: The identity of the User that created the resource :rtype: unicode """ return self._properties['identity'] @property def role_sid(self): """ :returns: The
Iterate over all of the instances in this page :returns: Iterator of all instances, or an iterable of results :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]
""" Verify Amazon signature chain url :param str signature_chain_url: Amazon signature chain url :returns: True if Amazon signature chain url is valid, False otherwise :rtype: bool """ try: sc_url_get = requests.get(signature_chain_url) except requests.exceptions.ConnectionError as e: log.error(f'Amazon signature chain url get error: {e}') return False sc_url_txt = sc_url_get.text sc_url_txt = sc_url_txt.replace('\n', '') sc_url_txt = sc_url_txt.replace('\r', '') sc_url_txt = sc_url_txt.replace(' ', '') sc_url_txt_split = sc_url_txt.split('-----BEGIN CERTIFICATE-----') sc_url_txt_split = sc_url_txt_split[1:] sc_url_txt_split = [x for x in sc_url_txt_split if x] sc_url_txt_split = [x.strip() for x in sc_url_txt_split] sc_url_txt_split = [x for x in sc_url_txt_split if x] sc_url_txt_split = [x.strip() for x in sc_url_txt_split] sc_url_txt_split = [x for x in sc_url_txt_split if x] sc_url_txt_split = [x.strip() for x in sc_url_txt_split] sc_url_txt_split = [x for x in sc_url_txt_split if x] sc_url_txt_split = [x.strip() for x in sc_url_txt_split] sc_url_txt_split = [x for x in sc_url_txt_split if x] sc_url_txt_split = [x.strip() for x in sc_url_txt_split] sc_url_txt_split = [x for x in sc_url_txt_split if x] sc_url_txt_split = [x.strip() for x in
Returns true if both instances are not equal, false otherwise :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance :returns: True if other is not a InviteInstance and they are not equal, False otherwise :rtype: bool
""" Iterate
Returns true if both instances are not equal, false otherwise :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance :returns: True if other is not a InviteInstance and they are not equal, False otherwise :rtype: bool
Convenience method for accessing the first page of :func:`ip_messaging.v2.service.channel.invite.InviteList.list` :param str key: The key-value pair of the resources to fetch :returns: twilio.rest.chat.v2.service.channel
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': payload.get('sid'), 'account_sid': payload.get('account_sid'), 'service_sid': payload.get('service_sid'), 'channel_sid': payload.get('channel_sid'), 'created_by': payload.get('created_by'), 'created_by_identity': payload.get('created_by_identity'), 'role_sid': payload.get('role_sid'), 'date_created': deserialize.iso8601_datetime(payload.get('date_created')), 'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')), 'url': payload.get('url'), } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': payload.get('sid'), } @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property def service_sid(self): """ :returns: The SID of the Service that the resource is associated with :rtype: unicode """ return self._properties['service_sid'] @property def channel_sid(self): """ :returns: The SID of the Channel the resource is associated with :rtype: unicode """ return self._properties['channel_sid'] @property def created_by(self): """ :returns: The identity of the User that created the resource :rtype: unicode """
""" Initialize the InviteList :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the new resource belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) def stream(self, limit=None, page_size=None): """ Streams InviteInstance records from the API as a generator stream. This operation lazily loads records as efficiently as possible until the limit is reached. The results are returned as a generator, so this operation is memory efficient. :param int limit: Upper limit for the number of records to return. stream() guarantees to never return more than limit. Default is no limit :param int page_size: Number of records to fetch per request, when not set will use the default value of 50 records. If no page_size is defined but a limit is defined, stream() will attempt to read the limit with the most efficient page size, i.e. min(limit, 1000) :returns: Generator that will yield up to limit results :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance] """ limits = self._version.read_limits(limit, page_size) page = self.page(page_size=limits['page_size'], ) return self._version.stream(page, limits['limit'], limits['page_limit']) def list(self, limit=None, page_size=None): """ Lists InviteInstance records from the API as a list. Unlike stream(), this operation is eager and will load `limit` records into memory before returning. :param int limit
""" Initialize the InviteContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :param sid: The SID of the Invite resource to fetch :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ super(InviteContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites/{sid}'.format(**self._solution) # Dependents self._channel = None self._member = None # Context self._context = None self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Provide a friendly representation :returns: Machine friendly representation :rtype: str

Convenience method for accessing the invites of a channel. :param sid: The sid :returns: twilio.rest.chat.v
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Get an instance of a user from the page
Initialize the InvitePage :param Version version: Version that contains the resource :param service_sid: The SID of the Service that the resource is associated with :param channel_sid: The SID of the Channel the resource belongs to :param dict response: Response from the API :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._version.account_sid, 'service_sid': service_sid, 'channel_sid': channel_sid, 'identity': identity, 'role_sid': role_sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :
Get a list of all variables that are not optimizer variables. :param tuple exclude_scopes: Scopes to exclude from the list of variables. :returns: List of all variables that are not optimizer variables. :rtype: List[tf.Variable]
Get all variables that are not in the exclude_scopes from the checkpoint :param str checkpoint_path: Path to the checkpoint :param tuple exclude_scopes: Scopes to exclude

:param str word: The word to search for. :param int d: The maximum edit distance. :param bool allow_spaces: Whether to allow spaces in the word. :param bool return_cost: Whether to return the cost of the edit. :returns: A list of tuples of the form (word, cost) :rtype: list[tuple[str, int]]

Send a packet to the server :param packet: Packet to send :type packet: twilio.rest.chat.v2.service.channel.invite.packet.Packet
This background task sends a PING to the server at

Get the session ID from the API :param dict request: Request to send to the API :returns: Session ID from the API :rtype
Send a packet to the server :param packet.Packet packet: Packet to send :returns: None :rtype: None
Handle session timeout request :param dict request: Request payload :returns: dict :rtype: dict
Handle invalid session response from Alexa :param dict request: Request payload :returns: dict :rtype
Provide a friendly representation :returns: Machine friendly representation :rtype: str
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._solution['account_sid'], 'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource
Get a role instance from the role_sid :param str role_sid: The sid of the role to get :returns: twilio.rest.chat.v2.service.role.RoleInstance :rtype: twilio.rest.chat
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._solution['service_sid'], 'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._solution['service_sid'], 'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def sid(self) -> str: """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self) -> str: """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property def service_sid(self) -> str: """ :returns: The SID of the Service that the resource is associated with :rtype: unicode """ return self._properties['service_sid'] @property def channel_sid(self) -> str: """ :returns: The SID of the Channel the resource belongs to :rtype: unicode """ return self._properties['channel_sid'] @property def date_created(self) -> datetime: """ :returns: The RFC 2822 date and time in GMT when the resource was
Read a file with the format: # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment # comment
Build an instance of InviteInstance :param dict payload:
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def date_created(self): """ :returns: The ISO 8601 date and time in GMT when the resource was created :rtype: datetime """ return self._properties['date_created'] @property def date_updated(self): """ :returns: The ISO 860

Provide a friendly representation :returns: Machine friendly representation :rtype: str

Get the word vectors for a given list of tokens :param List[str] tokens: List of tokens to get the vectors for :returns: List of word vectors :rtype: List[np.ndarray]
Provide a friendly representation :returns: Machine friendly representation :rtype: str
""" Initialize the InviteInstance :param Version version: Version that contains the resource :param service_sid: The SID of the Service that the resource is associated with :param channel_sid: The SID of the Channel the resource belongs to :param sid: The unique string that identifies the resource :param date_created: The RFC 2822 date and time in GMT when the resource was created :param date_updated: The RFC 2822 date and time in GMT when the resource was last updated :param created_by: The identity of the User that created the resource :param url: The absolute URL of the resource :param links: The absolute URLs of the Channel and User resources related to the Invite :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._solution['account_sid'], 'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], 'date_created': deserialize.rfc2822_datetime(date_created), 'date_updated': deserialize.rfc2822_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype:

Convenience method for accessing the first page of :func:`twilio.rest.chat.v2.service.channel.invite.InviteList.list` :param str key: The key-value pair of the resources to fetch :returns: twilio.rest.chat.v2.service.channel.invite.
nan
Run the bot framework server. :param callable agent_generator: A function that returns an agent. :param str app_id: The Microsoft Teams app ID. :param str app_secret: The Microsoft Teams app secret. :param bool stateful: Whether the server should be stateful.
Iterate over pages of Invites :returns: Page of InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._solution['account_sid'], 'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], 'identity': identity, 'role_sid': role_sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'url': url, } self._solution = { 'account_sid': account_sid, 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property def service_sid(self): """ :returns: The SID of the Service that the resource is associated with :rtype: unicode """ return self._properties['service_sid'] @property def channel_sid(self): """ :returns: The SID of the Channel the resource belongs to :rtype: unicode """ return self._properties['channel_sid'] @property def identity(self): """ :returns: The identity of the User that created the resource :rtype: unicode """ return self._
nan
Provide a friendly representation :returns: Machine friendly representation :rtype: str
:returns: Number
Build an instance of InviteInstance :param dict payload: Payload response from the API :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
Returns true if both instances are not equal, false otherwise :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance :returns: True if other is not a InviteInstance and they are not equal, False otherwise :rtype: bool
Returns true if both instances are not equal, false otherwise :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance :returns: True if other is not a InviteInstance and they are not equal, False otherwise :rtype: bool
Returns true if both instances are not equal, false otherwise :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance :returns: True if other is not a InviteInstance and they are not equal, False otherwise :rtype: bool
Returns true if both instances are not equal, false otherwise :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance :returns: True if other is not a InviteInstance and they are not equal, False otherwise :rtype: bool
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': payload.get('sid'), 'account_sid': payload.get('account_sid'), 'service_sid': payload.get('service_sid'), 'channel_sid': payload.get('channel_sid'), 'identity': payload.get('identity'), 'role_sid': payload.get('role_sid'), 'date_created': deserialize.iso8601_datetime(payload.get('date_created')), 'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')), 'url': payload.get('url'), 'links': payload.get('links'), }

""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': None, 'service_sid': service_sid, 'channel_sid': channel_sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property


Recursively parse config properties :param dict config: Config :param dict variables: Variables :returns: Parsed config :rtype: dict
""" Initialize the InviteContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :param sid: The SID of the Invite resource to fetch :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ super(InviteContext, self).__init__(version) # Path Solution self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites/{sid}'.format(**self._solution) # Dependents self._channel = None self._member = None # Context self._context = None self._properties = {'identity': identity, 'role_sid': role_sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'url': url, } if sid is not None: self._properties['sid'] = sid @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property

Handle a request :param Request request: The request to handle :returns: The response to the request :rtype: Response
Get a conversation by unique_name :param str unique_name: The unique_name of the conversation to get :returns: The conversation with the given unique_name :rtype: Optional[twilio.rest.chat.v2.service.channel.conversation.
Update the list of valid certificates. :param valid_certificates: List of valid certificates :type valid_certificates: List[str]
Send a packet to the server :param packet: Packet to send :type packet: twilio.rest.chat.v2.service.channel.invite.packet.Packet :returns: None :rtype: None
Initialize the agent :returns: The agent :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
Get an item from the list of resources :param unicode key: The index of the resource to fetch :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
Get an item from the list of resources in the response. :returns: An instance of the resource at the given index :rtype: twilio
Generate the payload for the request :returns: Payload for the request :rtype: dict
Build an instance of InviteInstance :param dict payload: Payload response
Provide a friendly representation :returns: Machine friendly representation :rtype: str

Provide a friendly representation :returns: Machine friendly representation :rtype: str
""" Iterate over list of invites :returns: List of invites :rtype: list[twilio
List the H2O clouds available in the network. :returns: list of H2O clouds :rtype: list
Retrieve a list of all Messages for the Channel :param int limit: Upper limit for the number of records to return. list() guarantees never to return more than limit. Default is no limit :param str order: The sort order of the returned messages. Can be: 'asc' or 'desc' and the default is 'asc' :param str from_: The Message Sid or index of the first Message to read :returns: generator of twilio.rest.chat.v2.service.channel.message.MessageInstance :rtype: list[twilio.rest.chat.v2.service.channel.message.MessageInstance]
Code
Returns true if both instances are not equal, false otherwise :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Initialize the InvitePage :param Version version: Version that contains the resource :param dict payload: A JSON response from the Twilio API :returns: twilio.
Return the summary for a single column for a single Frame in the h2o cluster. :param str key: The key of the Frame to get the summary for. :param str column: The column to get the summary for. :param int timeoutSecs: The timeout in seconds for the request. :param dict kwargs: Additional parameters to pass to the request. :returns: The summary for the column in the Frame. :rtype: dict ''' params_dict = { # 'offset': 0, # 'len': 100 } h2o_methods.check_params_update_kwargs(params_dict, kwargs,'summary', True) result = self.do_json_request('3/Frames.json/%s/columns/%s/summary' % (key, column), timeout=timeoutSecs, params=params_dict) h2o_sandbox.check_sandbox_for_errors() return result
Delete a model view on the h2o cluster, given its key. :param str key: The key of the model view to delete. :param bool ignoreMissingKey: If True,
Return a model metrics or all of the model metrics known to the h2o cluster. The model metrics are contained in a dictionary called "model_metrics" at the top level of the result. The dictionary maps algorithm names to parameters lists. Each of the parameters contains all the metdata required by a client to present a model building interface to the user. if parameters = True, return the parameters?
Check a dictionary of model builder parameters on the h2o cluster using the given algorithm and model parameters. :param str algo: The algorithm to use for the model builder. :param str training_frame: The training frame to use for the model builder. :param dict parameters: The parameters to use for the model builder. :param int timeoutSecs: The timeout in seconds for the REST call. :param kwargs: Additional parameters to pass to the REST call. :returns: The response from the REST call. :rtype: dict
Create a new ChannelInstance :param unicode service_sid: The SID of the Service to create the resource under :param unicode friendly_name: A string to describe the resource :param unicode attributes: A valid JSON string that contains application-specific data :param unicode type: The visibility of the channel. Can be: `public` or `private` and defaults to `public` :param unicode unique_name: An application-defined string that uniquely identifies the resource :param unicode x_twilio_webhook_enabled: The X-Twilio-Webhook-Enabled HTTP request header :returns
''' ModelMetrics list. ''' result = self.do_json_request('/3/ModelMetrics.
Get all models from the h2o cluster. :param bool ignoreMissingKey: If True, do not raise an exception if the model does not exist. :param int
Initialize the InvitePage :param Version version: Version that contains the resource :param Response response: Response from the API :param service_sid: The SID of the Service that the resource is associated with :param channel_sid: The SID of the Channel the resource belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage
Create a new reservation for count instances :param int count: Number of instances to create :param dict ec2_config: Configuration for the EC2 instance :param str region: Region to create the EC2 instance in :param bool waitForSSH: Wait for SSH to come up :param dict tags: Tags to add to the EC2 instance :returns: Reservation object :rtype: boto.ec2.reservation.Reservation
Get the instance state from the instance ids :param list[str] instance_ids: List of instance ids :returns: list[str] :rtype: list[str]
Get the default page size
Build an instance of InviteInstance :param dict payload: Payload response from the API :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
Get the default page size
Wait for ssh service to appear on given hosts''' log('Waiting for SSH on following hosts: {0}'.format(ips)) for ip in ips: if not skipAlive or not ssh_live(ip, port): log('Waiting for SSH on instance {0}...'.format(ip)) count = 0 while count < requiredsuccess: if ssh_live(ip, port): count += 1 else: count = 0 time.sleep(1) h2o_cmd.dot()
"""
Get the module of a function. :param function: The function to get the module of. :type function: function :returns: The module of the function. :rtype: module

""" Provide a friendly representation :returns: Machine friendly representation :rtype: str """ return '<Twilio.IpMessaging.
""" Resolve the model from the model key. :param str model_key: The model key. :param dict model_json: The model JSON. """ model_type = model_json["output"]["model_category"] if model_type == "Binomial": self._model = h2o.gbm.H2OGradientBoostingEstimator(**model_json["parameters"]) elif model_type == "Multinomial": self._model = h2o.gbm.H2OGradientBoostingEstimator(**model_json["parameters"]) elif model_type == "AutoEncoder": self._model = h2o.deeplearning.H2ODeepLearningEstimator(**model_json["parameters"]) elif model_type == "Clustering": self._model = h2o.kmeans.H2OKMeansEstimator(**model_json["parameters"]) elif model_type == "DeepLearning": self._model = h2o.deeplearning.H2ODeepLearningEstimator(**model_json["parameters"]) elif model_type == "DimReduction": self._model = h2o.decomposition.H2OPCAEstimator(**model_json["parameters"]) elif model_type == "GeneralizedLinear": self._model = h2o.glm.H2OGeneralizedLinearEstimator(**model_json["parameters"]) elif model_type == "IsolationForest": self._model = h2o.isolation_forest.H2OIsolationForestEstimator(**model_json["parameters"]) elif model_type == "NaiveBayes": self._model = h2o.naive_bayes.H2ONaiveBayesEstimator(**model_json["parameters"]) elif model_type == "Regression": self._model = h2o.glm.H2OGeneralizedLinearEstimator(**model_json["parameters"]) elif model_type == "StackedEnsemble": self._model = h2o.stack.H2OStackedEnsembleEstimator(**model_json["parameters"]) elif model_type == "AutoEncoder": self._model = h2o.deeplearning.H2ODeepLearningEstimator(**model_json["parameters"]) elif model_type == "Word
""" Train a model. :param x: The names or indices of the predictor variables. :type x: list of str or int :param y: The name or index of the response variable. :type y: str or int :param training_frame: The H2OFrame containing the training data. :type training_frame: H2OFrame :param offset_column: The name or index of the offset column. :type offset_column: str or int :param fold_column: The name or index of the fold column. :type fold_column: str or int :param weights_column: The name or index of the weights column. :type weights_column: str or int :param validation_frame: The H2OFrame containing the validation data. :type validation_frame: H2OFrame :param max_runtime_secs: Maximum allowed runtime in seconds for model training. Use 0 to disable. :type max_runtime_secs: float :param ignored_columns: Names of columns to ignore for training. :type ignored_columns: list of str :param model_id: The unique id assigned to the resulting model. :type model_id: str :param verbose: Whether to print information about the progress of the model training. :type verbose: bool """ if training_frame is None: raise H2OValueError("training_frame cannot be None") if x is None: raise H2OValueError("x cannot be None") if y is None: raise H2OValueError("y cannot be None") if not isinstance(x, (list, tuple)): x = [x] if not isinstance(y, (list, tuple)): y = [y] if not isinstance(training_frame, H2OFrame): raise H2OValueError("training_frame must be an H2OFrame") if not isinstance(offset_column, (list, tuple)): offset_column


""" Initialize the InviteContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to create the resource under :param channel_sid: The SID of the Channel the new resource belongs to :param sid: The SID of the Invite resource to fetch :param identity: The `identity` value that identifies the new resource's User :param role_sid: The SID of the Role to assign to the new resource :param date_created: The ISO 8601 date and time in GMT when the resource was created :param date_updated: The ISO 8601 date and time in GMT when the resource was last updated :param url: The absolute URL of the resource :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ super(InviteContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites/{sid}'.format(**self._solution) # Dependents self._channel = None self._user = None # Context self._context = None self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._
Get the identity from the identity argument or the identity property of the channel. :returns: The identity :rtype: unicode



""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._solution['account_sid'], 'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'by': by, 'role_sid': role_sid, 'url': url, } self._solution = { 'account_sid': account_sid, 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property def service_sid(self): """ :returns: The SID of the Service that the resource is associated with :rtype: unicode """ return self._properties['service_sid'] @property def channel_sid(self): """ :returns: The SID of the Channel the resource belongs to :rtype: unicode """ return self._properties['channel_sid'] @property def date_created(self): """ :returns: The RFC 2822 date and time in GMT when the resource was created :
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Lists NodeInstance records from the API as a list. Unlike stream(), this operation is eager and will load `limit` records into memory before returning. :returns: List of twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]

""" Initialize the InviteList :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) def stream(self, limit=None, page_
first_column = self.pre_trained.types[self.pre_trained.columns[0]] if first_column!='string': raise H2OValueError("First column of given pre_trained model %s is required to be a String", self.pre_trained.frame_id) if list(self.pre_trained.types.values()).count('string') > 1: raise H2OValueError("There are multiple columns in given pre_trained model %s with a String type.", self.pre_trained.frame_id) self.vec_size = self.pre_trained.dim[1] - 1;
""" Huber loss function. Parameters ---------- y_actual : array-like, shape = (n_samples,) Ground truth (correct) target values. y_predicted : array-like, shape = (n_samples,) Estimated target values. weights : array-like, shape = (n_samples,), optional Sample weights. delta : float, optional Threshold value for the Huber loss. Returns ------- loss : float Huber loss. """
""" Hinge loss function. Parameters ---------- y_actual : array-like, shape = (n_samples,) Ground truth (correct) target values. y_predicted : array-like, shape = (n_samples,) Estimated target values. weights : array-like, shape = (n_samples,), optional (default=None) Sample weights. Returns ------- loss : float Hinge loss of `y_actual` and `y_predicted`. Notes ----- The hinge loss is used for classification problems. The hinge loss is defined as: .. math:: L(y, \\hat{y}) = \\max(0, 1 - y \\hat{y}) Examples -------- >>> from sklearn.metrics import hinge_loss >>> y_true = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1] >>> y_pred = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1] >>> hinge_loss(y_true, y_pred) 0.0 >>> y_true = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1] >>> y_pred = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1.1] >>> hinge_loss(y_true, y_pred) 0.0 >>> y_true = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1] >>> y_pred = [1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9] >>> hinge_loss(y_true, y_pred) 0.1 >>> y_true = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1] >>> y_pred
Computes the gradient of the Huber loss between y_actual and y_predicted. :param y_actual: The actual values. :param y_predicted: The predicted values. :param delta: The delta value for the Huber loss. :return: The gradient of the Huber loss.
Gini impurity is a measure of the inequality of a variable. It is defined as the sum of the weighted squared differences between the predicted and actual values. :param y_actual: Actual values :type y_actual: array-like, shape = [n_samples] :param y_predicted: Predicted values :type y_predicted: array-like, shape = [n_samples] :param weights: Sample weights :type weights: array-like, shape = [n_

Get an item from the list of resources in the response. :returns: An instance of the resource at the given index, or None if that
Get an item from the list of resources in the response. :returns: An instance of the resource at the given index, or None if

Provide a friendly representation :returns: Machine friendly representation :rtype: str

Provide a friendly representation :returns: Machine friendly representation :rtype: str

Iterate over list of Invites and return a generator yielding one Invite instance each :returns: Generator that will yield up to limit results :rtype: list[twilio.rest.chat.v2.service

Read the log file and return the last 100 lines. :returns: log file contents :rtype: str

""" Store the progress of the model. :param numeric res: The progress of the model. :param numeric now: The current time moment. """ self._x0 = self._x0 + self._v0 * (now - self._t0) self._v0 = self._v0 + self._ve * (now - self._t0) self._t0 = now self._x1 = self._x0 + self._v0 * (now - self._t0) self._v1 = self._v0 + self._ve * (now - self._t0) self._t1 = now self._x2 = self._x1 + self._v1 * (now - self._t1) self._v2 = self._v1 + self._ve * (now - self._t1) self._t2 = now self._x3 = self._x2 + self._v2 * (now - self._t2) self._v3 = self._v2 + self._ve * (now - self._t2) self._t3 = now self._x4 = self._x3 + self._v3 * (now - self._t3) self._v4 = self._v3 + self._ve * (now - self._t3) self._t4 = now self._x5 = self._x4 + self._v4 * (now - self._t4) self._v5 = self._v4 + self._ve * (now - self._t4) self._t5 = now self._x6 = self._x5 + self._v5 * (now - self._t5) self._v6 = self._v5 + self._ve * (now - self._t5) self._t6 = now self._x7 = self._x6 + self._v6 * (now - self._t6) self._v7 = self._v6 + self._ve * (now - self._t6) self._t7 = now self._x8 = self._x7 + self._v7 * (now - self._t7) self._v
""" Guess the next poll interval based on the current progress. :returns: The next poll interval in seconds :rtype: int """ if not self._progress_data: return self.MIN_PROGRESS_CHECK_INTERVAL # We want to make sure that the next poll is at least 1 second after the last one. # This is to avoid the situation where the last poll is too fast and we miss the # progress update. last_poll_time, last_progress = self._progress_data[-1] next_poll_time = last_poll_time + 1 if next_poll_time < last_poll_time: next_poll_time = last_poll_time + 1 # We want to make sure that the next poll is at most 10 seconds after the last one. # This is to avoid the situation where the last poll is too slow and we miss the # progress update. if next_poll_time + 10 < last_poll_time: next_poll_time = last_poll_time + 10 # We want to make sure that the next poll is at least 1 second after the last one. # This is to avoid the situation where the last poll is too fast and we miss the # progress update. if next_poll_time < last_poll_time: next_poll_time = last_poll_time + 1 # We want to make sure that the next poll is at most 10 seconds after the last one. # This is to avoid the situation where the last poll is too slow and we miss the # progress update. if next_poll_time + 10 < last_poll_time: next_poll_time = last_poll_time + 10 # We want to make sure that the next poll is at least 1 second after the last one. # This is to avoid the situation where the last poll is too fast and we miss the # progress update. if next_poll_time < last_poll_time: next_poll_time = last_poll_time + 1 # We want to make sure that the next poll is at most 10 seconds after the last one.
Estimate the time delta when the progress will reach 100% :param datetime.datetime now: Current time :returns: datetime.timedelta :rtype: datetime.timedelta
Calculate the approximate speed of the raw progress based on recent data :param float now: Current time :returns: float :rtype: float
Get the time of the progress data of the stream. :returns: The time of the progress data of the stream. :rtype: float

Compute the progress at a given time :param float t: Time to compute the progress at :returns: (float, float) :rtype: (float, float)

Render the footer remaining time
Iterate over pages of results :returns: Page of InviteInstance :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]
Get an item from the list of resources :param unicode key: The index of the resource to fetch :returns: twilio.rest.chat.v2.service.channel
Build an instance of InviteInstance :param dict payload: Payload response from the API :returns: twilio.rest.
Get a frame from the H2O cluster by its path. :param str path: The path of the frame to get. :returns: A H2OFrame object. :rtype: H2OFrame
Provide a friendly representation :returns: Machine friendly representation :rtype: str

""" Initialize the InviteList :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Marshaled Properties self._properties = { 'invites': payload.get('invites'), 'meta': payload.get('meta'), } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, } @property def invites(self): """ :returns: The list of Invites :rtype: list[unicode] """ return self._properties['invites'] @property def meta(self): """ :returns: The response metadata properties for the request :rtype: dict

nan
""" Initialize the InviteList :param unicode service_sid: The SID of the Service to fetch the resource from :param unicode channel_sid: The SID of the Channel the resource to fetch belongs to :param Version version: Version that contains the resource :param dict payload: The instance payload :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Marshaled Properties self._properties = { 'invites': payload.get('invites'), 'meta': payload.get('meta'), } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, } @property def invites(self): """ :returns: The list of Invites :rtype: unicode """ return self._properties['invites'] @property def meta(self): """ :returns: The response metadata properties for the request :rtype: dict """ return self._properties['meta'] @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._context @property def service_sid(self): """ :returns: The SID of the Service that the resource is associated with :rtype: unicode """ return self._properties['service_sid'] @property def channel_sid(self): """ :returns: The SID of the Channel the resource to fetch belongs to :rtype: unicode """ return self._properties['channel_sid
nan
Initialize the InvitePage :param Version version: Version that contains the resource :param service_sid: The SID of the Service that the resource is associated with :param channel_sid: The SID of the Channel the resource belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage
Provide a friendly representation :returns: Machine friendly representation :rtype: str


""" Provide a friendly representation :returns: Machine friendly representation :rtype: str """ return '<Twilio.IpMessaging.V2.InviteList>' Doc
Delete the value of a column or
:param col: Column name or index :type col: int, str, None :param types: New column types :type types: dict




""" Provide a friendly representation :returns: Machine friendly representation :rtype: str


Concatenate a list of DataFrames along a particular axis. :param list frames: List of DataFrames to concatenate. :param int axis: Axis to concatenate along. :returns: Concatenated DataFrame. :rtype: pandas.DataFrame

""" Initialize the InviteList :param Session session: The session that owns this InviteList instance :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource is associated with :param sid: The unique string that identifies the resource :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version=session.version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) # Path Properties self._properties = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) @property def service_sid(self): """ :returns: The SID of the Service that the resource is associated with :rtype: unicode """ return self._properties['service_sid'] @property def channel_sid(self): """ :returns: The SID of the Channel the resource is associated with :rtype: unicode """ return self._properties['channel_sid'] @property def sid(self): """ :returns: The unique string that identifies the resource :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property def service_unique_name(self): """ :returns: The unique string that identifies the resource's parent :rtype: unicode """ return self._properties['service_unique_name'] @property def channel_unique_name(self): """ :returns:
Split the frame into multiple frames based on the provided ratios. :param list[float] ratios: The ratios to split the frame into. :param list[str] destination_frames: The destination frames to split the frame into. :param int seed: The seed to use for the random number generator. :returns: list[H2OFrame] :rtype: list[H2OFrame]
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Iterate over the rows of this H2OFrame. :return: An iterator over the rows of
Return a boolean H2OFrame indicating if the values are
Merge two H2OFrames. :param other: The other H2OFrame to merge with. :param all_x: If True, then all columns from the left frame are used. :param all_y: If True, then all columns from the right frame are used. :param by_x: The columns from the left frame to use. :param by_y: The columns from the right frame to use. :param method: The method to use for merging. :returns: A new H2OFrame containing the merged data. :rtype: H2OFrame
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Initialize the InvitePage :param Version version: Version that contains the resource :param Response response: Response from the API :param service_sid: The SID of the Service that the resource is associated with :param channel_sid: The SID of the Channel the resource belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage


Constructs a InviteContext :param sid: The sid
nan
Set an item or slice from this H2OFrame. :param key: The item or slice to set. :param value: The value to set the item or slice to.
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Set an item or slice from this H2OFrame. :param key: The item or slice to set. :param value: The value to set the item or slice to.
Get an item from the list of resources :param unicode key: The index of the resource to fetch :returns: twilio.
""" Provide a friendly representation :returns: Machine friendly representation :rtype: str """
Provide a friendly representation :returns: Machine friendly representation :rtype: str





""" Provide a friendly representation :returns: Machine friendly representation :rtype: str """
Provide a friendly representation :returns: Machine friendly representation :rtype: str
""" Provide a friendly representation :returns:
""" Provide a friendly representation :returns: Machine friendly representation :rtype: str """

Iterate over pages of results :returns: Page of InviteInstance :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]
""" Initialize a new H2OFrame. :param H2OFrame raw_expr: The H2OFrame to wrap. :param dict env: The environment to use for the H2OFrame. """ self._ex = raw_expr self._env = env self._nrows = raw_expr._nrows self._ncols = raw_expr._ncols self._types = raw_expr._types self._names = raw_expr._names self._row_names = raw_expr._row_names self._col_names = raw_expr._col_names self._frame_id = raw_expr._frame_id self._key = raw_expr._key self._summary = raw_expr._summary self._summary_frame = raw_expr._summary_frame self._frame_data = raw_expr._frame_data self._frame_data_raw = raw_expr._frame_data_raw self._frame_data_raw_size = raw_expr._frame_data_raw_size self._frame_data_raw_offset = raw_expr._frame_data_raw_offset self._frame_data_raw_length = raw_expr._frame_data_raw_length self._frame_data_raw_type = raw_expr._frame_data_raw_type self._frame_data_raw_encoding = raw_expr._frame_data_raw_encoding self._frame_data_raw_checksum = raw_expr._frame_data_raw_checksum self._frame_data_raw_checksum_valid = raw_expr._frame_data_raw_checksum_valid self._frame_data_raw_checksum_type = raw_expr._frame_data_raw_checksum_type self._frame_data_raw_checksum_value = raw_expr._frame_data_raw_checksum_value self._frame_data_raw_checksum_offset = raw_expr._frame_data_raw_checksum_offset self._frame_data_raw_checksum_length = raw_expr._frame_data_raw_checksum_length self._frame_data_raw_checksum_encoding = raw_expr._frame_data
Convert a pandas DataFrame to a H2OFrame. :param pandas_frame: pandas DataFrame to convert. :returns: H2OFrame. :rtype: H2OFrame
""" Insert a value into the frame at the given index. :param int i: Index to insert the value at. :param value: Value to insert. :returns: self """ if isinstance(value, H2OFrame): if value.nrow!= 1 or value.ncol!= 1: raise ValueError("Can only insert a single value into a H2OFrame") value = value.iloc[0,0] if isinstance(value, H2OVec): raise ValueError("Can only insert a single value into a H2OFrame") if isinstance(value, H2OVec): raise ValueError("Can only insert a single value into a H2OFrame") if isinstance(value, H2OVec): raise ValueError("Can only insert a single value into a H2OFrame") if isinstance(value, H2OVec): raise ValueError("Can only insert a single value into a H2OFrame") if isinstance(value, H2OVec): raise ValueError("Can only insert a single value into a H2OFrame") if isinstance(value, H2OVec): raise ValueError("Can only insert a single value into a H2OFrame") if isinstance(value, H2OVec): raise ValueError("Can only insert a single value into a H2OFrame") if isinstance(value, H2OVec): raise ValueError("Can only insert a single value into a H2OFrame") if isinstance(value, H2OVec): raise ValueError("Can only insert a single value into a H2OFrame") if isinstance(value, H2OVec): raise ValueError("Can only insert a single value into a H2OFrame") if isinstance(value, H2OVec): raise ValueError("Can only insert a single value into a H2OFrame") if isinstance(value, H2OVec): raise ValueError("Can only insert a single value into a H2OFrame") if isinstance(value, H2OVec): raise ValueError("Can

Iterate over list of invites :returns: List of InviteInstance :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]

Provide a friendly representation :returns: Machine friendly representation :rtype: str
""" Initialize the InviteList :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_
""" Provide a friendly representation :returns: Machine friendly representation :rtype: str """ return '<Twilio
:returns: Number of invites
Provide a friendly representation :returns: Machine friendly representation :rtype: str
""" Connect to H2O cluster using the configuration provided in the config file. """ if "connect_params" in config: connect_params = config["connect_params"] else: connect_params = config if "ip" in connect_params: ip = connect_params["ip"] else: ip = None if "port" in connect_params: port = connect_params["port"] else: port = None if "https" in connect_params: https = connect_params["https"] else: https = None if "verify_ssl_certificates" in connect_params: verify_ssl_certificates = connect_params["verify_ssl
""" Initialize the InviteContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :param sid: The SID of the Invite resource to fetch :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ super(InviteContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites/{sid}'.format(**self._solution) # Dependents self._channel = None @property def sid(self): """ :returns: The SID of the Invite resource :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property def service_sid(self): """ :returns: The SID of the Service that the resource is associated with :rtype: unicode """ return self._properties['service_sid'] @property def channel_sid(self): """ :returns: The SID of the Channel the resource to fetch belongs to :rtype: unicode """ return self._properties['channel_sid'] @property def role_sid(self): """ :returns: The SID of the Role assigned to the user when they join the Channel :rtype: unicode """ return self._properties['role_sid'] @property def identity(self): """ :returns: The identity of the User when they join the Channel :rtype: unicode """ return self._properties['identity'] @property def date_created(self): """ :returns: The RFC 2822 date and time in
""" Initialize the H2OConnection object :param str url: The URL of the H2O cluster :param str token: The token to use for authentication :param int port: The port to use for the connection :param str scheme: The scheme to use for the connection :param str proxy_host: The host of the proxy to use for the connection :param int proxy_port: The port of the proxy to use for the connection :param str proxy_scheme: The scheme of the proxy to use for the connection :param str proxy_user: The username to use for the proxy :param str proxy_password: The password to use for the proxy :param str proxy_auth: The authentication type to use for the proxy :param str proxy_workstation: The workstation to use for the proxy :param str proxy_domain: The domain to use for the proxy :param str proxy_workstation: The workstation to use for the proxy :param str proxy_domain: The domain to use for the proxy :param str proxy_workstation: The workstation to use for the proxy :param str proxy_domain: The domain to use for the proxy :param str proxy_workstation: The workstation to use for the proxy :param str proxy_domain: The domain to use for the proxy :param str proxy_workstation: The workstation to use for the proxy :param str proxy_domain: The domain to use for the proxy :param str proxy_workstation: The workstation to use for the proxy :param str proxy_domain: The domain to use for the proxy :param str proxy_workstation: The workstation to use for the proxy :param str proxy_domain: The domain to use for the proxy :param str proxy_workstation: The workstation to use for the proxy :param str proxy_domain: The domain to use for the proxy :param str proxy_workstation: The workstation to use for the proxy :param str proxy_domain: The domain to use for the proxy :param str proxy_workstation: The workstation to use for the proxy :param str proxy_domain: The domain to use for the proxy :param str proxy_workstation: The workstation to use for
Lists InviteInstance records from the API as a list. Unlike stream(), this operation is eager and will load `limit` records into memory before returning. :param int limit: Upper limit for the number of records to return. list() guarantees never to return more than limit. Default is no limit :param int page_size: Number of records to fetch per request, when not set will use the default value of 50 records. If no page_size is defined but a limit is defined, list() will attempt to read the limit with the most efficient page size, i.e. min(limit, 1000) :returns: Generator that will yield up to limit results :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]
Provide a friendly representation :returns: Machine friendly representation :rtype: str




Get an item from the list of resources :param unicode key: The index of the resource to fetch :returns
Provide a friendly representation :returns: Machine friendly representation :rtype: str

Get a model ID from the H2O cloud. :param str model_id: The model ID to get. :returns: A model ID. :rtype: str
Get the frame info for a given frame. :param str name: The frame name. :returns: The frame info. :rtype: dict
Build an instance of InviteInstance :param dict payload:
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._solution['account_sid'], 'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'expiration_date': deserialize.iso8601_datetime(expiration_date), 'date_expires': deserialize.iso8601_datetime(date_expires), 'role_sid': role_sid, 'identity': identity, 'invited_by': invited_by, 'channel_type': channel_type, 'member_count': member_count, 'unique_members_count': unique_members_count, 'attributes': attributes, 'friendly_name': friendly_name, 'date_deleted': deserialize.iso8601_datetime(date_deleted), 'deleted_by': deleted_by, 'links': links, } # Context self._context = None
Initialize the InvitePage :param Version version: Version that contains the resource :param dict payload: A JSON response from the Twilio API :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage

""" Initialize the InviteList :param Version version: Version that contains the resource :param dict payload: A JSON response from the Twilio API :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Marshaled Properties self._properties = { 'invites': payload.get('invites'), 'meta': payload.get('meta'), } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, } @property def invites(self): """ :returns: The list of Invites :rtype: list[unicode] """ return self._properties['invites'] @property def meta(self): """ :returns: The response metadata properties for the request :rtype: dict """ return self._properties['meta'] @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._context def __call__(self, sid): """ Constructs a InviteContext :param sid: The unique string that identifies the resource :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ return InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=sid,

Load a model from a string. :param str model_string: The string containing the model. :returns: A model object. :rtype: H2OModel
Make scoring history on a frame. :param H2OFrame frame: Frame to make scoring history on. :param list domain: Domain of the prediction. :param str distribution: Distribution of the prediction. :returns: H2OFrame

Get the name of the class

Convert seconds to a human-readable duration. :param int seconds: Seconds to convert :returns: Human-readable duration :rtype: str
""" Provide a friendly representation :returns: Machine friendly representation
""" Initialize the InviteList :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :param sid: The SID of the Invite resource to fetch :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites{sid}'.format(**self._solution) # Dependents self._invites = None @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = InviteList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._invites def __repr__(self): """ Provide a friendly representation :returns: Machine friendly representation :rtype: str """ return '<Twilio.IpMessaging.V2.InviteList>' class InvitePage(Page): """ PLEASE NOTE that this class contains preview products that are subject to change. Use them with caution. If you currently do not have developer preview access, please contact <EMAIL>. """ def __init__(self, version, response, solution): """ Initialize the InvitePage :param Version version: Version that contains the resource :
""" Predict using a MOJO model. :param str input_csv_path: Path to the CSV file containing the input data. :param str mojo_zip_path: Path to the MOJO model. :param str output_csv_path: Path to the CSV file where the predictions will be written. :param str genmodel_jar_path: Path to the GenModel JAR file. :param str classpath: Additional classpath entries. :param str java_options: Additional Java options. :param bool verbose: Whether to print verbose output. :returns: The number of rows in the output CSV file. :rtype: int """ if not can_use_pandas(): raise RuntimeException('Cannot import pandas') import pandas assert_is_type(input_csv_path,'str') assert_is_type(mojo_zip_path,'str') assert_is_type(output_csv_path,'str') assert_is_type(genmodel_jar_path,'str', optional=True) assert_is_type(classpath,'str', optional=True) assert_is_type(java_options,'str', optional=True) assert_is_type(verbose, 'bool', optional=True) if verbose: print('Predicting using MOJO model...') if genmodel_jar_path is None: genmodel_jar_path = os.path.join(os.path.dirname(__file__), 'genmodel.jar') if classpath is None: classpath = os.path.join(os.path.dirname(__file__), 'genmodel.jar') if java_options is None: java_options = '-Xmx1024m' if verbose: print(' input_csv_path = %s' % input_csv_path) print(' mojo_zip_path = %s' % mojo_zip_path) print(' output_csv_path = %s' % output_csv_path) print(' gen

Get an item from the list of resources in the response. :returns: An instance of the resource at the given index, or None if that index
""" Initialize the InviteList :param Version version: Version that contains the resource :param service_sid: The SID of the Service to create the resource under :param channel_sid: The SID of the Channel the new resource belongs to :param identity: The unique string that identifies the resource's User :param friendly_name: A string to describe the resource :param role_sid: The SID of the Role to assign to the new member :param attributes: A valid JSON string that contains application-specific data :param x_twilio_webhook_enabled: The X-Twilio-Webhook-Enabled HTTP request header :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, 'identity': identity, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) # Dependents self._invites = None # Filters self._filter = None if friendly_name is not None: self.filter(friendly_name=friendly_name, ) if role_sid is not None: self.filter(role_sid=role_sid, ) if attributes is not None: self.filter(attributes=attributes, ) self._x_twilio_webhook_enabled = x_twilio_webhook_enabled @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = InviteList( self._version, service_sid=self._solution['service_
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Constructs a InviteContext :param service_sid: The SID of
Return a sorted table of the best models based on the metric specified
:param id: The index or id of the model to get the hyperparameters for. :type id: int or str :param display: Whether to print the hyperparameters to the console. :type display: bool, default True :returns: The hyperparameters for the model. :rtype: list """ idx = id if is_type(id, int) else self.model_ids.index(id) model = self[idx] # if cross-validation is turned on, parameters in one of the fold model actuall contains the max_runtime_secs # parameter and not the main model that is returned. if model._is_xvalidated: model = h2o.get_model(model._xval_keys[0]) res = [model.params[h]['actual'][0] if isinstance(model.params[h]['actual'], list) else model.params[h]['actual'] for h in self.hyper_params] if display: print('Hyperparameters: [' + ', '.join(list(self.hyper_params.keys())) + ']') return res

Retrieve a single page of InviteInstance records from the API. Request is executed immediately :param str page_token: PageToken provided by the API :param int page_number: Page Number, this value is simply for client state :param int page_size: Number of records to return, defaults to 50 :returns: Page of InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Initialize the InvitePage :param Version version: Version that contains the resource :param Response response: Response from the API :param service_sid: The SID of the Service that the resource is associated with

Initialize the InvitePage :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage
""" Iterate over pages of InviteInstance :returns: Page of InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.Invite
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Build an instance of InviteInstance :param dict payload: Payload response from the API :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': payload.get('sid'), 'account_sid': payload.get('account_sid'), 'service_sid': payload.get('service_sid'), 'channel_sid': payload.get('channel_sid'), 'created_by': payload.get('created_by'), 'created_by_identity': payload.get('created_by_identity'), 'role_sid': payload.get('role_sid'), 'date_created': deserialize.iso8601_datetime(payload.get('date_created')), 'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')), 'url': payload.get('url'), } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': payload.get('sid'), } @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property def service_sid(self): """ :returns: The SID of the Service that the resource is associated with :rtype: unicode """ return self._properties['service_sid'] @property def channel_sid(self): """ :returns: The SID of the Channel the resource belongs to :rtype: unicode """ return self._properties['channel_sid'] @property def created_by(self): """ :returns: The identity of the User that created the resource :rtype: unicode """ return
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._solution['service_sid'], 'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property def service_sid(self): """ :returns: The SID of the Service that the resource is associated with :rtype: unicode """ return self._properties['service_sid'] @property def channel_sid(self): """ :returns: The SID of the Channel the resource belongs to :rtype: unicode """ return self._properties['channel_sid'] @property def date_created(self): """ :returns: The RFC 2822 date and time in GMT when the resource was created :
Convenience method for accessing a InviteInstance :param key: The sid :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :
Send a packet to the server.
Constructs a InviteContext :param sid: A 34 character string that uniquely identifies this resource. :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext
:param str filename: The path to the file to upload. :returns: A dictionary of file names and file objects. :rtype: dict :raises: H2OValueError if the file does not exist.
Log a message to the log file. :param str msg: The message to log.
""" Perform a request to the Twilio API. :param str method: HTTP method to use :param str url: URL to request :param dict data: Data to send with the request :param dict headers: Headers to send with the request :param int timeout: Timeout in seconds :param int connect_timeout: Timeout in seconds for establishing a connection :param str proxy: Proxy to use :param bool stream: Whether to stream the response :param str idempotency_key: Idempotency key to use :param retry_policy: Retry policy to use :returns: Response from the API :rtype: requests.Response """ if not self._is_logging: return start_time = time.time() headers = headers or {} headers['User-Agent'] = self.user_agent if idempotency_key: headers['Idempotency-Key'] = idempotency_key if self.auth: headers['Authorization'] = self.auth.get_authorization(method, url, data, headers) if self.proxy: proxy = self.proxy if self.timeout: timeout = self.timeout if self.connect_timeout: connect_timeout = self.connect_timeout if self.stream: stream = self.stream if self.retry_policy: retry_policy = self.

200 = "Ok", 201 = "Created", 202 = "Accepted", 204 = "No Content" :param requests.Response response: Response from the API :returns: Response data :rtype: str """ status_code = response.status_code if status_code == 200 and save_to: if save_to.startswith("~"): save_to = os.path.expanduser(save_to) if os.path.isdir(save_to) or save_to.endswith(os.path.sep): dirname = os.path.abspath(save_to) filename = H2OConnection._find_file_name(response) else: dirname, filename = os.path.split(os.path.abspath(save_to)) fullname = os.path.join(dirname, filename) try: if not os.path.exists(dirname): os.makedirs(dirname) with open(fullname, "wb") as f: for chunk in response.iter_content(chunk_size=65536): if chunk: # Empty chunks may occasionally happen f.write(chunk) except OSError as e: raise H2OValueError("Cannot write to file %s: %s" % (fullname, e)) return fullname content_type = response.headers.get("Content-Type", "") if ";" in content_type: # Remove a ";charset=..." part content_type = content_type[:content_type.index(";")] # Auto-detect response type by its content-type. Decode JSON, all other responses pass as-is. if content_type == "application/json": try: data = response.json(object_pairs_hook=H2OResponse) except (JSONDecodeError, requests.exceptions.ContentDecodingError) as e: raise H2OServerError("Malformed JSON from server (%s):\n%s" % (str(e), response.text)) else: data = response.text # Success (200 = "Ok", 201 = "Created", 202 = "Accepted", 204 = "No Content") if status_code in {200,
Provide a friendly representation :returns: Machine friendly representation :

Provide a friendly representation :returns: Machine friendly representation :rtype: str
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Build an instance of InviteInstance :param dict payload:
Provide a friendly representation :returns: Machine friendly representation :rtype: str
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._solution['account_sid'], 'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'account_sid': account_sid, 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account
Provide a friendly representation :returns: Machine friendly representation :rtype: str


11.test_timeout was found, no need to continue mining the console text




Write out a general build message :param str keyName: Key name :param list val: List of values :param file text_file: File

Get the channel sid from the channel name :param str channel_name: The channel name :returns: The channel sid :rtype: str


Provide a friendly representation :returns: Machine friendly representation :rtype: str

Iterate over the job
""" Initialize the InvitePage :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage """ super(InvitePage, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) @property def page_size(self): """ :returns: How many resources to return in each list page. The default is 50, and the maximum is 1000. :rtype: unicode """ return self._properties['page_size'] @property def next_page_url(self): """ :returns: The URL of the next page of results :rtype: unicode """ return self._properties['next_page_url'] @property def key(self): """ :returns: The unique string that identifies the resource :rtype: unicode """ return self._properties['key'] @property def invites(self): """ :
Build an instance of InviteInstance :param dict payload:
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Provide a friendly representation :returns: Machine friendly representation :rtype: str
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': payload.get('sid'), 'account_sid': payload.get('account_sid'), 'service_sid': payload.get('service_sid'), 'channel_sid': payload.get('channel_sid'), 'identity': payload.get('identity'), 'role_sid': payload.get('role_sid'), 'date_created': deserialize.rfc2822_datetime(payload.get('date_created')), 'date_updated': deserialize.rfc2822_datetime(payload.get('date_updated')), 'url': payload.get('url'), } # Context
""" Initialize the ModelContext :param Version version: Version that contains the resource :param service_sid: The service_sid :param sid: The sid :returns: twilio.rest.api.v2010.account.service.model.ModelContext :rtype: twilio.rest.api.v2010.account.service.model.ModelContext """ super(ModelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid,'sid': sid, } self._uri = '/Accounts/{account_sid}/Services/{service_sid}/Models/{sid}.json'.format(**self._solution) # Dependents self._fields = None self._permissions = None @property def fields(self): """ Access the fields :returns: twilio.rest.api.v2010.account.service.model.field.FieldList :rtype: twilio.rest.api.v2010.account.service.model.field.FieldList """ if self._fields is None: self._fields = FieldList(self._version, service_sid=self._solution['service_sid'], model_sid=self._solution['sid'], ) return self._fields @property def permissions(self): """ Access the permissions :returns: twilio.rest.api.v2010.account.service.model.permission.PermissionList :rtype: twilio.rest.api.v2010.account.service.model.permission.PermissionList """ if self._permissions is None: self._permissions = PermissionList(self._version, service_sid=self._solution['service_sid'], model_sid=self._solution['sid'], ) return self._permissions def fetch(self): """ Fetch a ModelInstance :returns: Fetched ModelInstance :rtype: twilio.rest.api.v20
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Provide a friendly representation
Initialize the InvitePage :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage
""" Set the parameters of this estimator. The method works on simple estimators as well as on nested objects (such as pipelines). The latter have parameters of the form ``<component>__<parameter>`` so that it's possible to update each component of a nested object. Returns ------- self """ if not params: # Simple optimization to gain speed (inspect is slow) return self valid_params = self.get_params(deep=True)
Provide a friendly representation :returns: Machine friendly representation :rtype:
Provide a friendly representation :returns: Machine friendly representation :rtype: str
""" PLEASE NOTE that this class contains preview products that are subject to change. Use them with ca
Initialize the InvitePage :param Version version: Version that contains the resource :param Response response: Response from the API :param service_sid: The SID of the Service that the resource is associated with :param channel_sid: The SID of the Channel the resource belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage

Provide a friendly representation :returns: Machine friendly representation :rtype: str
Build an instance of InviteInstance :param dict payload:
Initialize the InvitePage :param Version version: Version that contains the resource :param dict payload: A JSON response from the Twilio API :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage


""" :returns: Number of Invites in the response :rtype: unicode """ return self._version
""" Provide a friendly representation :returns: Machine friendly representation :rtype: str """ return '<Twilio.IpMessaging.

Return the path to the h2o.jar file from the local directory. :returns:

nan
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._solution['account_sid'], 'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource
Get the url of the package :returns: package url :rtype: string
Get package name from relative path :
Get the docstring of an object from a line of text :param line: line of
Parse a package and return a list of all classes and functions :param string uri: python location of package - e.g'sphinx.builders' :returns: (functions, classes) :rtype: (list, list)
Return module sequence discovered from ``self.package_name`` Parameters ---------- None Returns ------- mods : sequence Sequence of module names within ``self.package_name`` Examples -------- >>> dw = ApiDocWriter('sphinx') >>> mods = dw.discover_modules() >>>'sphinx.util' in mods True >>> dw.package_skip_patterns.append('\.util$') >>>'sphinx.util' in dw.discover_modules() False >>> ''' modules = [self.package_name] # raw directory parsing for dirpath, dirnames, filenames in os.walk(self.root_path): # Check directory names for packages root_uri = self._path2uri(os.

Get an item from the list of resources :param unicode key: The index of the resource to fetch :returns

Load ok java messages from file. :param str ok_java_messages_filename: The filename of the ok java messages file.




""" Process a message from the server :param dict message: Message payload from the server :returns: Message instance :rtype: twilio.rest.chat.v2.service.channel.message.MessageInstance """ if message['type'] == 'text': if message['author'] == self._client.identity: return None if message['author'] in self._client.ignore_list: return None if message['author'] in self._client.ignore_list_text: return None if message['author'] in self._client.ignore_list_regex: return None if message['author'] in self._client.ignore_list_regex_text: return None if message['author'] in self._client.ignore_list_regex_text_filename: return None if message['author'] in self._client.ignore_list_regex_text_filename_text: return None if message['author'] in self._client.ignore_list_regex_text_filename_text_text: return None if message['author'] in self._client.ignore_list_regex_text_filename_text_text_text: return None if message['author'] in self._client.ignore_list_regex_text_filename_text_text_text_text: return None if message['author'] in self._client.ignore_list_regex_text_filename_text_text_text_text_text: return None if message['author'] in self._client.ignore_list_regex_text_filename_text_text_text_text_text_text: return None if message['author'] in self._client.ignore_list_regex_text_filename_text_text_text_text_text_text_text: return None if message['author'] in self._client.ignore_list_regex_text_filename_text_text_text_text_text_text_text_text: return None if message['author'] in self._client.ignore_list_regex_text_filename_text_text_text_text_text_text_text_text_text: return None if message['author'] in self._client.ignore_

Extract a
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': None, 'service_sid': service_sid, 'channel_sid': channel_sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property
~~~~* <spell> ~~~~* <spell> ====* <spell> ====* <spell> ----* <spell> ----* <spell> """ import os import re import sys import time import urllib import urllib.parse import urllib.request import uuid import xml.etree.ElementTree as ET import requests import six from twilio.base import deserialize from twilio.base import values from twilio.base.instance_resource import InstanceResource from twilio.base.list_resource import ListResource from twilio.base.page import Page from twilio.rest.chat.v2.service.channel.invite.invite_instance import InviteInstance from twilio.rest.chat.v2.service.channel.invite.invite_list import InviteList from twilio.rest.chat.v2.service.channel.invite.invite_page import InvitePage from twilio.rest.chat.v2.service.channel.invite.invite_context import InviteContext from twilio.rest.chat.v2.service.channel.invite.invite_creator import InviteCreator from twilio.rest.chat.v2.service.channel.invite.invite_deleter import InviteDeleter from twilio.rest.chat.v2.service.channel.invite.invite_fetcher import InviteFetcher from twilio.rest.chat.v2.service.channel.invite.invite_reader import InviteReader from twilio.rest.chat.v2.service.channel.invite.invite_updater import InviteUpdater from twilio.rest.chat.v2.service.channel.invite.invite_page import InvitePage class InviteList(ListResource): """ PLEASE NOTE that this class contains preview products that are subject to change. Use them with caution. If you currently do not have developer preview access, please contact <EMAIL>. """ def __init__(self, version, service_sid, channel_sid): """ Initialize the InviteList :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def date_created(self): """ :returns: The ISO 8601 date and time in GMT when the resource was created :rtype: datetime """ return self._properties['date_created'] @property def date_updated(self): """ :returns: The ISO 8601
Provide a friendly representation :returns: Machine friendly representation :rtype: str
nan
""" Add failed tests to the intermittent dict :param dict g_summary_dict_intermittents: Intermittent dict :param dict g_summary_dict_all: All tests dict :param int ind: Index of the test """ testName = g_summary_dict_all["TestName"][ind] testInfo = g_summary_dict_all["TestInfo"][ind] testCategory = testInfo["TestCategory"] testCategory = testCategory[0] testCategory = testCategory.split(" ") testCategory = testCategory[0] testCategory = testCategory.split(".") testCategory = testCategory[0] testCategory = testCategory.split("-") testCategory = testCategory[0] testCategory = testCategory.split("_") testCategory = testCategory[0] testCategory = testCategory.split(" ") testCategory = testCategory[0] testCategory = testCategory.split(".") testCategory = testCategory[0] testCategory = testCategory.split("-") testCategory = testCategory[0] testCategory = testCategory.split("_") testCategory = testCategory[0] testCategory = testCategory.split(" ") testCategory = testCategory[0] testCategory = testCategory.split(".") testCategory = testCategory[0] testCategory = testCategory.split("-") testCategory = testCategory[0] testCategory = testCategory.split("_") testCategory = testCategory[0] testCategory = testCategory.split(" ") testCategory = testCategory[0] testCategory = testCategory.split(".") testCategory = testCategory[0] testCategory = testCategory.split("-") testCategory = testCategory[0] testCategory = testCategory.split("_") testCategory = testCategory[0] testCategory = testCategory.split(" ") testCategory = testCategory[0] testCategory = testCategory.split(".") testCategory = testCategory[0] testCategory = testCategory.split("-") testCategory = testCategory[0] testCategory = testCategory.split("_") testCategory = testCategory[0]
Initialize the InvitePage :param Version version: Version that contains the resource :param Response response: Response from the API :param service_sid: The SID of the Service that the resource is associated with :param channel_sid: The SID of the Channel the resource belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage
confusion_matrix(self, metrics=None, thresholds=None) # make lists out of metrics and thresholds arguments if metrics is None and thresholds is None: metrics = ['f1'] if isinstance(metrics, list): metrics_list = metrics elif metrics is None: metrics_list = [] else: metrics_list = [metrics] if isinstance(thresholds, list): thresholds_list = thresholds elif thresholds is None: thresholds_list = [] else: thresholds_list = [thresholds] # error check the metrics_list and thresholds_list assert_is_type(thresholds_list, [numeric]) assert_satisfies(thresholds_list, all(0 <= t <= 1 for t in thresholds_list)) if not all(m.lower() in H2OBinomialModelMetrics.max_metrics for m in metrics_list): raise ValueError("The only allowable metrics are {}", ', '.join(H2OBinomialModelMetrics.max_metrics)) # make one big list that combines the thresholds and metric-thresholds metrics_thresholds = [self.find_threshold_by_max_metric(m) for m in metrics_list] for mt in metrics_thresholds: thresholds_list.append(mt) first_metrics_thresholds_offset = len(thresholds_list) - len(metrics_thresholds) thresh2d = self._metric_json['thresholds_and_metric_scores'] actual_thresholds = [float(e[0]) for i, e in enumerate(thresh2d.cell_values)] cms = [] for i, t in enumerate(thresholds_list): idx = self.find_idx_by_threshold(t) row = thresh2d.cell_values[idx] tns = row[11] fns = row[12] fps = row[13] tps = row[14] p = tps + fns n = tns + fps c0 = n - fps c1 = p - tps if t in metrics_thresholds: m = metrics_list[i - first_metrics_thresholds_offset] table_header = "Confusion Matrix (Act/Pred) for
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': None, 'service_sid': service_sid, 'channel_sid': channel_sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property

""" Get all endpoints :returns: list of dicts :rtype: list of dicts """ return [ { "class_name": "Twilio", "class_type": "twilio", "class_id": "TWILIO", "class_description": "Twilio", "class_url": "https://www.twilio.com", "class_icon": "https://www.twilio.com/marketing/bundles/marketing/img/logos/wordmark-color.svg", "class_enabled": True, "class_config": { "account_sid": "ACXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", "auth_token": "y<PASSWORD>", "from": "+15558675310", "to": "+15558675310", "message": "Hello World", "method": "POST", "url": "https://example.com/twilio/webhook", "status_callback": "https://example.com/twilio/status", "status_callback_method": "POST", "media_url": "https://example.com/twilio/media", "media_method": "POST", "media_type": "application/pdf", "media_filename": "example.pdf", "media_expiration": 3600, "media_size": 1024, "media_content_type": "application/pdf", "media_encoding": "base64", "media_description": "Example media description", "media_keywords": "example, media, keywords", "media_title": "Example media title", "media_author": "Example media author", "media_copyright": "Example media copyright", "media_category": "Example media category", "media_rating": "Example media rating", "media_release_date": "2018-01-01", "media_language": "en-US", "media_transcript": "Example media transcript", "media_caption": "Example media caption", "media_frame_height": 100, "media_frame_width": 100

Convenience method for accessing the first element of the list :returns: The first element of
Comment medias :param list[str] medias: medias to comment :param int amount: amount of medias to comment :returns: True if success, False otherwise :rtype: bool

""" Lists ReactionInstance records from the API as a list. Unlike stream(), this operation is eager and will load `limit`
""" Lists ReactionInstance records from the API as a list. Unlike stream(), this operation is eager and will load `limit` records into
Get user info from api :param str user_id: user_id :returns: dict :rtype: dict
读取文件内容 :param str file_path: 文件路径 :param bool quiet: 是否静默模式 :returns: list :rtype: list
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Returns true if both instances are not equal, false otherwise :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance

Build an instance of InviteInstance :param dict payload:


raw_result = self._create_or_update_by_id_initial( application_definition_id=application_definition_id, parameters=parameters, custom_headers=custom_headers, raw=True, **operation_config ) def get_long_
Provide a friendly representation :returns: Machine friendly representation :rtype: unicode
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Send the request headers to the server. :param twilio.rest.chat.v2.service.channel.invite.InviteInstance.HTTPResponse connection: The connection to send the request headers to :param dict headers: The request headers
Execute script actions on the specified HDInsight cluster. :param resource_group_name: The name of the resource group. :type resource_group_name: str :param cluster_name: The name of the cluster. :type cluster_name: str :param persist_on_success: Persist script actions on the specified HDInsight cluster. :type persist_on_success: bool :param script_actions: The list of run time script actions. :type script_actions: list of :class:`ScriptAction <azure.mgmt.hdinsight.models.ScriptAction>` :param dict custom_headers: headers that will be added to the request :param bool raw: returns the direct response alongside the deserialized response :param polling: True for ARMPolling, False for no polling, or a polling object for personal polling strategy :return: An instance of LROPoller that returns None or ClientRawResponse<None> if raw==True :rtype: ~msrestazure.azure_operation.AzureOperationPoller[None] or ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[None]] :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>` """ raw_result = self._execute_script_actions_initial( resource_group_name=resource_group_name, cluster_name=cluster_name, persist_on_success=persist_on_success, script_actions=script_actions, custom_headers=custom_headers, raw=True, **operation_config ) if raw: return raw_result # Construct and send request def long_running_send(): return raw_result.response def get_long_running_status(status_link, headers=None): request = self._client.get(status_link) if headers: request.headers.update(headers) header_parameters = {} header_parameters['x-ms-client-request-id'] = raw_result.response.request.headers['x-ms-client-request-id'] return self._client.send( request, header_parameters, stream=False, **operation_config) def get_long_running_output(response):
Retrieve a single page of InviteInstance records from the API. Request is executed immediately :param Response response: The response from the server. :returns: Page of InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage

Get the client secret key sid sid :returns: The client secret key sid sid :rtype: unicode
Provide a friendly representation :returns: Machine friendly representation :rtype: str

""" Get the Azure CLI profile user. :param str resource: The


Read the response body. :returns: The response body. :rtype: str
Get an item from the list of resources :param str key: The index of the resource to return :returns: An instance of the resource :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
Sets the request header. :param str name: The name of the header to set. :param str value: The value
Gets back all response headers. :returns: All response headers :rtype: str
Sends the request body. :param request: The request body. :type request: str :returns: The response body. :rtype: str
Get response time from the server. :returns: Response time from the server. :rtype:
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Sets the request body for the request. :param str body: The request body to use for the request.
Connects to host and sends the request. :param method: HTTP method to use :type method: unicode :param uri: URI to request :type uri: unicode
Sends the headers of request. :param name: The name of the header to set. :param value: The value of the header to set. :returns: The updated request object. :rtype: requests.Request
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Gets the response and generates the _Response object'''
""" PLEASE NOTE that this class contains preview products that are subject to change. Use them with caution. If you currently do not have developer preview access, please contact <EMAIL>. :returns



get properties from entry xml :param entry: entry xml :type entry: xml.etree.ElementTree.Element :param include_id: include id in properties :type include_id: bool :param id_prefix_to_skip: prefix to skip when generating id :type id_prefix_to_skip: str :param use_title_as_id: use title as id :type use_title_as_id: bool :returns: properties :rtype: dict
Build an instance of InviteInstance :param dict payload: Payload response from the API :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance

Converts xml response to service bus namespace The xml format for namespace: <entry> <id>uuid:00000000-0000-0000-0000-000000000000;id=0000000</id> <title type="text">myunittests</title> <updated>2012-08-22T16:48:10Z</updated> <content type="application/xml"> <NamespaceDescription xmlns="http://schemas.microsoft.com/netservices/2010/10/servicebus/connect" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"> <Name>myunittests</Name> <Region>West US</Region> <DefaultKey>0000000000000000000000000000000000000000000=</DefaultKey> <Status>Active</Status> <CreatedAt>2012-08-22T16:48:10.217Z</CreatedAt> <AcsManagementEndpoint>https://myunittests-sb.accesscontrol.windows.net/</AcsManagementEndpoint> <ServiceBusEndpoint>https://myunittests.servicebus.windows.net/</ServiceBusEndpoint> <ConnectionString>Endpoint=sb://myunittests.servicebus.windows.net/;SharedSecretIssuer=owner;SharedSecretValue=0000000000000000000000000000000000000000000=</ConnectionString> <SubscriptionId>00000000000000000000000000000000</SubscriptionId> <Enabled>true</Enabled> </NamespaceDescription> </content> </entry>
Get the region endpoint of the service bus Code
Converts xml response to service bus namespace availability The xml format: <?xml version="1.0" encoding="utf-8"?> <entry xmlns="http://www.w3.org/2005/Atom"> <id>uuid:9fc7c652-1856-47ab-8d74-cd31502ea8e6;id=3683292</id> <title type="text"></title> <updated>2013-04-16T03:03:37Z</updated> <content type="application/xml"> <NamespaceAvailability xmlns="http://schemas.microsoft.com/netservices/2010/10/servicebus/connect" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"> <Result>false</Result> </NamespaceAvailability> </content> </entry>
Converts xml response to service bus metrics objects The xml format for MetricProperties <entry> <id>https://sbgm.windows.net/Metrics(\'listeners.active\')</id> <title/> <updated>2014-10-09T11:56:50Z</updated> <author> <name/> </author



""" Lists InviteInstance records from the API as a list. Unlike stream(), this operation is eager and will load `limit` records into memory before returning. :param int limit: Upper limit for the number of records to return. list() guarantees never to return more than limit. Default is no limit :param int page_size: Number of records to fetch per request, when not
""" Build the installation message for the PR :param github.PullRequest sdk_pr: The PR to build the message for :returns: The installation message :rtype: str """ installation_message = "## Installation\n\n" installation_message += "### Install the package\n\n" installation_message += "```bash\n" installation_message += "pip install azure-sdk-for-python\n" installation_message += "```\n\n" installation_message += "### Install the package and dependencies\n\n" installation_message += "```bash\n" installation_message += "pip install azure-sdk-for-python[all]\n" installation_message += "```\n\n" installation_message += "### Install the package and dependencies using pipenv\n\n" installation_message += "```bash\n" installation_message += "pipenv install azure-sdk-for-python\n" installation_message += "```\n\n" installation_message += "### Install the package and dependencies using poetry\n\n" installation_message += "```bash\n" installation_message += "poetry add azure-sdk-for-python\n" installation_message += "```\n\n" installation_message += "### Install the package and dependencies using setup.py\n\n" installation_message += "```bash\n" installation_message += "python -m pip install -e.\n" installation_message += "```\n\n" installation_message += "### Install the package and dependencies using setup.py with pipenv\n\n" installation_message += "```bash\n" installation_message += "pipenv install -e.\n" installation_message += "```\n\n" installation_message += "### Install the package and dependencies using setup.py with poetry\n\n" installation_message += "```bash\n" installation_message += "poetry install -e.\n" installation_message += "```\n\n" installation_message += "### Install the package and dependencies using setup.py with poetry\n\
""" Lists InviteInstance records from the API as a list. Unlike stream(), this operation is eager and will load `limit` records into memory before returning. :param str service_sid: The SID of the Service to read the resources from :param int limit: Upper limit for the number of records to return. list() guarantees never to return more than limit. Default is no limit :param int page_size: Number of records to fetch per request, when not set will use the default value of 50 records. If no page_size is defined but a limit is defined, list() will attempt to read the limit with the most efficient page size, i.e. min(limit, 1000) :returns: Generator that will yield up to limit results :rtype: list[twilio.rest.chat.

This background task receives messages from the server.
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel to fetch the resource from :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._invites = None self._members = None self._messages = None self

Returns system properties for the specified storage account. service_name: Name of the storage service account.
Constructs a UserContext :param sid: The sid :returns: twilio.rest.chat.v2.service.user.UserContext :rtype: twilio.rest.chat.v2.service.user.UserContext
Initialize the ServicePage :param Version version: Version that contains the resource :param Response response: Response from the API :param service_sid: The SID of the Service to fetch :returns: twilio.rest.chat.v2.service.ServicePage :rtype: twilio.rest.chat.v2.service.ServicePage
Creates a new storage account in Windows Azure. service_name: A name for the storage account that is unique within Windows Azure. Storage account names must be between 3 and 24 characters in length and use numbers and lower-case letters only. description: A description for the storage account. The description may be up to 1024 characters in length. label: A name for the storage account. The name may be up to 100 characters in length. The name can be used to identify the storage account for your tracking purposes. affinity_group: The name of an existing affinity group in the specified subscription. You can specify either a location or affinity_group, but not both. location: The location where the storage account is created. You can specify either a location or affinity_group, but not both. geo_replication_enabled: Deprecated. Replaced by the account_type parameter. extended_properties: Dictionary containing name/value pairs of storage account properties. You can have a maximum of 50 extended property name/value pairs. The maximum length of the Name element is 64 characters, only alphanumeric characters and underscores are valid in the Name, and the name must start with a letter. The value has a maximum length of 255 characters. account_type: Specifies whether the account supports locally-redundant storage, geo-redundant storage, zone-redundant storage, or read access geo-redundant storage. Possible values are: Standard_LRS, Standard_ZRS, Standard_GRS, Standard_RAGRS ''' _validate_not_none('service_name', service_name) _validate_not_none('description', description) _validate_not_none('label', label) if affinity_group is None and location is None: raise ValueError( 'location or affinity_group must be specified') if affinity_group is not None and location is not None: raise ValueError( 'Only one of location or affinity_group needs to be specified') if geo_replication_enabled == False: account_type = 'Standard_LRS' return self._perform_post( self._get_storage_service_path(), _Xml
Updates the extended properties for a storage account in Windows Azure. service_name: Name of the storage service account.
Deletes a UserChannelInvite instance from the service. :param service_sid: The service_sid :param channel_sid: The channel_sid :param sid: The sid :returns:
Deletes a Storage Service Account. service_name: Name of the storage service account.
Retrieves system properties for the specified hosted service. These properties include the service name and service type; the name of the affinity group to which the service belongs, or its location if it is not part of an affinity group; and optionally, information on the service's deployments. service_sid: A 34 character string that uniquely identifies this resource. embed_detail: When True, the management service returns properties for all deployments of the service, as well as for the service itself.
Gets
Deletes the specified hosted service from Windows Azure. service_name: Name of the hosted service. disk_name: Name of the data disk.
Uploads a new service package and creates a new deployment on staging or production. service_name: Name of the hosted service. deployment_slot: The environment to which the hosted service is deployed. Valid values are: staging, production name: The name for the deployment. The deployment name must be unique among other deployments for the hosted service. package_url: A URL that refers to the location of the service package in the Blob service. The service package can be located either in a storage account beneath the same subscription or a Shared Access Signature (SAS) URI from any storage account. label: A name for the hosted service. The name can be up to 100 characters in length. It is recommended that the label be unique within the subscription. The name can be used to identify the hosted service for your tracking purposes. configuration: The base-64 encoded service configuration file for the deployment. start_deployment: Indicates whether to start the deployment immediately after it is created. If false, the service model is still deployed to the virtual machines but the code is not run immediately. Instead, the service is Suspended until you call Update Deployment Status and set the status to Running, at which time the service will be started. A deployed service still incurs charges, even if it is suspended. treat_warnings_as_error: Indicates whether to treat package validation warnings as errors. If set to true, the Created Deployment operation fails if there are validation warnings on the service package. extended_properties: Dictionary containing name/value pairs of storage account properties. You can have a maximum of 50 extended property name/value pairs. The maximum length of the Name element is 64 characters, only alphanumeric characters and underscores are valid in the Name, and the name must start with a letter. The value has a maximum length of 255 characters.
Gets the specified deployment media. service_name: Name of the hosted service. deployment_name: The
Update the ServiceInstance :param unicode friendly_name: A string to describe the resource :param unicode attributes: An optional string metadata field you can use to store any data you wish. :param datetime date_created: The ISO 8601 date and time in GMT when the resource was created :param datetime date_updated: The
Build an instance of InviteInstance :param dict payload: Payload response from the API :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
Initiates a change in deployment status. service_sid: A 34 character string that uniquely identifies this resource. deployment_sid: A 34 character string that uniquely identifies this resource. status: The change to initiate to the deployment status. Possible values include: Running, Suspended
Initiates an upgrade. service_name: Name of the hosted service. deployment_name: The name of the deployment. mode: If set to Manual, WalkUpgradeDomain must be called to apply the update. If set to Auto, the Windows Azure platform will automatically apply the update To each upgrade domain for the service. Possible values are: Auto, Manual package_url: A URL that refers to the location of the service package in the Blob service. The service package can be located either in a storage account beneath the same subscription or a Shared Access Signature (SAS) URI from any storage account. configuration: The base-64 encoded service configuration file for the deployment. label: A name for the hosted service. The name can be up to 100 characters in length. It is recommended that the label be unique within the subscription. The name can be used to identify the hosted service for your tracking purposes. force: Specifies whether the rollback should proceed even when it will cause local data to be lost from some role instances. True if the rollback should proceed; otherwise false if the rollback should fail. role_to_upgrade: The name of the specific role to upgrade. extended_properties: Dictionary containing name/value pairs of storage account properties. You can have a maximum of 50 extended property name/value pairs. The maximum length of the Name element is 64 characters, only alphanumeric characters and underscores are valid in the Name, and the name must start with a letter. The value has a maximum length of 255 characters.
Waits for the deployment to complete. service_name: Name of the hosted service. deployment_name: The name of the deployment.
Get the path to a deployment. :param str service_name: Name of the hosted service. :param Deployment deployment: The deployment. :returns: The path to the deployment. :rtype: str
Gets the status of role instances. service_name: Name of the hosted service. deployment_name: The name of the deployment. role_instance_names: List of role instance names.
Checks to see if the specified hosted service name is available, or if it has already been taken. service_name: Name of the hosted service.
Lists all of the users associated with the account. :param identity: The identity of the User
Returns the user with the given sid. service_name: Name of the service to read the user from. sid: A string that uniquely identifies this user.
Gets a certificate from a hosted service. service_name: Name of the hosted service. certificate_sid: The SID of the certificate to fetch.
Deletes a user from the service. service_name: Name of the service to delete the user from. sid: A 34 character string that uniquely identifies this resource.
Retrieve a specific page of InviteInstance records from the API. Request is executed immediately :param str target_url: API-generated URL for the requested results page :returns: Page of InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage
The
Deletes a User Channel from the Service. :param sid: The sid :param channel_sid: The channel_sid :returns: True if delete succeeds, False otherwise :rtype: bool Code
Returns a list of all messages in the channel. channel_sid: The SID of the Channel resource to fetch.
Creates a new affinity group for the specified subscription. name: A name for the affinity group that is unique to the subscription. label: A name for the affinity group. The name can be up to 100 characters in length. location: The data center location where the affinity group will be created. To list available locations, use the list_location function.
Deletes a user from the specified channel. :param str user_sid: The SID of the User resource to delete :param str channel_sid: The SID of the Channel resource to delete :returns: True if delete succeeds, False otherwise :rtype: bool
List a list of all channels for a user. :param unicode identity: The identity of the User to read :param int limit: Upper limit for the number of records to return. list() guarantees never to return more than limit. Default is no limit :param int page_size: Number of records to fetch per request, when not set will use the default value of 50 records. If no page_size is defined but a limit is defined, list() will attempt to read the limit with the most efficient page size, i.e. min(limit, 1000) :returns: Generator that will yield up to limit results :rtype: list[
Lists reserved IP addresses for the account
Deletes a User Message from the Service. :param sid: The SID of the User Message resource to delete :returns: True if delete succeeds, False
Deletes the InviteInstance :returns: True if delete succeeds, False otherwise :rtype: bool
Get the path for reserved
Constructs a UserChannelContext :param sid: The sid :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
Retrieves the specified virtual machine. sid: The SID of the role. '''
Provisions a virtual machine based on the supplied configuration. :param str service_name: Name of the hosted service. :param str deployment_name: The name for the deployment. The deployment name must be unique among other deployments for the hosted service. :param str deployment_slot: The environment to which the hosted service is deployed. Valid values are: staging, production :param str label: Specifies an identifier for the deployment. The label can be up to 100 characters long. The label can be used for tracking purposes. :param str role_name: The name of the role. :param system_config: Contains the metadata required to provision a virtual machine from a Windows or Linux OS image. Use an instance of WindowsConfigurationSet or LinuxConfigurationSet. :param os_virtual_hard_disk: Contains the parameters Windows Azure uses to create the operating system disk for the virtual machine. If you are creating a Virtual Machine by using a VM Image, this parameter is not used. :param network_config: Encapsulates the metadata required to create the virtual network configuration for a virtual machine. If you do not include a network configuration set you will not be able to access the VM through VIPs over the internet. If your virtual machine belongs to a virtual network you can not specify which subnet address space it resides under. Use an instance of ConfigurationSet. :param availability_set_name: Specifies the name of an availability set to which to add the virtual machine. This value controls the virtual machine allocation in the Windows Azure environment. Virtual machines specified in the same availability set are allocated to different nodes to maximize availability. :param data_virtual_hard_disks: Contains the parameters Windows Azure uses to create a data disk for a virtual machine. :param role_size: The size of the virtual machine to allocate. The default value is Small. Possible values are: ExtraSmall,Small,Medium,Large, ExtraLarge,A5,A6,A7,A8,A9,Basic_A0,Basic_A1,Basic_A2,Basic_A3, Basic_A4,Standard_D1,Standard_D2,Standard_D3,Standard_D4, Standard_D11,Standard_D12,
Adds a virtual machine to an existing deployment. service_name: The name of the service. deployment_name: The name of the deployment. role_name: The name of the role. system_config: Contains the metadata required to provision a virtual machine from a Windows or Linux OS image. Use an instance of WindowsConfigurationSet or LinuxConfigurationSet. os_virtual_hard_disk: Contains the parameters Windows Azure uses to create the operating system disk for the virtual machine. If you are creating a Virtual Machine by using a VM Image, this parameter is not used. network_config: Encapsulates the metadata required to create the virtual network configuration for a virtual machine. If you do not include a network configuration set you will not be able to access the VM through VIPs over the internet. If your virtual machine belongs to a virtual network you can not specify which subnet address space it resides under. availability_set_name: Specifies the name of an availability set to which to add the virtual machine. This value controls the virtual machine allocation in the Windows Azure environment. Virtual machines specified in the same availability set are allocated to different nodes to maximize availability. data_virtual_hard_disks: Contains the parameters Windows Azure uses to create a data disk for a virtual machine. role_size: The size of the virtual machine to allocate. The default value is Small. Possible values are: ExtraSmall, Small, Medium, Large, ExtraLarge. The specified value must be compatible with the disk selected in the OSVirtualHardDisk values. role_type: The type of the role for the virtual machine. The only supported value is PersistentVMRole. resource_extension_references: Optional. Contains a collection of resource extensions that are to be installed on the Virtual Machine. This element is used if provision_guest_agent is set to True. provision_guest_agent: Optional. Indicates whether the VM Agent is installed on the Virtual Machine. To run a resource extension in a Virtual Machine, this service must be installed. vm_image_name: Optional. Specifies the name of the VM Image that is to be used to create the Virtual Machine. If this is specified, the system_config and network_config parameters are not used. media_location:
Updates the specified virtual machine. service_name: The name of the service. deployment_name: The name of the deployment. role_name: The name of the role. os_virtual_hard_disk: Contains the parameters Windows Azure uses to create the operating system disk for the virtual machine. network_config: Encapsulates the metadata required to create the virtual network configuration for a virtual machine. If you do not include a network configuration set you will not be able to access the VM through VIPs over the internet. If your virtual machine belongs to a virtual network you can not specify which subnet address space it resides under. availability_set_name: Specifies the name of an availability set to which to add the virtual machine. This value controls the virtual machine allocation in the Windows Azure environment. Virtual machines specified in the same availability set are allocated to different nodes to maximize availability. data_virtual_hard_disks: Contains the parameters Windows Azure uses to create a data disk for a virtual machine. role_size: The size of the virtual machine to allocate. The default value is Small. Possible values are: ExtraSmall, Small, Medium, Large, ExtraLarge. The specified value must be compatible with the disk selected in the OSVirtualHardDisk values. role_type: The type of the role for the virtual machine. The only supported value is PersistentVMRole. resource_extension_references: Optional. Contains a collection of resource extensions that are to be installed on the Virtual Machine. This element is used if provision_guest_agent is set to True. provision_guest_agent: Optional. Indicates whether the VM Agent is installed on the Virtual Machine. To run a resource extension in a Virtual Machine, this service must be installed. ''' _validate_not_none('service_name', service_name) _validate_not_none('deployment_name', deployment_name) _validate_not_none('role_name', role_name) return self._perform_put( self._get_role_path(service_name, deployment_name, role_name), _XmlSerializer.update_role_to_xml( role_name, os_virtual_hard_disk, role_type, network_
Gets the media content for the specified virtual machine. service_name: The name of the service. deployment_name: The name of the deployment. role_name: The name of the role.
Build an instance of UserInstance :param dict payload: Payload response from the API :returns: twilio.rest.chat.v2.service.user.UserInstance :rtype: twilio.rest.chat.v2.service.user.UserInstance
Stops the specified virtual machine. service_name: The name of the service. deployment_name: The name of the deployment. role_name: The name of the role. ''' _validate_not_none('service_name', service_name) _validate_not_none('deployment_name', deployment_name) _validate_not_none('role_name', role_name) return self._perform_post( self._get_role_instance_operations_path( service_name, deployment_name, role_name), _XmlSerializer.stop_role_operation_to_xml(), as_async=True)
Updates the specified virtual machines. service_name: The name of the service. deployment_name: The name of the deployment. role_names: The names of the roles, as an enumerable of strings.
Restarts the specified virtual machine. service_name: The name of the service. deployment_name: The name of the deployment. role_name: The name of the role. ''' _validate_not_none('service_name', service_name) _validate_not_none('deployment_name', deployment_name) _validate_not_none('role_name', role_name) return self._perform_post( self._get_role_instance_operations_path( service_name, deployment_name, role_name), _XmlSerializer.restart_role_operation_to_xml( ), as_async=True)
Update the ServiceInstance :param unicode friendly_name: A string to describe the resource :param unicode attributes: An optional string metadata
Shuts down the specified virtual machines. service_name: The name of the service. deployment_name: The name of the deployment. role_names: The names of the roles, as an enumerable of strings. post_shutdown_action: Specifies how the Virtual Machine should be shut down. Values are: Stopped Shuts down the Virtual Machine but retains the compute resources. You will continue to be billed for the resources that the stopped machine uses. StoppedDeallocated Shuts down the Virtual Machine and releases the compute resources. You are not billed for the compute resources that this Virtual Machine uses. If a static Virtual Network IP address is assigned to the Virtual Machine, it is reserved.
Adds a DNS server definition to an existing deployment. service_name: The name of the service. deployment_name: The name of the deployment. dns_server_name:
Updates the ip address of a DNS server. service_name: The name of the service. deployment_name: The name of the deployment. dns_server_name: Specifies the name of the DNS server. address: Specifies the IP address of the DNS server.
Deletes a service. service_name: The name of the service. ''' _validate_not_none('service_name', service_name) return self._perform_delete( self._get_service_path(service_name), as_async=True)
Lists UserInstance records from the API as a list. Unlike stream(), this operation is eager and will load `limit` records
Get the path to the replication operation using the vm_image_name
Build an instance of InviteInstance :param dict payload: Payload response from the API :returns: twilio.rest.chat.v2.service.
Get the path to share a VM image using the VM image ID. :param str vm_image_id: The
Creates a VM Image in the image repository that is associated with the specified subscription using a specified set of virtual hard disks. vm_image: An instance of VMImage class. vm_image.name: Required. Specifies the name of the image. vm_image.label: Required. Specifies an identifier for the image. vm_image.description: Optional. Specifies the description of the image. vm_image.os_disk_configuration: Required. Specifies configuration information for the operating system disk that is associated with the image. vm_image.os_disk_configuration.host_caching: Optional. Specifies the caching behavior of the operating system disk. Possible values are: None, ReadOnly, ReadWrite vm_image.os_disk_configuration.os_state: Required. Specifies the state of the operating system in the image. Possible values are: Generalized, Specialized A Virtual Machine that is fully configured and running contains a Specialized operating system. A Virtual Machine on which the Sysprep command has been run with the generalize option contains a Generalized operating system. vm_image.os_disk_configuration.os: Required. Specifies the operating system type of the image. vm_image.os_disk_configuration.media_link: Required. Specifies the location of the blob in Windows Azure storage. The blob location belongs to a storage account in the subscription specified by the <subscription-id> value in the operation call. vm_image.data_disk_configurations: Optional. Specifies configuration information for the data disks that are associated with the image. A VM Image might not have data disks associated with it. vm_image.data_disk_configurations[].host_caching: Optional. Specifies the caching behavior of the data disk. Possible values are: None, ReadOnly, ReadWrite vm_image.data_disk_configurations[].lun: Optional if the lun for the disk is 0. Specifies the Logical Unit Number (LUN) for the data disk. vm_image.data_disk_configurations[].media_link: Required. Specifies the location of the blob in Windows Azure storage. The blob location belongs to a storage account in the subscription specified by the <subscription-id> value in the operation call. vm_image.data_disk_configurations[].logical_
Gets a list of all the VM Images in the image repository that is associated with the specified subscription. location: The location of the resource. publisher_name: A valid image publisher. offer: A valid image publisher offer.
Retrieves a list of the VM Images from the image repository that is associated with the specified subscription. :param str location: The location of the VM Image. :param str publisher: The publisher of the VM
Updates a VM Image in the image repository that is associated with the specified subscription. vm_image_name: Name of image to update. vm_image: An instance of VMImage class. vm_image.label: Optional. Specifies an identifier for the image. vm_image.os_disk_configuration: Required. Specifies configuration information for the operating system disk that is associated with the image. vm_image.os_disk_configuration.host_caching: Optional. Specifies the caching behavior of the operating system disk. Possible values are: None, ReadOnly, ReadWrite vm_image.data_disk_configurations: Optional. Specifies configuration information for the data disks that are associated with the image. A VM Image might not have data disks associated with it. vm_image.data_disk_configurations[].name: Required. Specifies the name of the data disk. vm_image.data_disk_configurations[].host_caching: Optional. Specifies the caching behavior of the data disk. Possible values are: None, ReadOnly, ReadWrite vm_image.data_disk_configurations[].lun: Optional if the lun for the disk is 0. Specifies the Logical Unit Number (LUN) for the data disk. vm_image.description: Optional. Specifies the description of the image. vm_image.language: Optional. Specifies the language of the image. vm_image.image_family: Optional. Specifies a value that can be used to group VM Images. vm_image.recommended_vm_size: Optional. Specifies the size to use for the Virtual Machine that is created from the VM Image. vm_image.eula: Optional. Specifies the End User License Agreement that is associated with the image. The value for this element is a string, but it is recommended that the value be a URL that points to a EULA. vm_image.icon_uri: Optional. Specifies the URI to the icon that is displayed for the image in the Management Portal. vm_image.small_icon_uri: Optional. Specifies the URI to the small icon that is displayed for the image in the Management Portal. vm_image.privacy_uri: Optional. Specifies the URI that points to a document that contains the privacy policy related to the image. vm_image
Adds a new role to the service. friendly_name: A human readable description of this role. permissions: A list of permissions to be assigned to this role. ''' _validate_not_none('friendly_name', friendly_name) _validate_not_none('permissions', permissions) return self._perform_post(self._get_role_path(), _XmlSerializer.role_to_xml( friendly_name, permissions), as_async=True)
Updates an OS image that in your image repository. image_name: The name of the image to update. label: Specifies the friendly name of the image to be updated. You cannot use this operation to update images provided by the Windows Azure platform. media_link: Specifies the location of the blob in Windows Azure blob store where the media for the image is located. The blob location must belong to a storage account in the subscription specified by the <subscription-id> value in the operation call. Example: http://example.blob.core.windows.net/disks/mydisk.vhd name: Specifies a name for the OS image that Windows Azure uses to identify the image when creating one or more VM Roles. os: The operating system type of the OS image. Possible values are: Linux, Windows ''' _validate_not_none('image_name', image_name) _validate_
Updates metadata elements from a given OS image reference. image_name: The name of the image to update. os_image: An instance of OSImage class. os_image.label: Optional. Specifies an identifier for the image. os_image.description: Optional. Specifies the description of the image. os_image.language: Optional. Specifies the language of the image. os_image.image_family: Optional. Specifies a value that can be used to group VM Images. os_image.recommended_vm_size: Optional. Specifies the size to use for the Virtual Machine that is created from the VM Image. os_image.eula: Optional. Specifies the End User License Agreement that is associated with the image. The value for this element is a string, but it is recommended that the value be a URL that points to a EULA. os_image.icon_uri: Optional. Specifies the URI to the icon that is displayed for the image in the Management Portal. os_image.small_icon_uri: Optional. Specifies the URI to the small icon that is displayed for the image in the Management Portal. os_image.privacy_uri: Optional. Specifies the URI that points to a document that contains the privacy policy related to the image. os_image.published_date: Optional. Specifies the date when the image was added to the image repository. os.image.media_link: Required: Specifies the location of the blob in Windows Azure blob store where the media for the image is located. The blob location must belong to a storage account in the subscription specified by the <subscription-id> value in the operation call. Example: http://example.blob.core.windows.net/disks/mydisk.vhd os_image.name: Specifies a name for the OS image that Windows Azure uses to identify the image when creating one or more VM Roles. os_image.os: The operating system type of the OS image. Possible values are: Linux, Windows ''' _validate_not_none('image_name', image_name) _validate_not_none('os_image', os_image) return self._perform_put(self._get_image_path(image_name), _XmlSerializer
Deletes the specified OS image from your image repository. image_name: The name of the image. delete_vhd: Deletes the underlying vhd blob in Azure storage.
Build an instance of InviteInstance :param dict payload: Payload response from the API :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
Adds a data disk to a virtual machine. service_name: The name of the service. deployment_name: The name of the deployment. role_name: The name of the role. lun: Specifies the Logical Unit Number (LUN) for the disk. The LUN specifies the slot in which the data drive appears when mounted for usage by the virtual machine. Valid LUN values are 0 through 15. host_caching: Specifies the platform caching behavior of data disk blob for read/write efficiency. The default vault is ReadOnly. Possible values are: None, ReadOnly, ReadWrite media_link: Specifies the location of the blob in Windows Azure blob store where the media for the disk is located. The blob location must belong to the storage account in the subscription specified by the <subscription-id> value in the operation call. Example: http://example.blob.core.windows.net/disks/mydisk.vhd disk_label: Specifies the description of the data disk. When you attach a disk, either by directly referencing a media using the MediaLink element or specifying the target disk size, you can use the DiskLabel element to customize the name property of the target data disk. disk_name: Specifies the name of the disk. Windows Azure uses the specified disk to create the data disk for the machine and populates this field with the disk name. logical_disk_size_in_gb: Specifies the size, in GB, of an empty disk to be attached to the role. The disk can be created as part of disk attach or create VM role call by specifying the value for this property. Windows Azure creates the empty disk based on size preference and attaches the newly created disk to the Role. source_media_link: Specifies the location of a blob in account storage which is mounted as a data disk when the virtual machine is created.
Updates the specified data disk attached to the specified virtual machine. service_name: The name of the service. deployment_name: The name of the deployment. role_name: The name of the role. lun: Specifies the Logical Unit Number (LUN) for the disk. The LUN specifies the slot in which the data drive appears when mounted for usage by the virtual machine. Valid LUN values are 0 through 15. host_caching: Specifies the platform caching behavior of data disk blob for read/write efficiency. The default vault is ReadOnly. Possible values are: None, ReadOnly, ReadWrite media_link: Specifies the location of the blob in Windows Azure blob store where the media for the disk is located. The blob location must belong to the storage account in the subscription specified by the <subscription-id> value in the operation call. Example: http://example.blob.core.windows.net/disks/mydisk.vhd updated_lun: Specifies the Logical Unit Number (LUN) for the disk. The LUN specifies the slot in which the data drive appears when mounted for usage by the virtual machine. Valid LUN values are 0 through 15. disk_label: Specifies the description of the data disk. When you attach a disk, either by directly referencing a media using the MediaLink element or specifying the target disk size, you can use the DiskLabel element to customize the name property of the target data disk. disk_name: Specifies the name of the disk. Windows Azure uses the specified disk to create the data disk for the machine and populates this field with the disk name. logical_disk_size_in_gb: Specifies the size, in GB, of an empty disk to be attached to the role. The disk can be created as part of disk attach or create VM role call by specifying the value for this property. Windows Azure creates the empty disk based on size preference and attaches the newly created disk to the Role.
Gets the data disks from a virtual machine
Adds a disk to the user image repository. The disk can be an OS disk or a data disk. has_operating_system: Deprecated. label: Specifies the description of the disk. media_link: Specifies the location of the blob in Windows Azure blob store where the media for the disk is located. The blob location must belong to the storage account in the current subscription specified by the <subscription-id> value in the operation call. Example: http://example.blob.core.windows.net/disks/mydisk.vhd name: Specifies a name for the disk. Windows Azure uses the name to identify the disk when creating virtual machines from the disk. os: The OS type of the disk. Possible values are: Linux, Windows
Updates an existing instance in your image repository. disk_name: The name of the disk to update. label: Specifies the description of the disk. media_link: Deprecated. name: Deprecated.
Gets the specified data or operating system disk from your image repository. disk_name: The name of the disk to get.

""" Build the receiver link :returns: The receiver link :rtype: proton.Receiver """ self._receiver = self._session.receiver(self._name) self._receiver.source.address = self._address self._receiver.source.durable = self._durable self._receiver.source.dynamic = self._dynamic self._receiver.source.filter = self._filter self._receiver.source.rollover_policy = self._rollover_policy self._receiver.source.timeout = self._timeout self._receiver.source.capabilities = self._capabilities self._receiver.source.capabilities.set(self._capabilities) self._receiver.source.capabilities.set(self._capabilities) self._receiver.source.capabilities.set(self._capabilities) self._receiver.source.capabilities.set(self._capabilities) self._receiver.source.capabilities.set(self._capabilities) self._receiver.source.capabilities.set(self._capabilities) self._receiver.source.capabilities.set(self._
Fetch a single page of InviteInstance records from the API. Request is executed immediately :param int max_batch_size: Upper limit for the number of records to return. stream() guarantees to never return more than max_batch_size. Default is no limit :param int timeout: How long, in seconds, to wait for the response. Default is 15 seconds. :returns: Page of InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage """ self._can_run() wrapped_batch = [] max_batch_size = max_batch_size or self._handler._prefetch # pylint: disable=protected-access try: timeout_ms = 1000 * timeout if timeout else 0 batch = self._handler.receive_message_batch( max_batch_size=max_batch_size, timeout=timeout_ms) for received in batch: message = self._build_message(received) wrapped_batch.append(message) except Exception as
Send a packet to the server. :param twilio.rest.chat.v2.service.channel.invite.packet.Packet packet: The packet to send
Create or update a VM scale set. :param str resource_group_name: The name of the resource group. :param str vm_scale_set_name: The name of the VM scale set where the extension should be create or updated. :param VirtualMachineScaleSet parameters: Parameters supplied to the Create Virtual Machine Scale Set operation. :param dict custom_headers: headers that will be added to the request :param bool raw: returns the direct response alongside the deserialized response :param polling: True for ARMPolling, False for no polling, or a polling object for personal polling strategy :return: An instance of LROPoller that returns VirtualMachineScaleSet or ClientRawResponse<VirtualMachineScaleSet> if raw=true :rtype: ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.compute.v2017_03_30.models.VirtualMachineScaleSet] or ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.compute.v2017_03_30.models.VirtualMachineScaleSet]] :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>` """
Build an instance of InviteInstance :param dict payload:






""" Initialize the ServiceContext :param str service_namespace: The namespace of the Service to fetch :param str shared_access_key_name: The name of the Shared Access Policy to use when authenticating :param str shared_access_key_value: The value of the Shared Access Policy to use when authenticating :param str host_base: The base host for the Service :param loop: A loop to use for running the IOLoop in. If none is specified, a new event loop will be created. :param kwargs: Any additional keyword arguments :returns: twilio.rest.chat.v2.service.ServiceContext :rtype: twilio.rest.chat.v2.service.ServiceContext """ self._version = Version('v2') self._solution = { 'service_namespace': service_namespace, 'shared_access_key_name': shared_access_key_name, 'shared_access_key_value': shared_access_key_value, 'host_base': host_base, } self._uri = '/Services/{service_namespace}/Users/{shared_access_key_name}/{shared_access_key_value}'.format(**self._solution) self._channel_list = None self._channel_page = None self._user_list = None self._user_page = None self._role_list = None self._role_page = None self._binding_list = None self._binding_page = None self._invite_list = None self._invite_page = None self._webhook_list = None self._webhook_page = None self._credential_list = None self._credential_page = None self._style_list = None self._style_page = None self._style_sheet_list = None self._style_sheet_page = None self._user_binding_list = None self._user_binding_page = None self._user_channel_invitation_list = None self._user_channel_invitation_page = None self._user_channel_


Provide a friendly representation :returns: Machine friendly representation :rtype: str
Provide a friendly representation :returns: Machine friendly representation :rtype: str Code
:param twilio.rest.chat.v2.service.channel.channel_channel_sender.ChannelChannelSender session: The session to use for this sender. :param kwargs: Additional keyword arguments to pass to the sender. :returns: twilio.rest.chat.v2.service.channel.channel_channel_sender.ChannelChannelSender :rtype: twilio.rest.chat.v2.service.channel.channel_channel_sender.ChannelChannelSender

Provide a friendly representation :returns: Machine friendly representation :rtype: str
Updates the request URI and query string with the query parameters. request: The HTTPRequest object to update
Returns the request body as a string. body: The body to convert to a string.
Get the status of an asynchronous operation. :param str request_id: The request ID for the request you wish to track. :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance.OperationStatus :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance.OperationStatus
Retrieve a specific page of InviteInstance records from the API. Request is executed immediately :param Page page: Page of InviteInstance :param dict kwargs: Additional request parameters :returns: Page of InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage
Add additional headers for management. :param request: The request to be updated :param x_ms_version: The x_ms_version to be used :


Get list of available webhooks. :returns: List of available webhooks :rtype: list[twilio.rest.chat.v2.service.channel.invite.WebhookInstance]
Remove a role from the service. :param
Generate an absolute Twilio REST API path for this resource. :param sid: The sid :returns: str :rtype: str
Create a new Notification. :param unicode identity: The identity of the user to whom the Notification should be sent. :param unicode notification_level: The level of the Notification. :param unicode topic: The topic of the Notification. :param unicode endpoint: The endpoint of the Notification. :param unicode binding_type: The type of the Notification's endpoint. :param unicode binding_resource: The resource of the Notification's endpoint. :param unicode body: The body of the Notification. :param unicode attributes: The attributes of the Notification. :returns: The created NotificationInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
Delete a credential from the Service.
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Retrieves the rules in the service namespace. name: Name of the service bus namespace. subscription_name: Name of the subscription. :returns: A list of RuleDescription objects :rtype: list[~azure.servicebus.common.RuleDescription]
Retrieve a list of all Users for a Service Instance :param service_sid: The service_sid :returns: A list of User instances :rtype: list[twilio.rest.chat.v2.service.user.UserInstance]
Retrieves the topics in the service namespace. :returns: A list of TopicDescription objects :rtype: list[~azure.servicebus.
This operation gets rollup data for Service Bus metrics namespace. Rollup data
This operation gets rollup data for Service Bus metrics topic. Rollup data includes the time granularity for the telemetry aggregation as well as the retention settings for each time granularity. name: Name of the service bus namespace. topic_name: Name of the service bus queue in this namespace. metric: name of a supported metric start_time: Start time of the time range for which the data is to be fetched. end_time: End time of the time range for which the data is to be fetched.
This operation gets rollup data
This operation gets rollup data for Service Bus metrics topic. Rollup data includes the time granularity for the telemetry aggregation as well as the retention settings for
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': payload.get('sid'), 'account_sid': payload.get('account_sid'), 'service_sid': payload.get('service_sid'), 'channel_sid': payload.get('channel_sid'), 'created_by': payload.get('created_by'), 'created_by_identity': payload.get('created_by_identity'), 'role_sid': payload.get('role_sid'), 'date_created': deserialize.iso8601_datetime(payload.get('date_created')), 'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')), 'url': payload.get('url'), } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': payload.get('sid'), } @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property def service_sid(self): """ :returns: The SID of the Service that the resource is associated with :rtype: unicode """ return self._properties['service_sid'] @property def channel_sid(self): """ :returns: The SID of the Channel the resource belongs to :rtype: unicode """ return self._properties['channel_sid'] @property def created_by(self): """ :returns: The identity of the User that created the resource :rtype: unicode """ return
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def date_created(self): """ :returns: The ISO 8601 date and time in GMT when the resource was created :rtype: datetime """ return self._properties['date_created'] @property def date_updated(self): """ :returns: The ISO 8601
Create a new Azure SQL Database. server_name: The name of the server to create the database in. database_name: The name of the database to create. edition: The edition of the database to create. service_objective: The service objective of the database to create. collation: The collation of the database to create. location: The region to deploy the new database. :returns: A CreateDatabaseResponse object :rtype: twilio.rest.sql_management.v0.create_database_response.CreateDatabaseResponse '''
Reset the administrator password for a server. server_name: Name of the server to change the password. admin_password: The new administrator password for the server.
Lists all Users for a Service Instance :param service_sid: The SID of the Service to read the Users
Gets the event logs for an Azure SQL Database Server. server_name: Name of the server to retrieve the event logs from. start_date: The starting date and time of the events to retrieve in UTC format, for example '2011-09-28 16:05:00'. interval_size_in_minutes: Size of the event logs to retrieve (in minutes). Valid values are: 5, 60, or 1440. event_types: The event type of the log entries you want to retrieve. Valid values are: - connection_successful - connection_failed - connection_terminated - deadlock - throttling - throttling
Creates an Azure SQL Database server firewall rule. server_name: Name of the server to set the firewall rule on. name: The name of the new firewall rule. start_ip_address: The lowest IP address in the range of the server-level firewall setting. IP addresses equal to or greater than this can attempt to connect to the server. The lowest possible IP address is 0.0.0.0. end_ip_address: The highest IP address in the range of the server-level firewall setting. IP addresses equal to or less than this can attempt to connect to the server. The highest possible IP address is 255.255.255.255. ''' _validate_not_none('server_name', server_name) _validate_not_none('name', name) _validate_not_none('start_ip_address', start_ip_address) _validate_not_none('end_ip_address
Update a firewall rule for an Azure SQL Database server. server_name: Name of the server to set the firewall rule on. name: The name of the firewall rule to update. start_ip_address: The lowest IP address in the range of the server-level firewall setting. IP addresses equal to or greater than this can attempt to connect to the server. The lowest possible IP address is 0.0.0.0. end_ip_address: The highest IP address in the range of the server-level firewall setting. IP addresses equal to or less than this can attempt to connect to the server. The highest possible IP address is 255.255.255.255. ''' _validate_not_none('server_name', server_name) _validate_not_none('name', name) _validate_not_none('start_ip_address', start_ip_address) _validate_not
Deletes a Channel from the Service :param unicode service_sid: The SID of the Service to delete the resource from :param unicode sid: The SID of the Channel resource to delete :returns: True if delete succeeds, False otherwise :rtype: bool
Lists InviteInstance records from the API as a list. Unlike stream(), this operation is eager and will load `limit` records into memory before returning. :param int limit: Upper limit for the number of records to return. list() guarantees never to return more than limit. Default is no limit :param int page_size: Number of records to fetch per request, when not set will use the default value of 50 records. If no page_size is defined but a limit is defined, list() will attempt to read the limit with the most efficient page size, i.e. min(limit, 1000) :returns: Generator that will yield up to limit results :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]
Gets the usages for an Azure SQL Database server. server_name: Name of the server. :returns: A list of
Gets a database from the Azure SQL Database. server_name: Name of the server containing the database. name: Name of the database to get.
Updates existing database user details. server_name: Name of the server to contain the new database. name: Required. The name for the new database. See Naming Requirements in Azure SQL Database General Guidelines and Limitations and Database Identifiers for more information. user_name: Required. The name for the new database user. password: Optional.
Deletes a database user role. server_name: Name of the server where the database is located. name: Name of the database to delete. user_name: Name of the database user to delete. role_name: Name of the database user role to delete.
Lists InviteInstance records from the API as a list. Unlike stream(), this operation is eager and will load `limit` records into memory before returning. :param int limit: Upper limit for the number of records to return. list() guarantees never to return more than limit. Default is no limit :param int page_size: Number of records to fetch per request, when not set will use the default value of 50 records. If no page_size is defined but a limit is defined, list() will attempt to read the limit with the most efficient page size, i.e. min(limit, 1000) :returns: Generator that will yield up to limit results :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]
""" Retrieve a list of all Invites belonging to the Channel specified by the `channel_sid` parameter. :param int limit: Upper limit for the number of records to return. list() guarantees never to return more than limit. Default is no limit :param int page_size: Number of records to fetch per request, when not set will use the default value of 50 records. If no page_size is defined but a limit is defined, list() will attempt to read the limit with the most efficient page size, i.e. min(limit, 1000) :param str page_token: PageToken provided by the API :param str channel_sid: The SID of the Channel the resource to fetch belongs to :param str identity: The `identity` value that identifies the new resource's parent :param str role_sid: The SID of the Role assigned to the new resource :param datetime date_created_after: The `date_created` value of the resources to return :param datetime date_created_before: The `date_created` value of the resources to return :param datetime date_updated_after: The `date_updated` value of the resources to return :param datetime date_updated_before: The `date_updated` value of the resources to return :param str order_by: The order in which to list the resources :param bool alpha_sender: The `alpha_sender` value of the resources to return :param bool beta_sender: The `beta_sender` value of the resources to return :param bool
Receive a packet from the Service Bus. :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
Receive messages from the websocket. :returns: Message instance :rtype: twilio.rest.chat.v2.service.channel.message.MessageInstance



Merge a reservation order into a new reservation. :param reservation_order_id: The reservation order ID is the identifier for a reservation order. The reservation order ID is created by the reservation service when an order is created. The reservation order specifies the VM size and region for the new reservation. :type reservation_order_id: str :param sources: The list of resource IDs that need to be reserved. :type sources: list[str] :param dict custom_headers: headers that will be added to the request :param bool raw: returns the direct response alongside the deserialized response :param polling: True for ARMPolling, False for no polling, or a polling object for personal polling strategy :return: An instance of LROPoller that returns list[~azure.mgmt.reservations.models.ReservationResponse] or ClientRawResponse if raw=true :rtype: ~msrestazure.azure_operation.AzureOperationPoller[ list[~azure.mgmt.reservations.models.ReservationResponse]] or ~msrest.pipeline.ClientRawResponse :raises: :class:`ErrorResponseException<azure.mgmt.reservations.models.ErrorResponseException>` """
Retrieve a specific page of InviteInstance records from the API. Request is executed immediately :param str target_url: API-generated URL for the requested results page :returns: Page

Constructs a InviteContext :param sid: A 34 character string that uniquely identifies this resource. :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext
Gets a queue. queue_name: Name of the queue to get.
Get the host for the service bus namespace with SAS token and path. :param str path: The path to append to the host. :returns: The host for the service bus namespace with SAS token and path. :rtype: str
Retrieves a list of queues. limit: Upper limit for the number of records to return. list() guarantees never to return more than limit. Default is no limit page_size: Number of records to fetch per request, when not set will use the default value of 50 records. If no page_size is defined but a limit is defined, list() will attempt to read the limit with the most efficient page size, i.e. min(limit, 1000) Returns: Generator that will yield up to limit results ''' return self.iter_queues(limit=limit, page_size=page_size)
Gets a topic. topic_name: Name of the topic to get.
Retrieve a list of all Users. :returns: List of UserInstance :rtype: list[twilio.rest.chat.v2.service.channel.user.UserInstance]
Deletes a rule. topic_name: Name of the topic. subscription_name: Name of the subscription. rule_name: Name of the rule.
Retrieves the description for the specified rule. topic_name: Name of the topic. subscription_name: Name of the subscription. rule_name
Retrieves the subscriptions that exist under the specified topic. topic_name: Name of the topic. ''' _validate_not_none('topic_name', topic_name) request = HTTPRequest() request.method = 'GET' request.host = self._get_host() request.path = '/' + _str(topic_name) + '/subscriptions/' request.path, request.query = self._httpclient._update_request_uri
Gets a subscription. topic_name: Name of the topic.
Gets an existing subscription. topic_name: Name of the topic. subscription_name: Name of the subscription. ''' _validate_not_none('topic_name', topic_name) _validate_not_none('subscription_name', subscription_name) request = HTTPRequest() request.method = 'GET' request.host = self._get_host() request.path = '/' + \ _str(topic_name) + '/subscriptions/' + _str(subscription_name) + '' request.path, request
Retrieves the subscriptions in the specified topic. topic_name: Name of the topic. :returns: A list of SubscriptionInstance objects :rtype: list[twilio.rest.chat.v2.service.channel.subscription.SubscriptionInstance]
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Unlock a message for processing by other receivers on a given subscription. This operation deletes the lock object, causing the message to be unlocked. A message must have first been locked by a receiver before this operation is called. topic_name: Name of the topic. subscription_name: Name of the subscription. sequence_number: The sequence number of the message to be unlocked as returned in BrokerProperties['SequenceNumber'] by the Peek Message operation. lock_token: The ID of the lock as returned by the Peek Message operation in BrokerProperties['LockToken']
Sends a batch of messages into the specified queue. The limit to the number of messages which may be present in the topic is governed by the message size the MaxTopicSizeInMegaBytes. If this message will cause the queue to exceed its quota, a quota exceeded error is returned and the message will be rejected. queue_name: Name of the queue. messages: List of message objects containing message body and properties.
Unlocks a message for processing by other receivers on a given queue. This operation deletes the lock object, causing the message to be unlocked. A message must have first been locked by a receiver before this operation is called. queue_name: Name of the queue. sequence_number: The sequence number of the message to be unlocked as returned in BrokerProperties['SequenceNumber'] by the Peek Message operation. lock_token: The ID of the lock as returned by the Peek Message operation in BrokerProperties['LockToken']
Send a message to a queue. queue_name: Name of the queue. message: Message to send. visibility_timeout: Optional. The visibility timeout parameter
Read and delete a message from a subscription. topic_name: Name of the topic. subscription_name: Name of the subscription. timeout: Optional. The timeout parameter is expressed in seconds.
Gets an Event Hub. hub_name: Name of event hub.
Updates the Notification Level for a Channel. notification_level: Notification Level for a Channel. notification: Optional. Notification properties. Instance of Notification class. notification.log_enabled: Whether to log notifications. notification.log_level: Log level. notification.webhook_enabled: Whether to send a webhook event for each notification. notification.webhook_url: The URL of the target webhook.
Retrieves an existing notification. sid: A 34 character string that uniquely identifies this resource. ''' _validate_not_none('sid', sid) request = HTTPRequest
Makes a request and returns a list of results, if any.
Add additional headers for Service Bus. :param request: The request to be signed. :returns: The request with the authorization header added. :rtype: requests.Request
return the token expires at as rfc2822. :returns: The token expires at as rfc2822. :rtype: unicode ''' return self._token_expires_at.strftime('%a, %d %b %Y %H:%M:%S GMT')
Check if token is valid for channel or not. :param str token: Token to check :param str channel_sid: Channel SID to check :returns: True if token is valid for channel, False otherwise :rtype: bool
Handle an error from the server. :param packet: Packet to handle :type packet: Packet
pulls the query string out of the URI and moves it into the query portion of the request object. If there are already query parameters on the request the parameters in the URI will appear after the existing parameters

Returns true if both instances are not equal :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Returns true if both instances are equal :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance





Build an instance of Invite
:param str resource_group_name: Name of the resource group. :param str name: Name of the app. :param int duration_in_seconds: The duration to keep capturing in seconds. :param int max_frame_length: The maximum frame length in bytes (Optional). :param str sas_url: The Blob URL to store capture file. :param dict custom_headers: headers that will be added to the request :param bool raw: returns the direct response alongside the deserialized response :param polling: True for ARMPolling, False for no polling, or a polling object for personal polling strategy :return: An instance of LROPoller that returns list of NetworkTrace or ClientRawResponse if raw=true :rtype: ~msrestazure.azure_operation.AzureOperationPoller[list[~azure.mgmt.web.v2016_03_01.models.NetworkTrace]] or ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse] :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>` """





:param str resource_group_name: Name of the resource group within the Azure subscription. :param str namespace_name: The Namespace name :param str target_namespace: The Namespace name :param str post_migration_name: The Post Migration name :param dict custom_headers: headers that will be added to the request :param bool raw: returns the direct response alongside the deserialized response :param polling: True for ARMPolling, False for no polling, or a polling object for personal polling strategy :return: An instance of LROPoller that returns MigrationConfigProperties or ClientRawResponse if raw=true :rtype: ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.eventhub.v2017_04_01.models.MigrationConfigProperties] or ~msrest.pipeline.ClientRawResponse :raises: :class:`ErrorResponseException<azure.mgmt.eventhub.v2017_04_01.models.ErrorResponseException>` """
Lists Invite resources from the Channel :param str service_sid: The SID of the Service to read the resources from :param str channel_sid: The SID of the Channel the resource to read :param int limit: Upper limit for the number of records to return. list() guarantees never to return more than limit. Default is no limit :param int page_size: Number of records to fetch per request, when not set will use the default value of 50 records. If no page_size is defined but a limit is defined, list() will attempt to read the limit with the most efficient page size, i.e. min(limit, 1000) :returns: Generator that will yield up to limit results :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]

Iterate over list of Invites and return a generator yielding one Invite instance each :returns: Generator that will yield up to limit results :rtype: list[twilio.rest.chat.v2.service



Code


""" Initialize the ServiceContext :param str address: The address of the Service to fetch :param str name: The unique string that identifies the resource :param str shared_access_key_name: The name of the Shared Access Policy :param str shared_access_key_value: The value of the Shared Access Policy key :param unicode x_twilio_webhook_enabled: The X-Twilio-Webhook-Enabled HTTP request header :returns: twilio.rest.chat.v2.service.ServiceContext :rtype: twilio.rest.chat.v2.service.ServiceContext """ super(ServiceContext, self).__init__(**kwargs) # Path Solution self._solution = {'address': address, 'name': name, } self._uri = '/Services/{address}/Channels/{name}'.format(**self._solution) # Dependents self._channels = None self._users = None self._bindings = None self._roles = None self._invites = None self._webhooks = None # Context self._context = None self._solution = {'address': address, 'name': name, } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: ServiceContext for this ServiceInstance :rtype: twilio.rest.chat.v2.service.ServiceContext """ if self._context is None: self._context = ServiceContext( self._version, address=self._solution['address'], name=self._solution['name'], ) return self._context @property def channels(self): """ Access the channels :returns: twilio.rest.chat.v2.service.channel.channel.ChannelList :rtype: twilio.rest.chat.v2.service.channel.channel.ChannelList """ if self._channels is None: self._channels = ChannelList( self._version, service_sid=self._solution['address'], channel_sid=self._solution['name'],
Get the runtime information for the user. :returns: The runtime
Returns true if both instances are not equal, false otherwise :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance

raw_result = self._create_subscription_initial( billing_account_name=billing_account_name, invoice_section_name=invoice_section_name, body=body, custom_headers=custom_headers, raw=True, **operation_config ) def get_long_running_output(response): header_dict = { 'Location':'str', 'Retry-After': 'int', } deserialized = self._deserialize('SubscriptionCreationResult', response) if raw: client_raw_response = ClientRawResponse(deserialized, response) client_raw_response.add_headers(header_dict) return client_raw_response return deserialized lro_delay = operation_config.get( 'long_running_operation_timeout', self.config.long_running_operation_timeout) if polling is True: polling_method = ARMPolling(lro_delay, **operation_config) elif polling is False: polling_method = NoPolling() else: polling_method = polling

Code
In case of a chunk exceeding the MaxMessageSize split chunk in half and resubmit smaller chunk requests :param BatchErrorException e: BatchErrorException :param Queue results_queue: Queue :param list chunk_tasks_to_add: list
Add a list of tasks to the queue. :param Queue results_queue: Queue to put results in :param list tasks_to_add: List of tasks to add :returns: True if all tasks were added, False otherwise :rtype: bool
Get the package name prefix for the given service and channel. :param


Create message from response. :param response: response from Service Bus cloud server. :param service_instance: the Service Bus client. :returns: twilio.rest.chat.v2.service.channel.message.Message :rtype: twilio.rest.chat.v2.service.channel.message.Message
Converts entry element to rule object. The format of xml for rule: <entry xmlns='http://www.w3.org/2005/Atom'> <content type='application/xml'> <RuleDescription xmlns:i="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://schemas.microsoft.com/netservices/2010/10/servicebus/connect"> <Filter i:type="SqlFilterExpression"> <SqlExpression>MyProperty='XYZ'</SqlExpression> </Filter> <Action i:type="SqlFilterAction"> <SqlExpression>set MyProperty2 = 'ABC'</SqlExpression> </Action> </RuleDescription> </content> </entry>
Converts entry element to queue object. The format of xml response for queue: <QueueDescription xmlns=\"http://schemas.microsoft.com/netservices/2010/10/servicebus/connect\"> <MaxSizeInBytes>10000</MaxSizeInBytes> <DefaultMessageTimeToLive>PT5M</DefaultMessageTimeToLive> <LockDuration>PT2M</LockDuration> <RequiresGroupedReceives>False</RequiresGroupedReceives> <SupportsDuplicateDetection>False</SupportsDuplicateDetection> ... </QueueDescription> :param entry_element: Entry element of queue :type entry_element: lxml.etree._Element :rtype: Queue :returns: Queue object :raises: AzureServiceBusResourceNotFound
Converts entry element to topic The xml format for topic: <entry xmlns='http://www.w3.org/2005/Atom'> <content type='application/xml'> <TopicDescription xmlns:i="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://schemas.microsoft.com/netservices/2010/10/servicebus/connect"> <DefaultMessageTimeToLive>P10675199DT2H48M5.4775807S</DefaultMessageTimeToLive> <MaxSizeInMegabytes>1024</MaxSizeInMegabytes> <RequiresDuplicateDetection>false</RequiresDuplicateDetection> <DuplicateDetectionHistoryTimeWindow>P7D</DuplicateDetectionHistoryTimeWindow> <DeadLetteringOnFilterEvaluationExceptions>true</DeadLetteringOnFilterEvaluationExceptions> </TopicDescription> </content> </entry>
Converts entry element to subscription The xml format for subscription: <entry xmlns='http://www.w3.org/2005/Atom'> <content type='application/xml'> <SubscriptionDescription xmlns:i="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://schemas.microsoft.com/netservices/2010/10/servicebus/connect"> <LockDuration>PT5M</LockDuration> <RequiresSession>false</RequiresSession> <DefaultMessageTimeToLive>P10675199DT2H48M5.4775807S</DefaultMessageTimeToLive> <DeadLetteringOnMessageExpiration>false</DeadLetteringOnMessageExpiration> <DeadLetteringOnFilterEvaluationExceptions>true</DeadLetteringOnFilterEvaluationExceptions> </SubscriptionDescription> </content> </entry>



Get a client from a service principal. :param client_class: The client class to instantiate. :
""" Get a client from a JSON configuration dictionary. :param client_class: The client class to instantiate. :type client_class: :class:`msrestazure.azure_active_directory.AzureActiveDirectory` :param dict config_dict: The configuration dictionary. :param kwargs: Additional keyword arguments to pass to the client. :type kwargs: dict :rtype: client_class """ if 'tenant' not in config_dict: raise ValueError('Missing tenant in configuration') if'subscription_id' not in config_dict: raise ValueError('Missing subscription_id in configuration') if 'client_id' not in config_dict: raise ValueError('Missing client_id in configuration') if'secret' not in config_dict: raise ValueError('Missing secret in configuration') if 'active_directory_endpoint_url' not in config_dict: raise ValueError('Missing active_directory_endpoint_url in configuration') if'resource_management_endpoint_url' not in config_dict: raise ValueError('Missing resource_management_endpoint_url in configuration') if 'graph_resource_id' not in config_dict: raise ValueError('Missing graph_resource_id in configuration') if 'active_directory_graph_resource_id' not in config_dict: raise ValueError('Missing active_directory_graph_resource_id in configuration') if 'tenant_id' not in config_dict: raise ValueError('Missing tenant_id in configuration') if 'active_directory_graph_resource_id' not in config_dict: raise ValueError('Missing active_directory_graph_resource_id in configuration') if 'active_directory_graph_resource_id' not in config_dict: raise ValueError('Missing active_directory_graph_resource_id in configuration') if 'active_directory_graph_resource_id' not in config_dict: raise ValueError('Missing active_directory_graph_resource_id in configuration') if 'active_directory_graph_resource_id' not in config_dict: raise ValueError('Missing active_directory_graph_resource_id in configuration') if 'active_directory_graph_resource_id'
Initialize the InvitePage :param Version version: Version that contains the resource :param service_sid: The SID of the Service that the resource is associated with :param channel_sid: The SID of the Channel the resource belongs to :param Response response: Response from the API :param service_sid: The SID of the Service that the resource is associated with :param channel_sid: The SID of the Channel the resource belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage
get properties from element tree element :param element: Element tree element :type element: xml.etree.ElementTree.Element :param include_id: Include the id in the properties :type include_id: bool :param id_prefix_to_skip: Prefix to skip when generating readable id :type id_prefix_to_skip: str :param use_title_as_id: Use the title as the id :type use_





Receive deferred messages from the channel. :param list[int] sequence_numbers: The sequence numbers of the deferred messages to receive. :param ReceiveSettleMode mode: The mode to use for settling the deferred messages. :param dict kwargs: Additional keyword arguments to pass to the handler. :returns: DeferredMessageSet :rtype: twilio.rest.chat.v2.service.channel.message.message_set.DeferredMessageSet
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._solution['account_sid'], 'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'attributes': attributes, 'role_sid': role_sid, 'identity': identity, 'is_pending': is_pending, 'date_expires': deserialize.iso8601_datetime(date_expires), 'expiration_period': expiration_period, 'date_invited': deserialize.iso8601_datetime(date_invited), 'invite_reason': invite_reason, 'links': links, } # Context self._context = None self._solution = { 'account_sid': account_sid, 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are prox
List the domains defined
Get a website. webspace_name: The name of the webspace. website_name: The name of the website.
nan
Update a web site metadata. webspace_name: The name of the webspace. website_name: The name of the website. metadata: The metadata to apply.
Perform a POST request. path: The path to the resource. data: The data to send in the request. as_async: Whether to perform
Get historical usage metrics. webspace_name: The name of the webspace. website_name: The name of the website. metrics: Optional. List of metrics name. Otherwise, all metrics returned. start_time: Optional. An ISO8601 date. Otherwise, current hour is used. end_time: Optional. An ISO8601 date. Otherwise, current time is used. time_grain: Optional. A rollup name, as P1D. OTherwise, default rollup for the metrics is used. More information and metrics name at: http://msdn.microsoft.com/en-us/library/azure/dn166964.aspx ''' metrics = ('names='+','.join(metrics)) if metrics else '' start_time = ('StartTime='+start_time)
Get metric data of metrics available of this web site. webspace_name: The name of the webspace. website_name: The name of the website. metric_name: The name of the metric. start_time: The start time of the metric data. end_time: The end time of the metric data. granularity: The granularity of the metric data. limit: The number of results to return. offset: The offset of the first result to return. ''' return self._perform_get(self._get_metric_data_path(webspace_name, website_name, metric_name, start_time, end_time, granularity, limit, offset), MetricData)
Get a site's publish profile as a string webspace_name: The name of the webspace. website_name: The name of the website. sid: The sid of the site.
Constructs a WebhookContext :param sid: The SID that identifies the resource to fetch
:param str resource_group_name: The name of the resource group that contains the IoT hub. :param str registry_name: The name of the IoT hub. :param str quarantine_policy: The new quarantine policy. :param str trust_policy: The new trust policy. :param dict custom_headers: headers that will be added to the request :param bool raw: returns the direct response alongside the deserialized response :param polling: True for ARMPolling, False for no polling, or a polling object for personal polling strategy :return: An instance of LROPoller that returns RegistryPolicies or ClientRawResponse<RegistryPolicies> if raw=true :rtype: ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.iothub.v2018_04_01.models.RegistryPolicies] or ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.iothub.v2018_04_01.models.RegistryPolicies]] :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>` """
The Create Cloud Service Job Collection request creates a new job collection. When job collections are created, they are hosted within a cloud service. A cloud service groups job collections together in a given region. Once a cloud service has been created, job collections can then be created and contained within it.
The Check Name Availability operation checks if a new job collection with the given name may be created, or if it is unavailable. The result of the operation is a Boolean true or false. cloud_service_id: The cloud service id job_
The Get Job Collection Statistics operation gets the statistics of a job collection cloud_service_id: The cloud service id job_collection_id: Name of the hosted service. :returns: twilio.rest.chat.v2.service.job_collection.JobCollectionStatisticsInstance :rtype: twilio.rest.chat.v2.service.job_collection.JobCollectionStatisticsInstance

Create a new InviteInstance :param unicode identity: The unique string that identifies the resource :param unicode role_sid: The SID of the Role assigned to the new invite :param unicode ttl: The time-to-live of the invite, in seconds :param unicode type: The type of push notification to send to the new invite :param unicode unique_name: An application-defined string that uniquely identifies the resource :returns: Newly

""" Handle an exception that occurred during the connection. :param Exception e: The exception that occurred :returns: None :rtype: None """ self.logger.error('Connection error: %s', e) self.logger.debug('Connection error traceback: %s', traceback.format_exc()) self.logger.debug('Connection error stack: %s', traceback.extract_stack()) self.logger.debug('Connection error type: %s', type(e)) self.logger.debug('Connection error message: %s', e.message) self.logger.debug('Connection error code: %s', e.code) self.logger.debug('Connection error status: %s', e.status) self.logger.debug('Connection error reason: %s', e.reason) self.logger.debug('Connection error headers: %s', e.headers) self.logger.debug('Connection error body: %s', e.body) self.logger.debug('Connection error request: %s', e.request) self.logger.debug('Connection error response: %s', e.response) self.logger.debug('Connection error request_id: %s', e.request_id) self.logger.debug('Connection error request_time: %s', e.request_time) self.logger.debug('Connection error request_url: %s', e.request_url) self.logger.debug('Connection error request_method: %s', e.request_method) self.logger.debug('Connection error request_headers: %s', e.request_headers) self.logger.debug('Connection error request_body: %s', e.request_body) self.logger.debug('Connection error response_status: %s', e.response_status) self.logger.debug('Connection error response_headers: %s', e.response_headers) self.logger.debug('Connection error response_body: %s', e.response_body) self.logger.debug('Connection error response_code: %s', e.response_code) self.logger.debug('Connection error response_reason: %s', e.response_reason) self.logger.
Writes a certificate file to the specified location. This can then be used to instantiate ServiceManagementService. Returns the subscription ID. publish_settings_path: Path to subscription file downloaded from http://go.microsoft.com/fwlink/?LinkID=301775 path_to_write_certificate: Path to write the certificate file. subscription_id: (optional) Provide a subscription id here if you wish to use a specific subscription under the publish settings file.
Initialize the Plugin :param str service_sid: The SID of the Service to fetch the resource from :param str channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext
Iterate over list of Invites :returns: List of Invites :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]
Code
Get an item from the list of resources :param unicode key: The index of the resource to fetch :returns
""" :returns: True if other == this,

""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': None, 'service_sid': service_sid, 'channel_sid': channel_sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property
Provide a friendly representation :returns: Machine friendly representation :rtype: str
""" Initialize the SegmentList :returns: twilio.rest.video.v1.room.room_participant.room_participant_published_track.SegmentList :rtype: twilio.rest.video.v1.room.room_participant.room_participant_published_track.SegmentList """ super(SegmentList, self).__init__(version=kwargs.get('version')) # Path Solution self._solution = {'room_sid': kwargs.get('room_sid'), 'participant_sid': kwargs.get('participant_sid'), 'track_sid': kwargs.get('track_sid'), } self._uri = '/Rooms/{room_sid}/Participants/{participant_sid}/PublishedTracks/{track_sid}/Segments'.format(**self._solution) def stream(self, limit=None, page_size=None): """ Streams SegmentInstance records from the API as a generator stream. This operation lazily loads records as efficiently as possible until the limit is reached. The results are returned as a generator, so this operation is memory efficient. :param int limit: Upper limit for the number of records to return. stream() guarantees to never return more than limit. Default is no limit :param int page_size: Number of records to fetch per request, when not set will use the default value of 50 records. If no page_size is defined but a limit is defined, stream() will attempt to read the limit with the most efficient page size, i.e. min(limit, 1000) :returns: Generator that will yield up to limit results :rtype: list[twilio.rest.video.v1.room.room_participant.room_participant_published_track.SegmentInstance] """ limits = self._version.read_limits(limit, page_size) page = self.page(page_size=limits['page_size'], ) return self._version.stream(page, limits['limit'], limits['page_limit']) def list(self, limit=None, page_size=None): """ Lists SegmentInstance records from the API as a list. Unlike stream(), this operation is eager and will load `limit` records into memory before returning
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': payload.get('sid'), 'account_sid': payload.get('account_sid'), 'service_sid': payload.get('service_sid'), 'channel_sid': payload.get('channel_sid'), 'identity': payload.get('identity'), 'role_sid': payload.get('role_sid'), 'date_created': deserialize.iso8601_datetime(payload.get('date_created')), 'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')), 'url': payload.get('url'), } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': payload.get('sid'), } @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property def service_sid(self): """ :returns: The SID of the Service that the resource is
""" Provide a friendly representation :returns: Machine friendly representation :rtype: str """ return '<Twilio.IpMessaging.V2.InviteList>' Doc
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def date_created(self): """ :returns: The ISO 8601 date and time in GMT when the resource was created :rtype: datetime """ return self._properties['date_created'] @property def date_updated(self): """ :returns: The ISO 860
""" Initialize the InvitePage :param Version version: Version that contains the resource :param service_sid: The SID of the Service that the resource is associated with :param channel_sid: The SID of the Channel the resource belongs to :param sid: The unique string that identifies the resource :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage """ super(InvitePage, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites{sid}'.format(**self._solution) # Path Parameters self._solution['service_sid'] = service_sid self._solution['channel_sid'] = channel_sid self._solution['sid'] = sid # Components self._invites = None self._links = None @property def invites(self): """ :returns: A list of instances of InviteInstance :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance] """ if self._invites is None: self._invites = list() if self._invites: return self._invites self._invites = list() for payload in self._version.page(method='GET', uri=self._uri, params=self._solution,): self._invites.append(InviteInstance( self._version, payload, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], )) return self._invites @property def links(self): """ :returns: The links :rtype: unicode """ if self._links is None: self._links = self._
Provide a friendly representation :returns: Machine friendly representation :rtype: str

""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._solution['account_sid'], 'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'role_sid': role_sid, 'identity': identity, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'account_sid': account_sid, 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource.
Get an item from the list of resources in the response. :returns: An instance of the resource at the given index, or None if that index does not exist. :rtype: twilio
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': payload.get('sid'), 'account_sid': payload.get('account_sid'), 'service_sid': payload.get('service_sid'), 'channel_sid': payload.get('channel_sid'), 'created_by': payload.get('created_by'), 'created_by_identity': payload.get('created_by_identity'), 'role_sid': payload.get('role_sid'), 'date_created': deserialize.rfc2822_datetime(payload.get('date_created')), 'date_updated': deserialize.rfc2822_datetime(payload.get('date_updated')), 'url': payload.get('url'), } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': payload.get('sid'), } @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property def service_sid(self): """ :returns: The SID of the Service that the resource is associated with :rtype: unicode """ return self._properties['service_sid'] @property def channel_sid(self): """ :returns: The SID of the Channel the resource belongs to :rtype: unicode """ return self._properties['channel_sid'] @property def created_by(self): """ :returns: The identity of the User that created the resource :rtype: unicode """ return
""" Initialize the InviteContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :param sid: The SID of the Invite resource to fetch :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ super(InviteContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites/{sid}'.format(**self._solution) # Dependents self._channel = None @property def sid(self): """ :returns: The SID of the Invite resource :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property def service_sid(self): """ :returns: The SID of the Service that the resource is associated with :rtype: unicode """ return self._properties['service_sid'] @property def channel_sid(self): """ :returns: The SID of the Channel the resource to fetch belongs to :rtype: unicode """ return self._properties['channel_sid'] @property def role_sid(self): """ :returns: The SID of the Role assigned to the user when they join the Channel :rtype: unicode """ return self._properties['role_sid'] @property def identity(self): """ :returns: The identity of the User when they join the Channel :rtype: unicode """ return self._properties['identity'] @property def date_created(self): """ :returns: The RFC 2822 date and time in
""" :returns: Number of invites in the response :rtype: unicode
Spawn a process and wait for it to complete. :param list parameters: List of parameters to pass to the command. :param list arguments: List of arguments to pass to the command. :param file stderr: File-like object to write stderr to. :param int timeout: Timeout in seconds. :param str short_option_prefix: Prefix for short options. :param str long_option_prefix: Prefix for long options. :returns: subprocess.Popen :rtype: subprocess.Popen
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Get the channel unique name from the channel_sid or channel_unique_name :param str channel_sid: The channel_sid :param str channel_unique_name: The channel_unique_name :returns: The channel unique name :rtype: str
Get an item from the list of resources :param unicode key: The index of the resource to fetch :returns:
""" Iterate over list of invites
""" Iterate over pages of results :returns: Page of InviteInstance :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance] """ return list(self)
Iterate over list of resources, yielding each one as a dict. :returns: Generator that will yield up to limit results :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]

Initialize the InvitePage :param Version version: Version that contains the resource :param Response response: Response from the API :param service_sid: The SID of the Service that the resource is associated with :param channel_sid: The SID of the Channel the resource belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage
Provide a friendly representation :returns: Machine friendly representation :rtype: str

Attempt to login to the LiveEdu account :raises: LiveEduLoginError if login fails """ if self.session.is_logged_in: return self.logger.debug("Attempting login as {0}", self.username) res = self.session.http.get(self.login_url) csrf_match = self.csrf_re.search(res.text) token = csrf_match and csrf_match.group(1) self.logger.debug("Attempting login as {0} (token={1})", self.username, token) res = self.session.http.post(self.login_url, data=dict(login=self.username, password=self.password, csrfmiddlewaretoken=token), allow_redirects=False, raise_for_status=False, headers={"Referer": self.login_url}) if res.status_code!= 302: self.logger.error("Failed to login to LiveEdu account: {0}", self.username) raise LiveEduLogin
Provide a friendly representation :returns: Machine friendly representation :rtype: str
""" Constructs a InviteContext :param sid: The sid :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ return InviteContext( self._version, service_sid=
Iterate over the tags in the file. :param file fd: File object to read from. :param int buf: Size of buffer to read from file. :param bool skip_header: Skip the header. :returns: Iterator over the tags in the file. :rtype: iterator
Get an item from the list of resources :param unicode key: The index of the resource to fetch :returns
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._solution['service_sid'], 'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property def service_sid(self): """ :returns: The SID of the Service that the resource is associated with :rtype: unicode """ return self._properties['service_sid'] @property def channel_sid(self): """ :returns: The SID of the Channel the resource belongs to :rtype: unicode """ return self._properties['channel_sid'] @property def date_created(self): """ :returns: The RFC 2822 date and time in GMT when the resource was created :
Create a player thread. :param out: Output instance :type out: :class:`StreamlinkOutput` :returns: Player thread :rtype: :class:`threading.Thread`




Attempts to open the stream :param stream: The stream to open :returns: A tuple of (stream_fd, prebuffer) :rtype: tuple
Read from the stream and write to the output. :param int stream_fd: File descriptor of the stream :param output: Output object :type output: :class:`Output` :param bytes prebuffer: Prebuffer to read from the stream
Provide a friendly representation :returns: Machine friendly representation :rtype: str


Get streams from the plugin :param interval: Interval to wait between retries :type interval: int :param count: Number of retries :type count: int :returns: list of streams :rtype: list
Build an instance of InviteInstance :param dict payload: Payload response from the API :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest
Build an instance of InviteInstance :param dict payload:

Get the channel members from the channel sid :param str channel_sid: The channel sid :returns: The channel members :rtype: list

Get an item from the list of resources :param unicode key: The index of the resource to fetch
Get the user sid from the user name :param str user_name: User name :returns: User sid :rtype: str
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': payload.get('sid'), 'account_sid': payload.get('account_sid'), 'service_sid': payload.get('service_sid'), 'channel_sid': payload.get('channel_sid'), 'role_sid': payload.get('role_sid'), 'identity': payload.get('identity'), 'date_created': deserialize.rfc2822_datetime(payload.get('date_created')), 'date_updated': deserialize.rfc2822_datetime(payload.get('date_updated')), 'url': payload.get('url'), } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': payload.get('sid'), } @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property def service_sid(self): """ :returns: The SID of the Service that the resource is associated with :rtype: unicode """ return self._properties['service_sid'] @property def channel_sid(self): """ :returns: The SID of the Channel the resource belongs to :rtype: unicode """ return self._properties['channel_sid'] @property def role_sid(self): """ :returns: The SID of the Role assigned to the user when they join the Channel :rtype: unicode """ return self._properties['role_sid'] @property def identity(self):
Get stream URL from stream info list :param list stream_info_list: Stream info list :returns: str :rtype: str
Get the service sid from the service_sid or service_unique_name :param str service_sid: The service_sid :param str service_unique_name: The service_unique_name :

Initialize the InvitePage :param Version version: Version that contains the resource :param Response response: Response from the API :param service_sid: The SID of the Service that the resource is associated with :param channel_sid: The SID of the Channel the resource belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage



Retrieve a single page of InviteInstance records from the API. Request is executed immediately :param str target_url: API-generated URL for the requested results page :param dict params: Parameters for the request :returns: Page of InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Provide a friendly representation :returns: Machine friendly representation :rtype: str
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def date_created(self): """ :returns: The ISO 8601 date and time in GMT when the resource was created :rtype: datetime """ return self._properties['date_created'] @property def date_updated(self): """ :returns: The ISO 8601
""" Load a plugin from a file. :param str module_name: Name of the plugin module :param file file: File object of the plugin module :param str pathname: Pathname of the plugin module :param desc: Description of the plugin module :raises: :class:`streamlink.exceptions.
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': payload.get('sid'), 'account_sid': payload.get('account_sid'), 'service_sid': payload.get('service_sid'), 'channel_sid': payload.get('channel_sid'), 'created_by': payload.get('created_by'), 'created_by_identity': payload.get('created_by_identity'), 'role_sid': payload.get('role_sid'), 'date_created': deserialize.rfc2822_datetime(payload.get('date_created')), 'date_updated': deserialize.rfc2822_datetime(payload.get('date_updated')), 'url': payload.get('url'), } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property def service_sid(self): """ :returns: The SID of the Service that the resource is associated with :rtype: unicode """ return self._properties['service_sid'] @property def channel_sid(self): """ :returns: The SID of the Channel the resource belongs to :rtype: unicode """ return self._properties['channel_sid'] @property def created_by(self): """ :returns: The identity of the User that created the resource :
Get an item from the list of resources :param unicode key: The index of the resource to fetch :returns: twilio.rest.chat.v2.service.channel.invite.
""" Initialize the InvitePage :param Version version: Version that contains the resource :param dict payload: A JSON response from the Twilio API :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage """ super(InvitePage, self).__init__(version, response=payload, solution=service_sid) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._context @property def invites(self): """ :returns: A list of instances of InviteInstance :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance] """ return self._proxy.invites @property def page_size(self): """ :returns: How many resources to return in each list page. The default is 50, and the maximum is 1000. :rtype: unicode """ return self._properties['page_size'] @property def start(self): """ :returns: The index of the first resource to return in the response :rtype: unicode """ return self._properties['start'] @property def end(self): """ :returns: The index of the last resource in the response :rtype: unicode """ return self._properties['end'] @property def uri(self): """ :returns: The URI of the resource, relative to `https://chat.twilio
Get an item from the list of resources :param unicode key: The index of the resource to fetch :returns: twilio.rest.chat.v2.service.channel.invite
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Create a new InviteInstance instance from a JSON response. :param dict payload: JSON response from the API :returns: twilio.rest.chat.
Get an item from the list of resources :param unicode key: The index of the resource to fetch :returns: twilio.rest.chat.v2.service
Get an item from the list of resources :param unicode key: The index of the resource to fetch :returns:
:returns: Number of resources in the response :rtype: unicode
Get an item from the list of resources :param unicode key: The index of the resource to fetch :returns: twilio.rest.chat.v2
Get the player URL from the response :returns: The player URL :rtype: unicode
Initialize the InvitePage :param Version version: Version that contains the resource :param dict payload: A JSON response from the Twilio API :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Build an instance of InviteInstance :param dict payload: Payload response from the API :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
Extract video_height from html :param str html:
Get the video URL from the stream_info :param list stream_info: List of stream_info :returns: str :rtype: str
get channel url from channel sid :param str channel_sid: Channel sid :returns: Channel url :rtype: str
""" Initialize the InviteList :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the invite belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) def stream(self, limit=None, page_size=None): """ Streams InviteInstance records from the API as a generator stream. This operation lazily loads records as efficiently as possible until the limit is reached. The results are returned as a generator, so this operation is memory efficient. :param int limit: Upper limit for the number of records to return. stream() guarantees to never return more than limit. Default is no limit :param int page_size: Number of records to fetch per request, when not set will use the default value of 50 records. If no page_size is defined but a limit is defined, stream() will attempt to read the limit with the most efficient page size, i.e. min(limit, 1000) :returns: Generator that will yield up to limit results :rtype: list[
Receive a packet from the server. :returns: Packet received :rtype: twilio.rest.chat.v2.service.channel.invite.packet.Packet
Receive a packet from the server :returns: The packet received :rtype: packet.
Constructs a InviteContext :param role_sid: The role_sid

Provide a friendly representation :returns: Machine friendly representation :rtype: str
Initialize the InvitePage :param Version version: Version that contains the resource :param Response response: Response from the API :param service_sid: The SID of the Service that the resource is associated with :param channel_sid: The SID of the Channel the resource belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage
Initialize the InvitePage :param Version version: Version that contains the resource :param Response response: Response from the API :param service_sid: The SID of the Service that the resource is associated with :param channel_sid: The SID of the Channel the resource belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage

Convenience method to access members of the created :class:`InviteInstance` :param str key: name of member to access :
Returns true if both instances are not equal, false otherwise :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
Set the prefix length to use for encoding and decoding. :param int prefixLength: The prefix length to use for encoding and decoding. :returns: The updated Prefix
Provide a friendly representation :returns: Machine friendly representation :rtype: str
""" Initialize the InviteList :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) def stream(self, limit=None, page_size=None): """ Streams InviteInstance records from the API as a generator stream. This operation lazily loads records as efficiently as possible until the limit is reached. The results are returned as a generator, so this operation is memory efficient. :param int limit: Upper limit for the number of records to return. stream() guarantees to never return more than limit. Default is no limit :param int page_size: Number of records to fetch per request, when not set will use the default value of 50 records. If no page_size is defined but a limit is defined, stream() will attempt to read the limit with the most efficient page size, i.e. min(limit, 1000) :returns: Generator that will yield up to limit results :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance] """ limits = self._version.read_limits(limit, page_size) page = self.page(page_size=limits['page_size'], ) return self._version.stream(page, limits['limit'], limits['page_limit']) def list(self, limit=None, page_size=None): """ Lists InviteInstance records from the API as a list. Unlike stream(), this operation is eager and will load `limit` records into memory before returning. :param int
Read a list of tuples from the stream. :param stream: The stream to read from. :type stream: io.BytesIO :returns: The list of tuples read from the stream. :rtype: list
""" Initialize the InviteList :param Version version: Version that contains the resource :param dict payload: A JSON response from the Twilio API :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Marshaled Properties self._properties = { 'invites': payload.get('invites'), 'meta': payload.get('meta'), } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._context @property def invites(self): """ :returns: The list of Invites :rtype: unicode """ return self._properties['invites'] @property def meta(self): """ :returns: The response metadata :rtype: dict """ return self._properties['meta'] def __repr__(self): """ Provide a friendly representation :returns: Machine friendly representation :rtype: str """ return '<Twilio.IpMessaging.V2.InviteList>' class InvitePage(Page): """ PLEASE NOTE that this class contains preview products that are subject to change. Use them with caution. If you currently do not have developer preview access, please contact <EMAIL>. """ def __init__(self, version, response, solution): """ Initialize the InvitePage :param Version version: Version that contains the resource
""" Get an item or
""" Initialize the InviteList :param Version version: Version that contains the resource :param dict payload: A JSON response from the Twilio API :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Marshaled Properties self._properties = { 'invites': payload.get('invites'), 'meta': payload.get('meta'), } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, } @property def invites(self): """ :returns: The list of Invites :rtype: unicode """ return self._properties['invites'] @property def meta(self): """ :returns: The response metadata :rtype: dict """ return self._properties['meta'] @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._context def __call__(self, sid): """ Constructs a InviteContext :param sid: The unique string that identifies the resource :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ return InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=sid, ) def __repr__(self
1. If index is 0, return 1, 0. 2. If index is less than or equal to RLEMAX, return (1<<index)+extra, 0. 3. Otherwise, return 1, index-RLEMAX.
Get an item from the list of resources :param unicode key: The index of the resource to fetch :returns: twilio.rest.chat.v2.service.channel.
""" Provide a friendly representation :returns: Machine friendly representation :rtype: str """ return
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the resource to fetch belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._invites = None self._members = None self._messages = None self._webhooks = None @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = InviteList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._invites @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._
Provide a friendly representation :returns: Machine friendly representation :rtype: str
""" Provide a friendly representation :returns: Machine friendly representation :rtype: str """ context =''.join('{}={}'.format(k, v) for k, v in
Read a prefix code. :param int blockType: Block type :returns: Prefix code :rtype: list
""" Read a message from the stream. :param int message_type: The message type to read. :returns: A Message instance. :rtype: twilio.rest.chat.v2.service.channel.message.MessageInstance """ if message_type == Message.MESSAGE_TYPE_TEXT: return self._read_text_message() elif message_type == Message.MESSAGE_TYPE_MEDIA: return self._read_media_message() elif message_type == Message.MESSAGE_TYPE_COMMAND: return self._read_command_message() elif message_type == Message.MESSAGE_TYPE_NOTIFICATION: return self._read_notification_message() elif message_type == Message.MESSAGE_TYPE_PUSH: return self._read_push_message() elif message_type == Message.MESSAGE_TYPE_APNS: return self._read_apns_message() elif message_type == Message.MESSAGE_TYPE_GCM: return self._read_gcm_message() elif message_type == Message.MESSAGE_TYPE_APNS_FEEDBACK: return self._read_apns_feedback_message() elif message_type == Message.MESSAGE_TYPE_GCM_FEEDBACK: return self._read_gcm_feedback_message() elif message_type == Message.MESSAGE_TYPE_APNS_ERROR: return self._read_apns_error_message() elif message_type == Message.MESSAGE_TYPE_GCM_ERROR: return self._read_gcm_error_message() elif message_type == Message.MESSAGE_TYPE_APNS_FEEDBACK_ERROR: return self._read_apns_feedback_error_message() elif message_type == Message.MESSAGE_TYPE_GCM_FEEDBACK_ERROR: return self._read_gcm_feedback_error_message() elif message_type == Message.MESSAGE_TYPE_APNS_FEEDBACK_RETRY: return self._read_apns_feedback_retry_message() elif message_type == Message.MESSAGE_TYPE_GCM_FEEDBACK_RETRY: return self._read_gcm_feedback_retry_message() elif message_type == Message.MESSAGE_TYPE_APNS_ERROR_
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Read a list of blocks of data of the given type. :param str kind: The type of block to read. :returns: The list of blocks of data. :rtype: list[bytes]
""" Initialize the InviteList :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Marshaled Properties self._properties = { 'invites': payload.get('invites'), 'meta': payload.get('meta'), } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, } @property def invites(self): """ :returns: The list of Invites :rtype: unicode """ return self._properties['invites'] @property def meta(self): """ :returns: The response metadata :rtype: dict """ return self._properties['meta'] def __repr
Read a prefix code from the stream. :param alphabet: Alphabet to use for reading the code :type alphabet: Alphabet
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Provide a friendly representation :returns: Machine friendly representation :rtype: str

Adds method f to the Dataset class :param f: The method to add to the Dataset class :returns: The method f :rtype: function


""" :returns: Iterator for list of invites :rtype: list[twilio.rest.chat
Get the value at the given index :param int index: Index of the value to get :returns: Value at the given index :rtype: object



Create a new Channel from an Astropy Table. :param table: Astropy Table :type table: astropy.table.Table :returns: twilio.rest.chat.v2.service.channel.ChannelInstance :rtype: twilio.rest.chat.v2.service.channel.ChannelInstance


Initialize the InvitePage :param list[unicode] identity: The identity of the User that created the Invite :param unicode role_sid: The SID of the Role assigned to the User that created the Invite :param unicode last_consumed_message_index: The index of the last Message that the User in this Channel has read :param unicode last_consumption_timestamp: The RFC 2822 date and time in GMT

""" Read Excel file into DataFrame. Parameters ---------- filename_or_buffer : file path or file-like object File path or object to read. sheet_name : int, str, list, tuple, or dict, default 0 Name or index of sheet(s) to read, if a dict is passed, the keys indicate the sheet names and the values the corresponding indexes. header : int, list of ints, default 0 Row(s) to use as the column names, also accepts a list of row indices (zero-indexed). If this is None, and there is only one non-whitespace row in the file, then column names will be ``'X', 'X.1', 'X.2',...`` index_col : int, list of ints, str, or False, default 0 Column(s) to use as the row labels of the DataFrame. If a sequence is given, a MultiIndex is used. If False, no index is used. If None, and `header` and `index_col` are both non-None, then the values in `header` are used for both. parse_dates : boolean, list, or dict, default False - If boolean, determines if columns can be parsed to dates. - If list or dict, determines which columns can be parsed to dates, using the keys as a subset of the column names, and the values as the names of the columns. squeeze : boolean, default False If the parsed data only contains one column then return a Series. na_values : scalar,
Get an item from the list of resources :param unicode key: The index of the resource to fetch :returns

Concatenate a list of DataFrames. :rtype: DataFrame
""" Initialize the InviteList :param unicode service_sid: The SID of the Service to fetch the resources from :param unicode channel_sid: The SID of the Channel the resource to fetch belongs to :param Version version: Version that contains the resource :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) def stream(self, limit=None, page_size=None): """ Streams InviteInstance records from the API as a generator stream. This operation lazily loads records as efficiently as possible until the limit is reached. The results are returned as a generator, so this operation is memory efficient. :param int limit: Upper limit for the number of records to return. stream() guarantees to never return more than limit. Default is no limit :param int page_size: Number of records to fetch per request, when not set will use the default value of 50 records. If no page_size is defined but a limit is defined, stream() will attempt to read the limit with the most efficient page size, i.e. min(limit, 1000) :returns: Generator that will yield up to limit results :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance] """ limits = self._version.read_limits(limit, page_size) page = self.page(page_size=limits['page_size'], ) return self._version.stream(page, limits['limit'], limits['page_limit']) def list(self, limit=None, page_size=None): """ Lists InviteInstance records from the API as a list. Unlike stream(), this operation is eager and will load `limit` records into memory before returning. :
Open a dataset from a URL. :param str url: URL to the dataset file. :rtype: vaex.dataset.Dataset
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, } self._properties = { 'sid': payload.get('sid'), 'account_sid': payload.get('account_sid'), 'service_sid': payload.get('service_sid'), 'channel_sid': payload.get('channel_sid'), 'identity': payload.get('identity'), 'role_sid': payload.get('role_sid'), 'date_created': deserialize.iso8601_datetime(payload.get('date_created')), 'date_updated': deserialize.iso8601_datetime(payload.get('date_updated')), '
Build an instance of MessageInstance :param dict payload: Payload response from the API :returns: twilio.rest.chat.v2.service.channel.message.MessageInstance :rtype: twilio.rest.chat.v2.service
Get the column values for this selection :param pandas.DataFrame ds: Dataset to get column values for :returns: dict of column names to values :rtype: dict
Send a packet to the server. :param packet: The packet to send :type packet: :class:`vaex.execution.packet.Packet`
""" Handle a message received from the server. :param Message message: The message received from the server """ self.logger.debug('Received message: %s', message) if message.type =='message': self.emit(QtCore.SIGNAL('messageReceived(PyQt_PyObject)'), message) elif message.type == 'invite': self.emit(QtCore.SIGNAL('inviteReceived(PyQt_PyObject)'), message) elif message.type == 'command': self.emit(QtCore.SIGNAL('commandReceived(PyQt_PyObject)'), message) elif message.type == 'typing': self.emit(QtCore.SIGNAL('typingIndicatorReceived(PyQt_PyObject)'), message) elif message.type == 'user_typing': self.emit(QtCore.SIGNAL('userTypingIndicatorReceived(PyQt_PyObject)'), message) elif message.type == 'deleted': self.emit(QtCore.SIGNAL('messageDeleted(PyQt_PyObject)'), message) elif message.type =='read': self.emit(QtCore.SIGNAL('messageRead(PyQt_PyObject)'), message) elif message.type == 'channel_update': self.emit(QtCore.SIGNAL('channelUpdated(PyQt_PyObject)'), message) elif message.type =='service_update': self.emit(QtCore.SIGNAL('serviceUpdated(PyQt_PyObject)'), message) elif message.type =='member_update': self.emit(QtCore.SIGNAL('memberUpdated(PyQt_PyObject)'), message) elif message.type =='member_removed': self.emit(QtCore.SIGNAL('memberRemoved(PyQt_PyObject)'), message) elif message.type =='member_joined': self.emit(QtCore.SIGNAL('memberJoined(PyQt_PyObject)'), message) elif message.type == 'channel_deleted': self.emit(QtCore.SIGNAL('channelDeleted(PyQt_PyObject)'), message) elif message.type =='service_deleted': self.emit(QtCore.SIGNAL('serviceDeleted(PyQt_PyObject)'), message) elif message.type == 'role_updated': self.emit(QtCore.SIGNAL('roleUpdated(PyQt_PyObject)'), message)
Build an instance of InviteInstance :param dict payload: Payload response from the API :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Update the plot layout :param dict data: Data to update the plot with
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Returns the dtype of a block, or None if it is not a masked array
nan



""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._solution['account_sid'], 'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'by': by, 'from': from_, 'to': to, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'account_sid': account_sid, 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid']



""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': None, 'service_sid': service_sid, 'channel_sid': channel_sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def account_sid(self): """ :returns: The SID of the Account that created the resource :rtype: unicode """ return self._properties['account_sid'] @property def service



3D plot of a DataFrame. :param str x: Column name for x-axis :param str y: Column name for y-axis :param str z: Column name for z-axis :param str vx: Column name for x-axis velocity :param str vy: Column name for y-axis velocity :param str vz: Column name for z-axis velocity :param str vwhat: Column name for velocity vector length :param list limits: List of 6 values, defining the limits of the plot. The order is [xmin, xmax, ymin, ymax, zmin, zmax] :param list grid: List of 6 values, defining the grid of the plot. The order is [nx, ny, nz, xmin, xmax, ymin, ymax, zmin, zmax] :param str what: Column name for the density of the plot. If not given, defaults to count(*) :param int shape: Number of points per dimension of the grid :param list selection: List of boolean expressions to apply to the DataFrame before plotting. :param function f: Function to apply to the DataFrame before plotting. :param list vcount_limits: List of 2 values, defining the limits of the velocity vector length. :param int smooth_pre: Number of points to smooth the data before plotting. :param int smooth_post: Number of points to smooth the data after plotting. :param list grid_limits: List of 6 values, defining the limits of the grid. The order is [xmin, xmax, ymin, ymax, zmin, zmax] :param str normalize: Normalization of the density. Possible values are: 'normalize', 'none' :param str colormap: Colormap to use for the density. Possible values are: 'afmhot', 'autumn', 'binary', 'bone', 'cool', 'copper', 'flag', 'gist_earth', 'gist_gray', 'gist_heat', 'gist_ncar', 'gist_rainbow', 'gist_stern', 'gist_yarg', 'gnuplot', 'gnuplot2', 'gray', 'hot', 'hsv', 'jet', 'pink', 'prism','spring','summer', 'winter' :param str figure_key: Key to use for
Evaluate an expression on the data. :param str expression: The expression to evaluate. :param int start: The index of the first row to evaluate. :param int end: The index of the last row to evaluate. :param bool filtered: Whether to filter the data before evaluating. :returns: The result of the evaluation. :rtype: object

"""Set the state of the dataset from a dict. :param dict state: The state dict to set the dataset to. """ self.logger.debug("restoring state: %r", state) self.column_names = state.get('column_names', []) self.virtual_columns = state.get('virtual_columns', {}) self.variables = state.get('variables', {}) self.functions = state.get('functions', {}) self.selections = state.get('selections', {}) self.ucds = state.get('ucds', {}) self.units = state.get('units', {}) self.descriptions = state.get('descriptions', {}) self.description = state.get('description', '') self.column_units = state.get('column_units', {}) self.column_descriptions = state.get('column_descriptions', {}) self.column_ucds = state.get('column_ucds', {}) self.column_aliases = state.get('column_aliases', {}) self.column_virtual_types = state.get('column_virtual_types', {}) self.column_virtual_functions = state.get('column_virtual_functions', {}) self.column_virtual_expressions = state.get('column_virtual_expressions', {}) self.column_virtual_imports = state.get('column_virtual_imports', {}) self.column_virtual_modules = state.get('column_virtual_modules', {}) self.column_virtual_module_names = state.get('column_virtual_module_names', {}) self.column_virtual_module_versions = state.get('column_virtual_module_versions', {}) self.column_virtual_module_dependencies = state.get('column_virtual_module_dependencies', {}) self.column_virtual_module_dependencies_versions = state.get('column_virtual_module_dependencies_versions', {}) self.column_virtual_module_dependencies_versions_hashes = state.get('column_virtual_module_dependencies_versions_hashes', {}) self.column_virtual_module_dependencies_versions_hashes_signatures = state.get('column_virtual_module_dependencies_versions_hashes_signatures', {}) self.
"""Rename a column""" if old == new: return if old in self.column_names: index = self.column_names.index(old) self.column_names[index] = new if old in self.virtual_columns: self.virtual_columns[new] = self.virtual_columns.pop(old) if old in self.expressions: self.expressions[new] = self.expressions.pop(old) if old in self.virtual_masked_columns: self.virtual_masked_columns[new] = self.virtual_masked_columns.pop(old) if old in self.virtual_columns_dropped: self.virtual_columns_dropped[new] = self.virtual_columns_dropped.pop(old) if old in self.virtual_columns_selected: self.virtual_columns_selected[new] = self.virtual_columns_selected.pop(old) if old in self.virtual_columns_filtered: self.virtual_columns_filtered[new] = self.virtual_columns_filtered.pop(old) if old in self.virtual_columns_string: self.virtual_columns_string[new] = self.virtual_columns_string.pop(old) if old in self.virtual_columns_arithmetic: self.virtual_columns_arithmetic[new] = self.virtual_columns_arithmetic.pop(old) if old in self.virtual_columns_math: self.virtual_columns_math[new] = self.virtual_columns_math.pop(old) if old in self.virtual_columns_boolean: self.virtual_columns_boolean[new] = self.virtual_columns_boolean.pop(old) if old in self.virtual_columns_datetime: self.virtual_columns_datetime[new] = self.virtual_columns_datetime.pop(old) if old in self.virtual_columns_string_list: self.virtual_columns_string_list[new] = self.virtual_columns_string_list.pop(old) if old in self.virtual_columns_string_categorical: self.virtual_columns_string_categorical[
Build an instance of InviteInstance :param dict payload: Payload response from the API :returns: twilio.rest.chat.v2.
"""Write the meta information to disk""" path = os.path.join(self.get_private_dir(create=True), "meta.yaml") meta_info = dict( name=self.name, description=self.description, units=self.units, ucds=self.ucds, variables=self.variables, virtual_columns=self.virtual_columns, column_names=self.column_names, column_units=self.column_units, column_ucds=self.column_ucds, column_descriptions=self.column_descriptions, column_types=self.column_types, column_virtual_types=self.column_virtual_types, column_virtual_functions=self.column_virtual_functions, column_virtual_units=self.column_virtual_units, column_virtual_ucds=self.column_virtual_ucds, column_virtual_descriptions=self.column_virtual_descriptions, column_virtual_meta=self.column_virtual_meta, column_virtual_meta_functions=self.column_virtual_meta_functions, column_virtual_meta_units=self.column_virtual_meta_units, column_virtual_meta_ucds=self.column_virtual_meta_ucds, column_virtual_meta_descriptions=self.column_virtual_meta_descriptions, column_virtual_meta_meta=self.column_virtual_meta_meta, column_virtual_meta_meta_functions=self.column_virtual_meta_meta_functions, column_virtual_meta_meta_units=self.column_virtual_meta_meta_units, column_virtual_meta_meta_ucds=self.column_virtual_meta_meta_ucds, column_virtual_meta_meta_descriptions=self.column_virtual_meta_meta_descriptions, column_virtual_meta_meta_meta=self.column_virtual_meta_meta_meta, column_virtual_meta_meta_meta_functions=self.column_virtual_meta_meta_meta_functions, column_virtual_meta_meta_meta_units=self.column_virtual_meta_meta


Convenience method for `get(key)` :param key: The unique string that identifies the resource :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
Convenience method providing a common interface for accessing this domain's Invites resources. The following are valid ways to call this resources: .. code-block:: python from twilio.rest.chat.v2.service.channel import InviteList from twilio.rest.chat.v2.service.channel import InvitePage from twilio.rest.chat.v2.service.channel import InviteContext list_resource = InviteList(version, service_sid, channel_sid) page_resource = InvitePage(version, service_sid, channel_
""" Provides a friendly representation :returns: Operational friendly representation :rtype: str """ context = None if hasattr(self, '_proxy'): context = self._proxy else: context = self._context if
""" Return a list of tuples representing the object's attributes. :param list column_names: The list of attributes to return. :param list selection: The list of attributes to return. :param bool strings: Whether to return strings or unicode. :param bool virtual: Whether to return virtual attributes. :returns: A list of tuples representing the object's attributes. :rtype: list[tuple] """ if column_names is None: column_names = self.columns if selection is None: selection = self.attributes if not isinstance(column_names, list): column_names = [column_names] if not isinstance(selection, list): selection = [selection] if not column_names: column_names = selection if not selection: selection = column_names if not isinstance(strings, bool): raise ValueError('strings must be a boolean') if not isinstance(virtual, bool): raise ValueError('virtual must be a boolean') items = [] for name in column_names: if name in selection: if name in self.attributes: if strings: items.append((name, self.attributes[name])) else: items.append((name, self.attributes[name].to_unicode())) elif name in self.virtual_attributes: if strings: items.append((name, self.virtual_attributes[name])) else: items.append((name, self.virtual_attributes[name].to_unicode())) elif name in self.virtual_attributes_values: if strings: items.append((name, self.virtual_attributes_values[name])) else: items.append((name, self.virtual_attributes_values[name].to_unicode())) elif name in self.virtual_attributes_values_values: if strings: items.append((name, self.virtual_attributes_values_values[name])) else: items.append((name, self.virtual_attributes_values_values[name].to_unicode())) elif name in self.virtual_attributes_values_values_values: if strings: items.append((name, self.virtual_attributes_
Convert the DataFrame to a list of (name, array) tuples. :param list column_names: Names of the columns to include in the result. If None, all columns are included. :param list selection: A list of booleans indicating which rows to include. If None, all rows are included. :param bool strings: If True, convert strings to numpy.string_ arrays. If False, convert strings to numpy.bytes_ arrays.
""" Provide
Convert the vaex DataFrame to a pandas DataFrame. :param list column_names: Names of the columns to include in the DataFrame. :param list selection: List of boolean expressions to apply to the DataFrame. :param bool strings: Whether to convert string columns to strings. :param bool virtual: Whether to include virtual columns in the DataFrame. :returns: pandas.DataFrame :rtype: pandas.DataFrame
""" Return a pandas.DataFrame for this table. Parameters ---------- column_names : list of str, optional A list of column names to include in the output. If not provided, all columns will be included. selection : 2-tuple, optional A 2-
Get the column values for the given index. :param str name: The name of the column :param index: The index :returns: The column values :rtype: list
Get the row as a dictionary where the row_id is equal to row_id. :param row_id: The row_id to use. :
Code



:param x: x coordinate :type x: str or :class:`pymc3.distributions.continuous.Continuous` :param y: y coordinate :type y: str or :class:`pymc3.distributions.continuous.Continuous` :param xnew: x coordinate after rotation :type x


:param str old_name: :param str new_name: :param str expression: :returns: (new_expression, new_column_names) :rtype: (str, list)
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._solution['account_sid'], 'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'identity': identity, 'role_sid': role_sid, 'last_consumed_message_index': last_consumed_message_index, 'last_consumed_timestamp': deserialize.iso8601_datetime(last_consumed_timestamp), 'last_read_message_index': last_read_message_index, 'last_read_timestamp': deserialize.iso8601_datetime(last_read_timestamp), 'attributes': attributes, 'date_expires': deserialize.iso8601_datetime(date_expires), 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @
Return
Returns true if both instances are not equal, false otherwise :param other: twilio.rest.chat.v2.service.channel.invite.InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
""" Iterate over pages of Invites :returns: Page of InviteInstance :rtype
Provide a friendly representation :returns: Machine friendly representation :rtype: str


""" Initialize the InviteList :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the new resource belongs to :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) # Components self._invites = None @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList.InvitePage """ if self._invites is None: self._invites = InvitePage(self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._invites def __repr__(self): """ Provide a friendly representation :returns: Machine friendly representation :rtype: str """ return '<Twilio.IpMessaging.V2.InviteList>' class InvitePage(Page): """ PLEASE NOTE that this class contains preview products that are subject to change. Use them with caution. If you currently do not have developer preview access, please contact <EMAIL>. """ def __init__(self, version, service_sid, channel_sid, response, solution): """ Initialize the InvitePage :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the new resource belongs to :param Response response: Response from the API :param service_sid: The SID of the Service to fetch
'''Return True if column with specified name should be
Return the codes of the index. :returns: The codes of the index. :rtype: list
Export the DataFrame to a JSON file. :param path: Path to the file to write to. :type path: str :param kwargs: Keyword arguments passed to :func:`pandas.DataFrame.to_json`. :type kwargs: dict
Return a DataFrame containing only the filtered rows. {note_copy} The resulting DataFrame may be more efficient to work with when the original DataFrame is heavily filtered (contains just a small number of rows). If no filtering is applied, it returns a trimmed view. For the returned df, len(df) == df.length_original() == df.length_unfiltered() :rtype: DataFrame
Returns a DataFrame with a random set of rows {note_copy} Provide either n or frac. Example: >>> import vaex, numpy as np >>> df = vaex.from_arrays(s=np.array(['a', 'b', 'c', 'd']), x=np.arange(1,5)) >>> df # s x 0 a 1 1 b 2 2 c 3 3 d 4 >>> df.sample(n=2, random_state=42) # 2 random rows, fixed seed # s x 0 b 2 1 d 4 >>> df.sample(frac=1, random_state=42) #'shuffling' # s x 0 c 3 1 a 1 2 d 4 3 b 2 >>> df.sample(frac=1, replace=True, random_state=42) # useful for bootstrap (may contain repeated samples) # s x 0 d 4 1 a 1 2 a 1 3 d 4 :param int n: number of samples to take (default 1 if frac is None) :param float frac: fractional number of takes to take :param bool replace: If true, a row may be drawn multiple times :param str or expression weights: (unnormalized) probability that a row can be drawn :param int or RandomState: seed or RandomState for reproducability, when None a random seed it chosen :return: {return_shallow_copy} :rtype: DataFrame ''' self = self.extract() if type(random_state) == int or random_state is None: random_state = np.random.RandomState(seed=random_state) if n is None and frac is None: n = 1 elif frac is not None: n = int(round(frac * len(self))) weights_values = None if weights is not None: weights_values = self.evaluate(weights) weights_values = weights_values / self.sum(weights) indices = random_state.choice(len(self), n, replace=replace, p=weights_values
Returns a list containing random portions of the DataFrame. {note_copy} Example: >>> import vaex, import numpy as np >>> np.random.seed(111) >>> df = vaex.from_arrays(x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) >>> for dfs in df.split_random(frac=0.3, random_state=42): ... print(dfs.x.values) ... [8 1 5] [0 7 2 9 4 3 6] >>> for split in df.split_random(frac=[0.2, 0.3, 0.5], random_state=42): ... print(dfs.x.values) [8 1] [5 0 7] [2 9 4 3 6] :param int/list frac: If int will split the DataFrame in two portions, the first of which will have size as specified by this parameter. If list, the generator will generate as many portions as elements in the list, where each element defines the relative fraction of that portion. :param int random_state: (default, None) Random number seed for reproducibility. :return: A list of DataFrames. :rtype: list
Returns a list containing ordered subsets of the DataFrame. {note_copy} Example: >>> import vaex >>> df = vaex.from_arrays(x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) >>> for dfs in df.split(frac=0.3): ... print(dfs.x.values) ... [0 1 3] [3 4 5 6 7 8 9] >>> for split in df.split(frac=[0.2, 0.3, 0.5]): ... print(dfs.x.values) [0 1] [2 3 4] [5 6 7 8 9] :param int/list frac: If int will split the DataFrame in two portions, the first of which will have size as specified by this parameter. If list, the generator will generate as many portions as elements in the list, where each element defines the relative fraction of that portion. :return: A list of DataFrames. :rtype: list
Return a sorted DataFrame, sorted by the expression 'by' {note_copy} {note_filter} Example: >>> import vaex, numpy as np >>> df = vaex.from_arrays(s=np.array(['a', 'b', 'c', 'd']), x=np.arange(1,5)) >>> df['y'] = (df.x-1.8)**2 >>> df # s x y 0 a 1 0.64 1 b 2 0.04 2 c 3 1.44 3 d 4 4.84 >>> df.sort('y', ascending=False) # Note: passing '(x-1.8)**2' gives the same result # s x y 0 d 4 4.84 1 c 3 1.44 2 a 1 0.64 3 b 2 0.04 :param str or expression by: expression to sort by :param bool ascending: ascending (default, True) or descending (False) :param str kind: kind of algorithm to use (passed to numpy.argsort)
Return the mean of column_or_expression, possible over an expression selection. :param column_or_expression: {expression} :param out: {out} :param selection: {selection} :param kwargs: {kwargs} :return: {return_stat_scalar}
Get the current selection for the given name. :param str name: The name of the selection history to get. :returns: list :rtype: list


:param boolean_expression: A boolean expression to evaluate for each item in the history. :param mode: The mode to use when the expression evaluates to True. :param name: The name of the selection. :param executor: The executor to use when evaluating the expression. :returns: The selection object. :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList.Selection
""" Initialize the InvitePage :param Version version: Version that contains the resource :param service_sid: The SID of the Service that the resource is associated with :param channel_sid: The SID of the Channel the resource belongs to :param sid: The unique string that identifies the resource :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage """ super(InvitePage, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid,'sid': sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites{sid}'.format(**self._solution) # Dependents self._invites = None @property def invites(self): """ :returns: The list of Invites :rtype: unicode """ if self._invites is None: self._invites = list() if self._invites is not None: return self._invites self._invites = list() for child in self._version.page(self, 'invites', self._solution): self._invites.append(child) return self._invites def __repr__(self): """ Provide a friendly representation :returns: Machine friendly representation :rtype: str """ return '<Twilio.IpMessaging.V2.InvitePage>' class InviteContext(InstanceContext): """ PLEASE NOTE that this class contains preview products that are subject to change. Use them with caution. If you currently do not have developer preview access, please contact <EMAIL>. """ def __init__(self, version, service_sid, channel_sid, sid): """ Initialize the InviteContext :param Version version: Version that contains the resource :param service_sid:
nan
Select a box in the image. :param list[int] points: The points of the box. :param list[int] limits: The limits of the box. :param str mode: The mode to use when selecting the box. Can be: replace, add, or subtract. :param str name: The name of the box. :returns: twilio.rest.video.v1.room.room_participant.room_participant_track.room_participant_track_captions.room_participant_track_captions_captions_item.RoomParticipantTrackCaptionsCaptionsItem :rtype: twilio.rest.video.v1.room.room_



polygon selection :param expression_x: :param expression_y: :param xsequence: :param ysequence: :param mode: :param name: :param executor: :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance
Retrieve a single page of InviteInstance records from the API. Request is executed immediately :param int page_size: Number of records to return, defaults to 50 :param str name: A string to describe the selection. :param executor: The executor to use for this selection. :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Called when the selection has changed, and the selection has been applied
Constructs a InviteContext :param sid: The unique string that identifies the resource :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext
Get a unicode representation of the result set. :returns: The result set unicode representation. :rtype: unicode

Retrieve a user's identity :param identity: The identity :type identity: unicode :returns: The identity :rtype: unicode

Initialize the InvitePage :param Version
Constructs a InviteContext :param sid: The sid :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext
nan
Get an item from the list of resources :param unicode key: The index of the resource to fetch :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance

""" Create a new DataFrame from a dictionary, list of tuples, or array. Parameters ---------- data : dict, list of tuples, ndarray, dict of arrays, or DataFrame Dict can contain Series, arrays, constants, or list-like objects index : Index or array-like Index to use for resulting frame. Will default to np.arange(n) if no indexing information part of input data and no index provided columns : Index or array-like Column labels to use for resulting frame. Will default to RangeIndex(n) if no column labels are provided dtype : dtype, default None Data type to force, otherwise infer copy : boolean, default False Copy data from inputs. Only affects DataFrame / 2d ndarray input fastpath : boolean, default False Only use arrays / scalar values as input, do not attempt to put anything in object dtype. Only affects DataFrame / 2d ndarray input allow_duplicates : boolean, default False Allow columns to be duplicated. If False, will raise an exception if a column label is duplicated. verify_integrity : boolean, default False Check the new object for duplicates. Otherwise defer the check until necessary. Setting to False will improve the performance of this method Notes ----- To learn more about the canonical representation of DataFrames in pandas, please see :ref:`the User Guide <basics.dataframe>`. See Also -------- DataFrame : DataFrame object creation using constructor DataFrame.from_dict : DataFrame from dict of array-like or dicts DataFrame.from_items : DataFrame from sequence of (key, value) pairs DataFrame.from_records : DataFrame from ndarray (structured or homogeneous) DataFrame.from_csv : DataFrame from CSV file DataFrame.from_json : DataFrame from JSON file Examples -------- Constructing DataFrame from a dictionary >>> data = {'col1': [1, 2, 3], ... 'col2': [4, 5, 6]} >>> df = pd.DataFrame(data) >>> df col1 col2 0 1 4 1 2 5 2 3 6
Adds method f to the DataFrame class :param f: The method to add to the DataFrame class :returns: The method added to the DataFrame class :rtype: function

Provide a friendly representation :returns: Machine friendly representation :rtype: str


""" Initialize the InviteInstance :param Version version: Version that contains the resource :param service_sid: The SID of the Service that the resource is associated with :param channel_sid: The SID of the Channel the resource belongs to :param sid: The unique string that identifies the resource :param date_created: The ISO 8601 date and time in GMT when the resource was created :param date_updated: The ISO 8601 date and time in GMT when the resource was last updated :param created_by: The identity of the User that created the resource :param url: The absolute URL of the resource :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': sid, 'account_sid': self._solution['account_sid'], 'service_sid': self._solution['service_sid'], 'channel_sid': self._solution['channel_sid'], 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context



Code



Code

""" Initialize the InvitePage :param Version version: Version that contains the resource :param dict payload: A JSON response from the Twilio API :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage """ super(InvitePage, self).__init__(version, response=payload, service_sid=service_sid, channel_sid=channel_sid, ) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._context @property def invites(self): """ :returns: A list of instances of InviteInstance :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance] """ return self._proxy.invites @property def page_size(self): """ :returns: How many resources to return in each list page. The default is 50, and the maximum is 1000. :rtype: unicode """ return self._properties['page_size'] @property def next_page_url(self): """ :returns: The URL of the next page of results :rtype: unicode """ return self._properties['next_page_url'] @property def key(self): """ :returns: The unique string that identifies the resource :rtype: unicode """ return self._properties['key'] def __repr__(self): """ Provide a friendly representation
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ super(InviteInstance, self).__init__(version) # Marshaled Properties self._properties = { 'sid': sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'identity': identity, 'role_sid': role_sid, 'last_consumed_message_index': last_consumed_message_index, 'last_consumed_timestamp': deserialize.iso8601_datetime(last_consumed_timestamp), 'last_read_message_index': last_read_message_index, 'last_read_timestamp': deserialize.iso8601_datetime(last_read_timestamp), 'last_seen_timestamp': deserialize.iso8601_datetime(last_seen_timestamp), 'attributes': attributes, 'unread_messages_count': unread_messages_count, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Provide a friendly representation :returns: Machine friendly representation :rtype: str

""" Initialize the InviteList :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the new resource belongs to :param version: Version that contains the resource :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) def create(self, identity, role_sid=values.unset, type=values.unset, url=values.unset, ttl=values.unset): """ Create a new InviteInstance :param unicode identity: The `identity` value that identifies the new resource's User :param unicode role_sid: The SID of the Role to assign to the new resource :param unicode type: The type of push notification to use. Can be: `gcm` or `apn` and the default is `gcm` :param unicode url: The URL we should call using the `notification_protocol` to send a notification when the Invite has been accepted :param unicode ttl: The amount of time, in seconds, that a Push Notification should be retained for. Can be an integer between 0 and 1440 (24 hours). :returns: Newly created InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ data = values.of({ 'Identity': identity, 'RoleSid': role_sid, 'Type': type, 'Url': url, 'Ttl': ttl, }) payload = self._version.create( 'POST', self._uri, data=data, ) return InviteInstance( self._version, payload, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], )
Provide a friendly representation :returns: Machine friendly representation :rtype: str
Get an item from the list of resources :
Provide a friendly representation :returns: Machine friendly representation :rtype: str
""" Provide a friendly representation :returns: Machine friendly representation :rtype: str """ return '<Twilio.IpMessaging.V2.InvitePage
""" Initialize the InviteList :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the new resource belongs to :param version: Version that contains the resource :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ super(InviteList, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}/Invites'.format(**self._solution) def create(self, identity, role_sid=values.unset, type=values.unset, url=values.unset, ttl=values.unset): """ Create a new InviteInstance :param unicode identity: The `identity` value that identifies the new resource's User :param unicode role_sid: The SID of the Role to assign to the new resource :param unicode type: The type of push notification to send when the new resource is added to the Channel :param unicode url: The absolute URL of the new resource :param unicode ttl: The amount of time, in seconds, that a Push Notification should be retained for the new resource :returns: Newly created InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ data = values.of({ 'Identity': identity, 'RoleSid': role_sid, 'Type': type, 'Url': url, 'Ttl': ttl, }) payload = self._version.create( 'POST', self._uri, data=data, ) return InviteInstance( self._version, payload, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) def stream(self, limit=None, page_size=None): """ Streams InviteInstance records from the API as a generator stream. This operation lazily loads records as efficiently as
""" Provide a friendly representation :returns: Machine
Iterate over list of Invites :returns: List of Invites :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance]
""" Provide a friendly representation :returns: Machine friendly representation :rtype: str """ return '<Twilio.IpMessaging.V2.InvitePage
""" Initialize the InvitePage :param Version version: Version that contains the resource :param dict payload: A JSON response from the Twilio API :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage """ super(InvitePage, self).__init__(version, response=payload, service_sid=service_sid, channel_sid=channel_sid, ) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._context @property def invites(self): """ :returns: A list of instances of InviteInstance :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance] """ return self._proxy.invites @property def page_size(self): """ :returns: How many resources to return in each list page. The default is 50, and the maximum is 1000. :rtype: unicode """ return self._properties['page_size'] @property def next_page_url(self): """ :returns: The URL of the next page of results :rtype: unicode """ return self._properties['next_page_url'] @property def key(self): """ :returns: The unique string that identifies the resource :rtype: unicode """ return self._properties['key'] def __repr__(self): """ Provide a friendly representation
Get an item from the list
Provide a friendly representation :returns: Machine friendly representation :rtype: str
""" Initialize the InvitePage :param Version version: Version that contains the resource :param dict payload: A JSON response from the Twilio API :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage """ super(InvitePage, self).__init__(version, response=payload, service_sid=service_sid, channel_sid=channel_sid, ) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._context @property def invites(self): """ :returns: A list of instances of InviteInstance :rtype: list[twilio.rest.chat.v2.service.channel.invite.InviteInstance] """ return self._proxy.invites @property def page_size(self): """ :returns: How many resources to return in each list page. The default is 50, and the maximum is 1000. :rtype: unicode """ return self._properties['page_size'] @property def next_page_url(self): """ :returns: The URL of the next page of results :rtype: unicode """ return self._properties['next_page_url'] @property def key(self): """ :returns: The unique string that identifies the resource :rtype: unicode """ return self._properties['key'] def __repr__(self): """ Provide a friendly representation
Provide a friendly representation :returns: Machine friendly representation :rtype: str

Provide a friendly representation :returns: Machine friendly representation :rtype: str
Get an item from the list of resources :param unicode key: The index of the resource to fetch :returns: twilio.rest.chat.v2.service.channel.
Raise an exception if the given value is
Raise an exception if the given value is not a list. :param value: The value to check. :param str name: The name of the value. :raises TypeError: If the value is not a list.

Provide a friendly representation :returns: Machine friendly representation :rtype: str
Initialize the InvitePage :param Version version: Version that contains the resource :param Response response: Response from the API :param service_sid: The SID of the Service that the resource is associated with :param channel_sid: The SID of the Channel the resource belongs to :returns: twilio.rest.chat.
Provide a friendly representation :returns: Machine friendly representation
Set the hop length, in samples, of the STFT. Parameters ---------- hop_length : int > 0 [scalar] The number of samples between subsequent frames. If unspecified, defaults to `win_length / 4`. Examples -------- Use a shorter frame shift for better frequency resolution >>> y, sr = librosa.load(librosa.util.example_audio_file()) >>> D = librosa.stft(y) >>> librosa.set_hop_length(64) >>> D = librosa.stft(y) Reset to default hop length >>> librosa.set_hop_length() ''' global __HOP_LENGTH if hop_length is None: hop_
Initialize the InvitePage :param Version version: Version that contains the resource :param Response response: Response from the API :param service_sid: The SID of the Service to fetch the resource from :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage
Initialize the InvitePage :param Version version: Version that contains the resource :param Response response: Response from the API :param service_sid: The SID of the Service to fetch the resource from :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage
Get an item from the list of resources in the response. :returns: An instance of the resource at the given index, or None if
""" Initialize the InviteInstance :returns: twilio.rest.chat.v2.service.channel.invite.InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance """ self._version = version # Marshaled Properties self._properties = { 'sid': sid, 'date_created': deserialize.iso8601_datetime(date_created), 'date_updated': deserialize.iso8601_datetime(date_updated), 'created_by': created_by, 'url': url, 'links': links, } # Context self._context = None self._solution = { 'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self._properties['sid'], } @property def _proxy(self): """ Generate an instance context for the instance, the context is capable of performing various actions. All instance actions are proxied to the context :returns: InviteContext for this InviteInstance :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext """ if self._context is None: self._context = InviteContext( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'], ) return self._context @property def sid(self): """ :returns: A 34 character string that uniquely identifies this resource. :rtype: unicode """ return self._properties['sid'] @property def date_created(self): """ :returns: The RFC 2822 date and time in GMT when the resource was created. :rtype: datetime """ return self._properties['date_created'] @property def date_updated(self): """ :returns: The RFC 28
Convert time to samples :param list times: List of times in seconds :param int sr: Sampling rate in Hz :returns: List of samples :rtype: list
Convert one or more MIDI numbers to note strings. MIDI numbers will be rounded to the nearest integer. Notes will be of the format 'C0', 'C#0', 'D0',... Examples -------- >>> librosa.midi_to_note(0) 'C-1' >>> librosa.midi_to_note(37) 'C#2' >>> librosa.midi_to_note(-2) 'A#-2' >>> librosa.midi_to_note(104.7) 'A7' >>> librosa.midi_to_note(104.7, cents=True) 'A7-30' >>> librosa.midi_to_note(list(range(12, 24))) ['C0', 'C#0', 'D0', 'D#0', 'E0', 'F0', 'F#0', 'G0', 'G#0', 'A0', 'A#0', 'B0'] Parameters ---------- midi : int or iterable of int Midi numbers to convert. octave: bool If True, include the octave number cents: bool If true, cent markers will be appended for fractional notes. Eg, `midi_to_note(69.3, cents=True)` == `A4+03` Returns ------- notes : str or iterable of str Strings describing each midi note. Raises ------ ParameterError if `cents` is True and `octave` is False See Also -------- midi_to_hz note_to_midi hz_to_note ''' if cents and not octave: raise ParameterError('Cannot encode cents without octave information.') if not np.isscalar(midi): return [midi_to_note(x, octave=octave, cents=cents) for x in midi] note_map = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'] note_num = int(np.round(midi)) note_cents = int(100

Initialize the InvitePage :param Version version: Version that contains the resource :param dict payload: A JSON response from the Twilio API. :returns: twilio.rest.chat.v2.service.channel.invite.InvitePage :rtype: twilio.rest.chat.v2.service.channel.invite.InvitePage
Alternative implementation of `np.fft.fftfreq` Parameters ---------- sr : number >
Provide a friendly representation :returns: Machine friendly representation :rtype: str

Compute the A-weighting of a set of frequencies. Parameters ---------- frequencies : scalar or np.ndarray [shape=(n,)] One or more frequencies (in Hz) min_db : float [scalar] or None Clip
Provide a friendly representation :returns: Machine friendly representation :rtype: str
""" Initialize the ChannelContext :param Version version: Version that contains the resource :param service_sid: The SID of the Service to fetch the resource from :param channel_sid: The SID of the Channel the new resource belongs to :returns: twilio.rest.chat.v2.service.channel.ChannelContext :rtype: twilio.rest.chat.v2.service.channel.ChannelContext """ super(ChannelContext, self).__init__(version) # Path Solution self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, } self._uri = '/Services/{service_sid}/Channels/{channel_sid}'.format(**self._solution) # Dependents self._members = None self._messages = None self._invites = None self._webhooks = None @property def members(self): """ Access the members :returns: twilio.rest.chat.v2.service.channel.member.MemberList :rtype: twilio.rest.chat.v2.service.channel.member.MemberList """ if self._members is None: self._members = MemberList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._members @property def messages(self): """ Access the messages :returns: twilio.rest.chat.v2.service.channel.message.MessageList :rtype: twilio.rest.chat.v2.service.channel.message.MessageList """ if self._messages is None: self._messages = MessageList( self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], ) return self._messages @property def invites(self): """ Access the invites :returns: twilio.rest.chat.v2.service.channel.invite.InviteList :rtype: twilio.rest.chat.v2.service.channel.invite.InviteList """ if self._invites is None: self._invites = Inv
Compute the hybrid constant-Q transform of an audio signal. Here, the hybrid CQT uses the pseudo CQT for higher frequencies where the hop_length is longer than half the filter length and the full CQT for lower frequencies. Parameters ---------- y : np.ndarray [shape=(n,)] audio time series sr : number > 0 [scalar] sampling rate of `y` hop_length : int > 0 [scalar] number of samples between successive CQT columns. fmin : float > 0 [scalar] Minimum frequency. Defaults to C1 ~= 32.70 Hz n_bins : int > 0 [scalar] Number of frequency bins, starting at `fmin` bins_per_octave : int > 0 [scalar] Number of bins per octave tuning : None or float in `[-0.5, 0.5)` Tuning offset in fractions of a bin (cents). If `None`, tuning will be automatically estimated from the signal. filter_scale : float > 0 Filter filter_scale factor. Larger values use longer windows. sparsity : float in [0, 1) Sparsify the CQT basis by discarding up to `sparsity` fraction of the energy in each basis. Set `sparsity=0` to disable sparsification. window : str, tuple, number, or function Window specification for the basis filters. See `filters.get_window` for details. pad_mode : string Padding mode for centered frame analysis. See also: `librosa.core.stft` and `np.pad`. res_type : string Resampling mode. See `librosa.core.cqt` for details. Returns ------- CQT : np.ndarray [shape=(n_bins, t), dtype=np.float] Constant-Q energy for each frequency at each time. Raises ------ ParameterError If `hop_length` is not an integer multiple of `2**(n_bins / bins_per_octave)` Or if `y` is too short to support the frequency range of the CQT. See Also -------- cqt pseudo_cqt Notes ----- This function caches at level
Compute the pseudo constant-Q transform of an audio signal. This uses a single fft size that is the smallest power of 2 that is greater than or equal to the max of: 1. The longest CQT filter 2. 2x the hop_length Parameters ---------- y : np.ndarray [shape=(n,)] audio time series sr : number > 0 [scalar] sampling rate of `y` hop_length : int > 0 [scalar] number of samples between successive CQT columns. fmin : float > 0 [scalar] Minimum frequency. Defaults to C1 ~= 32.70 Hz n_bins : int > 0 [scalar] Number of frequency bins, starting at `fmin` bins_per_octave : int > 0 [scalar] Number of bins per octave tuning : None or float in `[-0.5, 0.5)` Tuning offset in fractions of a bin (cents). If `None`, tuning will be automatically estimated from the signal. filter_scale : float > 0 Filter filter_scale factor. Larger values use longer windows. sparsity : float in [0, 1) Sparsify the CQT basis by discarding up to `sparsity` fraction of the energy in each basis. Set `sparsity=0` to disable sparsification. window : str, tuple, number, or function Window specification for the basis filters. See `filters.get_window` for details. pad_mode : string Padding mode for centered frame analysis. See also: `librosa.core.stft` and `np.pad`. Returns ------- CQT : np.ndarray [shape=(n_bins, t), dtype=np.float] Pseudo Constant-Q energy for each frequency at each time. Raises ------ ParameterError If `hop_length` is not an integer multiple of `2**(n_bins / bins_per_octave)` Or if `y` is too short to support the frequency range of the CQT. Notes ----- This function caches at level 20. ''' if fmin is None: # C1 by default fmin = note_to_hz('C1
Given a constant-Q transform representation `C` of an audio signal `y`, this function produces an approximation `y_hat`. Parameters ---------- C : np.ndarray, [shape=(n_bins, n_frames)] Constant-Q representation as produced by `core.cqt` hop_length : int > 0 [scalar] number of samples between successive frames fmin : float > 0 [scalar] Minimum frequency. Defaults to C1 ~= 32.70 Hz tuning : float in `[-0.5, 0.5)` [scalar] Tuning offset in fractions of a bin (cents). filter_scale : float > 0 [scalar] Filter scale factor. Small values (<1) use shorter windows for improved time resolution. norm : {inf, -inf, 0, float > 0} Type of norm to use for basis function normalization. See `librosa.util.normalize`. sparsity : float in [0, 1) Sparsify the CQT basis by discarding up to
Generate the frequency domain constant-Q filter basis. :param int sr: Sample rate of the incoming signal. :param float fmin: Minimum frequency. Defaults to C1 ~= 32.70 Hz. :param int n_bins: Number of frequency bins, starting at ``fmin``. :param int bins_per_octave: Number of bins per octave. Defaults to 12. :param float tuning: Tuning deviation from A440 (in fractions of a bin). :param float filter_scale: Filter scale factor. Larger values (e.g., 1.0) use longer windows. :param str norm: Normalization mode. One of ``'ortho'`` (ortho-normal), ``'slaney'`` (slaney-rule), or ``None`` (no normalization). :param float sparsity: Sparsify the filterbank by discarding up to ``sparsity`` fraction of the energy in each basis function. :param int hop_length: The number of samples between subsequent columns of ``D``. If not supplied, defaults to ``win_length // 4``. :param str window: Window function for the basis filters. See `scipy.signal.get_window` for a list of windows and required parameters. If omitted, defaults to ``'hann'``. :returns: Constant-Q basis, FFT length, and filter lengths :rtype: tuple :raises ParameterError: If any of the parameters are invalid.
Helper function to trim and stack a collection of CQT responses :param list cqt_resp: List of CQT responses :param int n_bins: Number of bins to keep :returns: np.ndarray :rtype: np.ndarray
Compute the filter response with a target STFT hop. :param y: the input signal :type y: np.ndarray :param n_fft: the FFT window size :type n_fft: int :param hop_length: the hop length :type hop_length: int :param fft_basis: the FFT basis :type fft_basis: np.ndarray :param mode: the padding mode :type mode: str :returns: the filter response :rtype: np.ndarray
Compute the number of 2 factors in n :param int n: Number :returns: int :rtype: int
